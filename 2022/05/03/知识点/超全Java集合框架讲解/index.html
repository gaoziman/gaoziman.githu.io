<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>超全Java集合框架讲解 | 爱笑的Gao的个人博客</title><meta name="keywords" content="Java,Java-Basic"><meta name="author" content="Gao"><meta name="copyright" content="Gao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="超全Java集合框架讲解 超全Java集合框架讲解 集合框架总览 Iterator  Iterable ListIterator Map 和 Collection 接口   Map 集合体系详解 HashMap LinkedHashMap TreeMap WeakHashMap Hashtable   Collection 集合体系详解 Set 接口 AbstractSet 抽象类 SortedS">
<meta property="og:type" content="article">
<meta property="og:title" content="超全Java集合框架讲解">
<meta property="og:url" content="https://manamn.space/2022/05/03/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%B6%85%E5%85%A8Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3/index.html">
<meta property="og:site_name" content="爱笑的Gao的个人博客">
<meta property="og:description" content="超全Java集合框架讲解 超全Java集合框架讲解 集合框架总览 Iterator  Iterable ListIterator Map 和 Collection 接口   Map 集合体系详解 HashMap LinkedHashMap TreeMap WeakHashMap Hashtable   Collection 集合体系详解 Set 接口 AbstractSet 抽象类 SortedS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://pic.netbian.com/uploads/allimg/200318/115722-15845038426aea.jpg">
<meta property="article:published_time" content="2022-05-03T07:49:13.000Z">
<meta property="article:modified_time" content="2022-10-16T16:00:18.966Z">
<meta property="article:author" content="Gao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java-Basic">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pic.netbian.com/uploads/allimg/200318/115722-15845038426aea.jpg"><link rel="shortcut icon" href="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?"><link rel="canonical" href="https://manamn.space/2022/05/03/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%B6%85%E5%85%A8Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '超全Java集合框架讲解',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-10-17 00:00:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="/js/title.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Jayhrn/fontawesome-pro/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/remixicon@2.5.0/fonts/remixicon.css"><script src="https://at.alicdn.com/t/c/font_3570527_dthoqrrv2tv.css"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="爱笑的Gao的个人博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#iconfont icon-xiangji1"></use></svg><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://pic.netbian.com/uploads/allimg/200318/115722-15845038426aea.jpg')"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span>JAYHRN</span></a></span><span id="page_name"><a id="page-name-text" title="回到顶部" onclick="btf.scrollToDest(0,500)"><span>爱笑的Gao的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#iconfont icon-xiangji1"></use></svg><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于我</span></a></div></div></div><div id="hotkey"><div id="search-button"><a class="site-page social-icon search" title="搜索"><i class="ri-search-eye-line"></i></a></div><div id="randompost-button"><a class="site-page" title="随机文章" onclick="toRandomPost()"><i class="ri-subway-fill"></i></a></div><div id="mode-button"><a class="site-page" title="浅色和深色模式转换" onclick="switchDarkMode()"><i class="ri-sun-fill"></i></a></div><div id="top-button"><a class="site-page" title="回到顶部" onclick="btf.scrollToDest(0,500)"><i class="ri-plane-fill"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">超全Java集合框架讲解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-03T07:49:13.000Z" title="发表于 2022-05-03 15:49:13">2022-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-16T16:00:18.966Z" title="更新于 2022-10-17 00:00:18">2022-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-Basic/">Java-Basic</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="超全Java集合框架讲解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="超全Java集合框架讲解"><a href="#超全Java集合框架讲解" class="headerlink" title="超全Java集合框架讲解"></a>超全Java集合框架讲解</h1><ul>
<li><a href="#超全java集合框架讲解">超全Java集合框架讲解</a><ul>
<li><a href="#集合框架总览">集合框架总览</a><ul>
<li><a href="#iterator--iterable-listiterator">Iterator  Iterable ListIterator</a></li>
<li><a href="#map-和-collection-接口">Map 和 Collection 接口</a></li>
</ul>
</li>
<li><a href="#map-集合体系详解">Map 集合体系详解</a><ul>
<li><a href="#hashmap">HashMap</a></li>
<li><a href="#linkedhashmap">LinkedHashMap</a></li>
<li><a href="#treemap">TreeMap</a></li>
<li><a href="#weakhashmap">WeakHashMap</a></li>
<li><a href="#hashtable">Hashtable</a></li>
</ul>
</li>
<li><a href="#collection-集合体系详解">Collection 集合体系详解</a><ul>
<li><a href="#set-接口">Set 接口</a></li>
<li><a href="#abstractset-抽象类">AbstractSet 抽象类</a></li>
<li><a href="#sortedset-接口">SortedSet 接口</a></li>
<li><a href="#hashset">HashSet</a></li>
<li><a href="#linkedhashset">LinkedHashSet</a></li>
<li><a href="#treeset">TreeSet</a></li>
</ul>
</li>
<li><a href="#list-接口">List 接口</a><ul>
<li><a href="#abstractlist--和-abstractsequentiallist">AbstractList  和 AbstractSequentialList</a></li>
<li><a href="#vector">Vector</a></li>
<li><a href="#stack">Stack</a></li>
<li><a href="#arraylist">ArrayList</a></li>
<li><a href="#linkedlist">LinkedList</a></li>
</ul>
</li>
<li><a href="#queue接口">Queue接口</a><ul>
<li><a href="#deque-接口">Deque 接口</a></li>
<li><a href="#abstractqueue-抽象类">AbstractQueue 抽象类</a></li>
<li><a href="#linkedlist-1">LinkedList</a></li>
<li><a href="#arraydeque">ArrayDeque</a></li>
<li><a href="#priorityqueue">PriorityQueue</a></li>
</ul>
</li>
<li><a href="#文末总结">文末总结</a></li>
</ul>
</li>
</ul>
<p>集合在我们日常开发使用的次数数不胜数，<code>ArrayList</code>/<code>LinkedList</code>/<code>HashMap</code>/<code>HashSet</code>······信手拈来，抬手就拿来用，在 IDE 上龙飞凤舞，但是作为一名合格的优雅的程序猿，仅仅了解怎么使用<code>API</code>是远远不够的，如果在调用<code>API</code>时，知道它内部发生了什么事情，就像开了<code>透视</code>外挂一样，洞穿一切，这种感觉才真的爽，而且这样就<strong>不是集合提供什么功能给我们使用，而是我们选择使用它的什么功能了</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596208672973-ae64a99f-3831-4b18-b4f4-c69237eba98a.png?x-oss-process=image%2Fresize%2Cw_2400" alt="img"></p>
<h2 id="集合框架总览"><a href="#集合框架总览" class="headerlink" title="集合框架总览"></a>集合框架总览</h2><p>下图堪称集合框架的<strong>上帝视角</strong>，讲到集合框架不得不看的就是这幅图，当然，你会觉得眼花缭乱，不知如何看起，这篇文章带你一步一步地秒杀上面的每一个接口、抽象类和具体类。我们将会从最顶层的接口开始讲起，一步一步往下深入，帮助你把对集合的认知构建起一个知识网络。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1694029/1596110252275-7ae0c7a7-b8a9-4e36-bc2f-d651c6e0ae23.jpeg" alt="collection.jpeg"></p>
<p>工欲善其事必先利其器，让我们先来过一遍整个集合框架的组成部分：</p>
<ol>
<li>集合框架提供了两个遍历接口：<code>Iterator</code>和<code>ListIterator</code>，其中后者是前者的<code>优化版</code>，支持在任意一个位置进行<strong>前后双向遍历</strong>。注意图中的<code>Collection</code>应当继承的是<code>Iterable</code>而不是<code>Iterator</code>，后面会解释<code>Iterable</code>和<code>Iterator</code>的区别</li>
<li>整个集合框架分为两个门派（类型）：<code>Collection</code>和<code>Map</code>，前者是一个容器，存储一系列的<strong>对象</strong>；后者是键值对<code>&lt;key, value&gt;</code>，存储一系列的<strong>键值对</strong></li>
<li>在集合框架体系下，衍生出四种具体的集合类型：<code>Map</code>、<code>Set</code>、<code>List</code>、<code>Queue</code></li>
<li><code>Map</code>存储<code>&lt;key,value&gt;</code>键值对，查找元素时通过<code>key</code>查找<code>value</code></li>
<li><code>Set</code>内部存储一系列<strong>不可重复</strong>的对象，且是一个<strong>无序</strong>集合，对象排列顺序不一</li>
<li><code>List</code>内部存储一系列<strong>可重复</strong>的对象，是一个<strong>有序</strong>集合，对象按插入顺序排列</li>
<li><code>Queue</code>是一个<strong>队列</strong>容器，其特性与<code>List</code>相同，但只能从<code>队头</code>和<code>队尾</code>操作元素</li>
<li>JDK 为集合的各种操作提供了两个工具类<code>Collections</code>和<code>Arrays</code>，之后会讲解工具类的常用方法</li>
<li>四种抽象集合类型内部也会衍生出许多具有不同特性的集合类，<strong>不同场景下择优使用，没有最佳的集合</strong></li>
</ol>
<p>上面了解了整个集合框架体系的组成部分，接下来的章节会严格按照上面罗列的顺序进行讲解，每一步都会有<code>承上启下</code>的作用</p>
<blockquote>
<p>学习<code>Set</code>前，最好最好要先学习<code>Map</code>，因为<code>Set</code>的操作本质上是对<code>Map</code>的操作，往下看准没错</p>
</blockquote>
<h3 id="Iterator-Iterable-ListIterator"><a href="#Iterator-Iterable-ListIterator" class="headerlink" title="Iterator  Iterable ListIterator"></a>Iterator  Iterable ListIterator</h3><p>在第一次看这两个接口，真以为是一模一样的，没发现里面有啥不同，<strong>存在即合理</strong>，它们两个还是有本质上的区别的。</p>
<p>首先来看<code>Iterator</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供的API接口含义如下：</p>
<ul>
<li><code>hasNext()</code>：判断集合中是否存在下一个对象</li>
<li><code>next()</code>：返回集合中的下一个对象，并将访问指针移动一位</li>
<li><code>remove()</code>：删除集合中调用<code>next()</code>方法返回的对象</li>
</ul>
<p>在早期，遍历集合的方式只有一种，通过<code>Iterator</code>迭代器操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="number">2</span>) &#123; iter.remove(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看<code>Iterable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// JDK 1.8</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Iterable</code>接口里面提供了<code>Iterator</code>接口，所以实现了<code>Iterable</code>接口的集合依旧可以使用<code>迭代器</code>遍历和操作集合中的对象；</p>
<p>而在 <code>JDK 1.8</code>中，<code>Iterable</code>提供了一个新的方法<code>forEach()</code>，它允许使用增强 for 循环遍历对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过命令：<code>javap -c</code>反编译上面的这段代码后，发现它只是 Java 中的一个<code>语法糖</code>，本质上还是调用<code>Iterator</code>去遍历。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596110168937-9464cc3c-9198-4ef0-ada3-97c86cfaf175.png" alt="image-20200729000858377.png"></p>
<p>翻译成代码，就和一开始的<code>Iterator</code>迭代器遍历方式基本相同了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有更深层次的探讨：为什么要设计两个接口<code>Iterable</code>和<code>Iterator</code>，而不是保留其中一个就可以了。</p>
<p>简单讲解：<code>Iterator</code>的保留可以让子类去<strong>实现自己的迭代器</strong>，而<code>Iterable</code>接口更加关注于<code>for-each</code>的增强语法。具体可参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/litexy/p/9744241.html">Java中的Iterable与Iterator详解</a></p>
</blockquote>
<p>关于<code>Iterator</code>和<code>Iterable</code>的讲解告一段落，下面来总结一下它们的重点：</p>
<ol>
<li><code>Iterator</code>是提供集合操作内部对象的一个迭代器，它可以<strong>遍历、移除</strong>对象，且只能够<strong>单向移动</strong></li>
<li><code>Iterable</code>是对<code>Iterator</code>的封装，在<code>JDK 1.8</code>时，实现了<code>Iterable</code>接口的集合可以使用<strong>增强 for 循环</strong>遍历集合对象，我们通过<strong>反编译</strong>后发现底层还是使用<code>Iterator</code>迭代器进行遍历</li>
</ol>
<p>等等，这一章还没完，还有一个<code>ListIterator</code>。它继承 Iterator 接口，在遍历<code>List</code>集合时可以从<strong>任意索引下标</strong>开始遍历，而且支持<strong>双向遍历</strong>。</p>
<p>ListIterator 存在于 List 集合之中，通过调用方法可以返回<strong>起始下标</strong>为 <code>index</code>的迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 返回下标为0的迭代器</span></span><br><span class="line">ListIterator&lt;Integer&gt; listIter1 = list.listIterator(); </span><br><span class="line"><span class="comment">// 返回下标为5的迭代器</span></span><br><span class="line">ListIterator&lt;Integer&gt; listIter2 = list.listIterator(<span class="number">5</span>); </span><br></pre></td></tr></table></figure>
<p>ListIterator 中有几个重要方法，大多数方法与 Iterator 中定义的含义相同，但是比 Iterator 强大的地方是可以在<strong>任意一个下标位置</strong>返回该迭代器，且可以实现<strong>双向遍历</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 替换当前下标的元素,即访问过的最后一个元素</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map-和-Collection-接口"><a href="#Map-和-Collection-接口" class="headerlink" title="Map 和 Collection 接口"></a>Map 和 Collection 接口</h3><p>Map 接口和 Collection 接口是集合框架体系的两大门派，Collection 是存储元素本身，而 Map 是存储<code>&lt;key, value&gt;</code>键值对，在 Collection 门派下有一小部分弟子去<code>偷师</code>，利用 Map 门派下的弟子来修炼自己。</p>
<p>是不是听的一头雾水哈哈哈，举个例子你就懂了：<code>HashSet</code>底层利用了<code>HashMap</code>，<code>TreeSet</code>底层用了<code>TreeMap</code>，<code>LinkedHashSet</code>底层用了<code>LinkedHashMap</code>。</p>
<p>下面我会详细讲到各个具体集合类哦，所以在这里，我们先从整体上了解这两个<code>门派</code>的特点和区别。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595998378619-e54eb2d1-128a-448e-98c6-4941d81546b5.png" alt="img"></p>
<p><code>Map</code>接口定义了存储的数据结构是<code>&lt;key, value&gt;</code>形式，根据 key 映射到 value，一个 key 对应一个 value ，所以<code>key</code>不可重复，而<code>value</code>可重复。</p>
<p>在<code>Map</code>接口下会将存储的方式细分为不同的种类：</p>
<ul>
<li><code>SortedMap</code>接口：该类映射可以对<code>&lt;key, value&gt;</code>按照自己的规则进行<strong>排序</strong>，具体实现有 TreeMap</li>
<li><code>AbsractMap</code>：它为子类提供好一些<strong>通用的API实现</strong>，所有的具体Map如<code>HashMap</code>都会继承它</li>
</ul>
<p>而<code>Collection</code>接口提供了所有集合的<strong>通用方法</strong>（注意这里不包括<code>Map</code>）：</p>
<ul>
<li>添加方法：<code>add(E e)</code> / <code>addAll(Collection&lt;? extends E&gt; var1)</code></li>
<li>删除方法：<code>remove(Object var1)</code> / <code>removeAll(Collection&lt;?&gt; var1)</code></li>
<li>查找方法：<code>contains(Object var1)</code> / <code>containsAll(Collection&lt;?&gt; var1);</code></li>
<li>查询集合自身信息：<code>size()</code> / <code>isEmpty()</code></li>
<li>···</li>
</ul>
<p>在<code>Collection</code>接口下，同样会将集合细分为不同的种类：</p>
<ul>
<li><code>Set</code>接口：一个<strong>不允许存储重复元素</strong>的<strong>无序</strong>集合，具体实现有<code>HashSet</code> / <code>TreeSet</code>···</li>
<li><code>List</code>接口：一个<strong>可存储重复元素</strong>的<strong>有序</strong>集合，具体实现有<code>ArrayList</code> / <code>LinkedList</code>···</li>
<li><code>Queue</code>接口：一个<strong>可存储重复元素</strong>的<strong>队列</strong>，具体实现有<code>PriorityQueue</code> / <code>ArrayDeque</code>···</li>
</ul>
<h2 id="Map-集合体系详解"><a href="#Map-集合体系详解" class="headerlink" title="Map 集合体系详解"></a>Map 集合体系详解</h2><p><code>Map</code>接口是由<code>&lt;key, value&gt;</code>组成的集合，由<code>key</code>映射到<strong>唯一</strong>的<code>value</code>，所以<code>Map</code>不能包含重复的<code>key</code>，每个键<strong>至多</strong>映射一个值。下图是整个 Map 集合体系的主要组成部分，我将会按照日常使用频率从高到低一一讲解。</p>
<p>不得不提的是 Map 的设计理念：<strong>定位元素</strong>的时间复杂度优化到 <code>O(1)</code></p>
<p>Map 体系下主要分为 AbstractMap 和 SortedMap两类集合</p>
<p><code>AbstractMap</code>是对 Map 接口的扩展，它定义了普通的 Map 集合具有的<strong>通用行为</strong>，可以避免子类重复编写大量相同的代码，子类继承 AbstractMap 后可以重写它的方法，<strong>实现额外的逻辑</strong>，对外提供更多的功能。</p>
<p><code>SortedMap</code> 定义了该类 Map 具有 <code>排序</code>行为，同时它在内部定义好有关排序的抽象方法，当子类实现它时，必须重写所有方法，对外提供排序功能。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596032812883-d74e0796-09ad-41cd-8c7c-46e01775ec75.png" alt="image.png" style="zoom:67%;" /></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap 是一个<strong>最通用的</strong>利用哈希表存储元素的集合，将元素放入 HashMap 时，将<code>key</code>的哈希值转换为数组的<code>索引</code>下标<strong>确定存放位置</strong>，查找时，根据<code>key</code>的哈希地址转换成数组的<code>索引</code>下标<strong>确定查找位置</strong>。</p>
<p>HashMap 底层是用数组 + 链表 + 红黑树这三种数据结构实现，它是<strong>非线程安全</strong>的集合。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595419821508-67e5c9e1-ab2a-4f96-9df7-7a37658e564a.png" alt="img"></p>
<p>发送哈希冲突时，HashMap 的解决方法是将相同映射地址的元素连成一条<code>链表</code>，如果链表的长度大于<code>8</code>时，且数组的长度大于<code>64</code>则会转换成<code>红黑树</code>数据结构。</p>
<p>关于 HashMap 的简要总结：</p>
<ol>
<li>它是集合中最常用的<code>Map</code>集合类型，底层由<code>数组 + 链表 + 红黑树</code>组成</li>
<li>HashMap不是线程安全的</li>
<li>插入元素时，通过计算元素的<code>哈希值</code>，通过<strong>哈希映射函数</strong>转换为<code>数组下标</code>；查找元素时，同样通过哈希映射函数得到数组下标<code>定位元素的位置</code></li>
</ol>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap 可以看作是 <code>HashMap</code> 和 <code>LinkedList</code> 的结合：它在 HashMap 的基础上添加了一条双向链表，<code>默认</code>存储各个元素的插入顺序，但由于这条双向链表，使得 LinkedHashMap 可以实现 <code>LRU</code>缓存淘汰策略，因为我们可以设置这条双向链表按照<code>元素的访问次序</code>进行排序</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596103017691-7eb35af1-3fde-46b8-aa56-31df67c1b3de.png" alt="img"></p>
<p>LinkedHashMap 是 HashMap 的子类，所以它具备 HashMap 的所有特点，其次，它在 HashMap 的基础上维护了一条<code>双向链表</code>，该链表存储了<strong>所有元素</strong>，<code>默认</code>元素的顺序与插入顺序<strong>一致</strong>。若<code>accessOrder</code>属性为<code>true</code>，则遍历顺序按元素的访问次序进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K, V&gt; head;</span><br><span class="line"><span class="comment">// 尾结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K, V&gt; tail;</span><br></pre></td></tr></table></figure>
<p>利用 LinkedHashMap  可以实现 <code>LRU</code> 缓存淘汰策略，因为它提供了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(java.util.Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以移除<code>最靠近链表头部</code>的一个节点，而在<code>get()</code>方法中可以看到下面这段代码，其作用是挪动结点的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.accessOrder) &#123;</span><br><span class="line">    <span class="built_in">this</span>.afterNodeAccess(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要调用了<code>get()</code>且<code>accessOrder = true</code>，则会将该节点更新到链表<code>尾部</code>，具体的逻辑在<code>afterNodeAccess()</code>中，感兴趣的可翻看源码，篇幅原因这里不再展开。</p>
<p>现在如果要实现一个<code>LRU</code>缓存策略，则需要做两件事情：</p>
<ul>
<li>指定<code>accessOrder = true</code>可以设定链表按照访问顺序排列，通过提供的构造器可以设定<code>accessOrder</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重写<code>removeEldestEntry()</code>方法，内部定义逻辑，通常是判断<code>容量</code>是否达到上限，若是则执行淘汰。</li>
</ul>
<p>这里就要贴出一道大厂面试必考题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU缓存机制</a>，只要跟着我的步骤，就能顺利完成这道大厂题了。</p>
<p>关于 LinkedHashMap 主要介绍两点：</p>
<ol>
<li>它底层维护了一条<code>双向链表</code>，因为继承了 HashMap，所以它也不是线程安全的</li>
<li>LinkedHashMap 可实现<code>LRU</code>缓存淘汰策略，其原理是通过设置<code>accessOrder</code>为<code>true</code>并重写<code>removeEldestEntry</code>方法定义淘汰元素时需满足的条件</li>
</ol>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap 是 <code>SortedMap</code> 的子类，所以它具有<strong>排序</strong>功能。它是基于<code>红黑树</code>数据结构实现的，每一个键值对<code>&lt;key, value&gt;</code>都是一个结点，默认情况下按照<code>key</code>自然排序，另一种是可以通过传入定制的<code>Comparator</code>进行自定义规则排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照 key 自然排序，Integer 的自然排序是升序</span></span><br><span class="line">TreeMap&lt;Integer, Object&gt; naturalSort = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 定制排序，按照 key 降序排序</span></span><br><span class="line">TreeMap&lt;Integer, Object&gt; customSort = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((o1, o2) -&gt; Integer.compare(o2, o1));</span><br></pre></td></tr></table></figure>
<p>TreeMap 底层使用了数组+红黑树实现，所以里面的存储结构可以理解成下面这幅图哦。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596103385086-d684f26e-dabd-44b7-bab8-151af172496a.png" alt="image-20200730180101883.png"></p>
<p>图中红黑树的每一个节点都是一个<code>Entry</code>，在这里为了图片的简洁性，就不标明 key 和 value 了，注意这些元素都是已经按照<code>key</code>排好序了，整个数据结构都是保持着<code>有序</code> 的状态！</p>
<p>关于<code>自然</code>排序与<code>定制</code>排序：</p>
<ul>
<li>自然排序：要求<code>key</code>必须实现<code>Comparable</code>接口。</li>
</ul>
<p>由于<code>Integer</code>类实现了 Comparable 接口，按照自然排序规则是按照<code>key</code>从小到大排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">treeMap.put(<span class="number">2</span>, <span class="string">&quot;TWO&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">1</span>, <span class="string">&quot;ONE&quot;</span>);</span><br><span class="line">System.out.print(treeMap);</span><br><span class="line"><span class="comment">// &#123;1=ONE, 2=TWO&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定制排序：在初始化 TreeMap 时传入新的<code>Comparator</code>，<strong>不</strong>要求<code>key</code>实现 Comparable 接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((o1, o2) -&gt; Integer.compare(o2, o1));</span><br><span class="line">treeMap.put(<span class="number">1</span>, <span class="string">&quot;ONE&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">2</span>, <span class="string">&quot;TWO&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">4</span>, <span class="string">&quot;FOUR&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">3</span>, <span class="string">&quot;THREE&quot;</span>);</span><br><span class="line">System.out.println(treeMap);</span><br><span class="line"><span class="comment">// &#123;4=FOUR, 3=THREE, 2=TWO, 1=ONE&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过传入新的<code>Comparator</code>比较器，可以覆盖默认的排序规则，上面的代码按照<code>key</code>降序排序，在实际应用中还可以按照其它规则自定义排序。</p>
<p><code>compare()</code>方法的返回值有三种，分别是：<code>0</code>，<code>-1</code>，<code>+1</code></p>
<p>（1）如果返回<code>0</code>，代表两个元素相等，不需要调换顺序</p>
<p>（2）如果返回<code>+1</code>，代表前面的元素需要与后面的元素调换位置</p>
<p>（3）如果返回<code>-1</code>，代表前面的元素不需要与后面的元素调换位置</p>
<p>而何时返回<code>+1</code>和<code>-1</code>，则由我们自己去定义，JDK默认是按照<strong>自然排序</strong>，而我们可以根据<code>key</code>的不同去定义降序还是升序排序。</p>
<p>关于 TreeMap 主要介绍了两点：</p>
<ol>
<li>它底层是由<code>红黑树</code>这种数据结构实现的，所以操作的时间复杂度恒为<code>O(logN)</code></li>
<li>TreeMap 可以对<code>key</code>进行自然排序或者自定义排序，自定义排序时需要传入<code>Comparator</code>，而自然排序要求<code>key</code>实现了<code>Comparable</code>接口</li>
<li>TreeMap 不是线程安全的。</li>
</ol>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>WeakHashMap 日常开发中比较少见，它是基于普通的<code>Map</code>实现的，而里面<code>Entry</code>中的键在每一次的<code>垃圾回收</code>都会被清除掉，所以非常适合用于<strong>短暂访问、仅访问一次</strong>的元素，缓存在<code>WeakHashMap</code>中，并尽早地把它回收掉。</p>
<p>当<code>Entry</code>被<code>GC</code>时，WeakHashMap 是如何感知到某个元素被回收的呢？</p>
<p>在 WeakHashMap 内部维护了一个引用队列<code>queue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这个 queue 里包含了所有被<code>GC</code>掉的键，当JVM开启<code>GC</code>后，如果回收掉 WeakHashMap 中的 key，会将 key 放入queue 中，在<code>expungeStaleEntries()</code>中遍历 queue，把 queue 中的所有<code>key</code>拿出来，并在 WeakHashMap 中删除掉，以达到<strong>同步</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="literal">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="comment">// 去 WeakHashMap 中删除该键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再者，需要注意 WeakHashMap 底层存储的元素的数据结构是<code>数组 + 链表</code>，<strong>没有红黑树</strong>哦，可以换一个角度想，如果还有红黑树，那干脆直接继承 HashMap ，然后再扩展就完事了嘛，然而它并没有这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，WeakHashMap 的数据结构图我也为你准备好啦。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596106079292-a74fb47e-bb54-47e2-81ac-1254428e73b7.png" alt="image.png"></p>
<p>图中被虚线标识的元素将会在下一次访问 WeakHashMap 时被删除掉，WeakHashMap 内部会做好一系列的调整工作，所以记住队列的作用就是标志那些已经被<code>GC</code>回收掉的元素。</p>
<p>关于 WeakHashMap 需要注意两点：</p>
<ol>
<li>它的键是一种<strong>弱键</strong>，放入 WeakHashMap 时，随时会被回收掉，所以不能确保某次访问元素一定存在</li>
<li>它依赖普通的<code>Map</code>进行实现，是一个非线程安全的集合</li>
<li>WeakHashMap 通常作为<strong>缓存</strong>使用，适合存储那些<strong>只需访问一次</strong>、或<strong>只需保存短暂时间</strong>的键值对</li>
</ol>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable 底层的存储结构是<code>数组 + 链表</code>，而它是一个<strong>线程安全</strong>的集合，但是因为这个线程安全，它就被淘汰掉了。</p>
<p>下面是Hashtable存储元素时的数据结构图，它只会存在数组+链表，当链表过长时，查询的效率过低，而且会长时间<strong>锁住</strong> Hashtable。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596106328540-e1acec81-7896-45be-85c4-c93e142ef610.png" alt="image.png"></p>
<blockquote>
<p>这幅图是否有点眼熟哈哈哈哈，本质上就是 WeakHashMap 的底层存储结构了。你千万别问为什么 WeakHashMap 不继承 Hashtable 哦，Hashtable 的<code>性能</code>在并发环境下非常差，在非并发环境下可以用<code>HashMap</code>更优。</p>
</blockquote>
<p>HashTable 本质上是 HashMap 的前辈，它被淘汰的原因也主要因为两个字：<strong>性能</strong></p>
<p>HashTable 是一个 <strong>线程安全</strong> 的 Map，它所有的方法都被加上了 <strong>synchronized</strong> 关键字，也是因为这个关键字，它注定成为了时代的弃儿。</p>
<p>HashTable 底层采用 <strong>数组+链表</strong> 存储键值对，由于被弃用，后人也没有对它进行任何改进</p>
<p>HashTable 默认长度为 <code>11</code>，负载因子为 <code>0.75F</code>，即元素个数达到数组长度的 75% 时，会进行一次扩容，每次扩容为原来数组长度的 <code>2</code> 倍</p>
<p>HashTable 所有的操作都是线程安全的。</p>
<h2 id="Collection-集合体系详解"><a href="#Collection-集合体系详解" class="headerlink" title="Collection 集合体系详解"></a>Collection 集合体系详解</h2><p>Collection 集合体系的顶层接口就是<code>Collection</code>，它规定了该集合下的一系列行为约定。</p>
<p>该集合下可以分为三大类集合：List，Set和Queue</p>
<p><code>Set</code>接口定义了该类集合<strong>不允许存储重复</strong>的元素，且任何操作时均需要通过<strong>哈希函数映射</strong>到集合内部定位元素，集合内部的元素<strong>默认</strong>是<strong>无序</strong>的。</p>
<p><code>List</code>接口定义了该类集合<strong>允许存储重复</strong>的元素，且集合内部的元素按照元素插入的顺序<strong>有序排列</strong>，可以通过<strong>索引</strong>访问元素。</p>
<p><code>Queue</code>接口定义了该类集合是以<code>队列</code>作为存储结构，所以集合内部的元素<strong>有序排列</strong>，仅可以操作<strong>头结点</strong>元素，无法访问队列中间的元素。</p>
<p>上面三个接口是<strong>最普通，最抽象</strong>的实现，而在各个集合接口内部，还会有更加具体的表现，衍生出各种不同的<strong>额外功能</strong>，使开发者能够对比各个集合的优势，<strong>择优使用</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595682008755-6f1e6c3c-920e-427b-9c00-a4164026f181.png" alt="image.png"></p>
<h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p><code>Set</code>接口继承了<code>Collection</code>接口，是一个不包括重复元素的集合，更确切地说，Set 中任意两个元素不会出现 <code>o1.equals(o2)</code>，而且 Set <strong>至多</strong>只能存储一个 <code>NULL</code> 值元素，Set 集合的组成部分可以用下面这张图概括：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596107343106-b98a8b29-06ba-4f6f-ab14-7a139e506dd5.png" alt="1595682050240-6c6946f2-9dd4-4e5b-a006-39144184e2f1.png"></p>
<p>在 Set 集合体系中，我们需要着重关注两点：</p>
<ul>
<li><p>存入<strong>可变元素</strong>时，必须非常小心，因为任意时候元素状态的改变都有可能使得 Set 内部出现两个<strong>相等</strong>的元素，即 <code>o1.equals(o2) = true</code>，所以一般不要更改存入 Set 中的元素，否则将会破坏了 <code>equals()</code> 的作用！</p>
</li>
<li><p>Set 的最大作用就是判重，在项目中最大的作用也是<strong>判重</strong>！</p>
</li>
</ul>
<p>接下来我们去看它的实现类和子类： <code>AbstractSet</code> 和 <code>SortedSet</code></p>
<h3 id="AbstractSet-抽象类"><a href="#AbstractSet-抽象类" class="headerlink" title="AbstractSet 抽象类"></a>AbstractSet 抽象类</h3><p><code>AbstractSet</code> 是一个实现 Set 的一个抽象类，定义在这里可以将所有具体 Set 集合的<strong>相同行为</strong>在这里实现，<strong>避免子类包含大量的重复代码</strong></p>
<p>所有的 Set 也应该要有相同的 <code>hashCode()</code> 和 <code>equals()</code> 方法，所以使用抽象类把该方法重写后，子类无需关心这两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断两个 set 是否相等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>) &#123; <span class="comment">// 集合本身</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Set)) &#123; <span class="comment">// 集合不是 set</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 比较两个集合的元素是否全部相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算所有元素的 hashcode 总和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.iterator();</span><br><span class="line">        <span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">obj</span> <span class="operator">=</span> i.next();</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                h += obj.hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SortedSet-接口"><a href="#SortedSet-接口" class="headerlink" title="SortedSet 接口"></a>SortedSet 接口</h3><p><code>SortedSet</code> 是一个接口，它在 Set 的基础上扩展了<strong>排序</strong>的行为，所以所有实现它的子类都会拥有排序功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortedSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 元素的比较器,决定元素的排列顺序</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> E&gt; comparator(); </span><br><span class="line">    <span class="comment">// 获取 [var1, var2] 之间的 set</span></span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E var1, E var2)</span>; </span><br><span class="line">    <span class="comment">// 获取以 var1 开头的 Set</span></span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E var1)</span>; </span><br><span class="line">    <span class="comment">// 获取以 var1 结尾的 Set</span></span><br><span class="line">    SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E var1)</span>; </span><br><span class="line">    <span class="comment">// 获取首个元素</span></span><br><span class="line">    E <span class="title function_">first</span><span class="params">()</span>; </span><br><span class="line">    <span class="comment">// 获取最后一个元素</span></span><br><span class="line">    E <span class="title function_">last</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet 底层借助 <code>HashMap</code> 实现，我们可以观察它的多个构造方法，本质上都是 new 一个 HashMap</p>
<blockquote>
<p>这也是这篇文章为什么先讲解 Map 再讲解 Set 的原因！先学习 Map，有助于理解 Set</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以观察 <code>add()</code> 方法和<code>remove()</code>方法是如何将 HashSet 的操作嫁接到 HashMap 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.map.remove(o) == PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 <code>PRESENT</code> 就是一个<strong>静态常量</strong>：使用 PRESENT 作为 HashMap 的 value 值，使用HashSet的开发者只需<strong>关注</strong>于需要插入的 <code>key</code>，<strong>屏蔽</strong>了 HashMap 的 <code>value</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596109695209-9cd36cf2-1b1f-44db-94ee-71d60348d257.png" alt="image.png"></p>
<p>上图可以观察到每个<code>Entry</code>的<code>value</code>都是 PRESENT 空对象，我们就不用再理会它了。</p>
<p>HashSet 在 HashMap 基础上实现，所以很多地方可以联系到 HashMap：</p>
<ul>
<li>底层数据结构：HashSet 也是采用<code>数组 + 链表 + 红黑树</code>实现</li>
<li>线程安全性：由于采用 HashMap 实现，而 HashMap 本身线程不安全，在HashSet 中没有添加额外的同步策略，所以 HashSet 也<strong>线程不安全</strong></li>
<li>存入 HashSet 的对象的状态<strong>最好不要发生变化</strong>，因为有可能改变状态后，在集合内部出现两个元素<code>o1.equals(o2)</code>，破坏了 <code>equals()</code>的语义。</li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet 的代码少的可怜，不信我给你我粘出来</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596108598046-702b165f-6aa0-463e-b87b-de9305acb693.png" alt="image.png"></p>
<p>少归少，还是不能闹，<code>LinkedHashSet</code>继承了<code>HashSet</code>，我们跟随到父类 HashSet 的构造方法看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现父类中 map 的实现采用<code>LinkedHashMap</code>，这里注意不是<code>HashMap</code>，而 LinkedHashMap 底层又采用 HashMap + 双向链表 实现的，所以本质上 LinkedHashSet 还是使用 HashMap 实现的。</p>
<blockquote>
<p>LinkedHashSet -&gt; LinkedHashMap -&gt; HashMap + 双向链表</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596110006108-d064aa74-d71c-401a-94b9-83caef7cdbc7.png" alt="image.png"></p>
<p>而 LinkedHashMap 是采用 <code>HashMap</code>和<code>双向链表</code>实现的，这条双向链表中保存了元素的插入顺序。所以 LinkedHashSet 可以按照元素的插入顺序遍历元素，如果你熟悉<code>LinkedHashMap</code>，那 LinkedHashSet 也就更不在话下了。</p>
<p>关于 LinkedHashSet 需要注意几个地方：</p>
<ul>
<li>它继承了 <code>HashSet</code>，而 HashSet 默认是采用 HashMap 存储数据的，但是 LinkedHashSet 调用父类构造方法初始化 map 时是 LinkedHashMap 而不是 HashMap，这个要额外注意一下</li>
<li>由于 LinkedHashMap 不是线程安全的，且在 LinkedHashSet 中没有添加额外的同步策略，所以 LinkedHashSet 集合<strong>也不是线程安全</strong>的</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet 是基于 TreeMap 的实现，所以存储的元素是<strong>有序</strong>的，底层的数据结构是<code>数组 + 红黑树</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596126807774-1a122d9e-4210-4708-8328-c23f65bc55dd.png" alt="img"></p>
<p>而元素的排列顺序有<code>2</code>种，和 TreeMap 相同：自然排序和定制排序，常用的构造方法已经在下面展示出来了，TreeSet 默认按照自然排序，如果需要定制排序，需要传入<code>Comparator</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeSet 应用场景有很多，像在游戏里的玩家战斗力排行榜</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compareTo(<span class="built_in">this</span>.score, o.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Player</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="type">Player</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">90</span>);</span><br><span class="line">    <span class="type">Player</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">80</span>);</span><br><span class="line">    TreeSet&lt;Player&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">    set.add(s2); set.add(s1); set.add(s3);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [Student&#123;name=&#x27;王五&#x27;, score=80&#125;, Student&#123;name=&#x27;李四&#x27;, score=90&#125;, Student&#123;name=&#x27;张三&#x27;, score=100&#125;]</span></span><br></pre></td></tr></table></figure>
<p>对 TreeSet 介绍了它的主要实现方式和应用场景，有几个值得注意的点。</p>
<ul>
<li>TreeSet 的所有操作都会转换为对 TreeMap 的操作，TreeMap 采用<strong>红黑树</strong>实现，任意操作的平均时间复杂度为 <code>O(logN)</code></li>
<li>TreeSet 是一个<strong>线程不安全</strong>的集合</li>
<li>TreeSet 常应用于对<strong>不重复</strong>的元素<strong>定制排序</strong>，例如玩家战力排行榜</li>
</ul>
<blockquote>
<p>注意:TreeSet判断元素是否重复的方法是判断compareTo()方法是否返回0，而不是调用 hashcode() 和 equals() 方法，如果返回 0 则认为集合内已经存在相同的元素，不会再加入到集合当中。</p>
</blockquote>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p>List 接口和 Set 接口齐头并进，是我们日常开发中接触的很多的一种集合类型了。整个 List 集合的组成部分如下图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596123811338-4c47cdc8-bac9-4670-91ee-6d8a82159bc6.png" alt="img" style="zoom:67%;" /></p>
<p><code>List</code> 接口直接继承 Collection 接口，它定义为可以存储<strong>重复</strong>元素的集合，并且元素按照插入顺序<strong>有序排列</strong>，且可以通过<strong>索引</strong>访问指定位置的元素。常见的实现有：ArrayList、LinkedList、Vector和Stack</p>
<h3 id="AbstractList-和-AbstractSequentialList"><a href="#AbstractList-和-AbstractSequentialList" class="headerlink" title="AbstractList  和 AbstractSequentialList"></a>AbstractList  和 AbstractSequentialList</h3><p>AbstractList 抽象类实现了 List 接口，其内部实现了所有的 List 都需具备的功能，子类可以专注于实现自己具体的操作逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素 o 第一次出现的索引位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">// 查找元素 o 最后一次出现的索引位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">//···</span></span><br></pre></td></tr></table></figure>
<p>AbstractSequentialList 抽象类继承了 AbstractList，在原基础上限制了访问元素的顺序<strong>只能够按照顺序访问</strong>，而<strong>不支持随机访问</strong>，如果需要满足随机访问的特性，则继承 AbstractList。子类 LinkedList 使用链表实现，所以仅能支持<strong>顺序访问</strong>，顾继承了 <code>AbstractSequentialList</code>而不是 AbstractList。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595375364068-c2c49168-a2f4-4a06-97c0-eb3446d60a68.png" alt="image.png"></p>
<p><code>Vector</code> 在现在已经是一种过时的集合了，包括继承它的 <code>Stack</code> 集合也如此，它们被淘汰的原因都是因为<strong>性能</strong>低下。</p>
<blockquote>
<p>JDK 1.0 时代，ArrayList 还没诞生，大家都是使用 Vector 集合，但由于 Vector 的<strong>每个操作</strong>都被 <strong>synchronized</strong> 关键字修饰，即使在线程安全的情况下，仍然<strong>进行无意义的加锁与释放锁</strong>，造成额外的性能开销，做了无用功。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<p>在 JDK 1.2 时，Collection 家族出现了，它提供了大量<strong>高性能、适用於不同场合</strong>的集合，而 Vector 也是其中一员，但由于 Vector 在每个方法上都加了锁，由于需要兼容许多老的项目，很难在此基础上优化<code>Vector</code>了，所以渐渐地也就被历史淘汰了。</p>
<p>现在，在<strong>线程安全</strong>的情况下，不需要选用 Vector 集合，取而代之的是 <strong>ArrayList</strong> 集合；在并发环境下，出现了 <code>CopyOnWriteArrayList</code>，Vector 完全被弃用了。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596126551356-dc1af780-2fe9-4d04-8351-e70637ecdab5.png" alt="img"></p>
<p><code>Stack</code>是一种<code>后入先出（LIFO）</code>型的集合容器，如图中所示，<code>大雄</code>是最后一个进入容器的，top指针指向大雄，那么弹出元素时，大雄也是第一个被弹出去的。</p>
<p>Stack 继承了 Vector 类，提供了栈顶的压入元素操作（push）和弹出元素操作（pop），以及查看栈顶元素的方法（peek）等等，但由于继承了 Vector，正所谓跟错老大没福报，Stack 也渐渐被淘汰了。</p>
<p>取而代之的是后起之秀 <code>Deque</code>接口，其实现有 <code>ArrayDeque</code>，该数据结构更加完善、可靠性更好，依靠队列也可以实现<code>LIFO</code>的栈操作，所以优先选择 ArrayDeque 实现栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<p>ArrayDeque 的数据结构是：<code>数组</code>，并提供<strong>头尾指针下标</strong>对数组元素进行操作。本文也会讲到哦，客官请继续往下看，莫着急！:smile:</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 以<strong>数组</strong>作为存储结构，它是<strong>线程不安全</strong>的集合；具有<strong>查询快、在数组中间或头部增删慢</strong>的特点，所以它除了线程不安全这一点，其余可以替代<code>Vector</code>，而且线程安全的 ArrayList 可以使用 <code>CopyOnWriteArrayList</code>代替 Vector。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595375364068-c2c49168-a2f4-4a06-97c0-eb3446d60a68.png" alt="image.png"></p>
<p>关于 ArrayList 有几个重要的点需要注意的：</p>
<ul>
<li><p>具备<strong>随机访问</strong>特点，<strong>访问元素的效率</strong>较高，ArrayList 在<strong>频繁插入、删除</strong>集合元素的场景下效率较<code>低</code>。</p>
</li>
<li><p>底层数据结构：ArrayList 底层使用数组作为存储结构，具备<strong>查找快、增删慢</strong>的特点</p>
</li>
<li><p>线程安全性：ArrayList 是<strong>线程不安全</strong>的集合</p>
</li>
<li><p>ArrayList <strong>首次扩容</strong>后的长度为 <code>10</code>，调用 <code>add()</code> 时需要计算容器的最小容量。可以看到如果数组<code>elementData</code>为空数组，会将最小容量设置为<code>10</code>，之后会将数组长度完成首次扩容到 10。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new ArrayList 时的默认空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 计算该容器应该满足的最小容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>集合从<strong>第二次扩容</strong>开始，数组长度将扩容为原来的 <code>1.5</code> 倍，即：<code>newLength = oldLength * 1.5</code></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595724934991-c2f12445-bc9e-4e1c-b965-04f2ef9d3d79.png" alt="image.png"></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 底层采用<code>双向链表</code>数据结构存储元素，由于链表的内存地址<code>非连续</code>，所以它不具备随机访问的特点，但由于它利用指针连接各个元素，所以插入、删除元素只需要<code>操作指针</code>，不需要<code>移动元素</code>，故具有<strong>增删快、查询慢</strong>的特点。它也是一个非线程安全的集合。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595393003456-d37281f4-8332-46b4-9d81-e1f0c24dc060.png" alt="image.png"></p>
<p>由于以双向链表作为数据结构，它是<strong>线程不安全</strong>的集合；存储的每个节点称为一个<code>Node</code>，下图可以看到 Node 中保存了<code>next</code>和<code>prev</code>指针，<code>item</code>是该节点的值。在插入和删除时，时间复杂度都保持为 <code>O(1)</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595725358023-1f64f780-9dd0-47ff-a84c-d4101d16c1e1.png" alt="image.png"></p>
<p>关于 LinkedList，除了它是以链表实现的集合外，还有一些特殊的特性需要注意的。</p>
<ul>
<li>优势：LinkedList 底层没有<code>扩容机制</code>，使用<code>双向链表</code>存储元素，所以插入和删除元素效率较高，适用于频繁操作元素的场景</li>
<li>劣势：LinkedList 不具备<code>随机访问</code>的特点，查找某个元素只能从 <code>head</code> 或 <code>tail</code> 指针一个一个比较，所以<strong>查找中间的元素时效率很低</strong></li>
<li>查找优化：LinkedList 查找某个下标 <code>index</code> 的元素时<strong>做了优化</strong>，若 <code>index &gt; (size / 2)</code>，则从 <code>head</code> 往后查找，否则从 <code>tail</code> 开始往前查找，代码如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    LinkedList.Node x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">this</span>.size &gt;&gt; <span class="number">1</span>) &#123; <span class="comment">// 查找的下标处于链表前半部分则从头找</span></span><br><span class="line">        x = <span class="built_in">this</span>.first;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; ++i) &#123; x = x.next; &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 查找的下标处于数组的后半部分则从尾开始找</span></span><br><span class="line">        x = <span class="built_in">this</span>.last;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="built_in">this</span>.size - <span class="number">1</span>; i &gt; index; --i) &#123; x = x.prev; &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>双端队列：使用双端链表实现，并且实现了 <code>Deque</code> 接口，使得 LinkedList 可以用作<strong>双端队列</strong>。下图可以看到 Node 是集合中的元素，提供了前驱指针和后继指针，还提供了一系列操作<code>头结点</code>和<code>尾结点</code>的方法，具有双端队列的特性。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595693779116-a8156f03-36fa-4557-892e-ea5103b06136.png" alt="image.png"></p>
<p>LinkedList 集合最让人树枝的是它的链表结构，但是我们同时也要注意它是一个双端队列型的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Object&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();	</span><br></pre></td></tr></table></figure>
<h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p><code>Queue</code>队列，在 JDK 中有两种不同类型的集合实现：<strong>单向队列</strong>（AbstractQueue） 和 <strong>双端队列</strong>（Deque）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595684241064-e863aeca-6a95-4423-92c4-762f56be1dbe.png" alt="img"></p>
<p>Queue 中提供了两套增加、删除元素的 API，当插入或删除元素失败时，会有<strong>两种不同的失败处理策略</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法及失败策略</th>
<th style="text-align:left">插入方法</th>
<th style="text-align:left">删除方法</th>
<th>查找方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">抛出异常</td>
<td style="text-align:left">add()</td>
<td style="text-align:left">remove()</td>
<td>get()</td>
</tr>
<tr>
<td style="text-align:left">返回失败默认值</td>
<td style="text-align:left">offer()</td>
<td style="text-align:left">poll()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
</div>
<p>选取哪种方法的决定因素：插入和删除元素失败时，希望<code>抛出异常</code>还是返回<code>布尔值</code></p>
<p><code>add()</code> 和 <code>offer()</code> 对比：</p>
<p>在队列长度大小确定的场景下，队列放满元素后，添加下一个元素时，add() 会抛出 <code>IllegalStateException</code>异常，而 <code>offer()</code> 会返回 <code>false</code> 。</p>
<p>但是它们两个方法在插入<strong>某些不合法的元素</strong>时都会抛出三个相同的异常。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595691512036-ed9fd3ea-5432-4105-a3fb-a5374d571971.png" alt="image.png"></p>
<p><code>remove()</code> 和 <code>poll()</code> 对比：</p>
<p>在<strong>队列为空</strong>的场景下， <code>remove()</code> 会抛出 <code>NoSuchElementException</code>异常，而 <code>poll()</code> 则返回 <code>null</code> 。</p>
<p><code>get()</code>和<code>peek()</code>对比：</p>
<p>在队列为空的情况下，<code>get()</code>会抛出<code>NoSuchElementException</code>异常，而<code>peek()</code>则返回<code>null</code>。</p>
<h3 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h3><p><code>Deque</code> 接口的实现非常好理解：从<strong>单向</strong>队列演变为<strong>双向</strong>队列，内部额外提供<strong>双向队列的操作方法</strong>即可：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596166722772-975ff644-6abf-441b-b678-4a6de5b0eef1.png" alt="image.png"></p>
<p>Deque 接口额外提供了<strong>针对队列的头结点和尾结点</strong>操作的方法，而<strong>插入、删除方法同样也提供了两套不同的失败策略</strong>。除了<code>add()</code>和<code>offer()</code>，<code>remove()</code>和<code>poll()</code>以外，还有<code>get()</code>和<code>peek()</code>出现了不同的策略</p>
<h3 id="AbstractQueue-抽象类"><a href="#AbstractQueue-抽象类" class="headerlink" title="AbstractQueue 抽象类"></a>AbstractQueue 抽象类</h3><p>AbstractQueue 类中提供了各个 API 的基本实现，主要针对各个不同的处理策略给出基本的方法实现，定义在这里的作用是让<code>子类</code>根据其<code>方法规范</code>（操作失败时抛出异常还是返回默认值）实现具体的业务逻辑。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596167156067-36121579-8127-4019-ba47-e4de73f05cda.png" alt="image.png"></p>
<h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 在上面已经详细解释了，它实现了 <code>Deque</code> 接口，提供了针对头结点和尾结点的操作，并且每个结点都有<strong>前驱</strong>和<strong>后继</strong>指针，具备了双向队列的所有特性。</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>使用<strong>数组</strong>实现的双端队列，它是<strong>无界</strong>的双端队列，最小的容量是<code>8</code>（JDK 1.8）。在 JDK 11 看到它默认容量已经是 <code>16</code>了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595695213834-cb4f1c3a-e07a-42aa-981f-31a896febe26.png" alt="image.png"></p>
<p><code>ArrayDeque</code> 在日常使用得不多，值得注意的是它与 <code>LinkedList</code> 的对比：<code>LinkedList</code> 采用<strong>链表</strong>实现双端队列，而 <code>ArrayDeque</code> 使用<strong>数组</strong>实现双端队列。</p>
<blockquote>
<p>在文档中作者写到：<strong>ArrayDeque 作为栈时比 Stack 性能好，作为队列时比 LinkedList 性能好</strong></p>
</blockquote>
<p>由于双端队列<strong>只能在头部和尾部</strong>操作元素，所以删除元素和插入元素的时间复杂度大部分都稳定在 <code>O(1)</code> ，除非在扩容时会涉及到元素的批量复制操作。但是在大多数情况下，使用它时应该指定一个大概的数组长度，避免频繁的扩容。</p>
<blockquote>
<p>个人观点：链表的插入、删除操作涉及到<strong>指针的操作，我个人认为作者是觉得数组下标的移动要比指针的操作要廉价，而且数组</strong>采用<strong>连续</strong>的内存地址空间，而<strong>链表</strong>元素的内存地址是<strong>不连续</strong>的，所以数组操作元素的效率在<strong>寻址上</strong>会比链表要快。请批判看待观点。</p>
</blockquote>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 基于<strong>优先级堆实现</strong>的优先级队列，而堆是采用<strong>数组</strong>实现：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595727271522-d144468c-041e-4721-a786-9f952f06fafe.png" alt="image.png"></p>
<p>文档中的描述告诉我们：该数组中的元素通过传入 <code>Comparator</code> 进行定制排序，如果不传入<code>Comparator</code>时，则按照元素本身<code>自然排序</code>，但要求元素实现了<code>Comparable</code>接口，所以 PriorityQueue <strong>不允许存储 NULL 元素</strong>。</p>
<p>PriorityQueue 应用场景：元素本身具有优先级，需要按照<strong>优先级处理元素</strong></p>
<ul>
<li>例如游戏中的VIP玩家与普通玩家，VIP 等级越高的玩家越先安排进入服务器玩耍，减少玩家流失。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">vip1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">vip3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;洪七&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">vip4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老八&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">vip2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">normal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">normal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;赵六&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 根据玩家的 VIP 等级进行降序排序</span></span><br><span class="line">    PriorityQueue&lt;Student&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt;  o2.getScore().compareTo(o1.getScore()));</span><br><span class="line">    queue.add(vip1);queue.add(vip4);queue.add(vip3);</span><br><span class="line">    queue.add(normal1);queue.add(normal2);queue.add(vip2);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        System.out.println(s1.getName() + <span class="string">&quot;进入游戏; &quot;</span> + <span class="string">&quot;VIP等级: &quot;</span> + s1.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> Integer score;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, Integer score)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.name = name;</span><br><span class="line">         <span class="built_in">this</span>.score = score;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.score.compareTo(o.getScore());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的代码可以得到下面这种有趣的结果，可以看到<code>氪金</code>使人带来快乐。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1595727945968-768b45bb-96dc-4850-8759-f07776107a23.png" alt="image.png"></p>
<p>VIP 等级越高（优先级越高）就越优先安排进入游戏（优先处理），类似这种有优先级的场景还有非常多，各位可以发挥自己的想象力。</p>
<p>PriorityQueue 总结：</p>
<ul>
<li><p>PriorityQueue 是基于<strong>优先级堆</strong>实现的优先级队列，而堆是用<strong>数组</strong>维护的</p>
</li>
<li><p>PriorityQueue 适用于<strong>元素按优先级处理</strong>的业务场景，例如用户在请求人工客服需要排队时，根据用户的<strong>VIP等级</strong>进行 <code>插队</code> 处理，等级越高，越先安排客服。</p>
</li>
</ul>
<p>章节结束各集合总结：（以 JDK1.8 为例）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">插入、删除时间复杂度</th>
<th style="text-align:left">查询时间复杂度</th>
<th style="text-align:left">底层数据结构</th>
<th style="text-align:left">是否线程安全</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Vector</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">数组</td>
<td style="text-align:left">是（已淘汰）</td>
</tr>
<tr>
<td style="text-align:left">ArrayList</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">数组</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">LinkedList</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">双向链表</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">HashSet</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">数组+链表+红黑树</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">TreeSet</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">红黑树</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashSet</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(1)~O(N)</td>
<td style="text-align:left">数组 + 链表 + 红黑树</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">ArrayDeque</td>
<td style="text-align:left">O(N)</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">数组</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">PriorityQueue</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">堆（数组实现）</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">HashMap</td>
<td style="text-align:left">O(1) ~ O(N)</td>
<td style="text-align:left">O(1) ~ O(N)</td>
<td style="text-align:left">数组+链表+红黑树</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">TreeMap</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">数组+红黑树</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">HashTable</td>
<td style="text-align:left">O(1) / O(N)</td>
<td style="text-align:left">O(1) / O(N)</td>
<td style="text-align:left">数组+链表</td>
<td style="text-align:left">是（已淘汰）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>这一篇文章对各个集合都有些<code>点到即止</code>的味道，此文的目的是对整个集合框架有一个较为整体的了解，分析了最常用的集合的相关特性，以及某些特殊集合的应用场景例如<code>TreeSet</code>、<code>TreeMap</code>这种可定制排序的集合。</p>
<ul>
<li><p><code>Collection</code> 接口提供了整个集合框架<strong>最通用</strong>的增删改查以及集合自身操作的抽象方法，让子类去实现</p>
</li>
<li><p><code>Set</code> 接口决定了它的子类都是<strong>无序、无重复元素</strong>的集合，其主要实现有HashSet、TreeSet、LinkedHashSet。</p>
<ul>
<li><code>HashSet</code> 底层采用 <code>HashMap</code> 实现，而 <code>TreeSet</code> 底层使用 <code>TreeMap</code> 实现，大部分 Set 集合的操作都会转换为 Map 的操作，TreeSet 可以将元素按照规则进行<strong>排序</strong>。</li>
</ul>
</li>
<li><p><code>List</code> 接口决定了它的子类都是<strong>有序、可存储重复元素</strong>的集合，常见的实现有 ArrayList，LinkedList，Vector</p>
<ul>
<li><code>ArrayList</code> 使用<strong>数组</strong>实现，而 LinkedList 使用<strong>链表</strong>实现，所以它们两个的使用场景几乎是相反的，<strong>频繁查询</strong>的场景使用 ArrayList，而<strong>频繁插入删除</strong>的场景最好使用 LinkedList</li>
<li><code>LinkedList</code> 和 <code>ArrayDeque</code> 都可用于<strong>双端队列</strong>，而 <em>Josh Bloch and Doug Lea</em> 认为 <code>ArrayDeque</code> 具有比 <code>LinkedList</code> 更好的性能，<code>ArrayDeque</code>使用<strong>数组</strong>实现双端队列，<code>LinkedList</code>使用<strong>链表</strong>实现双端队列。</li>
</ul>
</li>
<li><p><code>Queue</code> 接口定义了队列的基本操作，子类集合都会拥有队列的特性：<strong>先进先出</strong>，主要实现有：LinkedList，ArrayDeque</p>
<ul>
<li><code>PriorityQueue</code> 底层使用<strong>二叉堆</strong>维护的优先级队列，而二叉堆是由<strong>数组</strong>实现的，它可以按照元素的优先级进行排序，<strong>优先级越高的元素，排在队列前面，优先被弹出处理</strong>。</li>
</ul>
</li>
<li><p><code>Map</code>接口定义了该种集合类型是以<code>&lt;key,value&gt;</code>键值对形式保存，其主要实现有：HashMap，TreeMap，LinkedHashMap，Hashtable</p>
<ul>
<li>LinkedHashMap 底层多加了一条双向链表，设置<code>accessOrder</code>为<code>true</code>并重写方法则可以实现<code>LRU</code>缓存</li>
<li>TreeMap 底层采用数组+红黑树实现，集合内的元素默认按照自然排序，也可以传入<code>Comparator</code>定制排序</li>
</ul>
</li>
</ul>
<p>看到这里非常不容易，感谢你愿意阅读我的文章，希望能对你有所帮助，你可以参考着文末总结的顺序，每当我提到一个集合时，回想它的重要知识点是什么，主要就是<code>底层数据结构</code>，<code>线程安全性</code>，<code>该集合的一两个特有性质</code>，只要能够回答出来个大概，我相信之后运用这些数据结构，你能够熟能生巧。</p>
<p>本文对整个集合体系的所有常用的集合类都分析了，这里并没有对集合内部的实现深入剖析，我想先从最宏观的角度让大家了解每个集合的的作用，应用场景，以及简单的对比，之后会抽时间对常见的集合进行源码剖析，尽情期待，感谢阅读！</p>
<blockquote>
<p>最后有些话想说：这篇文章花了我半个月去写，也是意义重大，多谢 <code>cxuan</code>哥一直指导我写文章，一步一步地去打磨出一篇好的文章真的非常不容易，写下的每一个字都能够让别人看得懂是一件非常难的事情，总结出最精华的知识分享给你们也是非常难的一件事情，希望能够一直进步下去！不忘初心，热爱分享，喜爱写作。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivkbczxoj31l20t8al5.jpg" alt="image-20210716163352584"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gsivl4khz9j31d60h8mze.jpg" alt="image-20210716163433337"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://manamn.space">Gao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://manamn.space/2022/05/03/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%B6%85%E5%85%A8Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3/">https://manamn.space/2022/05/03/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%B6%85%E5%85%A8Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://manamn.space" target="_blank">爱笑的Gao的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Java-Basic/">Java-Basic</a></div><div class="post_share"><div class="social-share" data-image="http://pic.netbian.com/uploads/allimg/200318/115722-15845038426aea.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/03/Java%E5%9F%BA%E7%A1%80/19-Java9-Java10-Java11%E6%96%B0%E7%89%B9%E6%80%A7/"><img class="prev-cover" src="http://pic.netbian.com/uploads/allimg/220511/003034-16522002340d03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">19 Java9&amp;Java10&amp;Java11新特性</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B8%A6%E4%BD%A0%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%A7%A3%E6%9E%90-HTTP/"><img class="next-cover" src="http://pic.netbian.com/uploads/allimg/221001/234650-1664639210d642.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">带你一步步解析 HTTP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/22/%E7%99%BE%E4%B8%87%E9%95%BF%E6%96%87%E5%B8%A6%E4%BD%A0%E5%AD%A6Java/" title="百万长文带你学Java"><img class="cover" src="http://pic.netbian.com/uploads/allimg/211227/235250-16406203705a57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-22</div><div class="title">百万长文带你学Java</div></div></a></div><div><a href="/2022/07/28/SGG_JavaSE/%E7%AC%AC10%E7%AB%A0-%E5%9F%BA%E7%A1%80API%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/" title="第10章 基础API与常见算法"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220311/000819-1646928499bd45.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-28</div><div class="title">第10章 基础API与常见算法</div></div></a></div><div><a href="/2022/07/28/SGG_JavaSE/%E7%AC%AC11%E7%AB%A0-%E9%9B%86%E5%90%88/" title="第11章 集合"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220314/000700-164718762039cc.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-28</div><div class="title">第11章 集合</div></div></a></div><div><a href="/2022/07/28/SGG_JavaSE/%E7%AC%AC12%E7%AB%A0-%E6%B3%9B%E5%9E%8B/" title="第12章 泛型"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220216/155548-164499814819f7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-28</div><div class="title">第12章 泛型</div></div></a></div><div><a href="/2022/07/28/SGG_JavaSE/%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="第15章 网络编程"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220124/181303-16430191838052.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-28</div><div class="title">第15章 网络编程</div></div></a></div><div><a href="/2022/07/28/SGG_JavaSE/%E7%AC%AC13%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="第13章 数据结构与算法"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220716/001159-1657901519eb96.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-28</div><div class="title">第13章 数据结构与算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gao</div><div class="author-info__description">生活明朗 万物可爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/gaoziman"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gaoziman" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2942894660@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/692044806?spm_id_from=333.1007.0.0" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2942894660&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B6%85%E5%85%A8Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">超全Java集合框架讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">集合框架总览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-Iterable-ListIterator"><span class="toc-number">1.1.1.</span> <span class="toc-text">Iterator  Iterable ListIterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-%E5%92%8C-Collection-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">Map 和 Collection 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">Map 集合体系详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">1.2.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">1.2.2.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">1.2.3.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakHashMap"><span class="toc-number">1.2.4.</span> <span class="toc-text">WeakHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-number">1.2.5.</span> <span class="toc-text">Hashtable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">Collection 集合体系详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">Set 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractSet-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">AbstractSet 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedSet-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.3.</span> <span class="toc-text">SortedSet 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet"><span class="toc-number">1.3.4.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">1.3.5.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.3.6.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractList-%E5%92%8C-AbstractSequentialList"><span class="toc-number">1.4.1.</span> <span class="toc-text">AbstractList  和 AbstractSequentialList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">1.4.2.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-number">1.4.3.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.4.4.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList"><span class="toc-number">1.4.5.</span> <span class="toc-text">LinkedList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.</span> <span class="toc-text">Queue接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">Deque 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractQueue-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.5.2.</span> <span class="toc-text">AbstractQueue 抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayDeque"><span class="toc-number">1.5.4.</span> <span class="toc-text">ArrayDeque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityQueue"><span class="toc-number">1.5.5.</span> <span class="toc-text">PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AB%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">文末总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/" title="Web环境搭建以及Servlet入门"><img src="http://pic.netbian.com/uploads/allimg/210827/235918-1630079958392e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web环境搭建以及Servlet入门"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/" title="Web环境搭建以及Servlet入门">Web环境搭建以及Servlet入门</a><time datetime="2022-10-16T15:01:07.000Z" title="发表于 2022-10-16 23:01:07">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/" title="一文学懂JSP"><img src="http://pic.netbian.com/uploads/allimg/221002/214642-1664718402e8b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂JSP"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/" title="一文学懂JSP">一文学懂JSP</a><time datetime="2022-10-16T15:00:49.000Z" title="发表于 2022-10-16 23:00:49">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/" title="一文学懂Cookie与Session的区别"><img src="http://pic.netbian.com/uploads/allimg/210831/102129-16303764895142.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂Cookie与Session的区别"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/" title="一文学懂Cookie与Session的区别">一文学懂Cookie与Session的区别</a><time datetime="2022-10-16T15:00:28.000Z" title="发表于 2022-10-16 23:00:28">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" title="一文学懂过滤器和监听器"><img src="http://pic.netbian.com/uploads/allimg/220909/000311-16626529918d5d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂过滤器和监听器"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" title="一文学懂过滤器和监听器">一文学懂过滤器和监听器</a><time datetime="2022-10-16T15:00:12.000Z" title="发表于 2022-10-16 23:00:12">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" title="一文了解转发与重定向"><img src="http://pic.netbian.com/uploads/allimg/210423/224716-16191892361adb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文了解转发与重定向"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" title="一文了解转发与重定向">一文了解转发与重定向</a><time datetime="2022-10-16T14:59:54.000Z" title="发表于 2022-10-16 22:59:54">2022-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Gao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="/js/diytitle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在湘进行备案" title=""><img src="https://img.shields.io/badge/湘ICP备-2022004213号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/js/runtime/runtime.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_213.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/随笔⌚/&quot;);" href="javascript:void(0);">随笔⌚</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">大学学习史</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_46.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/转载/&quot;);" href="javascript:void(0);">转载</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">前端成长历程</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_53.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM上篇/&quot;);" href="javascript:void(0);">JVM上篇</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">生活欢乐多</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM下篇/&quot;);" href="javascript:void(0);">JVM下篇</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JavaSE/&quot;);" href="javascript:void(0);">JavaSE</a><span class="categoryBar-list-count">19</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM中篇/&quot;);" href="javascript:void(0);">JVM中篇</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/重学Java基础/&quot;);" href="javascript:void(0);">重学Java基础</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL-shk/&quot;);" href="javascript:void(0);">MySQL-shk</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_214.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习路线/&quot;);" href="javascript:void(0);">学习路线</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_62.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/教程/&quot;);" href="javascript:void(0);">教程</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文档/&quot;);" href="javascript:void(0);">文档</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_189.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java自学笔记/&quot;);" href="javascript:void(0);">Java自学笔记</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_61.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C语言/&quot;);" href="javascript:void(0);">C语言</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);">Java</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java知识点/&quot;);" href="javascript:void(0);">Java知识点</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MyBatis/&quot;);" href="javascript:void(0);">MyBatis</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Thymeleaf/&quot;);" href="javascript:void(0);">Thymeleaf</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/多线程/&quot;);" href="javascript:void(0);">多线程</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java-Basic/&quot;);" href="javascript:void(0);">Java-Basic</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_214.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/HTTP/&quot;);" href="javascript:void(0);">HTTP</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_62.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Web网页技术/&quot;);" href="javascript:void(0);">Web网页技术</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper_container_card" style="height: auto;width: 100%"><div id="random"><div id="random-banner"><canvas id="peoplecanvas"></canvas></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://tx2.a.yximgs.com/udata/music/music_f307a39407e74b1ab48f8409b8b0c3210.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt="">2021最新版java学习路线</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://nwjshm.cn/usr/themes/Cuteen/static/img/default-list-bg.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt="">随机图api</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper_init.js"></script><script data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/people.min.js"></script><script async src="/anzhiyu/random.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>