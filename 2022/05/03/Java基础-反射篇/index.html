<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 反射篇 | 爱笑的Gao的个人博客</title><meta name="keywords" content="Java,Java基础"><meta name="author" content="Gao"><meta name="copyright" content="Gao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础 反射篇 Java基础 反射篇 反射的思想及作用 反射的基本使用 获取类的 Class 对象 构造类的实例化对象 获取一个类的所有信息 获取类中的变量（Field） 获取类中的方法（Method） 获取类的构造器（Constructor） 获取注解 通过反射调用方法   反射的应用场景 Spring 的 IOC 容器 反射 + 抽象工厂模式 JDBC 加载数据库驱动类   反射的优势及">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础 反射篇">
<meta property="og:url" content="https://manamn.space/2022/05/03/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87/index.html">
<meta property="og:site_name" content="爱笑的Gao的个人博客">
<meta property="og:description" content="Java基础 反射篇 Java基础 反射篇 反射的思想及作用 反射的基本使用 获取类的 Class 对象 构造类的实例化对象 获取一个类的所有信息 获取类中的变量（Field） 获取类中的方法（Method） 获取类的构造器（Constructor） 获取注解 通过反射调用方法   反射的应用场景 Spring 的 IOC 容器 反射 + 抽象工厂模式 JDBC 加载数据库驱动类   反射的优势及">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva3.sinaimg.cn/large/005BYqpggy1fwrgjdk74oj31hc0u0dqn.jpg">
<meta property="article:published_time" content="2022-05-03T08:04:25.000Z">
<meta property="article:modified_time" content="2022-05-06T03:52:36.136Z">
<meta property="article:author" content="Gao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva3.sinaimg.cn/large/005BYqpggy1fwrgjdk74oj31hc0u0dqn.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://manamn.space/2022/05/03/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础 反射篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-06 11:52:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="爱笑的Gao的个人博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">390</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-zhuye"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-yuedu"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link faa-float animated-hover"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/photos"><i class="fa-fw iconfont icon-xiangji1"></i><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-wo faa-float animated-hover"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tva3.sinaimg.cn/large/005BYqpggy1fwrgjdk74oj31hc0u0dqn.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">爱笑的Gao的个人博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-zhuye"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-yuedu"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link faa-float animated-hover"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/photos"><i class="fa-fw iconfont icon-xiangji1"></i><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-wo faa-float animated-hover"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础 反射篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-03T08:04:25.000Z" title="发表于 2022-05-03 16:04:25">2022-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-06T03:52:36.136Z" title="更新于 2022-05-06 11:52:36">2022-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-Basic/">Java-Basic</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础 反射篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java基础-反射篇"><a href="#Java基础-反射篇" class="headerlink" title="Java基础 反射篇"></a>Java基础 反射篇</h1><ul>
<li><a href="#java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87">Java基础 反射篇</a><ul>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E4%BD%9C%E7%94%A8">反射的思想及作用</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">反射的基本使用</a><ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84-class-%E5%AF%B9%E8%B1%A1">获取类的 Class 对象</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1">构造类的实例化对象</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF">获取一个类的所有信息</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8Ffield">获取类中的变量（Field）</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95method">获取类中的方法（Method）</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8constructor">获取类的构造器（Constructor）</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3">获取注解</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">通过反射调用方法</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">反射的应用场景</a><ul>
<li><a href="#spring-%E7%9A%84-ioc-%E5%AE%B9%E5%99%A8">Spring 的 IOC 容器</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84--%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">反射 + 抽象工厂模式</a></li>
<li><a href="#jdbc-%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%B1%BB">JDBC 加载数据库驱动类</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E7%BC%BA%E9%99%B7">反射的优势及缺陷</a><ul>
<li><a href="#%E5%A2%9E%E5%8A%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7">增加程序的灵活性</a></li>
<li><a href="#%E7%A0%B4%E5%9D%8F%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7">破坏类的封装性</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97">性能损耗</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%AF%87%E6%96%87%E6%9C%AB%E6%80%BB%E7%BB%93">反射基础篇文末总结</a></li>
</ul>
</li>
</ul>
<p>反射是一个非常重要的知识点，在学习<code>Spring 框架</code>时，Bean的初始化用到了反射，在<code>破坏单例模式</code>时也用到了反射，在<code>获取标注的注解</code>时也会用到反射······</p>
<p>当然了，反射在日常开发中，我们没碰到过多少，至少我没怎么用过。但面试是<strong>造火箭</strong>现场，可爱的面试官们又怎会轻易地放过我们呢？反射是开源框架中的一个重要设计理念，在源码分析中少不了它的身影，所以，今天我会尽量用浅显易懂的语言，让你去理解下面这几点：</p>
<p>（1）反射的思想以及它的作用​ :point_right: <strong>概念篇</strong></p>
<p>（2）反射的基本使用及应用场景 :point_right: <strong>应用篇</strong></p>
<p>（3）使用反射能给我们编码时带来的优势以及存在的缺陷 :point_right: <strong>分析篇</strong></p>
<h2 id="反射的思想及作用"><a href="#反射的思想及作用" class="headerlink" title="反射的思想及作用"></a>反射的思想及作用</h2><p>有反必有正，就像世间的阴和阳，计算机的0和1一样。天道有轮回，苍天…<del>（净会在这瞎bibi）</del></p>
<p>在学习反射之前，先来了解<strong>正射</strong>是什么。我们平常用的最多的 <code>new</code> 方式实例化对象的方式就是一种正射的体现。假如我需要实例化一个<code>HashMap</code>，代码就会是这样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>某一天发现，该段程序不适合用 HashMap 存储键值对，更倾向于用<code>LinkedHashMap</code>存储。重新编写代码后变成下面这个样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>假如又有一天，发现数据还是适合用 HashMap来存储，难道又要重新修改源码吗？</p>
<blockquote>
<p>发现问题了吗？我们每次改变一种需求，都要去重新<strong>修改源码</strong>，然后对代码进行编译，打包，再到 JVM 上重启项目。这么些步骤下来，效率非常低。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596529718718-903156ef-2e22-428e-9449-ab26ced3b5f8.png" alt="image.png"></p>
<p>对于这种<strong>需求频繁变更但变更不大</strong>的场景，频繁地更改源码肯定是一种不允许的操作，我们可以使用一个<code>开关</code>，判断什么时候使用哪一种数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; <span class="title function_">getMap</span><span class="params">(String param)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (param.equals(<span class="string">&quot;HashMap&quot;</span>)) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(<span class="string">&quot;LinkedHashMap&quot;</span>)) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(<span class="string">&quot;WeakHashMap&quot;</span>)) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过传入参数<code>param</code>决定使用哪一种数据结构，可以在项目运行时，通过<strong>动态传入参数</strong>决定使用哪一个数据结构。</p>
<p>如果某一天还想用<code>TreeMap</code>，还是避免不了修改源码，重新编译执行的弊端。这个时候，<strong>反射</strong>就派上用场了。</p>
<p>在代码运行之前，我们<strong>不确定</strong>将来会使用哪一种数据结构，只有在程序<strong>运行时才决定</strong>使用哪一个数据类，而<code>反射</code>可以在<strong>程序运行过程</strong>中动态<strong>获取类信息</strong>和<strong>调用类方法</strong>。通过反射构造类实例，代码会演变成下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Integer, Integer&gt; <span class="title function_">getMap</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">    <span class="type">Consructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line">    <span class="keyword">return</span> (Map&lt;Integer, Integer&gt;) con.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论使用什么 Map，只要实现了<code>Map接口</code>，就可以使用<code>全类名路径</code>传入到方法中，获得对应的 Map 实例。例如java.util.HashMap &#x2F; java.util.LinkedHashMap····如果要创建其它类例如<code>WeakHashMap</code>，我也<strong>不需要修改上面这段源码</strong>。</p>
<p>我们来回顾一下如何从 <code>new</code> 一个对象引出使用<code>反射</code>的。</p>
<ul>
<li>在不使用反射时，构造对象使用 new 方式实现，这种方式在<strong>编译期</strong>就可以把对象的类型确定下来。</li>
<li>如果需求发生变更，需要构造另一个对象，则需要修改源码，非常不优雅，所以我们通过使用<code>开关</code>，在程序运行时判断需要构造哪一个对象，在运行时可以<strong>变更开关</strong>来实例化不同的数据结构。</li>
<li>如果还有其它扩展的类有可能被使用，就会创建出<strong>非常多的分支</strong>，且在编码时不知道有什么其他的类被使用到，假如日后<code>Map</code>接口下多了一个集合类是<code>xxxHashMap</code>，还得创建分支，此时引出了反射：可以在<code>运行时</code>才确定使用哪一个数据类，在切换类时，无需重新修改源码、编译程序。</li>
</ul>
<p>第一章总结：</p>
<ul>
<li>反射的<strong>思想</strong>：<strong>在程序运行过程中确定和解析数据类的类型。</strong></li>
<li>反射的<strong>作用</strong>：对于在<code>编译期</code>无法确定使用哪个数据类的场景，通过<code>反射</code>可以在程序运行时<strong>构造出不同的数据类实例</strong>。</li>
</ul>
<h2 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h2><p>Java 反射的主要组成部分有4个：</p>
<ul>
<li><code>Class</code>：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的<strong>所有信息</strong>。记着一句话，通过反射干任何事，先找 Class 准没错！</li>
<li><code>Field</code>：描述一个类的<strong>属性</strong>，内部包含了该属性的所有信息，例如<strong>数据类型，属性名，访问修饰符</strong>······</li>
<li><code>Constructor</code>：描述一个类的<strong>构造方法</strong>，内部包含了构造方法的所有信息，例如<strong>参数类型，参数名字，访问修饰符</strong>······</li>
<li><code>Method</code>：描述一个类的<strong>所有方法</strong>（包括抽象方法），内部包含了该方法的所有信息，与<code>Constructor</code>类似，不同之处是 Method 拥有<strong>返回值类型</strong>信息，因为构造方法是没有返回值的。</li>
</ul>
<p>我总结了一张脑图，放在了下面，如果用到了反射，离不开这核心的<code>4</code>个类，只有去了解它们内部提供了哪些信息，有什么作用，运用它们的时候才能<strong>易如反掌</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596555823611-0f82d57a-d2b1-4457-a10f-b36e101c0b8e.png" alt="img"></p>
<p>我们在学习反射的基本使用时，我会用一个<code>SmallPineapple</code>类作为模板进行说明，首先我们先来熟悉这个类的基本组成：<strong>属性，构造函数和方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallPineapple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight; <span class="comment">// 体重只有自己知道</span></span><br><span class="line">   	</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallPineapple</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallPineapple</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>+ name + <span class="string">&quot; 的年龄是：&quot;</span> + age + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射中的用法有非常非常多，常见的功能有以下这几个：</p>
<ul>
<li>在运行时获取一个类的 <strong>Class 对象</strong></li>
<li>在运行时构造一个类的<strong>实例化对象</strong></li>
<li>在运行时获取一个类的所有信息：<strong>变量、方法、构造器、注解</strong></li>
</ul>
<h3 id="获取类的-Class-对象"><a href="#获取类的-Class-对象" class="headerlink" title="获取类的 Class 对象"></a>获取类的 Class 对象</h3><p>在 Java 中，每一个类都会有专属于自己的 Class 对象，当我们编写完<code>.java</code>文件后，使用<code>javac</code>编译后，就会产生一个字节码文件<code>.class</code>，在字节码文件中包含类的所有信息，如<code>属性</code>，<code>构造方法</code>，<code>方法</code>······当字节码文件被装载进虚拟机执行时，会在内存中生成 Class 对象，它包含了该类内部的所有信息，在程序运行时可以获取这些信息。</p>
<p>获取 Class 对象的方法有<code>3</code>种：</p>
<ul>
<li><code>类名.class</code>：这种获取方式只有在<code>编译</code>前已经声明了该类的类型才能获取到 Class 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> SmallPineapple.class;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>实例.getClass()</code>：通过实例化对象获取该实例的 Class 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SmallPineapple</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmallPineapple</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> sp.getClass();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Class.forName(className)</code>：通过类的<strong>全限定名</strong>获取该类的 Class 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bean.smallpineapple&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>拿到 <code>Class</code>对象就可以对它为所欲为了：剥开它的皮（获取<strong>类信息</strong>）、指挥它做事（调用它的<strong>方法</strong>），看透它的一切（获取<strong>属性</strong>），总之它就没有隐私了。</p>
<p>不过在程序中，每个类的 Class 对象只有一个，也就是说你只有这一个<code>奴隶</code>。我们用上面三种方式测试，通过三种方式打印各个 <code>Class</code> 对象都是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bean.SmallPineapple&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> SmallPineapple.class;</span><br><span class="line"><span class="type">SmallPineapple</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmallPineapple</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> instance.getClass();</span><br><span class="line">System.out.println(<span class="string">&quot;Class.forName() == SmallPineapple.class:&quot;</span> + (clazz1 == clazz2));</span><br><span class="line">System.out.println(<span class="string">&quot;Class.forName() == instance.getClass():&quot;</span> + (clazz1 == clazz3));</span><br><span class="line">System.out.println(<span class="string">&quot;instance.getClass() == SmallPineapple.class:&quot;</span> + (clazz2 == clazz3));</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596534789018-870958ba-911f-45a3-b4b7-f73ff93251fd.png" alt="image.png"></p>
<blockquote>
<p>内存中只有一个 Class 对象的原因要牵扯到 <code>JVM 类加载机制</code>的<code>双亲委派模型</code>，它保证了程序运行时，<code>加载类</code>时每个类在内存中仅会产生一个<code>Class对象</code>。在这里我不打算详细展开说明，可以简单地理解为 JVM 帮我们保证了<strong>一个类在内存中至多存在一个 Class 对象</strong>。</p>
</blockquote>
<h3 id="构造类的实例化对象"><a href="#构造类的实例化对象" class="headerlink" title="构造类的实例化对象"></a>构造类的实例化对象</h3><p>通过反射构造一个类的实例方式有<code>2</code>种：</p>
<ul>
<li>Class 对象调用<code>newInstance()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bean.SmallPineapple&quot;</span>);</span><br><span class="line"><span class="type">SmallPineapple</span> <span class="variable">smallPineapple</span> <span class="operator">=</span> (SmallPineapple) clazz.newInstance();</span><br><span class="line">smallPineapple.getInfo();</span><br><span class="line"><span class="comment">// [null 的年龄是：0]</span></span><br></pre></td></tr></table></figure>

<p>即使 SmallPineapple 已经显式定义了构造方法，通过 newInstance()  创建的实例中，所有属性值都是对应类型的<code>初始值</code>，因为 newInstance() 构造实例会<strong>调用默认无参构造器</strong>。</p>
<ul>
<li>Constructor 构造器调用<code>newInstance()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bean.SmallPineapple&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">SmallPineapple</span> <span class="variable">smallPineapple2</span> <span class="operator">=</span> (SmallPineapple) constructor.newInstance(<span class="string">&quot;小菠萝&quot;</span>, <span class="number">21</span>);</span><br><span class="line">smallPineapple2.getInfo();</span><br><span class="line"><span class="comment">// [小菠萝 的年龄是：21]</span></span><br></pre></td></tr></table></figure>

<p>通过 getConstructor(Object… paramTypes) 方法指定获取<strong>指定参数类型</strong>的 Constructor， Constructor 调用 newInstance(Object… paramValues) 时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。</p>
<p>通过<code>Class</code>对象调用 newInstance() 会走<strong>默认无参构造方法</strong>，如果想通过<strong>显式构造方法</strong>构造实例，需要提前从Class中调用<code>getConstructor()</code>方法获取对应的构造器，通过构造器去实例化对象。</p>
<blockquote>
<p>这些 API 是在开发当中最常遇到的，当然还有非常多重载的方法，本文由于篇幅原因，且如果每个方法都一一讲解，我们也记不住，所以用到的时候去类里面查找就已经足够了。</p>
</blockquote>
<h3 id="获取一个类的所有信息"><a href="#获取一个类的所有信息" class="headerlink" title="获取一个类的所有信息"></a>获取一个类的所有信息</h3><p><strong>Class 对象中包含了该类的所有信息，在编译期我们能看到的信息就是该类的变量、方法、构造器，在运行时最常被获取的也是这些信息。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1597313607659-2df4f865-3bc8-4dbd-8dfc-f6eafe34519d.png" alt="img"></p>
<h3 id="获取类中的变量（Field）"><a href="#获取类中的变量（Field）" class="headerlink" title="获取类中的变量（Field）"></a>获取类中的变量（Field）</h3><ul>
<li>Field[] getFields()：获取类中所有被<code>public</code>修饰的所有变量</li>
<li>Field getField(String name)：根据<strong>变量名</strong>获取类中的一个变量，该<strong>变量必须被public修饰</strong></li>
<li>Field[] getDeclaredFields()：获取类中所有的变量，但<strong>无法获取继承下来的变量</strong></li>
<li>Field getDeclaredField(String name)：根据姓名获取类中的某个变量，<strong>无法获取继承下来的变量</strong></li>
</ul>
<h3 id="获取类中的方法（Method）"><a href="#获取类中的方法（Method）" class="headerlink" title="获取类中的方法（Method）"></a>获取类中的方法（Method）</h3><ul>
<li><p>Method[] getMethods()：获取类中被<code>public</code>修饰的所有方法</p>
</li>
<li><p>Method getMethod(String name, Class…&lt;?&gt; paramTypes)：根据<strong>名字和参数类型</strong>获取对应方法，该方法必须被<code>public</code>修饰</p>
</li>
<li><p>Method[] getDeclaredMethods()：获取<code>所有</code>方法，但<strong>无法获取继承下来的方法</strong></p>
</li>
<li><p>Method getDeclaredMethod(String name, Class…&lt;?&gt; paramTypes)：根据<strong>名字和参数类型</strong>获取对应方法，<strong>无法获取继承下来的方法</strong></p>
</li>
</ul>
<h3 id="获取类的构造器（Constructor）"><a href="#获取类的构造器（Constructor）" class="headerlink" title="获取类的构造器（Constructor）"></a>获取类的构造器（Constructor）</h3><ul>
<li>Constuctor[] getConstructors()：获取类中所有被<code>public</code>修饰的构造器</li>
<li>Constructor getConstructor(Class…&lt;?&gt; paramTypes)：根据<code>参数类型</code>获取类中某个构造器，该构造器必须被<code>public</code>修饰</li>
<li>Constructor[] getDeclaredConstructors()：获取类中所有构造器</li>
<li>Constructor getDeclaredConstructor(class…&lt;?&gt; paramTypes)：根据<code>参数类型</code>获取对应的构造器</li>
</ul>
<p>每种功能内部以 Declared 细分为<code>2</code>类：</p>
<blockquote>
<p>有<code>Declared</code>修饰的方法：可以获取该类内部包含的<strong>所有</strong>变量、方法和构造器，但是<strong>无法获取继承下来的信息</strong></p>
<p>无<code>Declared</code>修饰的方法：可以获取该类中<code>public</code>修饰的变量、方法和构造器，可<strong>获取继承下来的信息</strong></p>
</blockquote>
<p>如果想获取类中<strong>所有的（包括继承）</strong>变量、方法和构造器，则需要同时调用<code>getXXXs()</code>和<code>getDeclaredXXXs()</code>两个方法，用<code>Set</code>集合存储它们获得的变量、构造器和方法，以防两个方法获取到相同的东西。</p>
<p>例如：要获取SmallPineapple获取类中<strong>所有的变量</strong>，代码应该是下面这样写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bean.SmallPineapple&quot;</span>);</span><br><span class="line"><span class="comment">// 获取 public 属性，包括继承</span></span><br><span class="line">Field[] fields1 = clazz.getFields();</span><br><span class="line"><span class="comment">// 获取所有属性，不包括继承</span></span><br><span class="line">Field[] fields2 = clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">// 将所有属性汇总到 set</span></span><br><span class="line">Set&lt;Field&gt; allFields = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">allFields.addAll(Arrays.asList(fields1));</span><br><span class="line">allFields.addAll(Arrays.asList(fields2));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不知道你有没有发现一件<strong>有趣的事情</strong>，如果父类的属性用<code>protected</code>修饰，利用反射是<strong>无法获取到</strong>的。</p>
<p>protected 修饰符的作用范围：只允许<code>同一个包下</code>或者<code>子类</code>访问，可以继承到子类。</p>
<p>getFields() 只能获取到本类的<code>public</code>属性的变量值；</p>
<p>getDeclaredFields() 只能获取到<strong>本类的所有属性，不包括继承</strong>的；无论如何都获取不到父类的 protected 属性修饰的变量，但是它的的确确存在于子类中。</p>
</blockquote>
<h3 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h3><p><strong>获取注解单独拧了出来，因为它并不是专属于 Class 对象的一种信息，每个变量，方法和构造器都可以被注解修饰，所以在反射中，Field，Constructor 和 Method 类对象都可以调用下面这些方法获取标注在它们之上的注解。</strong></p>
<ul>
<li>Annotation[] getAnnotations()：获取该对象上的<strong>所有注解</strong></li>
<li>Annotation getAnnotation(Class annotaionClass)：传入<code>注解类型</code>，获取该对象上的特定一个注解</li>
<li>Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取<code>继承</code>下来的注解</li>
<li>Annotation getDeclaredAnnotation(Class annotationClass)：根据<code>注解类型</code>，获取该对象上的特定一个注解，无法获取<code>继承</code>下来的注解</li>
</ul>
<p>只有注解的<code>@Retension</code>标注为<code>RUNTIME</code>时，才能够通过反射获取到该注解，@Retension 有<code>3</code>种保存策略：</p>
<ul>
<li><code>SOURCE</code>：只在<strong>源文件(.java)<strong>中保存，即该注解只会保留在源文件中，</strong>编译时编译器会忽略该注解</strong>，例如 @Override 注解</li>
<li><code>CLASS</code>：保存在<strong>字节码文件(.class)<strong>中，注解会随着编译跟随字节码文件中，但是</strong>运行时</strong>不会对该注解进行解析</li>
<li><code>RUNTIME</code>：一直保存到<strong>运行时</strong>，<strong>用得最多的一种保存策略</strong>，在运行时可以获取到该注解的所有信息</li>
</ul>
<p>像下面这个例子，SmallPineapple 类继承了抽象类<code>Pineapple</code>，<code>getInfo()</code>方法上标识有 @Override 注解，且在子类中标注了<code>@Transient</code>注解，在运行时获取子类重写方法上的所有注解，只能获取到<code>@Transient</code>的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pineapple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallPineapple</span> <span class="keyword">extends</span> <span class="title class_">Pineapple</span> &#123;</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;小菠萝的身高和年龄是:&quot;</span> + height + <span class="string">&quot;cm ; &quot;</span> + age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类<code>Bootstrap</code>获取 SmallPineapple 类中的 getInfo() 方法上的注解信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bootstrap</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据运行时传入的全类名路径判断具体的类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 类的全类名路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">obj</span> <span class="operator">=</span> Class.forName(path);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> obj.getMethod(<span class="string">&quot;getInfo&quot;</span>);</span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        execute(<span class="string">&quot;com.pineapple.SmallPineapple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @java.beans.Transient(value=true)</span></span><br></pre></td></tr></table></figure>

<h3 id="通过反射调用方法"><a href="#通过反射调用方法" class="headerlink" title="通过反射调用方法"></a>通过反射调用方法</h3><p>通过反射获取到某个 Method 类对象后，可以通过调用<code>invoke</code>方法执行。</p>
<ul>
<li><code>invoke(Oject obj, Object... args)</code>：参数&#96;&#96;1<code>指定调用该方法的**对象**，参数</code>2&#96;是方法的参数列表值。</li>
</ul>
<p>如果调用的方法是<strong>静态方法</strong>，参数1只需要传入<code>null</code>，因为静态方法不与某个对象有关，只与某个类有关。</p>
<p>可以像下面这种做法，通过反射实例化一个对象，然后获取<code>Method</code>方法对象，调用<code>invoke()</code>指定<code>SmallPineapple</code>的<code>getInfo()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bean.SmallPineapple&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">SmallPineapple</span> <span class="variable">sp</span> <span class="operator">=</span> (SmallPineapple) constructor.newInstance(<span class="string">&quot;小菠萝&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getInfo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">    method.invoke(sp, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [小菠萝的年龄是：21]</span></span><br></pre></td></tr></table></figure>

<h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><p>反射常见的应用场景这里介绍<code>3</code>个：</p>
<ul>
<li>Spring 实例化对象：当程序启动时，Spring 会读取配置文件<code>applicationContext.xml</code>并解析出里面所有的 <bean> 标签实例化到<code>IOC</code>容器中。</li>
<li>反射 + 工厂模式：通过<code>反射</code>消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，<code>反射</code>可以使得程序更加健壮。</li>
<li>JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的<code>驱动类</code>时用到反射加载驱动类</li>
</ul>
<h3 id="Spring-的-IOC-容器"><a href="#Spring-的-IOC-容器" class="headerlink" title="Spring 的 IOC 容器"></a>Spring 的 IOC 容器</h3><p>在 Spring 中，经常会编写一个上下文配置文件<code>applicationContext.xml</code>，里面就是关于<code>bean</code>的配置，程序启动时会读取该 xml 文件，解析出所有的 <code>&lt;bean&gt;</code>标签，并实例化对象放入<code>IOC</code>容器中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;smallpineapple&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bean.SmallPineapple&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小菠萝&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在定义好上面的文件后，通过<code>ClassPathXmlApplicationContext</code>加载该配置文件，程序启动时，Spring 会将该配置文件中的所有<code>bean</code>都实例化，放入 IOC 容器中，IOC 容器本质上就是一个工厂，通过该工厂传入 &lt;bean&gt; 标签的<code>id</code>属性获取到对应的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">SmallPineapple</span> <span class="variable">smallPineapple</span> <span class="operator">=</span> (SmallPineapple) ac.getBean(<span class="string">&quot;smallpineapple&quot;</span>);</span><br><span class="line">        smallPineapple.getInfo(); <span class="comment">// [小菠萝的年龄是：21]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：</p>
<ul>
<li><strong>获取Class对象的构造器</strong></li>
<li>通过构造器<strong>调用 newInstance()</strong> 实例化对象</li>
</ul>
<p>当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的<strong>便捷且稳定</strong>。</p>
<blockquote>
<p>在之后的文章中会专门写一篇文章讲解如何利用反射实现一个<code>简易版</code>的<code>IOC</code>容器，IOC容器原理很简单，只要掌握了反射的思想，了解反射的常用 API 就可以实现，我可以提供一个简单的思路：利用 HashMap 存储所有实例，key 代表 &lt;bean&gt; 标签的 <code>id</code>，value 存储对应的实例，这对应了 Spring IOC容器管理的对象默认是<strong>单例</strong>的。</p>
</blockquote>
<h3 id="反射-抽象工厂模式"><a href="#反射-抽象工厂模式" class="headerlink" title="反射 + 抽象工厂模式"></a>反射 + 抽象工厂模式</h3><p>传统的工厂模式，如果需要生产新的子类，<strong>需要修改工厂类，在工厂类中增加新的分支</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, object&gt; <span class="title function_">produceMap</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;HashMap&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;TreeMap&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用反射和工厂模式相结合，在产生新的子类时，<strong>工厂类不用修改任何东西</strong>，可以专注于子类的实现，<strong>当子类确定下来时，工厂也就可以生产该子类了。</strong></p>
<p>反射 + 抽象工厂的<strong>核心思想</strong>是：</p>
<ul>
<li><strong>在运行时通过参数传入不同子类的全限定名获取到不同的 Class 对象，调用 newInstance() 方法返回不同的子类。</strong>细心的读者会发现提到了<strong>子类</strong>这个概念，所以反射 + 抽象工厂模式，一般会用于有<strong>继承</strong>或者<strong>接口实现</strong>关系。</li>
</ul>
<p>例如，在运行时才确定使用哪一种 <code>Map</code> 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类的全限定名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">produceMap</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        Map&lt;Object, Object&gt; map = clazz.newInstance();</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>className</code> 可以指定为 java.util.HashMap，或者 java.util.TreeMap 等等，根据业务场景来定。</p>
<h3 id="JDBC-加载数据库驱动类"><a href="#JDBC-加载数据库驱动类" class="headerlink" title="JDBC 加载数据库驱动类"></a>JDBC 加载数据库驱动类</h3><p>在导入第三方库时，JVM不会主动去加载外部导入的类，而是<strong>等到真正使用时，才去加载需要的类</strong>，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给 JVM 加载该类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBConnectionUtil</span> &#123;</span><br><span class="line">    <span class="comment">/** 指定数据库的驱动类 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER_CLASS_NAME</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 加载驱动类</span></span><br><span class="line">        Class.forName(DRIVER_CLASS_NAME);</span><br><span class="line">        <span class="comment">// 获取数据库连接对象</span></span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://···&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们开发 SpringBoot 项目时，会经常遇到这个类，但是可能习惯成自然了，就没多大在乎，我在这里给你们看看常见的<code>application.yml</code>中的数据库配置，我想你应该会恍然大悟吧。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1597332406168-5103f33d-79f5-456b-9962-0f779bab5174.png" alt="img"></p>
<p>这里的 <strong>driver-class-name</strong>，和我们一开始加载的类是不是觉得很相似，这是因为<strong>MySQL</strong>版本不同引起的<strong>驱动类不同</strong>，这体现使用反射的好处：不需要修改源码，<strong>仅加载配置文件就可以完成驱动类的替换</strong>。</p>
<blockquote>
<p>在之后的文章中会专门写一篇文章详细地介绍反射的应用场景，实现简单的<code>IOC</code>容器以及通过反射实现工厂模式的好处。</p>
<p>在这里，你只需要掌握反射的基本用法和它的思想，了解它的主要使用场景。</p>
</blockquote>
<h2 id="反射的优势及缺陷"><a href="#反射的优势及缺陷" class="headerlink" title="反射的优势及缺陷"></a>反射的优势及缺陷</h2><p>反射的<strong>优点</strong>：</p>
<ul>
<li><strong>增加程序的灵活性</strong>：面对需求变更时，可以灵活地实例化不同对象</li>
</ul>
<p>但是，有得必有失，一项技术不可能只有优点没有缺点，反射也有<strong>两个比较隐晦的缺点</strong>：</p>
<ul>
<li><strong>破坏类的封装性</strong>：可以强制访问 private 修饰的信息</li>
<li><strong>性能损耗</strong>：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的<strong>检查步骤和解析步骤</strong>，JVM无法对它们优化。</li>
</ul>
<h3 id="增加程序的灵活性"><a href="#增加程序的灵活性" class="headerlink" title="增加程序的灵活性"></a>增加程序的灵活性</h3><p>这里不再用 SmallPineapple 举例了，我们来看一个更加<code>贴近开发</code>的例子：</p>
<ul>
<li>利用反射连接数据库，<strong>涉及到数据库的数据源</strong>。在 SpringBoot 中一切约定大于配置，想要<strong>定制配置</strong>时，使用<code>application.properties</code>配置文件指定数据源</li>
</ul>
<p><strong>角色1 - Java的设计者</strong>：我们设计好<code>DataSource</code>接口，你们其它数据库厂商想要开发者用<code>你们的数据源</code>监控数据库，就得实现<code>我的这个接口</code>！</p>
<p><strong>角色2 - 数据库厂商</strong>：</p>
<ul>
<li>MySQL 数据库厂商：我们提供了 <strong>com.mysql.cj.jdbc.MysqlDataSource</strong> 数据源，开发者可以使用它连接 MySQL。</li>
<li>阿里巴巴厂商：我们提供了 <strong>com.alibaba.druid.pool.DruidDataSource</strong> 数据源，我这个数据源更牛逼，具有<strong>页面监控</strong>，<strong>慢SQL日志记录</strong>等功能，开发者快来用它监控 MySQL吧！</li>
<li>SQLServer 厂商：我们提供了 <strong>com.microsoft.sqlserver.jdbc.SQLServerDataSource</strong> 数据源，如果你想实用SQL Server 作为数据库，那就使用我们的这个数据源连接吧</li>
</ul>
<p><strong>角色3 - 开发者</strong>：我们可以用<code>配置文件</code>指定使用<code>DruidDataSource</code>数据源</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<p><strong>需求变更</strong>：某一天，老板来跟我们说，Druid 数据源不太符合我们现在的项目了，我们使用 <strong>MysqlDataSource</strong> 吧，然后程序猿就会修改配置文件，重新加载配置文件，并重启项目，完成数据源的切换。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.mysql.cj.jdbc.MysqlDataSource</span></span><br></pre></td></tr></table></figure>

<p>在改变连接数据库的数据源时，只需要改变配置文件即可，<strong>无需改变任何代码</strong>，原因是：</p>
<ul>
<li><strong>Spring Boot 底层封装好了连接数据库的数据源配置，利用反射，适配各个数据源。</strong></li>
</ul>
<p>下面来简略的进行源码分析。我们用<code>ctrl+左键</code>点击<code>spring.datasource.type</code>进入 DataSourceProperties 类中，发现使用setType() 将<strong>全类名转化为 Class 对象</strong>注入到<code>type</code>成员变量当中。在连接并监控数据库时，就会使用指定的数据源操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">DataSource</span>&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(Class&lt;? extends DataSource&gt; type)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Class</code>对象指定了泛型上界<code>DataSource</code>，我们去看一下各大数据源的<code>类图结构</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1694029/1596689119592-98ae06fd-c59e-4794-8130-ff0bdfe0f550.png" alt="image.png"></p>
<p><strong>上图展示了一部分数据源，当然不止这些，但是我们可以看到，无论指定使用哪一种数据源，我们都只需要与配置文件打交道，而无需更改源码，这就是反射的灵活性！</strong></p>
<h3 id="破坏类的封装性"><a href="#破坏类的封装性" class="headerlink" title="破坏类的封装性"></a>破坏类的封装性</h3><p>很明显的一个特点，反射可以获取类中被<code>private</code>修饰的变量、方法和构造器，这<strong>违反了面向对象的封装特性</strong>，因为被 private 修饰意味着不想对外暴露，只允许本类访问，而<code>setAccessable(true)</code>可以无视访问修饰符的限制，外界可以强制访问。</p>
<p>还记得<code>单例模式</code>一文吗？里面讲到反射破坏饿汉式和懒汉式单例模式，所以之后用了<code>枚举</code>避免被反射KO。</p>
<p>回到最初的起点，SmallPineapple 里有一个 weight 属性被 private 修饰符修饰，目的在于自己的体重并不想给外界知道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallPineapple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight; <span class="comment">// 体重只有自己知道</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmallPineapple</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 weight 属性理论上只有自己知道，但是如果经过反射，这个类就像在<strong>裸奔</strong>一样，在反射面前变得<code>一览无遗</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SmallPineapple</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmallPineapple</span>(<span class="string">&quot;小菠萝&quot;</span>, <span class="number">21</span>, <span class="string">&quot;54.5&quot;</span>);</span><br><span class="line"><span class="type">Clazz</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(sp.getClass());</span><br><span class="line"><span class="type">Field</span> <span class="variable">weight</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line">weight.setAccessable(<span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;窥觑到小菠萝的体重是：&quot;</span> + weight.get(sp));</span><br><span class="line"><span class="comment">// 窥觑到小菠萝的体重是：54.5 kg</span></span><br></pre></td></tr></table></figure>

<h3 id="性能损耗"><a href="#性能损耗" class="headerlink" title="性能损耗"></a>性能损耗</h3><p><strong>在直接 new 对象并调用对象方法和访问属性时，编译器会在编译期提前检查可访问性，如果尝试进行不正确的访问，IDE会提前提示错误，例如参数传递类型不匹配，非法访问 private 属性和方法。</strong></p>
<blockquote>
<p>而在利用反射操作对象时，编译器无法提前得知对象的类型，访问是否合法，参数传递类型是否匹配。只有在程序运行时调用反射的代码时才会从头开始检查、调用、返回结果，JVM也无法对反射的代码进行优化。</p>
</blockquote>
<p>虽然反射具有性能损耗的特点，但是我们不能一概而论，产生了使用反射就会性能下降的思想，反射的慢，需要同时调用上<code>100W</code>次才可能体现出来，在几次、几十次的调用，并不能体现反射的性能低下。所以不要一味地戴有色眼镜看反射，<strong>在单次调用反射的过程中，性能损耗可以忽略不计。如果程序的性能要求很高，那么尽量不要使用反射。</strong></p>
<h2 id="反射基础篇文末总结"><a href="#反射基础篇文末总结" class="headerlink" title="反射基础篇文末总结"></a>反射基础篇文末总结</h2><ul>
<li>反射的思想：反射就像是<strong>一面镜子</strong>一样，在<strong>运行时</strong>才看到自己是谁，可获取到自己的信息，甚至实例化对象。</li>
<li>反射的作用：<strong>在运行时才确定实例化对象，使程序更加健壮</strong>，面对需求变更时，可以最大程度地做到不修改程序源码应对不同的场景，实例化不同类型的对象。</li>
<li>反射的应用场景常见的有<code>3</code>个：Spring的 IOC 容器，反射+工厂模式 使工厂类更稳定，JDBC连接数据库时加载驱动类</li>
<li>反射的<code>3</code>个特点：增加程序的灵活性、破坏类的封装性以及性能损耗</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://manamn.space">Gao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://manamn.space/2022/05/03/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87/">https://manamn.space/2022/05/03/Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://manamn.space" target="_blank">爱笑的Gao的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="https://tva3.sinaimg.cn/large/005BYqpggy1fwrgjdk74oj31hc0u0dqn.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-static-%E5%85%B3%E9%94%AE%E5%AD%97/"><img class="prev-cover" src="https://tva1.sinaimg.cn/large/005BYqpggy1fwre2b3fzij31hc0u0qog.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深入理解 static 关键字</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/03/%E8%B0%88%E8%B0%88%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8/"><img class="next-cover" src="https://tva2.sinaimg.cn/large/005BYqpgly1fwrgkuutffj31hc0u0nl9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">谈谈强引用、软引用、弱引用、幻象引用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/12/01-Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="01  Java基础入门"><img class="cover" src="https://static.likepoems.com/2020/09/19/028c07d2a02377542313d32bd13f1257a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">01  Java基础入门</div></div></a></div><div><a href="/2022/06/12/02-Java%E5%85%A5%E9%97%A8/" title="02 Java入门"><img class="cover" src="https://static.likepoems.com/2020/09/19/51810c32187febb42dab27b7a7aa6c5e6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">02 Java入门</div></div></a></div><div><a href="/2022/06/12/03-Java%E5%9F%BA%E7%A1%80/" title="03  Java基础"><img class="cover" src="https://static.likepoems.com/2020/09/19/7b7e66260c17430fc2f26c77aeb05f66e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">03  Java基础</div></div></a></div><div><a href="/2022/06/12/04-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="04  Java流程控制"><img class="cover" src="https://tva4.sinaimg.cn/large/005FzdTdgy1geesy5jf3uj31hc0u0b29.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">04  Java流程控制</div></div></a></div><div><a href="/2022/06/12/05-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" title="05  数组与方法"><img class="cover" src="https://static.likepoems.com/2020/09/19/dd256f708c66b8d6e834fe5c44a35b7bb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">05  数组与方法</div></div></a></div><div><a href="/2022/06/12/06-IDEA%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" title="06  IDEA集成开发工具"><img class="cover" src="https://static.likepoems.com/2020/09/19/ea4aa8816248178d17aecec2e80832e57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">06  IDEA集成开发工具</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gao</div><div class="author-info__description">生活明朗 万物可爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">390</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">104</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">54</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">Java基础 反射篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">反射的思想及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">反射的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84-Class-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">获取类的 Class 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">构造类的实例化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%89%80%E6%9C%89%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">获取一个类的所有信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88Field%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">获取类中的变量（Field）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">获取类中的方法（Method）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88Constructor%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">获取类的构造器（Constructor）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.7.</span> <span class="toc-text">获取注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.8.</span> <span class="toc-text">通过反射调用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.</span> <span class="toc-text">反射的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E7%9A%84-IOC-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">Spring 的 IOC 容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">反射 + 抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">JDBC 加载数据库驱动类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E7%BC%BA%E9%99%B7"><span class="toc-number">1.4.</span> <span class="toc-text">反射的优势及缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">增加程序的灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">1.4.2.</span> <span class="toc-text">破坏类的封装性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8D%9F%E8%80%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">性能损耗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E7%AF%87%E6%96%87%E6%9C%AB%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">反射基础篇文末总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/Map-HashSet-HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="无题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/10/16/Map-HashSet-HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="无题">无题</a><time datetime="2022-10-16T03:58:41.832Z" title="发表于 2022-10-16 11:58:41">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/%E7%AC%AC17%E7%AB%A0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="第17章 Java8新特性"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第17章 Java8新特性"/></a><div class="content"><a class="title" href="/2022/07/28/%E7%AC%AC17%E7%AB%A0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="第17章 Java8新特性">第17章 Java8新特性</a><time datetime="2022-07-28T05:08:53.000Z" title="发表于 2022-07-28 13:08:53">2022-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/%E7%AC%AC16%E7%AB%A0-%E5%8F%8D%E5%B0%84%EF%BC%88Reflect%EF%BC%89/" title="第16章 反射（Reflect）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第16章 反射（Reflect）"/></a><div class="content"><a class="title" href="/2022/07/28/%E7%AC%AC16%E7%AB%A0-%E5%8F%8D%E5%B0%84%EF%BC%88Reflect%EF%BC%89/" title="第16章 反射（Reflect）">第16章 反射（Reflect）</a><time datetime="2022-07-28T05:08:38.000Z" title="发表于 2022-07-28 13:08:38">2022-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="第15章 网络编程"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第15章 网络编程"/></a><div class="content"><a class="title" href="/2022/07/28/%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="第15章 网络编程">第15章 网络编程</a><time datetime="2022-07-28T05:08:24.000Z" title="发表于 2022-07-28 13:08:24">2022-07-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/28/%E7%AC%AC14%E7%AB%A0-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="第14章 File类与IO流"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第14章 File类与IO流"/></a><div class="content"><a class="title" href="/2022/07/28/%E7%AC%AC14%E7%AB%A0-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="第14章 File类与IO流">第14章 File类与IO流</a><time datetime="2022-07-28T05:08:10.000Z" title="发表于 2022-07-28 13:08:10">2022-07-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Gao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>