<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>08  Java进阶 | 爱笑的Gao的个人博客</title><meta name="keywords" content="Java,Java基础,Java自学笔记"><meta name="author" content="Gao"><meta name="copyright" content="Gao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="08  Java进阶final使用final变量final变量有成员变量或者是本地变量(方法内的局部变量)，在类成员中final经常和static一起使用，作为类常量使用。其中类常量 必须在声明时初始化，final成员常量可以在构造函数初始化。 12345678public class Main &amp;#123;    public static final int i; &#x2F;&#x2F;报错，必须初始化 因为常">
<meta property="og:type" content="article">
<meta property="og:title" content="08  Java进阶">
<meta property="og:url" content="https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/08-Java%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="爱笑的Gao的个人博客">
<meta property="og:description" content="08  Java进阶final使用final变量final变量有成员变量或者是本地变量(方法内的局部变量)，在类成员中final经常和static一起使用，作为类常量使用。其中类常量 必须在声明时初始化，final成员常量可以在构造函数初始化。 12345678public class Main &amp;#123;    public static final int i; &#x2F;&#x2F;报错，必须初始化 因为常">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://pic.netbian.com/uploads/allimg/220612/151918-16550183582aa7.jpg">
<meta property="article:published_time" content="2022-06-12T14:38:24.000Z">
<meta property="article:modified_time" content="2022-10-16T16:05:51.530Z">
<meta property="article:author" content="Gao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="Java自学笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pic.netbian.com/uploads/allimg/220612/151918-16550183582aa7.jpg"><link rel="shortcut icon" href="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?"><link rel="canonical" href="https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/08-Java%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '08  Java进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-10-17 00:05:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="/js/title.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Jayhrn/fontawesome-pro/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/remixicon@2.5.0/fonts/remixicon.css"><script src="https://at.alicdn.com/t/c/font_3570527_dthoqrrv2tv.css"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="爱笑的Gao的个人博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#iconfont icon-xiangji1"></use></svg><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://pic.netbian.com/uploads/allimg/220612/151918-16550183582aa7.jpg')"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span>JAYHRN</span></a></span><span id="page_name"><a id="page-name-text" title="回到顶部" onclick="btf.scrollToDest(0,500)"><span>爱笑的Gao的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#iconfont icon-xiangji1"></use></svg><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于我</span></a></div></div></div><div id="hotkey"><div id="search-button"><a class="site-page social-icon search" title="搜索"><i class="ri-search-eye-line"></i></a></div><div id="randompost-button"><a class="site-page" title="随机文章" onclick="toRandomPost()"><i class="ri-subway-fill"></i></a></div><div id="mode-button"><a class="site-page" title="浅色和深色模式转换" onclick="switchDarkMode()"><i class="ri-sun-fill"></i></a></div><div id="top-button"><a class="site-page" title="回到顶部" onclick="btf.scrollToDest(0,500)"><i class="ri-plane-fill"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">08  Java进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-12T14:38:24.000Z" title="发表于 2022-06-12 22:38:24">2022-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-16T16:05:51.530Z" title="更新于 2022-10-17 00:05:51">2022-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">Java自学笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">47.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>169分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="08  Java进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="08-Java进阶"><a href="#08-Java进阶" class="headerlink" title="08  Java进阶"></a>08  Java进阶</h1><h2 id="final使用"><a href="#final使用" class="headerlink" title="final使用"></a>final使用</h2><h3 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h3><p>final变量有成员变量或者是本地变量(方法内的局部变量)，在类成员中final经常和static一起使用，作为类常量使用。<strong>其中类常量</strong></p>
<p><strong>必须在声明时初始化，final成员常量可以在构造函数初始化。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> i; <span class="comment">//报错，必须初始化 因为常量在常量池中就存在了，调用时不需要类的初始化，所以必须在声明时初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> j;</span><br><span class="line">    Main() &#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        j = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就如上所说的，对于类常量，JVM会缓存在常量池中，在读取该变量时不会加载这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    Main() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用构造函数&quot;</span>); <span class="comment">// 该方法不会调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Main.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final修饰基本数据类型变量和引用"><a href="#final修饰基本数据类型变量和引用" class="headerlink" title="final修饰基本数据类型变量和引用"></a>final修饰基本数据类型变量和引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">final</span>修饰基本类型变量和引用() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] b = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] c = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//  b = c;报错</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Fi</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fi</span>();</span><br><span class="line">    <span class="comment">//aa = &quot;b&quot;;报错</span></span><br><span class="line">    <span class="comment">// f = null;//报错</span></span><br><span class="line">    f.a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>final方法表示该方法不能被子类的方法重写，将方法声明为final，在编译的时候就已经静态绑定了，不需要在运行时动态绑定。final方法调用时使用的是invokespecial指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PersonalLoan</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;personal loan”;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class CheapPersonalLoan extends PersonalLoan&#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public final String getName()&#123;</span></span><br><span class="line"><span class="string">        return&quot;</span>cheap personal loan<span class="string">&quot;;//编译错误，无法被重载</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public String test() &#123;</span></span><br><span class="line"><span class="string">        return getName(); //可以调用，因为是public方法</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>final类不能被继承，final类中的方法默认也会是final类型的，java中的String类和Integer类都是final类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Si</span>&#123;</span><br><span class="line">    <span class="comment">//一般情况下final修饰的变量一定要被初始化。</span></span><br><span class="line">    <span class="comment">//只有下面这种情况例外，要求该变量必须在构造方法中被初始化。</span></span><br><span class="line">    <span class="comment">//并且不能有空参数的构造方法。</span></span><br><span class="line">    <span class="comment">//这样就可以让每个实例都有一个不同的变量，并且这个变量在每个实例中只会被初始化一次</span></span><br><span class="line">    <span class="comment">//于是这个变量在单个实例里就是常量了。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s ;</span><br><span class="line">    Si(<span class="type">int</span> s) &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bi</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//final修饰方法无法被继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ci</span> <span class="keyword">extends</span> <span class="title class_">Bi</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        void go() &#123;</span></span><br><span class="line"><span class="comment">//            //final修饰方法无法被继承</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">char</span>[]a = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[]b = &#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PersonalLoan</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheapPersonalLoan</span> <span class="keyword">extends</span> <span class="title class_">PersonalLoan</span> &#123;  <span class="comment">//编译错误，无法被继承 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">final</span>修饰类() &#123;</span><br><span class="line">    <span class="comment">//引用没有被final修饰，所以是可变的。</span></span><br><span class="line">    <span class="comment">//final只修饰了Fi类型，即Fi实例化的对象在堆中内存地址是不可变的。</span></span><br><span class="line">    <span class="comment">//虽然内存地址不可变，但是可以对内部的数据做改变。</span></span><br><span class="line">    <span class="type">Fi</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fi</span>();</span><br><span class="line">    f.a = <span class="number">1</span>;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">    f.a = <span class="number">2</span>;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">    <span class="comment">//改变实例中的值并不改变内存地址。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Fi</span> <span class="variable">ff</span> <span class="operator">=</span> f;</span><br><span class="line">    <span class="comment">//让引用指向新的Fi对象，原来的f对象由新的引用ff持有。</span></span><br><span class="line">    <span class="comment">//引用的指向改变也不会改变原来对象的地址</span></span><br><span class="line">    f = <span class="keyword">new</span> <span class="title class_">Fi</span>();</span><br><span class="line">    System.out.println(f);</span><br><span class="line">    System.out.println(ff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final关键字的知识点"><a href="#final关键字的知识点" class="headerlink" title="final关键字的知识点"></a>final关键字的知识点</h3><ol>
<li><p>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。final变量一旦被初始化后不能再次赋值。</p>
</li>
<li><p>本地变量必须在声明时赋值。 因为没有初始化的过程</p>
</li>
<li><p>在匿名类中所有变量都必须是final变量。</p>
</li>
<li><p>final方法不能被重写, final类不能被继承</p>
</li>
<li><p>接口中声明的所有变量本身是final的。类似于匿名类</p>
</li>
<li><p>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</p>
</li>
<li><p>final方法在编译阶段绑定，称为静态绑定(static binding)。</p>
</li>
<li><p>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</p>
</li>
</ol>
<p>final方法的好处:</p>
<ol>
<li><p>提高了性能，JVM在常量池中会缓存final变量</p>
</li>
<li><p>final变量在多线程中并发安全，无需额外的同步开销</p>
</li>
<li><p>final方法是静态编译的，提高了调用速度</p>
</li>
<li><p><strong>final类创建的对象是只可读的，在多线程可以安全共享</strong></p>
</li>
</ol>
<h2 id="final关键字的最佳实践"><a href="#final关键字的最佳实践" class="headerlink" title="final关键字的最佳实践"></a>final关键字的最佳实践</h2><h3 id="final的用法"><a href="#final的用法" class="headerlink" title="final的用法"></a>final的用法</h3><p>1、final 对于常量来说，意味着值不能改变，例如 final int i=100。这个i的值永远都是100。<br>但是对于变量来说又不一样，只是标识这个引用不可被改变，例如 final File f=new File(“c:\test.txt”);</p>
<p>那么这个f一定是不能被改变的，如果f本身有方法修改其中的成员变量，例如是否可读，是允许修改的。有个形象的比喻：一个女子定义了一个final的老公，这个老公的职业和收入都是允许改变的，只是这个女人不会换老公而已。</p>
<h3 id="关于空白final"><a href="#关于空白final" class="headerlink" title="关于空白final"></a>关于空白final</h3><p>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。\<br>　另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。<br>　<br>但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalTest</span> &#123; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> p; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> q=<span class="number">3</span>; </span><br><span class="line">FinalTest()&#123; </span><br><span class="line">p=<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">FinalTest(<span class="type">int</span> i)&#123; </span><br><span class="line">p=i;<span class="comment">//可以赋值，相当于直接定义p </span></span><br><span class="line">q=i;<span class="comment">//不能为一个final变量赋值 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="final内存分配"><a href="#final内存分配" class="headerlink" title="final内存分配"></a>final内存分配</h3><p>刚提到了内嵌机制，现在详细展开。<br>要知道调用一个函数除了函数本身的执行时间之外，还需要额外的时间去寻找这个函数（类内部有一个函数签名和函数地址的映射表）。所以减少函数调用次数就等于降低了性能消耗。</p>
<p>final修饰的函数会被编译器优化，优化的结果是减少了函数调用的次数。如何实现的，举个例子给你看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;g&quot;</span>);&#125;; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)   </span><br><span class="line">func(); </span><br><span class="line">&#125;&#125; </span><br><span class="line">经过编译器优化之后，这个类变成了相当于这样写： </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;g&quot;</span>);&#125;; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">&#123;System.out.println(<span class="string">&quot;g&quot;</span>);&#125; </span><br><span class="line">&#125;&#125; </span><br></pre></td></tr></table></figure>
<p>看出来区别了吧？编译器直接将func的函数体内嵌到了调用函数的地方，这样的结果是节省了1000次函数调用，当然编译器处理成字节码，只是我们可以想象成这样，看个明白。</p>
<p>不过，当函数体太长的话，用final可能适得其反，因为经过编译器内嵌之后代码长度大大增加，于是就增加了jvm解释字节码的时间。</p>
<p>在使用final修饰方法的时候，编译器会将被final修饰过的方法插入到调用者代码处，提高运行速度和效率，但被final修饰的方法体不能过大，编译器可能会放弃内联，但究竟多大的方法会放弃，我还没有做测试来计算过。</p>
<p><strong>下面这些内容是通过两个疑问来继续阐述的</strong></p>
<h3 id="使用final修饰方法会提高速度和效率吗"><a href="#使用final修饰方法会提高速度和效率吗" class="headerlink" title="使用final修饰方法会提高速度和效率吗"></a>使用final修饰方法会提高速度和效率吗</h3><p>见下面的测试代码，我会执行五次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getJava</span><span class="params">()</span>   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Java &quot;</span>;   </span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;final &quot;</span>;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            str1 += str2;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getJava_Final</span><span class="params">()</span>   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Java &quot;</span>;   </span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;final &quot;</span>;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            str1 += str2;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        getJava();   </span><br><span class="line">        System.out.println(<span class="string">&quot;调用不带final修饰的方法执行时间为:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;毫秒时间&quot;</span>);   </span><br><span class="line">        start = System.currentTimeMillis();   </span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Java &quot;</span>;   </span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;final &quot;</span>;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            str1 += str2;   </span><br><span class="line">        &#125;   </span><br><span class="line">        System.out.println(<span class="string">&quot;正常的执行时间为:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;毫秒时间&quot;</span>);   </span><br><span class="line">        start = System.currentTimeMillis();   </span><br><span class="line">        getJava_Final();   </span><br><span class="line">        System.out.println(<span class="string">&quot;调用final修饰的方法执行时间为:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;毫秒时间&quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果为： </span><br><span class="line">第一次： </span><br><span class="line">调用不带<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1732</span>毫秒时间 </span><br><span class="line">正常的执行时间为:<span class="number">1498</span>毫秒时间 </span><br><span class="line">调用<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1593</span>毫秒时间 </span><br><span class="line">第二次： </span><br><span class="line">调用不带<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1217</span>毫秒时间 </span><br><span class="line">正常的执行时间为:<span class="number">1031</span>毫秒时间 </span><br><span class="line">调用<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1124</span>毫秒时间 </span><br><span class="line">第三次： </span><br><span class="line">调用不带<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1154</span>毫秒时间 </span><br><span class="line">正常的执行时间为:<span class="number">1140</span>毫秒时间 </span><br><span class="line">调用<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1202</span>毫秒时间 </span><br><span class="line">第四次： </span><br><span class="line">调用不带<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1139</span>毫秒时间 </span><br><span class="line">正常的执行时间为:<span class="number">999</span>毫秒时间 </span><br><span class="line">调用<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1092</span>毫秒时间 </span><br><span class="line">第五次： </span><br><span class="line">调用不带<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1186</span>毫秒时间 </span><br><span class="line">正常的执行时间为:<span class="number">1030</span>毫秒时间 </span><br><span class="line">调用<span class="keyword">final</span>修饰的方法执行时间为:<span class="number">1109</span>毫秒时间 </span><br><span class="line"></span><br><span class="line">由以上运行结果不难看出，执行最快的是“正常的执行”即代码直接编写，而使用<span class="keyword">final</span>修饰的方法，不像有些书上或者文章上所说的那样，速度与效率与“正常的执行”无异，而是位于第二位，最差的是调用不加<span class="keyword">final</span>修饰的方法。 </span><br></pre></td></tr></table></figure>
<p>观点：加了比不加好一点。</p>
<h3 id="使用final修饰变量会让变量的值不能被改变吗；"><a href="#使用final修饰变量会让变量的值不能被改变吗；" class="headerlink" title="使用final修饰变量会让变量的值不能被改变吗；"></a>使用final修饰变量会让变量的值不能被改变吗；</h3><p>见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>   </span><br><span class="line">    &#123;   </span><br><span class="line">        Color.color[<span class="number">3</span>] = <span class="string">&quot;white&quot;</span>;   </span><br><span class="line">        <span class="keyword">for</span> (String color : Color.color)   </span><br><span class="line">            System.out.print(color+<span class="string">&quot; &quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] color = &#123; <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;black&quot;</span> &#125;;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行结果： </span><br><span class="line">red blue yellow white </span><br><span class="line">看！，黑色变成了白色。 </span><br></pre></td></tr></table></figure>
<p>\<br>    在使用findbugs插件时，就会提示public static String[] color = { “red”, “blue”, “yellow”, “black” };这行代码不安全，但加上final修饰，这行代码仍然是不安全的，因为final没有做到保证变量的值不会被修改！<br>\<br>    原因是：final关键字只能保证变量本身不能被赋与新值，而不能保证变量的内部结构不被修改。例如在main方法有如下代码Color.color = new String[]{“”};就会报错了。</p>
<h3 id="如何保证数组内部不被修改"><a href="#如何保证数组内部不被修改" class="headerlink" title="如何保证数组内部不被修改"></a>如何保证数组内部不被修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那可能有的同学就会问了，加上final关键字不能保证数组不会被外部修改，那有什么方法能够保证呢？答案就是降低访问级别，把数组设为private。这样的话，就解决了数组在外部被修改的不安全性，但也产生了另一个问题，那就是这个数组要被外部使用的。 </span><br></pre></td></tr></table></figure>
<p>解决这个问题见代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.AbstractList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span> (String color : Color.color)   </span><br><span class="line">            System.out.print(color + <span class="string">&quot; &quot;</span>);   </span><br><span class="line">        Color.color.set(<span class="number">3</span>, <span class="string">&quot;white&quot;</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] _color = &#123; <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;black&quot;</span> &#125;;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; color = <span class="keyword">new</span> <span class="title class_">AbstractList</span>&lt;String&gt;()   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> _color[index];   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, String value)</span>   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;为了代码安全,不能修改数组&quot;</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> _color.length;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就OK了，既保证了代码安全，又能让数组中的元素被访问了。</p>
<h3 id="final方法的三条规则"><a href="#final方法的三条规则" class="headerlink" title="final方法的三条规则"></a>final方法的三条规则</h3><blockquote>
<p>规则1：final修饰的方法不可以被重写。</p>
<p>规则2：final修饰的方法仅仅是不能重写，但它完全可以被重载。</p>
<p>规则3：父类中private final方法，子类可以重新定义，这种情况不是重写。</p>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">规则<span class="number">1</span>代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">FinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 下面方法定义将出现编译错误，不能重写final方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">规则<span class="number">2</span>代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Finaloverload</span> &#123;</span><br><span class="line">	<span class="comment">//final 修饰的方法只是不能重写，完全可以重载</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String arg)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">规则<span class="number">3</span>代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateFinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">PrivateFinalMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 下面方法定义将不会出现问题</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>抽象类和接口以及抽象类和接口的区别。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">2.1、抽象类</span><br><span class="line">	第一：抽象类怎么定义？在class前添加abstract关键字就行了。</span><br><span class="line">	第二：抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。</span><br><span class="line">	第三：final和abstract不能联合使用，这两个关键字是对立的。</span><br><span class="line">	第四：抽象类的子类可以是抽象类。也可以是非抽象类。</span><br><span class="line">	第五：抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。</span><br><span class="line">	第六：抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。</span><br><span class="line">	第七：抽象方法怎么定义？</span><br><span class="line">		public abstract void doSome();</span><br><span class="line">	第八：一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现。</span><br><span class="line"></span><br><span class="line">	到目前为止，只是学习了抽象类的基础语法，一个类到底声明为抽象还是非抽象，</span><br><span class="line"></span><br><span class="line">	面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。</span><br><span class="line">		不对，错误的。</span><br><span class="line">		Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们</span><br><span class="line">		都不是抽象方法，例如：</span><br><span class="line">			public native int hashCode();</span><br><span class="line">			这个方法底层调用了C++写的动态链接库程序。</span><br><span class="line">			前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</span><br><span class="line"></span><br><span class="line">2.2、接口的基础语法。</span><br><span class="line">	1、接口是一种“引用数据类型”。</span><br><span class="line">	2、接口是完全抽象的。</span><br><span class="line">	3、接口怎么定义：[修饰符列表] interface 接口名&#123;&#125;</span><br><span class="line">	4、接口支持多继承。</span><br><span class="line">	5、接口中只有常量+抽象方法。</span><br><span class="line">	6、接口中所有的元素都是public修饰的</span><br><span class="line">	7、接口中抽象方法的public abstract可以省略。</span><br><span class="line">	8、接口中常量的public static final可以省略。</span><br><span class="line">	9、接口中方法不能有方法体。</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><h4 id="一、抽象类的基本概念"><a href="#一、抽象类的基本概念" class="headerlink" title="一、抽象类的基本概念"></a>一、抽象类的基本概念</h4><blockquote>
<p>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。而抽象类是指在普通类的结构里面增加抽象方法的组成部分。</p>
<p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</p>
</blockquote>
<p>​    而拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。</p>
<p>​    下面我写一个关于抽象类的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="二、抽象类的使用"><a href="#二、抽象类的使用" class="headerlink" title="二、抽象类的使用"></a>二、抽象类的使用</h4><p>我们看一下下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.Error: Unresolved compilation problem: </span><br><span class="line">	Cannot instantiate the type A</span><br><span class="line"></span><br><span class="line">	at com.wz.abstractdemo.TestDemo.main(TestDemo.java:<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上可知，<strong>A是抽象的，无法直接进行实例化操作</strong>。为什么不能直接实例化呢？当一个类实例化之后，就意味着这个对象可以调用类中的属性或者放过了，但在抽象类里存在抽象方法，而抽象方法没有方法体，没有方法体就无法进行调用。既然无法进行方法调用的话，又怎么去产生实例化对象呢。所以抽象类不能进行实例化对象。</p>
<hr>
<blockquote>
<ol>
<li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；</li>
<li>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；</li>
<li>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</li>
<li>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）否则编译不通过；</li>
</ol>
</blockquote>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;存在方法体的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//B类是抽象类的子类，是一个普通类</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;<span class="comment">//强制要求重写（也叫”实现“）</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        	<span class="comment">//多态</span></span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">		</span><br><span class="line">		a.print();<span class="comment">//被子类所覆写的过的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World !</span><br></pre></td></tr></table></figure>
<p>现在就可以清楚的发现：</p>
<blockquote>
<ol>
<li>抽象类继承子类里面有明确的方法覆写要求，而普通类可以有选择性的来决定是否需要覆写；</li>
<li>抽象类实际上就比普通类多了一些抽象方法而已，其他组成部分和普通类完全一样；</li>
<li>普通类对象可以直接实例化，但抽象类的对象必须经过向上转型之后才可以得到。</li>
</ol>
</blockquote>
<p>​    虽然一个类的子类可以去继承任意的一个普通类，可是从开发的实际要求来讲，普通    类尽量不要去继承另外一个普通类，而是去继承抽象类。</p>
<hr>
<h4 id="三、抽象类的使用限制"><a href="#三、抽象类的使用限制" class="headerlink" title="三、抽象类的使用限制"></a>三、抽象类的使用限制</h4><ol>
<li><p>抽象类中有构造方法么？<br>由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。<br>并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</p>
<p>下面我写一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wz.abstractdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;*****A类构造方法*****&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法，没有方法体，有abstract关键字做修饰</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="comment">//B类是抽象类的子类，是一个普通类</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;*****B类构造方法*****&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;<span class="comment">//强制要求覆写</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*****A类构造方法*****</span><br><span class="line">*****B类构造方法*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
</li>
</ol>
<ol>
<li><p>抽象类可以用final声明么？<br>不能，因为抽象类必须有子类，而final定义的类不能有子类；（final关键字规定不可以进行继承，因此final与abstract这两个关键字是冲突的）</p>
<hr>
</li>
</ol>
<ol>
<li><p>抽象类能否使用static声明？<br>下面我写一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//向上转型</span></span><br><span class="line">		a.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.Error: Unresolved compilation problem: </span><br><span class="line">	Illegal modifier <span class="keyword">for</span> the <span class="keyword">class</span> <span class="title class_">A</span>; only <span class="keyword">public</span>, <span class="keyword">abstract</span> &amp; <span class="keyword">final</span> are permitted</span><br><span class="line"></span><br><span class="line">	at com.manman.abstractdemo.A.&lt;init&gt;(TestDemo.java:<span class="number">3</span>)</span><br><span class="line">	at com.manman.abstractdemo.B.&lt;init&gt;(TestDemo.java:<span class="number">9</span>)</span><br><span class="line">	at com.manman.abstractdemo.TestDemo.main(TestDemo.java:<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面再看一个关于内部抽象类的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="comment">//static定义的内部类属于外部类</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>.B&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		A.<span class="type">B</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();<span class="comment">//向上转型</span></span><br><span class="line">		ab.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**********</span><br></pre></td></tr></table></figure>
<p>由此可见，外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p>
</li>
<li><p>可以直接调用抽象类中用static声明的方法么？<br>任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</p>
<p>下面我写个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个抽象类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		A.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World !</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><p>​    接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合。接口    通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<blockquote>
<p>如果一个类只由抽象方法和全局常量组成，那么这种情况下不会将其定义为一个抽象类。只会定义为一个接口，所以接口严格的来讲属于一个特殊的类，而这个类里面只有抽象方法和全局常量，就连构造方法也没有。</p>
</blockquote>
<p>​    下面我写一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//全局常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二、接口的使用"><a href="#二、接口的使用" class="headerlink" title="二、接口的使用"></a>二、接口的使用</h4><p>1、由于接口里面存在抽象方法，所以接口对象不能直接使用关键字new进行实例化。接口的使用原则如下：</p>
<blockquote>
<ol>
<li>接口必须要有子类，但此时一个子类可以使用implements关键字实现多个接口；</li>
<li>接口的子类（如果不是抽象类），那么必须要覆写接口中的全部抽象方法；</li>
<li>接口的对象可以利用子类对象的向上转型进行实例化。</li>
</ol>
</blockquote>
<p>​    下面我用一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzm.interfacedemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个接口A</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//全局常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;<span class="comment">//定义一个接口B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B&#123;<span class="comment">//X类实现了A和B两个接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A的抽象方法print()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口B的抽象方法get()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">X</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();<span class="comment">//实例化子类对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> x;<span class="comment">//向上转型</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> x;<span class="comment">//向上转型</span></span><br><span class="line">        a.print();</span><br><span class="line">        b.get();	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口A的抽象方法print()</span><br><span class="line">接口B的抽象方法get()</span><br></pre></td></tr></table></figure>
<p>以上的代码实例化了X类的对象，由于X类是A和B的子类，那么X类的对象可以变为A接口或者B接口对象。我们把测试主类代码改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) a;</span><br><span class="line">        b.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口B的抽象方法get()</span><br></pre></td></tr></table></figure>
<p>下面我们接着做一个测验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) a;</span><br><span class="line">        b.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> A);</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> B);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口B的抽象方法get()</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们发现，从定义结构来讲，A和B两个接口没有任何直接联系，但这两个接口却拥有同一个子类。我们不要被类型和名称所迷惑，因为实例化的是X子类，而这个类对象属于B类的对象，所以以上代码可行，只不过从代码的编写规范来讲，并不是很好。</p>
</blockquote>
<p>2、对于子类而言，除了实现接口外，还可以继承抽象类。若既要继承抽象类，同时还要实现接口的话，使用一下语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类 [extends 父类] [implemetns 接口<span class="number">1</span>,接口<span class="number">2</span>,...] &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>下面我用例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//定义一个接口A</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//全局常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;<span class="comment">//定义一个接口B</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">C</span>&#123;<span class="comment">//定义一个抽象类C</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">extends</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B&#123;<span class="comment">//X类继承C类，并实现了A和B两个接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A的抽象方法print()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口B的抽象方法get()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类C的抽象方法change()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于接口，里面的组成只有抽象方法和全局常量，所以很多时候为了书写简单，可以不用写public abstract 或者public static final。并且，接口中的访问权限只有一种：public，即：定义接口方法和全局常量的时候就算没有写上public，那么最终的访问权限也是public，注意不是default。以下两种写法是完全等价的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这样会不会带来什么问题呢？如果子类子类中的覆写方法也不是public，我们来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gzm.interfacedemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//注意子类这里不是public 而是默认default</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A的抽象方法print()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X</span>();</span><br><span class="line">        a.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我们看看运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalAccessError: com.wz.interfacedemo.X.print()V</span><br><span class="line">    at com.gzm.interfacedemo.TestDemo.main(TestDemo.java:<span class="number">22</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是因为接口中默认是public修饰，若子类中没用public修饰，则访问权限变严格了，给子类分配的是更低的访问权限。所以，在定义接口的时候强烈建议在抽象方法前加上public ，子类也加上：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">MSG</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A的抽象方法print()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、在Java中，一个抽象类只能继承一个抽象类，但一个接口却可以使用extends关键字同时继承多个接口（但接口不能继承抽象类）。</p>
<p>下面我写一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C接口同时继承了A和B两个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>,B&#123;<span class="comment">//使用的是extends</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，从继承关系来说接口的限制比抽象类少：</p>
<blockquote>
<ol>
<li>一个抽象类只能继承一个抽象父类，而接口可以继承多个接口；</li>
<li>一个子类只能继承一个抽象类，却可以实现多个接口（在Java中，接口的主要功能是解决单继承局限问题）</li>
</ol>
</blockquote>
<p>​    4、从接口的概念上来讲，接口只能由抽象方法和全局常量组成，但是内部结构是不    受概念限制的，正如抽象类中可以定义抽象内部类一样，在接口中也可以定义普通内    部类、抽象内部类和内部接口（但从实际的开发来讲，用户自己去定义内部抽象类或    内部接口的时候是比较少见的）</p>
<p>​    下面我们看一个例子，在接口中定义一个抽象内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="comment">//定义一个抽象内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在接口中如果使用了static去定义一个内接口，它表示一个外部接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">B</span>&#123;<span class="comment">//使用了static，是一个外部接口</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> <span class="keyword">implements</span> <span class="title class_">A</span>.B&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">funB</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="三、接口的实际应用（标准定义）"><a href="#三、接口的实际应用（标准定义）" class="headerlink" title="三、接口的实际应用（标准定义）"></a><strong>三、接口的实际应用（标准定义）</strong></h4><p>在日常的生活之中，接口这一名词经常听到的，例如：USB接口、打印接口、充电接口等等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20161006002203942" alt="img"></p>
<p>如果要进行开发，要先开发出USB接口标准，然后设备厂商才可以设计出USB设备。</p>
<p>现在假设每一个USB设备只有两个功能：安装驱动程序、工作。<br>定义一个USB的标准：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;   <span class="comment">// 操作标准       </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在电脑上应用此接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">plugin</span><span class="params">(USB usb)</span> &#123;</span><br><span class="line">          usb.install() ;</span><br><span class="line">          usb.work() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义USB设备—手机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;安装手机驱动程序。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;手机与电脑进行工作。&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="四、接口的作用"><a href="#四、接口的作用" class="headerlink" title="四、接口的作用"></a>四、接口的作用</h4><h5 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h5><blockquote>
<p>接口的规范性体现在抽象方法中，因为子类实现接口，就必须全部重写接口中所有的抽象方法，而且方法声明一模一样，这就是强制性，也是规范性的体现。</p>
</blockquote>
<h5 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h5><blockquote>
<p>生活中的接口有很多，USB接口，插座孔，充电孔，等只要是按照接口的规则创建，就可以和接口对接，所有按照接口规范创建的都可以对接，所有的实现类只要实现接口重写接口中所有的抽象方法【规则】，就可以使用，这也就是接口的拓展性。</p>
</blockquote>
<hr>
<h4 id="五、接口中的成员特点"><a href="#五、接口中的成员特点" class="headerlink" title="五、接口中的成员特点"></a>五、接口中的成员特点</h4><blockquote>
<p>接口中所有的变量都是被final修饰的，也就是只能赋值一次。所以接口中也没有变量这一说，都是常量。</p>
</blockquote>
<ul>
<li><p>接口中默认的常量使用final修饰的，只能赋值一次。</p>
</li>
<li><p>接口中默认的常量默认都是static修饰的，也就是说可以通过类名.调用。</p>
</li>
<li><p>接口中默认都是public修饰的，都是公开的。</p>
<blockquote>
<p>接口中所有的方法都是抽象方法，所以都默认使用public abstract修饰</p>
</blockquote>
</li>
</ul>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>因为接口不能创建对象，所以接口中也没有构造方法，没有构造代码块，没有静态代码块。</p>
<ul>
<li><h5 id="接口中没有构造方法"><a href="#接口中没有构造方法" class="headerlink" title="接口中没有构造方法"></a>接口中没有构造方法</h5></li>
<li><h5 id="接口中没有构造代码块"><a href="#接口中没有构造代码块" class="headerlink" title="接口中没有构造代码块"></a>接口中没有构造代码块</h5></li>
<li><p>接口中没有静态代码块</p>
</li>
</ul>
<h4 id="六、抽象类和接口有什么区别"><a href="#六、抽象类和接口有什么区别" class="headerlink" title="六、抽象类和接口有什么区别"></a>六、抽象类和接口有什么区别</h4><blockquote>
<ol>
<li>抽象类是半抽象的，接口是完全抽象的。</li>
<li>抽象类中有构造方法，接口没有构造方法。</li>
<li>接口和接口之间支持多继承，类和类之间只能单继承。</li>
<li>一个类可以同时实现多个接口，一个抽象类只能继承一个类。</li>
<li>接口中只允许出现常量和抽象方法。</li>
</ol>
</blockquote>
<p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
<p>JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。</p>
<p>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。</p>
<h4 id="七、思维导图"><a href="#七、思维导图" class="headerlink" title="七、思维导图"></a>七、思维导图</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/image-20211116154032200.png" alt="接口" style="zoom:200%;" /></p>
<hr>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><h3 id="一、Object类简介"><a href="#一、Object类简介" class="headerlink" title="一、Object类简介"></a>一、Object类简介</h3><p>Object类是Java<code>java.lang</code>包下的核心类，<strong>Object类是所有类的父类</strong>，何一个类时候如果没有明确的继承一个父类的话，那么它就是Object的子类；</p>
<p>以下两种类的定义的最终效果是完全相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">&#125;</span><br><span class="line">class Person extends Object&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Object类型接收所有对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/image-20220223150524533.png" alt="image-20220223150524533" style="zoom:200%;" /></p>
<blockquote>
<p>​    Object 类属于<code>java.lang</code>包，此包下的所有类在使用时无需手动导入，系统会在程序编译期间自动导入</p>
</blockquote>
<p>​    <strong>Object 类的结构图（Object提供了11 个方法）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/image-20220223150602850.png" alt="image-20220223150602850" style="zoom:150%;" /></p>
<p>​    下面我们对这些方法一一分析，看看这些方法都有什么作用：</p>
<ol>
<li>clone()</li>
</ol>
<blockquote>
<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>
</blockquote>
<ol>
<li>getClass()</li>
</ol>
<blockquote>
<p>final方法，返回Class类型的对象，反射来获取对象。</p>
</blockquote>
<ol>
<li>toString()</li>
</ol>
<blockquote>
<p>该方法用得比较多，一般子类都有覆盖，来获取对象的信息。</p>
</blockquote>
<ol>
<li>finalize()</li>
</ol>
<blockquote>
<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p>
</blockquote>
<ol>
<li>equals()</li>
</ol>
<blockquote>
<p>比较对象的内容是否相等</p>
</blockquote>
<ol>
<li>hashCode()</li>
</ol>
<blockquote>
<p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
</blockquote>
<ol>
<li>wait()</li>
</ol>
<blockquote>
<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<p>其他线程调用了该对象的notify方法。<br>其他线程调用了该对象的notifyAll方法。<br>其他线程调用了interrupt中断该线程。<br>时间间隔到了。<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>
</blockquote>
<ol>
<li>notify()</li>
</ol>
<blockquote>
<p>该方法唤醒在该对象上等待的某个线程。</p>
</blockquote>
<ol>
<li>notifyAll()</li>
</ol>
<blockquote>
<p>该方法唤醒在该对象上等待的所有线程。</p>
</blockquote>
<hr>
<h3 id="二-Object类的常用方法"><a href="#二-Object类的常用方法" class="headerlink" title="二. Object类的常用方法"></a>二. Object类的常用方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">toString( )</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">取得对象信息</td>
</tr>
<tr>
<td style="text-align:center">equals()</td>
<td style="text-align:center">普通</td>
<td style="text-align:center">比较对象是否相等</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>toString方法</li>
</ol>
<p><strong>toString()：取得对象信息，返回该对象的字符串表示</strong></p>
<p>下面我写一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">20</span>,<span class="string">&quot;manamn&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.manman.javase.object.Person@4554617c</span><br></pre></td></tr></table></figure>
<p>在使用对象直接输出的时候，默认输出的是一个对象在堆内存上的地址值；如若要输出该对象的内容，则要覆写<code>toString()</code>方法</p>
<p>覆写Person中的<code>toString()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;年龄为&quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;名字为&quot;</span> + <span class="built_in">this</span>.name; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">年龄:<span class="number">20</span>名字:manamn</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>toString( )的核心目的在于取得对象信息</strong></p>
<p>String作为信息输出的重要数据类型，在Java中所有的数据类型只要遇见String就执行了<code>+</code>，都要求其变为字符串后连接，而所有对象想要变为字符串就默认用toString( )方法</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span> + <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 输出：hello123</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么hello 和 123 (一个是字符串，一个是int类型的数据) 就可以直接拼接在一起呢？</p>
<p>因为字符串是爸爸，在这个拼爹的时代，他有一个万能的爸爸Object</p>
<p>换而言之，Object是所有类的父类，任意类都是继承Object类的。而Object中定义了 toString()方法，所以任意类中都包含了toString()方法，对象在实例化之后都可以调用。</p>
<p>所以任意对象转字符串的输出，是通过覆写 toString()方法实现的…</p>
<p>每一个类中都包含有toString()，但是并不是每一个类都覆写了toString()</p>
</blockquote>
<hr>
<ol>
<li><p>quals方法</p>
<p><strong>equals()：对象比较</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43232955/article/details/103216143"><strong>String类对象比较</strong></a> 使用的是 equals()方法，实际上String类的equals()方法就是覆写 Object类中的equals()方法</p>
<ul>
<li>基本数据类型之间比较使用 “==”(如： a == 3，b == 4, a == b，比较的是值是否相等）</li>
<li>引用数据类型比较 ： 调用equals（）方法进行比较。</li>
</ul>
<p>用equals（）来比较两个对象内容是否相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.javase.object;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/2/23 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">30</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">people2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">30</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(people1.equals(people2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>两个对象people1和people2的内容明明相等，应该是true呀？怎么会是false?</p>
<p>因为此时直接调用equals()方法默认进行比较的是两个对象的地址。</p>
<p>在源码中，传递来的Object对象和当前对象比较地址值，返回布尔值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/image-20220223153940456.png" alt="image-20220223153940456"></p>
<blockquote>
<p>但是，new一下就会在堆上创建新空间，两个对象地址自然不会相同，所以为false。</p>
<p>但是在判断两个对象是否相等时，比如要判断一个Person类的两个对象的姓名是否相同时，此时要重新覆写<code>equals()</code></p>
</blockquote>
<p>还是上面的例子，覆写equals()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里重写父类Object 的equals方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断内存地址是否相同 内存地址相同，则他们是同一个引用返回true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !(obj <span class="keyword">instanceof</span> People))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        程序进行到这里 说明 它不是空 且 是People对象</span></span><br><span class="line"><span class="comment">//        此时进行向下转型 将Object 强转为 Perple对象</span></span><br><span class="line">           <span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> (People)obj;</span><br><span class="line">            <span class="keyword">return</span> p.name.equals(<span class="built_in">this</span>.name)&amp;&amp; p.age == <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>所以，引用类型的数据在进行比较时，应该先覆写<code>equals()</code>方法，不然比较的还是两个对象的堆内存地址值，必然不会相等.</strong></p>
<hr>
</li>
</ol>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>1、八种基本数据类型对应的包装类。</p>
<blockquote>
<p>​    1.1、什么是自动装箱和自动拆箱，代码怎么写？<br>​        Integer x = 100; // x里面并不是保存100，保存的是100这个对象的内存地址。<br>​        Integer y = 100;<br>​        System.out.println(x == y); // true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">	System.out.println(x == y); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>、Integer类常用方法。</span><br><span class="line">	Integer.valueOf()</span><br><span class="line">	Integer.parseInt(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">	Integer.parseInt(<span class="string">&quot;中文&quot;</span>) : NumberFormatException</span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span>、Integer String <span class="type">int</span>三种类型互相转换。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2、日期类<br>    2.1、获取系统当前时间<br>        Date d = new Date();<br>    2.2、日期格式化：Date —&gt; String<br>        yyyy-MM-dd HH:mm:ss SSS<br>        SimpleDateFormat sdf = new SimpleDate(“yyyy-MM-dd HH:mm:ss SSS”);<br>        String s = sdf.format(new Date());<br>    2.3、String —&gt; Date<br>        SimpleDateFormat sdf = new SimpleDate(“yyyy-MM-dd HH:mm:ss”);<br>        Date d = sdf.parse(“2008-08-08 08:08:08”);<br>    2.4、获取毫秒数<br>        long begin = System.currentTimeMillis();<br>        Date d = new Date(begin - 1000 <em> 60 </em> 60 * 24);</p>
<p>3、数字类<br>    3.1、DecimalFormat数字格式化</p>
<pre><code>    ###,###.## 表示加入千分位，保留两个小数。
    ###,###.0000 表示加入千分位，保留4个小数，不够补0
3.2、BigDecimal
    财务软件中通常使用BigDecimal
</code></pre></blockquote>
<p>4、随机数</p>
<blockquote>
<p>​    4.1、怎么产生int类型随机数。<br>​        Random r = new Random();<br>​        int i = r.nextInt();<br>​    4.2、怎么产生某个范围之内的int类型随机数。<br>​        Random r = new Random();<br>​        int i = r.nextInt(101); // 产生[0-100]的随机数。</p>
</blockquote>
<p>5、枚举</p>
<blockquote>
<p>​    5.1、枚举是一种引用数据类型。<br>​    5.2、枚举编译之后也是class文件。<br>​    5.3、枚举类型怎么定义？<br>​        enum 枚举类型名{<br>​            枚举值,枚举值2,枚举值3<br>​        }<br>​    5.4、当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来<br>​    的时候，建议返回值类型设计为枚举类型。</p>
</blockquote>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><ul>
<li><p>java中异常的作用是：增强程序健壮性。</p>
</li>
<li><p>java中异常以类和对象的形式存在。</p>
</li>
</ul>
<p>  1、java的异常处理机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span>、异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？</span><br><span class="line">我们可以使用UML图来描述一下继承结构。</span><br><span class="line">画UML图有很多工具，例如：Rational Rose（收费的）、starUML等....</span><br><span class="line">	Object</span><br><span class="line">	Object下有Throwable（可抛出的）</span><br><span class="line">	Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）</span><br><span class="line">	Exception下有两个分支：</span><br><span class="line">		Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。</span><br><span class="line">		RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</span><br><span class="line"></span><br><span class="line"><span class="number">1.2</span>、编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。</span><br><span class="line">编译时异常因为什么而得名？</span><br><span class="line">	因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。</span><br><span class="line">	所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以<span class="keyword">new</span>对象。</span><br><span class="line">	因为异常的发生就是<span class="keyword">new</span>异常对象。</span><br><span class="line"></span><br><span class="line"><span class="number">1.3</span>、编译时异常和运行时异常的区别？</span><br><span class="line"></span><br><span class="line">	编译时异常一般发生的概率比较高。</span><br><span class="line">		举个例子：</span><br><span class="line">			你看到外面下雨了，倾盆大雨的。</span><br><span class="line">			你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。</span><br><span class="line">			而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。</span><br><span class="line">			“拿一把伞”就是对“生病异常”发生之前的一种处理方式。</span><br><span class="line"></span><br><span class="line">			对于一些发生概率较高的异常，需要在运行之前对其进行预处理。</span><br><span class="line"></span><br><span class="line">	运行时异常一般发生的概率比较低。</span><br><span class="line">		举个例子：</span><br><span class="line">			小明走在大街上，可能会被天上的飞机轮子砸到。</span><br><span class="line">			被飞机轮子砸到也算一种异常。</span><br><span class="line">			但是这种异常发生概率较低。</span><br><span class="line">			在出门之前你没必要提前对这种发生概率较低的异常进行预处理。</span><br><span class="line">			如果你预处理这种异常，你将活的很累。</span><br><span class="line">	</span><br><span class="line">	假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加</span><br><span class="line">	的安全，但是你这个人活的很累。</span><br><span class="line">	</span><br><span class="line">	假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，</span><br><span class="line">	所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？</span><br><span class="line">		首先，如果这样的话，程序肯定是绝对的安全的。</span><br><span class="line">		但是程序员编写程序太累，代码到处都是处理异常</span><br><span class="line">		的代码。</span><br><span class="line"></span><br><span class="line"><span class="number">1.4</span>、编译时异常还有其他名字：</span><br><span class="line">	受检异常：CheckedException</span><br><span class="line">	受控异常</span><br><span class="line"></span><br><span class="line"><span class="number">1.5</span>、运行时异常还有其它名字：</span><br><span class="line">	未受检异常：UnCheckedException</span><br><span class="line">	非受控异常</span><br><span class="line"></span><br><span class="line"><span class="number">1.6</span>、再次强调：所有异常都是发生在运行阶段的。</span><br><span class="line"></span><br><span class="line"><span class="number">1.7</span>、Java语言中对异常的处理包括两种方式：</span><br><span class="line"></span><br><span class="line">	第一种方式：在方法声明的位置上，使用<span class="keyword">throws</span>关键字，抛给上一级。</span><br><span class="line">		谁调用我，我就抛给谁。抛给上一级。</span><br><span class="line"></span><br><span class="line">	第二种方式：使用<span class="keyword">try</span>..<span class="keyword">catch</span>语句进行异常的捕捉。</span><br><span class="line">		这件事发生了，谁也不知道，因为我给抓住了。</span><br><span class="line"></span><br><span class="line">	举个例子：</span><br><span class="line">		我是某集团的一个销售员，因为我的失误，导致公司损失了<span class="number">1000</span>元，</span><br><span class="line">		“损失<span class="number">1000</span>元”这可以看做是一个异常发生了。我有两种处理方式，</span><br><span class="line">		第一种方式：我把这件事告诉我的领导【异常上抛】</span><br><span class="line">		第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】</span><br><span class="line">		</span><br><span class="line">		张三 --&gt; 李四 ---&gt; 王五 --&gt; CEO</span><br><span class="line">	</span><br><span class="line">	思考：</span><br><span class="line">		异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要</span><br><span class="line">		对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。</span><br><span class="line"></span><br><span class="line"><span class="number">1.8</span>、注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续</span><br><span class="line">向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h3><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/cf1918ef54754b3ba6ccfaec127a8c6b~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png" style="zoom:150%;" /></p>
<p>从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。</p>
<p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p>
<p>Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p>总体上我们根据Javac对异常的处理要求，将异常类分为2类。</p>
<blockquote>
<p>非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。</p>
<p>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p>
<p>检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p>这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>
</blockquote>
<p>​    <strong>需要明确的是：检查和非检查是对于javac来说的，这样就很好理解和区分了。</strong></p>
<hr>
<h3 id="初识异常"><a href="#初识异常" class="headerlink" title="初识异常"></a>初识异常</h3><p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。</p>
<p>异常最先发生的地方，叫做异常抛出点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 异常 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        System . out. println( <span class="string">&quot;----欢迎使用命令行除法计算器----&quot;</span> ) ;</span><br><span class="line">        CMDCalculate ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">CMDCalculate</span> <span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> ( System. in );</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> scan .nextInt () ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> scan .nextInt () ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> devide (num1 , num2 ) ;</span><br><span class="line">        System . out. println( <span class="string">&quot;result:&quot;</span> + result) ;</span><br><span class="line">        scan .close () ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">devide</span> <span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2 )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 / num2 ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    ----欢迎使用命令行除法计算器----</span></span><br><span class="line"><span class="comment">//            1</span></span><br><span class="line"><span class="comment">//            0</span></span><br><span class="line"><span class="comment">//    Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">//    at com.javase.异常.异常.devide(异常.java:24)</span></span><br><span class="line"><span class="comment">//    at com.javase.异常.异常.CMDCalculate(异常.java:19)</span></span><br><span class="line"><span class="comment">//    at com.javase.异常.异常.main(异常.java:12)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。</p>
</blockquote>
<p>这种行为叫做异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p>
<blockquote>
<p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p>
</blockquote>
<p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。</p>
<hr>
<h3 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h3><p>下面看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误即error一般指jvm无法处理的错误</span></span><br><span class="line"><span class="comment">//异常是Java定义的用于简化错误处理流程和定位错误的一种工具。</span></span><br><span class="line"><span class="keyword">public</span> class 错误和错误 &#123;</span><br><span class="line">    <span class="type">Error</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面这四个异常或者错误有着不同的处理方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error1</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//编译期要求必须处理，因为这个异常是最顶层异常，包括了检查异常，必须要处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Exception也必须处理。否则报错，因为检查异常都继承自exception，所以默认需要捕捉。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error2</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//error可以不处理，编译不报错,原因是虚拟机根本无法处理，所以啥都不用做</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error3</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//runtimeexception众所周知编译不会报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error4</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    Exception in thread &quot;main&quot; java.lang.Error</span></span><br><span class="line"><span class="comment">//    at com.javase.异常.错误.main(错误.java:11)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h3><p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：</p>
<blockquote>
<p>使用try…catch…finally语句块处理它。</p>
<p>或者，在函数签名中使用throws 声明交给函数调用者caller去解决。</p>
</blockquote>
<p>下面看几个具体的例子，包括error，exception和throwable</p>
<p>上面的例子是运行时异常，不需要显示捕获。 下面这个例子是可检查异常需，要显示捕获或者抛出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testException</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//FileInputStream的构造函数会抛出FileNotFoundException</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> word;</span><br><span class="line">    <span class="comment">//read方法会抛出IOException</span></span><br><span class="line">    <span class="keyword">while</span>((word =  fileIn.read())!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)word);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//close方法会抛出IOException</span></span><br><span class="line">    fileIn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般情况下的处理方式 try catch finally</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 异常处理方式 &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//try块中放可能发生异常的代码。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果发生异常，则尝试去匹配catch块。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>();</span><br><span class="line">        <span class="comment">//使用1.8jdk同时捕获多个异常，runtimeexception也可以捕获。只是捕获后虚拟机也无法处理，所以不建议捕获。</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException | IOException | ArrayIndexOutOfBoundsException exception)&#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">        <span class="comment">//每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果try中没有发生异常，则所有的catch块将被忽略。</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception exception)&#123;</span><br><span class="line">        System.out.println(exception.getMessage());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//finally块通常是可选的。</span></span><br><span class="line">        <span class="comment">//无论异常是否发生，异常是否匹配被处理，finally都会执行。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一个try至少要跟一个catch或者finally</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>异常出现时该方法后面的代码就不会再执行了，即使异常已经被捕获了。这里举一个不一样的例子，在catch语句块之后仍然可以试用 try catch finally</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        throwE();</span><br><span class="line">        System.out.println(<span class="string">&quot;我前面抛出异常了&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我不会执行了&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (StringIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(e.getCause());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//在catch块中仍然可以使用try catch finally</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我所在的catch块没有执行，我也不会执行的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在方法声明中抛出的异常必须由调用方法处理或者继续往上抛，</span></span><br><span class="line"><span class="comment">// 当抛到jre时由于无法处理终止程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwE</span> <span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        Socket socket = new Socket(&quot;127.0.0.1&quot;, 80);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动抛出异常时，不会报错，但是调用该方法的方法需要处理这个异常，否则会出错。</span></span><br><span class="line"><span class="comment">//        java.lang.StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//        at com.javase.异常.异常处理方式.throwE(异常处理方式.java:75)</span></span><br><span class="line"><span class="comment">//        at com.javase.异常.异常处理方式.test(异常处理方式.java:62)</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="“不负责任”的throws"><a href="#“不负责任”的throws" class="headerlink" title="“不负责任”的throws"></a>“不负责任”的throws</h3><p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>
<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> ExceptionType1 , ExceptionType2 ,ExceptionTypeN</span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">//foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="纠结的finally"><a href="#纠结的finally" class="headerlink" title="纠结的finally"></a>纠结的finally</h3><p>finally块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：<strong>System.exit()。</strong>因此finally块通常用来做资源释放操作：关闭文件，关闭数据库连接等等。</p>
<p>良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。</p>
<p>需要注意的地方:</p>
<blockquote>
<p>1、finally块没有处理异常的能力。处理异常的只能是catch块。</p>
<p>2、在同一try…catch…finally块中 ，如果try中抛出异常，且有匹配的catch块，则先执行catch块，再执行finally块。如果没有catch块匹配，则先执行finally，然后去外面的调用者中寻找合适的catch块。</p>
<p>3、在同一try…catch…finally块中 ，try发生异常，且匹配的catch块中处理异常时也抛出异常，那么后面的finally也会执行：首先执行finally块，然后去外围调用者中寻找合适的catch块。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">finally</span>使用 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="comment">// throw new Throwable();</span></span><br><span class="line">            <span class="comment">//此时如果再抛异常，finally无法执行，只能报错。</span></span><br><span class="line">            <span class="comment">//finally无论何时都会执行</span></span><br><span class="line">            <span class="comment">//除非我显示调用。此时finally才不会执行</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你真狠&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="throw-JRE也使用的关键字"><a href="#throw-JRE也使用的关键字" class="headerlink" title="throw : JRE也使用的关键字"></a>throw : JRE也使用的关键字</h3><p>throw exceptionObject</p>
<p>程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面必须是一个异常对象。</p>
<p>throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，==它和由JRE自动形成的异常抛出点没有任何差别。==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>(user  == <span class="literal">null</span>) </span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;User对象为空&quot;</span>);</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>
<p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p>
<blockquote>
<p>一个无参构造函数 一个带有String参数的构造函数，并传递给父类的构造函数。 一个带有String参数和Throwable参数，并都传递给父类构造函数 一个带有Throwable 参数的构造函数，并传递给父类的构造函数。 下面是IOException类的完整源代码，可以借鉴。</p>
</blockquote>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7818375828146090155L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IOException</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IOException</span><span class="params">(String message)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IOException</span><span class="params">(String message, Throwable cause)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IOException</span><span class="params">(Throwable cause)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h3><p>异常的注意事项</p>
<blockquote>
<p>当子类重写父类的带有 throws声明的函数时，其throws声明的异常必须在父类异常的可控范围内——用于处理父类的throws方法的异常处理器，必须也适用于子类的这个带throws方法 。这是为了支持多态。</p>
<p>例如，父类方法throws 的是2个异常，子类就不能throws 3个及以上的异常。父类throws IOException，子类就必须throws IOException或者IOException的子类。</p>
</blockquote>
<p>至于为什么？我想，也许下面的例子可以说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/<strong><strong><strong><strong>**</strong></strong></strong></strong>假设上面的代码是允许的（实质是错误的）<strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong>/</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Father[] objs = <span class="keyword">new</span> <span class="title class_">Father</span>[<span class="number">2</span>];</span><br><span class="line">        objs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        objs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(Father obj:objs)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//因为Son类抛出的实质是SQLException，而IOException无法处理它。</span></span><br><span class="line">        <span class="comment">//那么这里的try。。catch就不能处理Son中的异常。</span></span><br><span class="line">        <span class="comment">//多态就不能实现了。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 obj.start();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException)</span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">//处理IOException</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="JAVA异常常见面试题"><a href="#JAVA异常常见面试题" class="headerlink" title="JAVA异常常见面试题"></a>JAVA异常常见面试题</h3><p>下面是我个人总结的在Java和J2EE开发者在面试中经常被问到的有关Exception和Error的知识。在分享我的回答的时候，我也给这些问题作了快速修订，并且提供源码以便深入理解。我总结了各种难度的问题，适合新手码农和高级Java码农。如果你遇到了我列表中没有的问题，并且这个问题非常好，请在下面评论中分享出来。你也可以在评论中分享你面试时答错的情况。</p>
<p><strong>1) Java中什么是Exception?</strong> 　</p>
<blockquote>
<p>这个问题经常在第一次问有关异常的时候或者是面试菜鸟的时候问。我从来没见过面高级或者资深工程师的时候有人问这玩意，但是对于菜鸟，是很愿意问这个的。</p>
<p>简单来说，异常是Java传达给你的系统和程序错误的方式。在java中，异常功能是通过实现比如Throwable，Exception，RuntimeException之类的类，然后还有一些处理异常时候的关键字，比如throw，throws，try，catch，finally之类的。 所有的异常都是通过Throwable衍生出来的。Throwable把错误进一步划分为 java.lang.Exception 和 java.lang.Error.  java.lang.Error 用来处理系统错误，例如java.lang.StackOverFlowError 之类的。然后 Exception用来处理程序错误，请求的资源不可用等等。</p>
</blockquote>
<p><strong>2) Java中的检查型异常和非检查型异常有什么区别？</strong></p>
<blockquote>
<p>这又是一个非常流行的Java异常面试题，会出现在各种层次的Java面试中。</p>
<p>检查型异常和非检查型异常的主要区别在于其处理方式。检查型异常需要使用try, catch和finally关键字在编译期进行处理，否则会出现编译器会报错。对于非检查型异常则不需要这样做。Java中所有继承自java.lang.Exception类的异常都是检查型异常，所有继承自RuntimeException的异常都被称为非检查型异常。</p>
</blockquote>
<p><strong>3) Java中的NullPointerException和ArrayIndexOutOfBoundException之间有什么相同之处？</strong></p>
<blockquote>
<p>在Java异常面试中这并不是一个很流行的问题，但会出现在不同层次的初学者面试中，用来测试应聘者对检查型异常和非检查型异常的概念是否熟悉。顺便说一下，该题的答案是，</p>
<p>这两个异常都是非检查型异常，都继承自RuntimeException。该问题可能会引出另一个问题，即Java和C的数组有什么不同之处，因为C里面的数组是没有大小限制的，绝对不会抛出ArrayIndexOutOfBoundException。</p>
</blockquote>
<p><strong>4)在Java异常处理的过程中，你遵循的那些最好的实践是什么？</strong></p>
<p>这个问题在面试技术经理是非常常见的一个问题。因为异常处理在项目设计中是非常关键的，所以精通异常处理是十分必要的。异常处理有很多最佳实践，下面列举集中，它们提高你代码的健壮性和灵活性：</p>
<blockquote>
<ol>
<li>调用方法的时候返回布尔值来代替返回null，这样可以 NullPointerException。由于空指针是java异常里最恶心的异常</li>
<li>catch块里别不写代码。空catch块是异常处理里的错误事件，因为它只是捕获了异常，却没有任何处理或者提示。通常你起码要打印出异常信息，当然你最好根据需求对异常信息进行处理。</li>
</ol>
<p>3)能抛受控异常（checked Exception）就尽量不抛受非控异常(checked Exception)。通过去掉重复的异常处理代码，可以提高代码的可读性。</p>
<ol>
<li>绝对不要让你的数据库相关异常显示到客户端。由于绝大多数数据库和SQLException异常都是受控异常，在Java中，你应该在DAO层把异常信息处理，然后返回处理过的能让用户看懂并根据异常提示信息改正操作的异常信息。</li>
<li>在Java中，一定要在数据库连接，数据库查询，流处理后，在finally块中调用close()方法。</li>
</ol>
</blockquote>
<p><strong>5) 既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常?</strong></p>
<blockquote>
<p>这是一个有争议的问题，在回答该问题时你应当小心。虽然他们肯定愿意听到你的观点，但其实他们最感兴趣的还是有说服力的理由。我认为其中一个理由是，存在检查型异常是一个设计上的决定，受到了诸如C++等比Java更早编程语言设计经验的影响。绝大多数检查型异常位于java.io包内，这是合乎情理的，因为在你请求了不存在的系统资源的时候，一段强壮的程序必须能够优雅的处理这种情况。通过把IOException声明为检查型异常，Java 确保了你能够优雅的对异常进行处理。另一个可能的理由是，可以使用catch或finally来确保数量受限的系统资源（比如文件描述符）在你使用后尽早得到释放。 Joshua Bloch编写的 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.amazon.com%2Fdp%2F0321356683%2F%3Ftag%3Djavamysqlanta-20">Effective Java 一书</a> 中多处涉及到了该话题，值得一读。</p>
</blockquote>
<p><strong>6)  throw 和 throws这两个关键字在java中有什么不同?</strong></p>
<blockquote>
<p>一个java初学者应该掌握的面试问题。 throw 和 throws乍看起来是很相似的尤其是在你还是一个java初学者的时候。尽管他们看起来相似，都是在处理异常时候使用到的。但在代码里的使用方法和用到的地方是不同的。throws总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常, 你也可以申明未检查的异常，但这不是编译器强制的。如果方法抛出了异常那么调用这个方法的时候就需要将这个异常处理。另一个关键字  throw 是用来抛出任意异常的，按照语法你可以抛出任意 Throwable (i.e. Throwable 或任何Throwable的衍生类) , throw可以中断程序运行，因此可以用来代替return . 最常见的例子是用 throw 在一个空方法中需要return的地方抛出 </p>
</blockquote>
<p>​    UnSupportedOperationException 代码如下 :</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>123</th>
<th><code>private``static ````void</code> <code>show() &#123;</code>throw<code>new ``````UnsupportedOperationException(</code>“Notyet implemented”`);``} ```</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>可以看下这篇 <a href="https://link.juejin.cn?target=http%3A%2F%2Fjavarevisited.blogspot.com%2F2012%2F02%2Fdifference-between-throw-and-throws-in.html">文章</a>查看这两个关键字在java中更多的差异 。</p>
<p><strong>7) 什么是“异常链”?</strong></p>
<blockquote>
<p>“异常链”是Java中非常流行的异常处理概念，是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。该技术大多用于将“ 受检查异常” （ checked exception）封装成为“非受检查异常”（unchecked exception)或者RuntimeException。顺便说一下，如果因为因为异常你决定抛出一个新的异常，你一定要包含原有的异常，这样，处理程序才可以通过getCause()和initCause()方法来访问异常最终的根源。</p>
</blockquote>
<p><strong>8) 你曾经自定义实现过异常吗？怎么写的?</strong></p>
<blockquote>
<p>很显然，我们绝大多数都写过自定义或者业务异常，像AccountNotFoundException。在面试过程中询问这个Java异常问题的主要原因是去发现你如何使用这个特性的。这可以更准确和精致的去处理异常，当然这也跟你选择checked 还是unchecked exception息息相关。通过为每一个特定的情况创建一个特定的异常，你就为调用者更好的处理异常提供了更好的选择。相比通用异常（general exception)，我更倾向更为精确的异常。大量的创建自定义异常会增加项目class的个数，因此，在自定义异常和通用异常之间维持一个平衡是成功的关键。</p>
</blockquote>
<p><strong>9) JDK7中对异常处理做了什么改变？</strong></p>
<blockquote>
<p>这是最近新出的Java异常处理的面试题。JDK7中对错误(Error)和异常(Exception)处理主要新增加了2个特性，一是在一个catch块中可以出来多个异常，就像原来用多个catch块一样。另一个是自动化资源管理(ARM), 也称为try-with-resource块。这2个特性都可以在处理异常时减少代码量，同时提高代码的可读性。对于这些特性了解，不仅帮助开发者写出更好的异常处理的代码，也让你在面试中显的更突出。我推荐大家读一下Java 7攻略，这样可以更深入的了解这2个非常有用的特性。</p>
</blockquote>
<p><strong>10) 你遇到过 OutOfMemoryError 错误嘛？你是怎么搞定的？</strong></p>
<blockquote>
<p>这个面试题会在面试高级程序员的时候用，面试官想知道你是怎么处理这个危险的OutOfMemoryError错误的。必须承认的是，不管你做什么项目，你都会碰到这个问题。所以你要是说没遇到过，面试官肯定不会买账。要是你对这个问题不熟悉，甚至就是没碰到过，而你又有3、4年的Java经验了，那么准备好处理这个问题吧。在回答这个问题的同时，你也可以借机向面试秀一下你处理内存泄露、调优和调试方面的牛逼技能。我发现掌握这些技术的人都能给面试官留下深刻的印象。</p>
</blockquote>
<p><strong>11) 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗？</strong></p>
<blockquote>
<p>这个问题也可以换个方式问：“如果在try或者finally的代码块中调用了System.exit()，结果会是怎样”。了解finally块是怎么执行的，即使是try里面已经使用了return返回结果的情况，对了解Java的异常处理都非常有价值。只有在try里面是有System.exit(0)来退出JVM的情况下finally块中的代码才不会执行。</p>
</blockquote>
<p><strong>12)Java中final,finalize,finally关键字的区别</strong></p>
<blockquote>
<p>这是一个经典的Java面试题了。我的一个朋友为Morgan Stanley招电信方面的核心Java开发人员的时候就问过这个问题。final和finally是Java的关键字，而finalize则是方法。final关键字在创建不可变的类的时候非常有用，只是声明这个类是final的。而finalize()方法则是垃圾回收器在回收一个对象前调用，但也Java规范里面没有保证这个方法一定会被调用。finally关键字是唯一一个和这篇文章讨论到的异常处理相关的关键字。在你的产品代码中，在关闭连接和资源文件的是时候都必须要用到finally块。</p>
</blockquote>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="一、集合大纲"><a href="#一、集合大纲" class="headerlink" title="一、集合大纲"></a>一、集合大纲</h3><p><strong>Connection 集合：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/image-20220226212403861.png" alt="image-20220226212403861"></p>
<p><strong>Map集合：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_21-24-25.png" alt=""></p>
<h4 id="1-集合和数组的区别"><a href="#1-集合和数组的区别" class="headerlink" title="1. 集合和数组的区别"></a>1. 集合和数组的区别</h4><p>​    <img src="C:\Users\lemon\Pictures\截图6（CSS）\Snipaste_2022-02-26_21-26-22.png" style="zoom:150%;" /></p>
<ol>
<li><h4 id="Connection集合的方法："><a href="#Connection集合的方法：" class="headerlink" title="Connection集合的方法："></a>Connection集合的方法：</h4></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_21-28-41.png" style="zoom:150%;" /></p>
<ol>
<li><h4 id="常用集合的分类："><a href="#常用集合的分类：" class="headerlink" title="常用集合的分类："></a>常用集合的分类：</h4><p>Collection 接口的接口 对象的集合（单列集合）</p>
<blockquote>
<p>——&gt;&gt;&gt;List 接口：元素按进入先后有序保存，可重复<br>——&gt;&gt;&gt; LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>——&gt;&gt;&gt; ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>——&gt;&gt;&gt;  Vector 接口实现类 数组， 同步， 线程安全<br>——&gt;&gt;&gt;  Stack 是Vector类的实现类<br>——&gt;&gt;&gt; Set 接口： 仅接收一次，不可重复，并做内部排序<br>——&gt;&gt;&gt; └HashSet 使用hash表（数组）存储元素<br>——&gt;&gt;&gt;  LinkedHashSet 链表维护元素的插入次序<br>——&gt;&gt;&gt; TreeSet 底层实现为二叉树，元素排好序</p>
</blockquote>
<p>Map 接口 键值对的集合 （双列集合）</p>
<blockquote>
<p> ——&gt;&gt;&gt; Hashtable 接口实现类， 同步， 线程安全<br> ——&gt;&gt;&gt; HashMap 接口实现类 ，没有同步， 线程不安全-<br> ——&gt;&gt;&gt;  LinkedHashMap 双向链表和哈希表实现<br> ——&gt;&gt;&gt;  WeakHashMap<br> ——&gt;&gt;&gt; TreeMap 红黑树对所有的key进行排序<br> ——&gt;&gt;&gt; IdentifyHashMap</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="二、List和Set集合详解"><a href="#二、List和Set集合详解" class="headerlink" title="二、List和Set集合详解"></a>二、List和Set集合详解</h3><h4 id="1-list-和-set的区别："><a href="#1-list-和-set的区别：" class="headerlink" title="1.list 和 set的区别："></a>1.list 和 set的区别：</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_21-32-35.png" style="zoom:150%;" /></p>
<h4 id="2-List："><a href="#2-List：" class="headerlink" title="2.List："></a>2.List：</h4><blockquote>
<ol>
<li>ArrayList：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素</li>
<li>LinkedList 底层数据结构是链表，查询慢，增删快，线程不安全，效率高，可以存储重复元素</li>
<li>Vector:底层数据结构是数组，查询快，增删慢，线程安全，效率低，可以存储重复元素</li>
</ol>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_21-42-28.png" style="zoom:150%;" /></p>
<h4 id="3-Set："><a href="#3-Set：" class="headerlink" title="3.Set："></a>3.Set：</h4><blockquote>
<ol>
<li>HashSet底层数据结构采用哈希表实现，元素无序且唯一，线程不安全，效率高，可以存储null元素，元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性。<br>具体实现唯一性的比较过程：存储元素首先会使用hash()算法函数生成一个int类型hashCode散列值，然后已经的所存储的元素的hashCode值比较，如果hashCode不相等，则所存储的两个对象一定不相等，此时存储当前的新的hashCode值处的元素对象；如果hashCode相等，存储元素的对象还是不一定相等，此时会调用equals()方法判断两个对象的内容是否相等，如果内容相等，那么就是同一个对象，无需存储；如果比较的内容不相等，那么就是不同的对象，就该存储了，此时就要采用哈希的解决地址冲突算法，在当前hashCode值处类似一个新的链表， 在同一个hashCode值的后面存储存储不同的对象，这样就保证了元素的唯一性。<br>Set的实现类的集合对象中不能够有重复元素，HashSet也一样他是使用了一种标识来确定元素的不重复，HashSet用一种算法来保证HashSet中的元素是不重复的， HashSet采用哈希算法，底层用数组存储数据。默认初始化容量16，加载因子0.75。<br>Object类中的hashCode()的方法是所有子类都会继承这个方法，这个方法会用Hash算法算出一个Hash（哈希）码值返回，HashSet会用Hash码值去和数组长度取模， 模（这个模就是对象要存放在数组中的位置）相同时才会判断数组中的元素和要加入的对象的内容是否相同，如果不同才会添加进去。</li>
</ol>
</blockquote>
<p>Hash算法是一种散列算法。<br>Set hs=new HashSet();</p>
<p>hs.add(o);<br>|<br>o.hashCode();<br>|<br>o%当前总容量 (0–15)<br>|<br>| 不发生冲突<br>是否发生冲突—————–直接存放<br>|<br>| 发生冲突<br>| 假（不相等）<br>o1.equals(o2)——————-找一个空位添加<br>|<br>| 是（相等）</p>
<p><strong>不添加覆盖hashCode()方法的原则：</strong></p>
<blockquote>
<p>1、一定要让那些我们认为相同的对象返回相同的hashCode值</p>
<p>2、尽量让那些我们认为不同的对象返回不同的hashCode值，否则，就会增加冲突的概率。</p>
<p>3、尽量的让hashCode值散列开（两值用异或运算可使结果的范围更广）<br>HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，我们应该为保存到HashSet中的对象覆盖hashCode()和equals()，因为再将对象加入到HashSet中时，会首先调用hashCode方法计算出对象的hash值，接着根据此hash值调用HashMap中的hash方法，得到的值&amp; (length-1)得到该对象在hashMap的transient Entry[] table中的保存位置的索引，接着找到数组中该索引位置保存的对象，并调用equals方法比较这两个对象是否相等，如果相等则不添加，注意：所以要存入HashSet的集合对象中的自定义类必须覆盖hashCode(),equals()两个方法，才能保证集合中元素不重复。在覆盖equals()和hashCode()方法时， 要使相同对象的hashCode()方法返回相同值，覆盖equals()方法再判断其内容。为了保证效率，所以在覆盖hashCode()方法时， 也要尽量使不同对象尽量返回不同的Hash码值。</p>
<p>如果数组中的元素和要加入的对象的hashCode()返回了相同的Hash值（相同对象）,才会用equals()方法来判断两个对象的内容是否相同。</p>
</blockquote>
<ol>
<li><blockquote>
<p>LinkedHashSet底层数据结构采用链表和哈希表共同实现，链表保证了元素的顺序与存储顺序一致，哈希表保证了元素的唯一性。线程不安全，效率高。</p>
</blockquote>
</li>
<li><blockquote>
<p>TreeSet底层数据结构采用二叉树来实现，元素唯一且已经排好序；唯一性同样需要重写hashCode和equals()方法，二叉树结构保证了元素的有序性。根据构造方法不同，分为自然排序（无参构造）和比较器排序（有参构造），自然排序要求元素必须实现Compareable接口，并重写里面的compareTo()方法，元素通过比较返回的int值来判断排序序列，返回0说明两个对象相同，不需要存储；比较器排需要在TreeSet初始化是时候传入一个实现Comparator接口的比较器对象，或者采用匿名内部类的方式new一个Comparator对象，重写里面的compare()方法；</p>
</blockquote>
</li>
<li><blockquote>
<p>小结：Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection,只 是行为不同。(这是继承与多态思想的典型应用：表现不同的行为。)Set不保存重复的元素。<br>Set 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。</p>
</blockquote>
</li>
</ol>
<h4 id="4-List和Set总结："><a href="#4-List和Set总结：" class="headerlink" title="4.List和Set总结："></a>4.List和Set总结：</h4><ol>
<li><blockquote>
<p>List,Set都是继承自Collection接口，Map则不是</p>
</blockquote>
</li>
<li><blockquote>
<p>List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）</p>
</blockquote>
</li>
<li><p>.Set和List对比：</p>
<p>Set：</p>
<blockquote>
<p>检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</p>
</blockquote>
<p>List：</p>
<blockquote>
<p>和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
</blockquote>
</li>
<li><p>ArrayList与LinkedList的区别和适用场景<br>Arraylist：</p>
<blockquote>
<p>优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p>
<p>缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p>
</blockquote>
</li>
</ol>
<p><strong>LinkedList：</strong></p>
<blockquote>
<p>优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>因为LinkedList要移动指针,所以查询操作性能比较低。</p>
</blockquote>
<hr>
<p><strong>适用场景分析</strong>：<br>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p>
<p>ArrayList与Vector的区别和适用场景</p>
<p><strong>ArrayList有三个构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span><span class="comment">//构造一个具有指定初始容量的空列表。    </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span>      <span class="comment">//默认构造一个初始容量为10的空列表。    </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span><span class="comment">//构造一个包含指定 collection 的元素的列表</span></span><br></pre></td></tr></table></figure>
<p><strong>Vector有四个构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span><span class="comment">//使用指定的初始容量和等于0的容量增量构造一个空向量。    </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span><span class="comment">//构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。    </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span><span class="comment">//构造一个包含指定 collection 中的元素的向量    </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity,<span class="type">int</span> capacityIncrement)</span><span class="comment">//使用指定的初始容量和容量增量构造一个空的向量    </span></span><br></pre></td></tr></table></figure>
<p><strong>ArrayList和Vector都是用数组实现的，主要有这么三个区别：</strong></p>
<ol>
<li><blockquote>
<p>Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</p>
</blockquote>
</li>
<li><blockquote>
<p>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</p>
</blockquote>
</li>
<li><blockquote>
<p>Vector可以设置增长因子，而ArrayList不可以。</p>
</blockquote>
</li>
<li><blockquote>
<p>Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>
</blockquote>
</li>
</ol>
<p><strong>适用场景分析：</strong></p>
<ol>
<li><blockquote>
<p>Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</p>
</blockquote>
</li>
<li><blockquote>
<p>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</p>
</blockquote>
</li>
<li><blockquote>
<p>TreeSet 是二差树（红黑树的树据结构）实现的,Treeset中的数据是自动排好序的，不允许放入null值。</p>
</blockquote>
</li>
<li><blockquote>
<p>HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束</p>
</blockquote>
</li>
<li><blockquote>
<p>HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例</p>
</blockquote>
</li>
</ol>
<p><strong>适用场景分析</strong>:</p>
<blockquote>
<p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p>
</blockquote>
<h4 id="5-何时使用？"><a href="#5-何时使用？" class="headerlink" title="5. 何时使用？"></a>5. 何时使用？</h4><p><strong>请看下面这个图具体分析</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-02-29.png" style="zoom:150%;" /></p>
<hr>
<h3 id="三、Map详解"><a href="#三、Map详解" class="headerlink" title="三、Map详解"></a>三、Map详解</h3><blockquote>
<p>Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。</p>
</blockquote>
<h4 id="1-注意事项："><a href="#1-注意事项：" class="headerlink" title="1. 注意事项："></a>1. 注意事项：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map 没有继承 Collection 接口， Map 提供 key 到 value 的映射，你可以通过“键”查找“值”。一个 Map 中不能包含相同的 key ，每个 key 只能映射一个 value 。 Map 接口提供 <span class="number">3</span> 种集合的视图， Map 的内容可以被当作一组 key 集合，一组 value 集合，或者一组 key-value 映射。</span><br></pre></td></tr></table></figure>
<h4 id="2-Map："><a href="#2-Map：" class="headerlink" title="2.Map："></a>2.Map：</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-09-44.png" style="zoom:150%;" /></p>
<h4 id="3-HashMap和HashTable的比较："><a href="#3-HashMap和HashTable的比较：" class="headerlink" title="3. HashMap和HashTable的比较："></a>3. HashMap和HashTable的比较：</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-10-35.png" style="zoom:150%;" /></p>
<h4 id="4-TreeMap："><a href="#4-TreeMap：" class="headerlink" title="4. TreeMap："></a>4. TreeMap：</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-11-16.png" style="zoom:150%;" /></p>
<h4 id="5-Map的其他类："><a href="#5-Map的其他类：" class="headerlink" title="5. Map的其他类："></a>5. Map的其他类：</h4><p><strong>IdentityHashMap和HashMap的具体区别，IdentityHashMap使用 == 判断两个key是否相等，而HashMap使用的是equals方法比较key值。有什么区别呢？</strong></p>
<blockquote>
<p>对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等； 如果作用于引用类型的变量，则比较的是所指向的对象的地址。<br>对于equals方法，注意：equals方法不能作用于基本数据类型的变量<br>如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；<br>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-12-24.png" style="zoom:150%;" /></p>
<h4 id="6-小结："><a href="#6-小结：" class="headerlink" title="6. 小结："></a>6. 小结：</h4><blockquote>
<p>HashMap 非线程安全<br>HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。</p>
<p>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p>
</blockquote>
<pre><code>适用场景分析：
</code></pre><blockquote>
<p>HashMap和HashTable:HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法。HashTable同步的，而HashMap是非同步的，效率上比HashTable要高。HashMap允许空键值，而HashTable不允许。</p>
<p>HashMap：适用于Map中插入、删除和定位元素。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p>
</blockquote>
<h4 id="7-其他小结："><a href="#7-其他小结：" class="headerlink" title="7. 其他小结："></a>7. 其他小结：</h4><p><strong>线程安全集合类与非线程安全集合类</strong></p>
<blockquote>
<p>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;<br>HashMap是非线程安全的，HashTable是线程安全的;<br>StringBuilder是非线程安全的，StringBuffer是线程安全的。</p>
</blockquote>
<p><strong>数据结构</strong></p>
<blockquote>
<p>ArrayXxx:底层数据结构是数组，查询快，增删慢<br>LinkedXxx:底层数据结构是链表，查询慢，增删快<br>HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()<br>TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</p>
</blockquote>
<hr>
<h2 id="JavaIO流"><a href="#JavaIO流" class="headerlink" title="JavaIO流"></a>JavaIO流</h2><h3 id="一、初始IO流"><a href="#一、初始IO流" class="headerlink" title="一、初始IO流"></a>一、初始IO流</h3><blockquote>
<p>IO，即in和out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。</p>
</blockquote>
<p>Java 中是通过流处理IO 的，那么什么是流？</p>
<blockquote>
<p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。</p>
<p>当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
</blockquote>
<p><strong>一般来说关于流的特性有下面几点：</strong></p>
<ol>
<li><blockquote>
<p>先进先出：最先写入输出流的数据最先被输入流读取到。</p>
</blockquote>
</li>
<li><blockquote>
<p>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据。（RandomAccessFile除外）</p>
</blockquote>
</li>
<li><blockquote>
<p>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</p>
</blockquote>
</li>
</ol>
<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><p><strong>IO流主要的分类方式有以下3种：</strong></p>
<ol>
<li><blockquote>
<p>按数据流的方向：输入流、输出流</p>
</blockquote>
</li>
<li><blockquote>
<p>按处理数据单位：字节流、字符流</p>
</blockquote>
</li>
<li><blockquote>
<p>按功能：节点流、处理流</p>
</blockquote>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-31-15.png" style="zoom:150%;" /></p>
<h5 id="1-输入输出流"><a href="#1-输入输出流" class="headerlink" title="1. 输入输出流"></a>1. 输入输出流</h5><blockquote>
<p>输入与输出是相对于程序而言的，比如文件的读写，读取文件就是输入流 ；写文件就是输出流，这点很容易记混！</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-32-19.png" style="zoom:150%;" /></p>
<h5 id="2-字节流与字符流"><a href="#2-字节流与字符流" class="headerlink" title="2. 字节流与字符流"></a>2. 字节流与字符流</h5><blockquote>
<p>字节流和字符流的用法几乎一样，区别于字节流和字符流的所操作的数据单元不一样，字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符</p>
</blockquote>
<p><strong>为什么要有字符流？</strong></p>
<blockquote>
<p>Java中字符是采用Unicode标准，Unicode 编码中，一个英文字母或一个中文汉字为两个字节。</p>
</blockquote>
<p>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-37-36.png"  /></p>
<p>而在UTF-8编码中，一个中文字符是3个字节。例如下面图中，“云深不知处”5个中文对应的是15个字节：-28-70-111-26-73-79-28-72-115-25-97-91-27-92-124</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-38-13.png" alt=""></p>
<p>那么问题来了，如果使用字节流处理中文，如果一次读写一个字符对应的字节数就不会有问题，一旦将一个字符对应的字节分裂开来，就会出现乱码了。为了更方便地处理中文这些字符，Java就推出了<strong>字符流</strong>。</p>
<p><strong>字节流和字符流的其他区别：</strong></p>
<ol>
<li><blockquote>
<p>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</p>
</blockquote>
</li>
<li><blockquote>
<p>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。详见文末效率对比。</p>
</blockquote>
<p>以写文件为例，我们查看字符流的源码，发现确实有利用到缓冲区：</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-40-32.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-41-01.png" alt=""></p>
<h5 id="3、节点流和处理流"><a href="#3、节点流和处理流" class="headerlink" title="3、节点流和处理流"></a>3、节点流和处理流</h5><blockquote>
<p>节点流：直接操作数据读写的流类，比如FileInputStream</p>
<p>处理流（也叫包装流）：对一个已存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能，例如BufferedInputStream（缓冲字节流）</p>
</blockquote>
<p>​    <strong>处理流和节点流应用了Java的装饰者设计模式。</strong></p>
<p>​    下图就很形象地描绘了节点流和处理流，处理流是对节点流的封装，最终的数据处理    还是由节点流完成的。<br>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-44-05.png" style="zoom:150%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在诸多处理流中，有一个非常重要，那就是缓冲流。</span><br></pre></td></tr></table></figure>
<p>我们知道，程序与磁盘的交互相对于内存运算是很慢的，容易成为程序的性能瓶颈。减少程序与磁盘的交互，是提升程序效率一种有效手段。缓冲流，就应用这种思路：普通流每次读写一个字节，而缓冲流在内存中设置一个缓存区，缓冲区先存储足够的待操作数据后，再与内存或磁盘进行交互。这样，在总数据量不变的情况下，通过提高每次交互的数据量，减少了交互次数。<br><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-45-03.png" alt=""></p>
<blockquote>
<p>联想一下生活中的例子，我们搬砖的时候，一块一块地往车上装肯定是很低效的。我们可以使用一个小推车，先把砖装到小推车上，再把这小推车推到车前，把砖装到车上。这个例子中，小推车可以视为缓冲区，小推车的存在，减少了我们装车次数，从而提高了效率。</p>
</blockquote>
<p>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_22-45-56.png" alt=""></p>
<p>需要注意的是，缓冲流效率一定高吗？不一定，某些情形下，缓冲流效率反而更低，具体请见IO流效率对比。</p>
<p>完整的IO分类图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20200922220641678.png" alt="img"></p>
<hr>
<h4 id="案例实操"><a href="#案例实操" class="headerlink" title="案例实操"></a>案例实操</h4><p>接下来，我们看看如何使用Java IO。</p>
<p><strong>文本读写的例子</strong>，也就是文章开头所说的，将“松下问童子，言师采药去。只在此山中，云深不知处。”写入本地文本，然后再从文件读取内容并输出到控制台。</p>
<h5 id="1、FileInputStream、FileOutputStream（字节流）"><a href="#1、FileInputStream、FileOutputStream（字节流）" class="headerlink" title="1、FileInputStream、FileOutputStream（字节流）"></a>1、FileInputStream、FileOutputStream（字节流）</h5><blockquote>
<p><strong>字节流的方式效率较低，不建议使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">		write(file);</span><br><span class="line">		System.out.println(read(file));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要写入的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;</span><br><span class="line">		<span class="comment">// 写入文件</span></span><br><span class="line">		os.write(string.getBytes());</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">read</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 一次性取多少个字节</span></span><br><span class="line">		<span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="comment">// 用来接收读取的字节数组</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">// 读取到的字节数组长度，为-1时表示没有数据</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 循环取数据</span></span><br><span class="line">		<span class="keyword">while</span> ((length = in.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">			sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		in.close();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2、BufferedInputStream、BufferedOutputStream（缓冲字节流）"><a href="#2、BufferedInputStream、BufferedOutputStream（缓冲字节流）" class="headerlink" title="2、BufferedInputStream、BufferedOutputStream（缓冲字节流）"></a>2、BufferedInputStream、BufferedOutputStream（缓冲字节流）</h5><blockquote>
<p>缓冲字节流是为高效率而设计的，真正的读写操作还是靠<code>FileOutputStream</code>和<code>FileInputStream</code>，所以其构造方法入参是这两个类的对象也就不奇怪了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 缓冲字节流，提高了效率</span></span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要写入的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;</span><br><span class="line">		<span class="comment">// 写入文件</span></span><br><span class="line">		bis.write(string.getBytes());</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		bis.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">read</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">BufferedInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 一次性取多少个字节</span></span><br><span class="line">		<span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="comment">// 用来接收读取的字节数组</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">// 读取到的字节数组长度，为-1时表示没有数据</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 循环取数据</span></span><br><span class="line">		<span class="keyword">while</span> ((length = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">			sb.append(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, length));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		fis.close();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3、InputStreamReader、OutputStreamWriter（字符流）"><a href="#3、InputStreamReader、OutputStreamWriter（字符流）" class="headerlink" title="3、InputStreamReader、OutputStreamWriter（字符流）"></a>3、InputStreamReader、OutputStreamWriter（字符流）</h5><blockquote>
<p><strong>字符流适用于文本文件的读写</strong>，<code>OutputStreamWriter</code>类其实也是借助<code>FileOutputStream</code>类实现的，故其构造方法是<code>FileOutputStream</code>的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// OutputStreamWriter可以显示指定字符集，否则使用默认字符集</span></span><br><span class="line">		<span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file, <span class="literal">true</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要写入的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;</span><br><span class="line">		osw.write(string);</span><br><span class="line">		osw.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">read</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		<span class="comment">// 字符数组：一次读取多少个字符</span></span><br><span class="line">		<span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="comment">// 每次读取的字符数组先append到StringBuilder中</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">// 读取到的字符数组长度，为-1时表示没有数据</span></span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="comment">// 循环取数据</span></span><br><span class="line">		<span class="keyword">while</span> ((length = isr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">			sb.append(chars, <span class="number">0</span>, length);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		isr.close();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sb.toString()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、字符流便捷类"><a href="#4、字符流便捷类" class="headerlink" title="4、字符流便捷类"></a>4、字符流便捷类</h5><blockquote>
<p>Java提供了<code>FileWriter</code>和<code>FileReader</code>简化字符流的读写，<code>new FileWriter</code>等同于<code>new OutputStreamWriter(new FileOutputStream(file, true))</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要写入的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;</span><br><span class="line">		fw.write(string);</span><br><span class="line">		fw.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">read</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">		<span class="comment">// 一次性取多少个字节</span></span><br><span class="line">		<span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="comment">// 用来接收读取的字节数组</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="comment">// 读取到的字节数组长度，为-1时表示没有数据</span></span><br><span class="line">		<span class="type">int</span> length;</span><br><span class="line">		<span class="comment">// 循环取数据</span></span><br><span class="line">		<span class="keyword">while</span> ((length = fr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">			sb.append(chars, <span class="number">0</span>, length);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		fr.close();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="5、BufferedReader、BufferedWriter（字符缓冲流）"><a href="#5、BufferedReader、BufferedWriter（字符缓冲流）" class="headerlink" title="5、BufferedReader、BufferedWriter（字符缓冲流）"></a>5、BufferedReader、BufferedWriter（字符缓冲流）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new</span></span><br><span class="line">		<span class="comment">// FileOutputStream(file, true), &quot;UTF-8&quot;));</span></span><br><span class="line">		<span class="comment">// FileWriter可以大幅度简化代码</span></span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 要写入的字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;松下问童子，言师采药去。只在此山中，云深不知处。&quot;</span>;</span><br><span class="line">		bw.write(string);</span><br><span class="line">		bw.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">read</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">		<span class="comment">// 用来接收读取的字节数组</span></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按行读数据</span></span><br><span class="line">		String line;</span><br><span class="line">		<span class="comment">// 循环取数据</span></span><br><span class="line">		<span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">			sb.append(line);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭流</span></span><br><span class="line">		br.close();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二、IO流对象"><a href="#二、IO流对象" class="headerlink" title="二、IO流对象"></a>二、IO流对象</h3><p>第一节中，我们大致了解了IO，并完成了几个案例，但对IO还缺乏更详细的认知，那么接下来我们就对Java IO细细分解，梳理出完整的知识体系来。</p>
<p>Java种提供了40多个类，我们只需要详细了解一下其中比较重要的就可以满足日常应用了。</p>
<h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><p><code>File</code>类是用来操作文件的类，但它不能操作文件中的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Comparable&lt;File&gt;</span><br></pre></td></tr></table></figure>
<p><code>File</code>类实现了<code>Serializable</code>、 <code>Comparable&lt;File&gt;</code>，说明它是支持序列化和排序的。</p>
<p><strong>File类的构造方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">File(File parent, String child)</td>
<td style="text-align:center">根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</td>
</tr>
<tr>
<td style="text-align:center">File(String pathname)</td>
<td style="text-align:center">通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。</td>
</tr>
<tr>
<td style="text-align:center">File(String parent, String child)</td>
<td style="text-align:center">根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</td>
</tr>
<tr>
<td style="text-align:center">File(URI uri)</td>
<td style="text-align:center">通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>File类的常用方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>方法</strong></th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">createNewFile()</td>
<td style="text-align:center">当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</td>
</tr>
<tr>
<td style="text-align:center">delete()</td>
<td style="text-align:center">删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td style="text-align:center">exists()</td>
<td style="text-align:center">测试此抽象路径名表示的文件或目录是否存在。</td>
</tr>
<tr>
<td style="text-align:center">getAbsoluteFile()</td>
<td style="text-align:center">返回此抽象路径名的绝对路径名形式。</td>
</tr>
<tr>
<td style="text-align:center">getAbsolutePath()</td>
<td style="text-align:center">返回此抽象路径名的绝对路径名字符串。</td>
</tr>
<tr>
<td style="text-align:center">length()</td>
<td style="text-align:center">返回由此抽象路径名表示的文件的长度。</td>
</tr>
<tr>
<td style="text-align:center">mkdir()</td>
<td style="text-align:center">创建此抽象路径名指定的目录。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>File类使用实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/fileTest.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断文件是否存在</span></span><br><span class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">			<span class="comment">// 不存在则创建</span></span><br><span class="line">			file.createNewFile();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;文件的绝对路径：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">		System.out.println(<span class="string">&quot;文件的大小：&quot;</span> + file.length());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 刪除文件</span></span><br><span class="line">		file.delete();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><code>InputStream</code>与<code>OutputStream</code>是两个抽象类，是字节流的基类，所有具体的字节流实现类都是分别继承了这两个类。</p>
<p>以<code>InputStream</code>为例，它继承了<code>Object</code>，实现了<code>Closeable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Closeable</span></span><br></pre></td></tr></table></figure>
<p><code>InputStream</code>类有很多的实现子类，下面列举了一些比较常用的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_23-03-04.png" alt=""></p>
<p><strong>详细说明一下上图中的类：</strong></p>
<ol>
<li><blockquote>
<p>InputStream：InputStream是所有字节输入流的抽象基类，前面说过抽象类不能被实例化，实际上是作为模板而存在的，为所有实现类定义了处理输入流的方法。</p>
</blockquote>
</li>
<li><blockquote>
<p>FileInputSream：文件输入流，一个非常重要的字节输入流，用于对文件进行读取操作。</p>
</blockquote>
</li>
<li><blockquote>
<p>PipedInputStream：管道字节输入流，能实现多线程间的管道通信</p>
</blockquote>
</li>
<li><blockquote>
<p>ByteArrayInputStream：字节数组输入流，从字节数组(byte[])中进行以字节为单位的读取，也就是将资源文件都以字节的形式存入到该类中的字节数组中去。</p>
</blockquote>
</li>
<li><blockquote>
<p>FilterInputStream：装饰者类，具体的装饰者继承该类，这些类都是处理类，作用是对节点类进行封装，实现一些特殊功能。</p>
</blockquote>
</li>
<li><blockquote>
<p>DataInputStream：数据输入流，它是用来装饰其它输入流，作用是“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。</p>
</blockquote>
</li>
<li><blockquote>
<p>BufferedInputStream：缓冲流，对节点流进行装饰，内部会有一个缓存区，用来存放字节，每次都是将缓存区存满然后发送，而不是一个字节或两个字节这样发送，效率更高。</p>
</blockquote>
</li>
<li><blockquote>
<p>ObjectInputStream：对象输入流，用来提供对基本数据或对象的持久存储。通俗点说，也就是能直接传输对象，通常应用在反序列化中。它也是一种处理流，构造器的入参是一个InputStream的实例对象。</p>
</blockquote>
<p>OutputStream类继承关系图：<br><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_23-05-39.png" style="zoom:150%;" /></p>
</li>
</ol>
<p><code>OutputStream</code>类继承关系与<code>InputStream</code>类似，需要注意的是<code>PrintStream</code>.</p>
<h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>与字节流类似，字符流也有两个抽象基类，分别是<code>Reader</code>和<code>Writer</code>。其他的字符流实现类都是继承了这两个类。</p>
<p>以<code>Reader</code>为例，它的主要实现子类如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-26_23-06-30.png" alt=""></p>
<p>各个类的详细说明：</p>
<ol>
<li><blockquote>
<p>InputStreamReader：从字节流到字符流的桥梁（InputStreamReader构造器入参是FileInputStream的实例对象），它读取字节并使用指定的字符集将其解码为字符。它使用的字符集可以通过名称指定，也可以显式给定，或者可以接受平台的默认字符集。</p>
</blockquote>
</li>
<li><blockquote>
<p>BufferedReader：从字符输入流中读取文本，设置一个缓冲区来提高效率。BufferedReader是对InputStreamReader的封装，前者构造器的入参就是后者的一个实例对象。</p>
</blockquote>
</li>
<li><blockquote>
<p>FileReader：用于读取字符文件的便利类，new FileReader(File file)等同于new InputStreamReader(new FileInputStream(file, true),”UTF-8”)，但FileReader不能指定字符编码和默认字节缓冲区大小。</p>
</blockquote>
</li>
<li><blockquote>
<p>PipedReader ：管道字符输入流。实现多线程间的管道通信。</p>
</blockquote>
</li>
<li><blockquote>
<p>CharArrayReader：从Char数组中读取数据的介质流。</p>
</blockquote>
</li>
<li><blockquote>
<p>StringReader ：从String中读取数据的介质流。</p>
<p>Writer与Reader结构类似，方向相反，不再赘述。唯一有区别的是，Writer的子类PrintWriter。</p>
</blockquote>
</li>
</ol>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>待续</p>
<hr>
<h3 id="IO流方法"><a href="#IO流方法" class="headerlink" title="IO流方法"></a>IO流方法</h3><h4 id="字节流方法"><a href="#字节流方法" class="headerlink" title="字节流方法"></a>字节流方法</h4><p><strong>字节输入流InputStream主要方法：</strong></p>
<ol>
<li><blockquote>
<p>read() ：从此输入流中读取一个数据字节。</p>
</blockquote>
</li>
<li><blockquote>
<p>read(byte[] b) ：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。</p>
</blockquote>
</li>
<li><blockquote>
<p>read(byte[] b, int off, int len) ：从此输入流中将最多 len 个字节的数据读入一个 byte 数组中。</p>
</blockquote>
</li>
<li><blockquote>
<p>close()：关闭此输入流并释放与该流关联的所有系统资源。</p>
</blockquote>
</li>
</ol>
<p><strong>字节输出流OutputStream主要方法：</strong></p>
<ol>
<li><blockquote>
<p>write(byte[] b) ：将 b.length 个字节从指定 byte 数组写入此文件输出流中。</p>
</blockquote>
</li>
<li><blockquote>
<p>write(byte[] b, int off, int len) ：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</p>
</blockquote>
</li>
<li><blockquote>
<p>write(int b) ：将指定字节写入此文件输出流。</p>
</blockquote>
</li>
<li><blockquote>
<p>close() ：关闭此输入流并释放与该流关联的所有系统资源。</p>
</blockquote>
</li>
</ol>
<h4 id="字符流方法"><a href="#字符流方法" class="headerlink" title="字符流方法"></a>字符流方法</h4><p><strong>字符输入流Reader主要方法：</strong></p>
<ol>
<li><blockquote>
<p>read()：读取单个字符。</p>
</blockquote>
</li>
<li><blockquote>
<p>read(char[] cbuf) ：将字符读入数组。</p>
</blockquote>
</li>
<li><blockquote>
<p>read(char[] cbuf, int off, int len) ： 将字符读入数组的某一部分。</p>
</blockquote>
</li>
<li><blockquote>
<p>read(CharBuffer target) ：试图将字符读入指定的字符缓冲区。</p>
</blockquote>
</li>
<li><blockquote>
<p>flush() ：刷新该流的缓冲。</p>
</blockquote>
</li>
<li><blockquote>
<p>close() ：关闭此流，但要先刷新它。</p>
</blockquote>
</li>
</ol>
<p><strong>字符输出流Writer主要方法：</strong></p>
<ol>
<li><blockquote>
<p>write(char[] cbuf) ：写入字符数组。</p>
</blockquote>
</li>
<li><blockquote>
<p>write(char[] cbuf, int off, int len) ：写入字符数组的某一部分。</p>
</blockquote>
</li>
<li><blockquote>
<p>write(int c) ：写入单个字符。</p>
</blockquote>
</li>
<li><blockquote>
<p>write(String str) ：写入字符串。</p>
</blockquote>
</li>
<li><blockquote>
<p>write(String str, int off, int len) ：写入字符串的某一部分。</p>
</blockquote>
</li>
<li><blockquote>
<p>flush() ：刷新该流的缓冲。</p>
</blockquote>
</li>
<li><blockquote>
<p>close() ：关闭此流，但要先刷新它。</p>
</blockquote>
</li>
</ol>
<p><strong>另外，字符缓冲流还有两个独特的方法：</strong></p>
<ul>
<li><code>BufferedWriter</code>类<code>newLine()</code> ：<strong>写入一个行分隔符。这个方法会自动适配所在系统的行分隔符。</strong></li>
<li><code>BufferedReader</code>类<code>readLine()</code> ：读取一个文本行。</li>
</ul>
<hr>
<h3 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h3><h4 id="位、字节、字符"><a href="#位、字节、字符" class="headerlink" title="位、字节、字符"></a>位、字节、字符</h4><blockquote>
<p>字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。</p>
<p>字符(Character)计算机中使用的字母、数字、字和符号，比如’A’、‘B’、’$’、’&amp;’等。</p>
<p>一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。</p>
</blockquote>
<p><strong>字节与字符：</strong></p>
<ul>
<li><p>ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。</p>
</li>
<li><p>UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。</p>
</li>
<li><p>Unicode 编码中，一个英文为一个字节，一个中文为两个字节。</p>
</li>
<li><p>符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。</p>
</li>
<li><p>UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。</p>
</li>
<li><p>UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。</p>
<h4 id="IO流效率相比"><a href="#IO流效率相比" class="headerlink" title="IO流效率相比"></a>IO流效率相比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/test.txt&quot;</span>);</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">			sb.append(<span class="string">&quot;abcdefghigklmnopqrstuvwsyz&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">byte</span>[] bytes = sb.toString().getBytes();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		write(file, bytes);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		bufferedWrite(file, bytes);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;普通字节流耗时：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;缓冲字节流耗时：&quot;</span> + (end2 - start2) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通字节流</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(File file, <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">		os.write(bytes);</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲字节流</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bufferedWrite</span><span class="params">(File file, <span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">		bo.write(bytes);</span><br><span class="line">		bo.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通字节流耗时：<span class="number">250</span> ms</span><br><span class="line">缓冲字节流耗时：<span class="number">268</span> ms</span><br></pre></td></tr></table></figure>
<p>这个结果让我大跌眼镜，不是说好缓冲流效率很高么？要知道为什么，只能去源码里找答案了。翻看字节缓冲流的<code>write</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= buf.length) &#123;</span><br><span class="line">        <span class="comment">/* If the request length exceeds the size of the output buffer,</span></span><br><span class="line"><span class="comment">           flush the output buffer and then write the data directly.</span></span><br><span class="line"><span class="comment">           In this way buffered streams will cascade harmlessly. */</span></span><br><span class="line">        flushBuffer();</span><br><span class="line">        out.write(b, off, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; buf.length - count) &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(b, off, buf, count, len);</span><br><span class="line">    count += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注释里说得很明白：如果请求长度超过输出缓冲区的大小，刷新输出缓冲区，然后直接写入数据。这样，缓冲流将无害地级联。</p>
</blockquote>
<p>但是，至于为什么这么设计，我没有想明白，有哪位明白的大佬可以留言指点一下。</p>
<blockquote>
<p>基于上面的情形，要想对比普通字节流和缓冲字节流的效率差距，就要避免直接读写较长的字符串，于是，设计了下面这个对比案例：用字节流和缓冲字节流分别复制文件。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/data.zip&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/a.zip&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/b.zip&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		copy(data, a);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		bufferedCopy(data, b);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;普通字节流耗时：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;缓冲字节流耗时：&quot;</span> + (end2 - start2) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通字节流</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File in, File out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 封装数据源</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(in);</span><br><span class="line">		<span class="comment">// 封装目的地</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(out);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">by</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((by = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			os.write(by);</span><br><span class="line">		&#125;</span><br><span class="line">		is.close();</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲字节流</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bufferedCopy</span><span class="params">(File in, File out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 封装数据源</span></span><br><span class="line">		<span class="type">BufferedInputStream</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(in));</span><br><span class="line">		<span class="comment">// 封装目的地</span></span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(out));</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">by</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((by = bi.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			bo.write(by);</span><br><span class="line">		&#125;</span><br><span class="line">		bo.close();</span><br><span class="line">		bi.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通字节流耗时：<span class="number">184867</span> ms</span><br><span class="line">缓冲字节流耗时：<span class="number">752</span> ms</span><br></pre></td></tr></table></figure>
<p>这次，普通字节流和缓冲字节流的效率差异就很明显了，达到了245倍。</p>
<p>再看看字符流和缓冲字符流的效率对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 数据准备</span></span><br><span class="line">		dataReady();</span><br><span class="line"></span><br><span class="line">		<span class="type">File</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/data.txt&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/a.txt&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/b.txt&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/c.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		copy(data, a);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		copyChars(data, b);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">start3</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		bufferedCopy(data, c);</span><br><span class="line">		<span class="type">long</span> <span class="variable">end3</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;普通字节流1耗时：&quot;</span> + (end - start) + <span class="string">&quot; ms,文件大小：&quot;</span> + a.length() / <span class="number">1024</span> + <span class="string">&quot; kb&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;普通字节流2耗时：&quot;</span> + (end2 - start2) + <span class="string">&quot; ms,文件大小：&quot;</span> + b.length() / <span class="number">1024</span> + <span class="string">&quot; kb&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;缓冲字节流耗时：&quot;</span> + (end3 - start3) + <span class="string">&quot; ms,文件大小：&quot;</span> + c.length() / <span class="number">1024</span> + <span class="string">&quot; kb&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通字符流不使用数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(File in, File out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(in);</span><br><span class="line">		<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(out);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((ch = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			writer.write((<span class="type">char</span>) ch);</span><br><span class="line">		&#125;</span><br><span class="line">		reader.close();</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通字符流使用字符流</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyChars</span><span class="params">(File in, File out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(in);</span><br><span class="line">		<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(out);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span> ((reader.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			writer.write(chs);</span><br><span class="line">		&#125;</span><br><span class="line">		reader.close();</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲字符流</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bufferedCopy</span><span class="params">(File in, File out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(in));</span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(out));</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		bw.close();</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据准备</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dataReady</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">600000</span>; i++) &#123;</span><br><span class="line">			sb.append(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/Mu/data.txt&quot;</span>));</span><br><span class="line">		os.write(sb.toString().getBytes());</span><br><span class="line"></span><br><span class="line">		os.close();</span><br><span class="line">		System.out.println(<span class="string">&quot;完毕&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">普通字符流<span class="number">1</span>耗时：<span class="number">1337</span> ms,文件大小：<span class="number">15234</span> kb</span><br><span class="line">普通字符流<span class="number">2</span>耗时：<span class="number">82</span> ms,文件大小：<span class="number">15235</span> kb</span><br><span class="line">缓冲字符流耗时：<span class="number">205</span> ms,文件大小：<span class="number">15234</span> kb</span><br></pre></td></tr></table></figure>
<p>测试多次，结果差不多，可见字符缓冲流效率上并没有明显提高，我们更多的是要使用它的<code>readLine()</code>和<code>newLine()</code>方法。</p>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="什么是进程，线程？"><a href="#什么是进程，线程？" class="headerlink" title="什么是进程，线程？"></a>什么是进程，线程？</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-27_22-21-34.png" alt=""></p>
<p>进程：</p>
<blockquote>
<p>资源分配最小的单位，cpu从磁盘中读取一段程序到内存中，该执行程序的实例就叫做进程。一个程序如果被cpu多次读取到内存中，则变成多个独立的进程。</p>
</blockquote>
<p><strong>线程</strong> : </p>
<blockquote>
<p>线程是程序执行的最小单位，在一个进程中可以有多个不同的线程。</p>
</blockquote>
<h4 id="线程的应用实例："><a href="#线程的应用实例：" class="headerlink" title="线程的应用实例："></a><strong>线程的应用实例：</strong></h4><p><em>同一个应用程序中(进程)，更好的并行处理。</em></p>
<p>例子：手写一个文本编辑器需要多少个线程？</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-27_22-24-15.png" style="zoom:150%;" /></p>
<h4 id="为什么需要使用多线程？"><a href="#为什么需要使用多线程？" class="headerlink" title="为什么需要使用多线程？"></a>为什么需要使用多线程？</h4><p><strong>采用多线程的形式执行代码，目的是为了提高程序开发的效率。</strong></p>
<p>​    串行、并行的区别</p>
<blockquote>
<p>CPU分时间片交替执行，宏观并行，微观串行，由OS负责调度。如今的CPU已经发展到了多核CPU，真正存在并行。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-27_22-25-09.png" alt=""></p>
<h4 id="CPU调度算法"><a href="#CPU调度算法" class="headerlink" title="CPU调度算法"></a>CPU调度算法</h4><blockquote>
<p>多线程是不是一定提高效率？ 不一定，需要了解cpu调度的算法。</p>
</blockquote>
<p>CPU调度算法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-27_22-26-12.png" alt=""></p>
<p><strong>如果在生产环境中，开启很多线程，但是我们的服务器核数很低，我们这么多线程会在cpu上做上下文切换，反而会降低效率。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用线程池来限制线程数和cpu数相同会比较好。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="一、Java多线程基础"><a href="#一、Java多线程基础" class="headerlink" title="一、Java多线程基础"></a>一、Java多线程基础</h3><h4 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h4><ol>
<li>继承<code>Thread</code>类创建线程</li>
<li>实现<code>Runnable</code>接口创建线程</li>
<li>使用匿名内部类形式创建线程</li>
<li>使用<code>Lambda</code>表达式创建</li>
<li>使用<code>Callable</code>和 <code>Future</code>创建线程</li>
<li>使用线程池创建</li>
<li>Spring中的<code>@Async</code>创建</li>
</ol>
<p><strong>下面我们一一举例：</strong></p>
<h5 id="1-继承Thread类创建线程"><a href="#1-继承Thread类创建线程" class="headerlink" title="1.继承Thread类创建线程"></a>1.继承<code>Thread</code>类创建线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程,线程一&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 创建对象进入初始状态，调用start()进入就绪状态。直接调用run()方法，相当于在main中执行run。并不是新线程*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里调用start方法启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-实现Runnable接口创建线程"><a href="#2-实现Runnable接口创建线程" class="headerlink" title="2.实现Runnable接口创建线程"></a>2.实现<code>Runnable</code>接口创建线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//           创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread01</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        开启线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  这里实现父接口Runnable的run方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        获取当前线程的名字</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;我是一个分支线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="3-使用匿名内部类形式创建线程"><a href="#3-使用匿名内部类形式创建线程" class="headerlink" title="3.使用匿名内部类形式创建线程"></a>3.使用匿名内部类形式创建线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        这里使用匿名对象去实现Rnnable接口</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;我是一个分支接口&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-使用Lambda表达式创建"><a href="#4-使用Lambda表达式创建" class="headerlink" title="4.使用Lambda表达式创建"></a>4.使用<code>Lambda</code>表达式创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread02</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot;我是子线程&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-使用Callable和-Future创建线程"><a href="#5-使用Callable和-Future创建线程" class="headerlink" title="5.使用Callable和 Future创建线程"></a>5.使用<code>Callable</code>和 <code>Future</code>创建线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable的缺点：</span><br><span class="line"><span class="number">1.</span>  run没有返回值</span><br><span class="line"><span class="number">2.</span>  不能抛异常</span><br><span class="line">    </span><br><span class="line">Callable接口允许线程有返回值，也允许线程抛出异常</span><br><span class="line">Future接口用来接受返回值</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread03</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前线程需要执行的代码，返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;返回1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread03</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread03</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; integerFutureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(callable);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(integerFutureTask).start();</span><br><span class="line">    <span class="comment">//通过api获取返回结果，主线程需要等待子线程返回结果</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> integerFutureTask.get();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,&quot;</span>+result); <span class="comment">// main,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-使用线程池创建"><a href="#6-使用线程池创建" class="headerlink" title="6.使用线程池创建"></a>6.使用线程池创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">     executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName()+<span class="string">&quot;我是子线程1&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     executorService.submit(<span class="keyword">new</span> <span class="title class_">Thread03</span>()); <span class="comment">//submit一个线程到线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-Spring中的-Async创建"><a href="#7-Spring中的-Async创建" class="headerlink" title="7.Spring中的@Async创建"></a>7.Spring中的<code>@Async</code>创建</h5><p>第一步：在入口类中开启异步注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br></pre></td></tr></table></figure>
<p>第二步：在当前方法上加上@Async</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncLog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            log.info(<span class="string">&quot;&lt;2&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步：验证测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Thread01 thread01;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&lt;1&gt;&quot;</span>);</span><br><span class="line">        thread01.asyncLog();</span><br><span class="line">        log.info(<span class="string">&quot;&lt;3&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问<code>localhost:8080/test</code>查看日志为：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-27_22-55-49.png" style="zoom:150%;" /></p>
<hr>
<h4 id="Thread中的常用的方法"><a href="#Thread中的常用的方法" class="headerlink" title="Thread中的常用的方法"></a><code>Thread</code>中的常用的方法</h4><h5 id="1-Thread-currentThread-方法可以获得当前线程"><a href="#1-Thread-currentThread-方法可以获得当前线程" class="headerlink" title="1.Thread.currentThread() 方法可以获得当前线程"></a>1.<code>Thread.currentThread() 方法可以获得当前线程</code></h5><p>java中的任何一段代码都是执行在某个线程当中的，执行当前代码的线程就是当前线程。</p>
<h5 id="2-setName-getName"><a href="#2-setName-getName" class="headerlink" title="2.setName()/getName"></a>2.<code>setName()/getName</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.setName(线程名称) <span class="comment">//设置线程名称</span></span><br><span class="line">thread.getName() <span class="comment">//返回线程名称</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过设置线程名称，有助于调试程序，提高程序的可读性，建议为每一个线程设置一个能够体现该线程功能的名称。</p>
</blockquote>
<h5 id="3-isAlive"><a href="#3-isAlive" class="headerlink" title="3.isAlive()"></a>3.<code>isAlive()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.isAlive() <span class="comment">//判断当前线程是否处于活动状态</span></span><br></pre></td></tr></table></figure>
<h5 id="4-sleep"><a href="#4-sleep" class="headerlink" title="4.sleep()"></a>4.<code>sleep()</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(millis); <span class="comment">//让当前线程休眠指定的毫秒数</span></span><br></pre></td></tr></table></figure>
<p><strong>实例：计时器(一分钟倒计时)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/2/28 13:21</span></span><br><span class="line"><span class="comment"> *  关于线程的sleep方法：</span></span><br><span class="line"><span class="comment"> *  static void Sleep(long millis)</span></span><br><span class="line"><span class="comment"> *  1. 静态方法 ： Thread.sleep(1000 * 5);</span></span><br><span class="line"><span class="comment"> *  2. 参数是毫秒</span></span><br><span class="line"><span class="comment"> *  3. 作用 ：让当前线程进入休眠，进入阻塞状态，放弃占有CPU时间片，让其他线程去使用。</span></span><br><span class="line"><span class="comment"> *          如果这行代码出现在A线程中 A线程就会进入休眠状态</span></span><br><span class="line"><span class="comment"> *          如果这行代码出现在B线程中 B线程就会进入休眠状态</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//让当前线程进入休眠状态 睡眠5秒</span></span><br><span class="line"><span class="comment">//        当前线程是主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         try &#123;</span></span><br><span class="line"><span class="comment">         *             Thread.sleep(1000 * 5);</span></span><br><span class="line"><span class="comment">         *         &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">         *             e.printStackTrace();</span></span><br><span class="line"><span class="comment">         *         &#125;</span></span><br><span class="line"><span class="comment">         *         System.out.println(&quot;hell0,world&quot;);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot; ----&gt;&gt;&quot;</span> + i );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep( <span class="number">1000</span> * <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-getId-java中的线程都有一个唯一编号"><a href="#5-getId-java中的线程都有一个唯一编号" class="headerlink" title="5.getId() java中的线程都有一个唯一编号"></a>5.<code>getId()</code> java中的线程都有一个唯一编号</h5><h5 id="6-yield-放弃当前的cpu资源"><a href="#6-yield-放弃当前的cpu资源" class="headerlink" title="6.yield() 放弃当前的cpu资源"></a>6.<code>yield()</code> 放弃当前的cpu资源</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.yield();  <span class="comment">//可以让线程由运行转为就绪状态</span></span><br></pre></td></tr></table></figure>
<h5 id="7-setPriority-设置线程的优先级"><a href="#7-setPriority-设置线程的优先级" class="headerlink" title="7.setPriority() 设置线程的优先级"></a>7.<code>setPriority()</code> 设置线程的优先级</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(num); 设置线程的优先级，取值为<span class="number">1</span>-<span class="number">10</span>，如果超过范围会抛出异常  IllegalArugumentExption;</span><br><span class="line"></span><br><span class="line">优先级越高的线程，获得cpu资源的概率越大。（抢夺的CPU时间片就越多即概率越大）</span><br><span class="line">优先级本质上只是给线程调度器一个提示信息，以便于线程调度器决定先调度哪些线程。不能保证优先级高的线程先运行。</span><br><span class="line">java优先级设置不当，可能导致某些线程永远无法得到运行，产生了线程饥饿。</span><br><span class="line">线程的优先级并不是设置的越高越好，在开发时不必设置线程的优先级。</span><br></pre></td></tr></table></figure>
<h5 id="8-interrupt-中断线程-Thread中的方法。"><a href="#8-interrupt-中断线程-Thread中的方法。" class="headerlink" title="8.interrupt()中断线程 (Thread中的方法。)"></a>8.<code>interrupt()</code>中断线程 (Thread中的方法。)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为interrupt()方法只能中断阻塞过程中的线程而不能中断正在运行过程中的线程。</span><br><span class="line"></span><br><span class="line">在运行中的线程使用：</span><br><span class="line">注意调用此方法仅仅是在当前线程打一个停止标志，并不是真正的停止线程。</span><br><span class="line">例如在线程<span class="number">1</span>中调用线程b的interrupt(),在b线程中监听b线程的中断标志，来处理结束。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.high.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaoziman</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YieldTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断中断标志</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted())&#123;</span><br><span class="line">                <span class="comment">//如果为true，结束线程</span></span><br><span class="line">                <span class="comment">//break;</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread 1 ---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.high.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaoziman</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">YieldTest</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YieldTest</span>();</span><br><span class="line">        t1.start(); <span class="comment">//开启子线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前线程main线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main ---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印完main线程中100个后，中断子线程,仅仅是个标记，必须在线程中处理</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="9-setDaemon-守护线程"><a href="#9-setDaemon-守护线程" class="headerlink" title="9.setDaemon() 守护线程"></a>9.<code>setDaemon()</code> 守护线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程启动前</span></span><br><span class="line">thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>Java中的线程分为用户线程与守护线程</p>
<blockquote>
<p>守护线程是为其他线程提供服务的线程，如垃圾回收(GC)就是一个典型的守护线程。</p>
<p>守护线程不能单独运行，当jvm中没有其他用户线程，只有守护线程时，守护线程会自动销毁，jvm会自动退出。</p>
</blockquote>
<hr>
<h4 id="线程的状态（线程的生命周期）"><a href="#线程的状态（线程的生命周期）" class="headerlink" title="线程的状态（线程的生命周期）"></a>线程的状态（线程的生命周期）</h4><p><strong>线程的状态： </strong>  getState()</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-27_17-56-17.png" style="zoom:150%;" /></p>
<hr>
<h3 id="二、线程安全原理篇"><a href="#二、线程安全原理篇" class="headerlink" title="二、线程安全原理篇"></a>二、线程安全原理篇</h3><h4 id="多线程的好处："><a href="#多线程的好处：" class="headerlink" title="多线程的好处："></a><strong>多线程的好处：</strong></h4><ol>
<li>提高了系统的<code>吞吐量</code>，多线程编程可以使一个进程有<code>多个并发(concurrent)。</code></li>
<li>提高<code>响应性</code>，服务器会采用一些专门的线程负责用户的请求处理，缩短了用户的等待时间。</li>
<li><code>充分利用多核处理器资源</code>，通过多线程可以充分的利用CPU资源。</li>
</ol>
<h4 id="多线程的问题："><a href="#多线程的问题：" class="headerlink" title="多线程的问题："></a>多线程的问题：</h4><blockquote>
<p>线程安全问题，多线程共享数据时，如果没有采取正确的并发访问控制措施，就可能产生数据一致性问题，如读取脏数据（过期的数据），如丢失数据更新。</p>
<p>线程活性(thread liveness)问题。由于程序自身的缺陷或者由资源稀缺性导致的线程一直处于非RUNNABLE状态，这就是线程活性问题。</p>
</blockquote>
<h5 id="常见的线程活性问题："><a href="#常见的线程活性问题：" class="headerlink" title="常见的线程活性问题："></a><strong>常见的线程活性问题：</strong></h5><blockquote>
<p>1.死锁 （DeadLock） 鹬蚌相争<br>2.锁死 （Lockout） 睡美人故事中王子挂啦<br>3.活锁 （LiveLock） 类似小猫一直咬自己的尾巴，但是咬不到<br>4.饥饿 （Starvation）类似于健壮的雏鸟总是从母鸟嘴中抢食物。</p>
</blockquote>
<p>​    上下文切换(Context Switch)处理器从执行一个线程切换到执行另外一个线程。</p>
<p>​    可靠性可能会由一个线程导致JVM意外终止，其他线程也无法执行。线程安全问题</p>
<h5 id="什么是线程安全问题？"><a href="#什么是线程安全问题？" class="headerlink" title="什么是线程安全问题？"></a><strong>什么是线程安全问题？</strong></h5><blockquote>
<p>当多个线程对同一个对象的实例变量，做写(修改)的操作时，可能会受到其他线程的干扰，发生线程安全的问题。</p>
</blockquote>
<h5 id="原子性-Atomic-："><a href="#原子性-Atomic-：" class="headerlink" title="原子性(Atomic)："></a><strong>原子性(Atomic)：</strong></h5><p><code>不可分割</code>，访问(读，写)某个共享变量的时候，从其他线程来看，该操作要么已经执行完毕，要么尚未发生。其他线程看不到当前操作的中间结果。 访问同一组<code>共享变量</code>的原子操作是不能够交错的，如现实生活中从ATM取款。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java中有两种方式实现原子性：</span><br><span class="line">    <span class="number">1.</span>锁 ：锁具有排他性，可以保证共享变量某一时刻只能被一个线程访问。</span><br><span class="line">    <span class="number">2.</span>CAS指令 ：直接在硬件层次上实现，看做是一个硬件锁。</span><br></pre></td></tr></table></figure>
<h5 id="可见性-visbility-："><a href="#可见性-visbility-：" class="headerlink" title="可见性(visbility)："></a><strong>可见性(visbility)：</strong></h5><blockquote>
<p>在多线程环境中，一个线程对某个共享变量更新之后，后续其他的线程可能无法立即读到这个更新的结果。</p>
<p>如果一个线程对共享变量更新之后，后续访问该变量的其他线程可以读到更新的结果，称这个线程对共享变量的更新对其他线程可见。否则称这个线程对共享变量的更新对其他线程不可见。</p>
</blockquote>
<p>​    多线程程序因为可见性问题可能会导致其他线程读取到旧数据(脏数据)。</p>
<h5 id="有序性-Ordering-："><a href="#有序性-Ordering-：" class="headerlink" title="有序性(Ordering)："></a><strong>有序性(Ordering)：</strong></h5><p>是指在什么情况下一个处理器上运行的一个线程所执行的 <code>内存访问操作</code>在另外一个处理器运行的其他线程来看是<code>乱序</code>的(Out of Order)</p>
<blockquote>
<p><em>乱序: 是指内存访问操作的顺序看起来发生了变化。</em></p>
</blockquote>
<h4 id="JVM与JMM"><a href="#JVM与JMM" class="headerlink" title="JVM与JMM"></a>JVM与JMM</h4><h4 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h4><p>先谈一下运行时数据区，下面这张图相信大家一点都不陌生：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-28_10-24-06.png" alt=""></p>
<p> <strong>对于每一个线程来说，栈都是私有的，而堆是共有的。</strong></p>
<blockquote>
<p>也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。</p>
</blockquote>
<p>所以，内存可见性是针对的<strong>共享变量</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-28_10-25-51.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-28_10-26-22.png" style="zoom:150%;" /></p>
<h4 id="出现线程不安全的例子"><a href="#出现线程不安全的例子" class="headerlink" title="出现线程不安全的例子"></a>出现线程不安全的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&gt;&quot;</span>+count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadCount</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadCount</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(threadCount).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(threadCount).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-28_10-28-17.png" alt=""></p>
<p><strong>如何解决线程安全的问题？</strong></p>
<p>核心思想：上锁</p>
<blockquote>
<p>在同一个JVM中，多个线程需要竞争锁的资源，最终只能够有一个线程能够获取到锁，多个线程同时抢一把锁，哪个线程能够获得到锁，谁就可以执行该代码，如果没有获取锁成功，中间需要经历锁的升级过程，如果一直没有获取到锁则会一直阻塞等待。</p>
</blockquote>
<p>例如上述情况下如何上锁呢？？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCount</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">/*线程0 线程1 同时获取this锁，假设线程0 获取到this锁，意味着线程1没有获取到锁则会等待。等线程0执行完count-- 释放锁资源后，就会唤醒线程1 从新进入到获取锁的资源。 获取锁与释放锁全部由虚拟机实现*/</span></span><br><span class="line">               </span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&quot;</span>+count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadCount</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadCount</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(threadCount).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(threadCount).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="三、线程同步"><a href="#三、线程同步" class="headerlink" title="三、线程同步"></a>三、线程同步</h3><blockquote>
<p>线程同步可以理解为线程之间按照一定的顺序执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们的线程之间，有一个同步的概念。什么是同步呢，假如我们现在有<span class="number">2</span>位正在抄暑假作业答案的同学：线程A和线程B。当他们正在抄的时候，老师突然来修改了一些答案，可能A和B最后写出的暑假作业就不一样。我们为了A,B能写出<span class="number">2</span>本相同的暑假作业，我们就需要让老师先修改答案，然后A，B同学再抄。或者A，B同学先抄完，老师再修改答案。这就是线程A，线程B的线程同步。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程安全的产生就是因为多线程之间没有同步，线程同步机制是一套用于协调线程之间的数据访问机制，该机制可以保证线程安全。</p>
</blockquote>
<p>​    Java平台提供的线程机制包括锁，volatile关键字，final关键字，static关键字，以    及相关的API,Objet.wait(); Object.notify()等。</p>
<h5 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a><strong>锁的概念</strong></h5><p>线程安全的问题的产生前提是多个线程并发访问共享数据，将多个线程对共享数据的并发转换为串行访问，<strong>即一个共享数据一次只能被一个线程所访问</strong>。<strong>锁就是通过这种方式来保证线程安全的。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-28_10-35-06.png" style="zoom:150%;" /></p>
<p><strong>JVM把锁分为内部锁和显示锁两种。内部所通过<code>synchronized</code>关键字实现；显示锁通过<code>java.concurrent.locks.lock</code>接口实现类实现的。</strong></p>
<p><strong>锁的作用：</strong>锁可以实现对共享数据的安全访问，保障线程的<code>原子性</code>，<code>可见性</code>，<code>与有序性。</code></p>
<ul>
<li>锁是通过互斥保障原子性，一个锁只能被一个线程所持有的，这就保证临界区代码一次只能被一个线程执行，使得操作不可分割，保证原子性。</li>
<li>可见性的保障是通过<strong>写线程冲刷处理器的缓存和读线程刷新处理缓存</strong>这两个动作实现的。在Java中。锁的获得隐含着刷新处理器缓存的动作，锁的释放隐含着刷新处理器缓存的动作。<strong>保证写线程对数据的修改，第一时间推送到刷新处理器的高速缓存中，保证读线程的第一时间可见。</strong></li>
<li>锁能够保证有序性，写线程在临界区所执行的临界区看来像是完全按照源码顺序执行的。</li>
</ul>
<p><strong>注意</strong>：使用锁来保证线程的安全性必须满足以下条件：</p>
<blockquote>
<ul>
<li>这些线程在访问共享数据时，必须使用同一个锁。</li>
<li>这些线程即使仅仅是读共享数据，也需要使用锁。</li>
</ul>
</blockquote>
<h4 id="内部锁：synchronized"><a href="#内部锁：synchronized" class="headerlink" title="内部锁：synchronized"></a><strong>内部锁：synchronized</strong></h4><blockquote>
<p>java中的每个对象都有一个与之关联的内部锁(这种锁也被称为监视器Monitor)，这种锁是一种排他锁，可以保证原子性，可见性，有序性。</p>
</blockquote>
<p>​    所谓<code>`“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。如果synchronized</code>关键字在方法上，那临界区就是整个方法内部。而如果是使用    synchronized代码块，那临界区就指的是代码块内部的区域。</p>
<h4 id="synchronized的几种使用场景："><a href="#synchronized的几种使用场景：" class="headerlink" title="synchronized的几种使用场景："></a><strong>synchronized的几种使用场景：</strong></h4><p>1、synchronized修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象锁)&#123;</span><br><span class="line">    同步代码块，可以在同步代码块中访问共享数据</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> se.high.thread.intrinsiclock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaoziman</span></span><br><span class="line"><span class="comment"> * 同步代码块</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个线程，分别调用mm()方法</span></span><br><span class="line">        <span class="comment">//先创建Test01对象，通过对象名调用mm()方法</span></span><br><span class="line">        <span class="type">Test01</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test01</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                obj.mm(); <span class="comment">//使用的锁对象this就是obj对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                obj.mm(); <span class="comment">// 使用的锁对象this就是obj对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法，打印100行字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用this当前对象作为锁对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&gt;&quot;</span>+i);</span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、synchronized修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.high.thread.intrinsiclock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 王泽</span></span><br><span class="line"><span class="comment"> * 同步实例方法，把整个方法体作为同步代码块。</span></span><br><span class="line"><span class="comment"> * 默认的锁对象是this锁对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两个线程，分别调用mm()方法 mm2</span></span><br><span class="line">        <span class="type">Test02</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test02</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                obj.mm(); <span class="comment">//使用的锁对象this就是obj对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                obj.mm2(); <span class="comment">// 使用的锁对象this就是obj对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用this当前对象作为锁对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&gt;&quot;</span>+i);</span><br><span class="line">            &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步实例方法，同步实例方法，默认this作为锁对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">mm2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、synchronized修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字在静态方法上，锁为当前Class对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">classLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>等价于===</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字在代码块上，锁为括号里面的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.getClass()) &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、synchronized修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</p>
<p><strong>总结：</strong></p>
<blockquote>
<p>同步代码块比同步方法效率更高。<br>脏读出现的原因是对共享数据的修改与对共享数据的读取不同步。需要对读取数据的代码块同步。<br>线程出现异常会自动释放锁。</p>
</blockquote>
<h4 id="多线程访问同步方法的7种情况"><a href="#多线程访问同步方法的7种情况" class="headerlink" title="多线程访问同步方法的7种情况"></a><strong>多线程访问同步方法的7种情况</strong></h4><p>1、两个线程同时访问一个对象的同步方法</p>
<blockquote>
<p>答：串行执行</p>
</blockquote>
<p>2、两个线程访问的是两个对象的同步方法</p>
<blockquote>
<p>答：并行执行，因为两个线程持有的是各自的对象锁，互补影响。</p>
</blockquote>
<p>3、两个线程访问的是synchronized的static方法</p>
<blockquote>
<p>答：串行执行，持有一个类锁</p>
</blockquote>
<p>4、同时访问同步方法和非同步方法</p>
<blockquote>
<p>答：并行执行，无论是同一对象还是不同对象，普通方法都不会受到影响</p>
</blockquote>
<p>5、访问同一对象的不同的普通同步方法</p>
<blockquote>
<p>答：串行执行，持有相同的锁对象</p>
</blockquote>
<p>6、同时访问静态的synchronized方法和非静态的synchronized方法</p>
<blockquote>
<p>答：并行执行，因为一个是持有的class类锁，一个是持有的是this对象锁，不同的锁，互补干扰。</p>
</blockquote>
<p>7、方法抛出异常后，会释放锁</p>
<blockquote>
<p>答：synchronized无论是正常结束还是抛出异常后，都会释放锁，而lock必须手动释放锁才可以。</p>
</blockquote>
<h4 id="死锁的问题"><a href="#死锁的问题" class="headerlink" title="死锁的问题"></a><strong>死锁的问题</strong></h4><blockquote>
<p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
</blockquote>
<p><strong>java 死锁产生的四个必要条件：</strong></p>
<blockquote>
<p>1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用<br>2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。<br>3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。<br>4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</p>
</blockquote>
<p>当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。下面用java代码来模拟一下死锁的产生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.high.thread.intrinsiclock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.auth.Subject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaoziman</span></span><br><span class="line"><span class="comment"> * 演示死锁问题。</span></span><br><span class="line"><span class="comment"> * 在多线程程序中，同步时可能需要使用多个锁，如果获得锁的顺序不一致，可能会导致死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">t1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SubThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">SubThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubThread</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">yitian</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">tulong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;a&quot;</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (yitian)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;a线程获得了倚天剑，爽翻了，再来个屠龙刀就好了...&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (tulong)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;a线程获得了倚天剑和屠龙刀，直接称霸武林...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;b&quot;</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (tulong)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;b线程获得了屠龙宝刀，得劲,谁也不给....&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (yitian)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;b线程获得了屠龙后又来把倚天剑....b称霸武林&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决死锁：</p>
<blockquote>
<p>当需要获得多个锁时，所有线程获得锁的顺序保持一致。</p>
</blockquote>
<hr>
<h3 id="四、线程之间的通信"><a href="#四、线程之间的通信" class="headerlink" title="四、线程之间的通信"></a>四、线程之间的通信</h3><blockquote>
<p>众所周知线程都有自己的线程栈，那么线程之间是如何保证通信的呢？下面来分析：</p>
</blockquote>
<h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h4><p>什么是等待通知机制？</p>
<p>举例：吃自助的时候吃现做的一些饭，放到台子上才能拿。</p>
<blockquote>
<p>在单线程编程中，要执行的操作需要满足一定的条件才能执行，可以把这个操作放在if语句块中。</p>
<p>在多线程编程中，可能A线程条件没有满足只是暂时的，稍后其他的线程B可能会更新条件使得A线程的条件得到满足，可以将A线程暂停，直到他的条件得到满足后再将A线程唤醒。</p>
</blockquote>
<p>​    伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">atomic&#123;</span><br><span class="line">    <span class="keyword">while</span>（条件不成立）&#123;</span><br><span class="line">        等待</span><br><span class="line">    &#125;</span><br><span class="line">    条件满足后当前线程被唤醒，继续执行下面的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>等待通知机制的实现：</strong></p>
<p>Object类中的<code>wait()</code>方法，可以使当前执行代码的线程等待。暂停执行，知道接受到通知或被中断为止。</p>
<p>注意：</p>
<blockquote>
<ol>
<li>wait()方法只能在同步代码块中由锁对象调用。</li>
<li>调用wait()方法后，当前线程会释放锁。</li>
</ol>
</blockquote>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在调用wait()方法前获得对象的内部锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">        <span class="comment">//通过锁对象调用wait()方法暂停线程，释放锁对象</span></span><br><span class="line">        锁对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程的条件满足了继续向下执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object类的 notify()可以唤醒线程，该方法也必须在同步代码块中由锁对象调用。没有使用锁对象调用wait()/notify()会抛出异常。</p>
</blockquote>
<p>​    如果有多个等待的线程，<strong>notify()方法只能唤醒其中的一个，并不会立即释放锁对象。</strong>一般将notify方法放在同步代码块的最后。</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    执行修改保护条件的代码</span><br><span class="line">    唤醒其他线程</span><br><span class="line">        锁对象.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看一个了例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.high.thread.wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 结构化思维wz</span></span><br><span class="line"><span class="comment"> * 用notify唤醒等待的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="string">&quot;wzjiayou&quot;</span>; <span class="comment">//定义一个字符串作为锁对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1开始等待--&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">//线程等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1结束等待--&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义线程2，用来唤醒线程1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//notify需要在同步代码块中由锁对象调用</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2开始唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                    lock.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2结束唤醒&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start(); <span class="comment">//开启t1线程,main线程谁3秒，确保t1等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>开始等待--&gt;<span class="number">1633345984896</span></span><br><span class="line">线程<span class="number">2</span>开始唤醒<span class="number">1633345987897</span></span><br><span class="line">线程<span class="number">2</span>结束唤醒<span class="number">1633345987897</span></span><br><span class="line">线程<span class="number">1</span>结束等待--&gt;<span class="number">1633345987897</span></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="interrupt-方法会中断wait"><a href="#interrupt-方法会中断wait" class="headerlink" title="interrupt()方法会中断wait()"></a>interrupt()方法会中断wait()</h4><p>当线程处于<code>wait()</code>等待状态时，调用线程对象的<code>interrupt()</code>方法会中断线程等待状态，会产生<code>InterruptedExceptiont</code>异常。</p>
<h4 id="notify-与notifyAll"><a href="#notify-与notifyAll" class="headerlink" title="notify()与notifyAll()"></a>notify()与notifyAll()</h4><p><code>notify()</code>一次只能唤醒一个线程，如果有多个等待的线程，只能随机唤醒其中的某一个；想要唤醒所有的线程，需要调用<code>notifyAll()</code>;</p>
<h4 id="wait-long"><a href="#wait-long" class="headerlink" title="wait(long)"></a>wait(long)</h4><p>如果在参数指定的时间内没有被唤醒，超时后会自动唤醒。</p>
<p><strong>通知过早</strong></p>
<blockquote>
<p>线程wait()等待后，可以调用notify()唤醒线程，如果notify()唤醒过早，在等待之前就调用了notify()可能会打乱程序正常的执行逻辑。</p>
<p>在应用中，我们为了保证t1等待后才让t2唤醒。如果t2线程先唤醒，就不让t1等待了。</p>
<p>可以设置一个Boolean变量，通知后设为false，如果为true再等待。</p>
</blockquote>
<h4 id="wait-等待条件发生了变化"><a href="#wait-等待条件发生了变化" class="headerlink" title="wait() 等待条件发生了变化"></a>wait() 等待条件发生了变化</h4><p>在使用<code>wait(),notify()</code>,注意wait条件发生的了变化，也可能导致逻辑的混乱。</p>
<p><em>*生产者消费者模式</em></p>
<blockquote>
<p>生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。生产者生成一定量的数据放到缓冲区中，然后重复此过程；与此同时，消费者也在缓冲区消耗这些数据。生产者和消费者之间必须保持同步，要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据。不够完善的解决方法容易出现死锁的情况，此时进程都在等待唤醒。</p>
</blockquote>
<p>示意图：<br><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-02-28_12-19-02.png" style="zoom:150%;" /></p>
<p><strong>解决思路：</strong></p>
<ol>
<li><blockquote>
<p>采用某种机制保护生产者和消费者之间的同步。有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。</p>
</blockquote>
</li>
<li><blockquote>
<p>在生产者和消费者之间建立一个管道。管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。</p>
</blockquote>
</li>
</ol>
<p><strong>解决问题的核心：</strong></p>
<p> 保证同一资源被多个线程并发访问时的完整性。常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。</p>
<p><strong>wait() / notify()方法</strong></p>
<blockquote>
<p>当缓冲区已满时，生产者线程停止执行，放弃锁，使自己处于等待状态，让其他线程执行；</p>
<p>当缓冲区已空时，消费者线程停止执行，放弃锁，使自己处于等待状态，让其他线程执行。</p>
<p>当生产者向缓冲区放入一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态；<br>当消费者从缓冲区取出一个产品时，向其他等待的线程发出可执行的通知，同时放弃锁，使自己处于等待状态。</p>
</blockquote>
<p><strong>仓库Storage.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line"><span class="comment">// 仓库容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 仓库存储的载体</span></span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="comment">/*仓库满的情况*/</span></span><br><span class="line">        <span class="keyword">while</span> (list.size() + <span class="number">1</span> &gt; MAX_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;【生产者&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">	                + <span class="string">&quot;】仓库已满&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*生产者生产*/</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;【生产者&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;】生产一个产品，现库存&quot;</span> + list.size());</span><br><span class="line">        list.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">        <span class="comment">/*仓库空了*/</span></span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;【消费者&quot;</span> + Thread.currentThread().getName() </span><br><span class="line">					+ <span class="string">&quot;】仓库为空&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*消费者消费*/</span></span><br><span class="line">        list.remove();</span><br><span class="line">        System.out.println(<span class="string">&quot;【消费者&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;】消费一个产品，现库存&quot;</span> + list.size());</span><br><span class="line">        list.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Storage storage;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Storage storage)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.storage = storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            storage.produce();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Storage storage;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Storage storage)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.storage = storage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            storage.consume();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Main：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Storage</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line"></span><br><span class="line">    p1.start();</span><br><span class="line">    p2.start();</span><br><span class="line">    p3.start();</span><br><span class="line">    c1.start();</span><br><span class="line">    c2.start();</span><br><span class="line">    c3.start();</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">运行结果</span><br><span class="line"></span><br><span class="line">【生产者p1】生产一个产品，现库存<span class="number">1</span></span><br><span class="line">【生产者p2】生产一个产品，现库存<span class="number">2</span></span><br><span class="line">【生产者p3】生产一个产品，现库存<span class="number">3</span></span><br><span class="line">【生产者p1】生产一个产品，现库存<span class="number">4</span></span><br><span class="line">【生产者p2】生产一个产品，现库存<span class="number">5</span></span><br><span class="line">【生产者p3】生产一个产品，现库存<span class="number">6</span></span><br><span class="line">【生产者p1】生产一个产品，现库存<span class="number">7</span></span><br><span class="line">【生产者p2】生产一个产品，现库存<span class="number">8</span></span><br><span class="line">【消费者c1】消费一个产品，现库存<span class="number">7</span></span><br><span class="line">【生产者p3】生产一个产品，现库存<span class="number">8</span></span><br><span class="line">【消费者c2】消费一个产品，现库存<span class="number">7</span></span><br><span class="line">【消费者c3】消费一个产品，现库存<span class="number">6</span></span><br><span class="line">【生产者p1】生产一个产品，现库存<span class="number">7</span></span><br><span class="line">【生产者p2】生产一个产品，现库存<span class="number">8</span></span><br><span class="line">【生产者p3】生产一个产品，现库存<span class="number">9</span></span><br><span class="line">【生产者p1】生产一个产品，现库存<span class="number">10</span></span><br><span class="line">【生产者p2】仓库已满</span><br><span class="line">【生产者p3】仓库已满</span><br><span class="line">【生产者p1】仓库已满</span><br><span class="line">【消费者c1】消费一个产品，现库存<span class="number">9</span></span><br><span class="line">【生产者p1】生产一个产品，现库存<span class="number">10</span></span><br><span class="line">【生产者p3】仓库已满</span><br><span class="line">。。。。。。以下省略</span><br></pre></td></tr></table></figure>
<p>一个生产者线程运行produce方法，睡眠1s；一个消费者运行一次consume方法，睡眠3s。此次实验过程中，有3个生产者和3个消费者，也就是我们说的多对多的情况。仓库的容量为10，可以看出消费的速度明显慢于生产的速度，符合设定。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>notifyAll()方法可使所有正在等待队列中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。此时，优先级最高的哪个线程最先执行，但也有可能是随机执行的，这要取决于JVM虚拟机的实现。即最终也只有一个线程能被运行，上述线程优先级都相同，每次运行的线程都不确定是哪个，后来给线程设置优先级后也跟预期不一样，还是要看JVM的具体实现吧。</p>
</blockquote>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h4><p>join()方法是Thread类的一个实例方法。它的作用是让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程。</p>
<blockquote>
<p>有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。</p>
<p>如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到join方法了。(插队)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Join</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程，我先睡一秒&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程，我睡完了一秒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadA</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;如果不加join方法，我会先被打出来，加了就不一样了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意join()方法有两个重载方法，一个是join(long)， 一个是join(long, int)。</p>
<blockquote>
<p>实际上，通过源码你会发现，join()方法及其重载方法底层都是利用了wait(long)这个方法。</p>
<p>对于join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理。</p>
</blockquote>
<h3 id="五、Callable与Future"><a href="#五、Callable与Future" class="headerlink" title="五、Callable与Future"></a><strong>五、Callable与Future</strong></h3><p>通常来说，我们使用Runnable和Thread来创建一个新的线程。但是它们有一个弊端，就是run方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p>
<blockquote>
<p>JDK提供了Callable接口与Future接口为我们解决这个问题，这也是所谓的“异步”模型。</p>
</blockquote>
<p><strong>Callable接口</strong></p>
<blockquote>
<p>Callable与Runnable类似，同样是只有一个抽象方法的函数式接口。不同的是，Callable提供的方法是有返回值的，而且支持泛型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那一般是怎么使用Callable的呢？Callable一般是配合线程池工具ExecutorService来使用的。我们会在后续章节解释线程池的使用。这里只介绍ExecutorService可以使用submit方法来让一个Callable接口执行。它会返回一个Future，我们后续的程序可以通过这个Future的get方法得到结果。</p>
<p>这里可以看一个简单的使用demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义Callable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟计算需要一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        <span class="comment">// 注意调用get方法会阻塞当前线程，直到得到结果。</span></span><br><span class="line">        <span class="comment">// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span></span><br><span class="line">        System.out.println(result.get()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p><code>Future</code>接口只有几个比较简单的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> paramBoolean)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> paramLong, TimeUnit paramTimeUnit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>cancel方法是试图取消一个线程的执行。</strong></p>
<blockquote>
<p>注意是试图取消，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。boolean类型的返回值是“是否取消成功”的意思。参数paramBoolean表示是否采用中断的方式取消线程执行。</p>
<p>所以有时候，为了让任务有能够取消的功能，就使用Callable来代替Runnable。如果为了可取消性而使用 Future但又不提供可用的结果，则可以声明 Future&lt;?&gt;形式类型、并返回 null作为底层任务的结果。</p>
</blockquote>
<h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><p>上面介绍了<code>Future</code>接口。这个接口有一个实现类叫<code>FutureTask</code>。<code>FutureTask</code>是实现的<code>RunnableFuture</code>接口的，而<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那<code>FutureTask</code>类有什么用？为什么要有一个<code>FutureTask</code>类？前面说到了<code>Future</code>只是一个接口，而它里面的<code>cancel</code>，<code>get</code>，<code>isDone</code>等方法要自己实现起来都是<strong>非常复杂</strong>的。所以JDK提供了一个<code>FutureTask</code>类来供我们使用。</p>
<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义Callable，与上面一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟计算需要一秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上与第一个Demo有一点小的区别。首先，调用submit方法是没有返回值的。这里实际上是调用的submit(Runnable task)方法，而上面的Demo，调用的是submit(Callable<T> task)方法。</p>
<p>然后，这里是使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。</p>
<blockquote>
<p>在很多高并发的环境下，有可能Callable和FutureTask会创建多次。FutureTask能够在高并发环境下确保任务只执行一次。</p>
</blockquote>
<hr>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="一、反射的概述"><a href="#一、反射的概述" class="headerlink" title="一、反射的概述"></a>一、反射的概述</h3><blockquote>
<p>Java反射机制是实在运行状态中，对于任意一个类，都能够知道这个类的属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能我们称之为Java反射机制。</p>
<p>想要剖析一个类，必须要获取该类的的字节码文件对象。而剖析使用的就是Class类的方法，所以要先获取一个字节码文件对应的Class类型的对象。</p>
</blockquote>
<p><strong><em>\</em>以上的总结就是什么是反射**</strong></p>
<blockquote>
<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
</blockquote>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<blockquote>
<p>​     （其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br>如图是类的正常加载过程：反射的原理在与class对象。<br>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p>
</blockquote>
<p>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_16-48-36.png" style="zoom:150%;" /></p>
<p><strong>其中这个Class对象很特殊。我们先了解一下这个C lass类</strong></p>
<hr>
<h3 id="二、查看Class类在Java中api详解（查阅文档）"><a href="#二、查看Class类在Java中api详解（查阅文档）" class="headerlink" title="二、查看Class类在Java中api详解（查阅文档）"></a>二、查看Class类在Java中api详解（查阅文档）</h3><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_16-50-48.png" style="zoom:150%;" /></p>
<blockquote>
<p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass 方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p>
</blockquote>
<p>​    <strong>没有公共的构造方法，方法共有64个太多了。咱们只需要了解一些常用的即可</strong></p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_16-53-22.png" style="zoom:200%;" /></p>
<hr>
<h3 id="三、反射的使用"><a href="#三、反射的使用" class="headerlink" title="三、反射的使用"></a>三、反射的使用</h3><p><strong>下面我们来举一个例子：</strong></p>
<p>先写一个Student类。</p>
<h4 id="1、获取Class对象的三种方式"><a href="#1、获取Class对象的三种方式" class="headerlink" title="1、获取Class对象的三种方式"></a>1、获取Class对象的三种方式</h4><ol>
<li>Object ——&gt; getClass();</li>
<li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性</li>
<li>通过Class的静态方法：forName（String  className）(常用)</li>
</ol>
<p>其中1.1是因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_16-55-09.png" style="zoom:200%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Class对象的三种方式</span></span><br><span class="line"><span class="comment"> * 1 Object ——&gt; getClass();</span></span><br><span class="line"><span class="comment"> * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</span></span><br><span class="line"><span class="comment"> * 3 通过Class类的静态方法：forName（String  className）(常用)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fanshe</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//第一种方式获取Class对象  </span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//这一new 产生一个Student对象，一个Class对象。</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu1.getClass();<span class="comment">//获取Class对象</span></span><br><span class="line">		System.out.println(stuClass.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第二种方式获取Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">		System.out.println(stuClass == stuClass2);<span class="comment">//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第三种方式获取Class对象</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Class</span> <span class="variable">stuClass3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);<span class="comment">//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名</span></span><br><span class="line">			System.out.println(stuClass3 == stuClass2);<span class="comment">//判断三种方式是否获取的是同一个Class对象</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>注意：在运行期间，一个类，只有一个Class对象产生。</strong></p>
<blockquote>
<p>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>
</blockquote>
<h4 id="2、通过反射获取构造方法并使用："><a href="#2、通过反射获取构造方法并使用：" class="headerlink" title="2、通过反射获取构造方法并使用："></a>2、通过反射获取构造方法并使用：</h4><p><strong>student类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//---------------构造方法-------------------</span></span><br><span class="line">	<span class="comment">//（默认的构造方法）</span></span><br><span class="line">	Student(String str)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;(默认)的构造方法 s = &quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了公有、无参构造方法执行了。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//有一个参数的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">char</span> name)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//有多个参数的构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;年龄：&quot;</span>+ age);<span class="comment">//这的执行效率有问题，以后解决。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//受保护的构造方法</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">Student</span><span class="params">(<span class="type">boolean</span> n)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;受保护的构造方法 n = &quot;</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//私有构造方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;私有的构造方法   年龄：&quot;</span>+ age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>共有6个构造方法；</strong></p>
<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.获取构造方法：</span></span><br><span class="line"><span class="comment"> * 		1).批量的方法：</span></span><br><span class="line"><span class="comment"> * 			public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法</span></span><br><span class="line"><span class="comment">            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment"> * 		2).获取单个的方法，并调用：</span></span><br><span class="line"><span class="comment"> * 			public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：</span></span><br><span class="line"><span class="comment"> * 			public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span></span><br><span class="line"><span class="comment"> * 		</span></span><br><span class="line"><span class="comment"> * 			调用构造方法：</span></span><br><span class="line"><span class="comment"> * 			Constructor--&gt;newInstance(Object... initargs)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructors</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.加载Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取所有公有构造方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;**********************所有公有构造方法*********************************&quot;</span>);</span><br><span class="line">		Constructor[] conArray = clazz.getConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;</span>);</span><br><span class="line">		conArray = clazz.getDeclaredConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************获取公有、无参的构造方法*******************************&quot;</span>);</span><br><span class="line">		<span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor(<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span></span><br><span class="line">		<span class="comment">//2&gt;、返回的是描述这个无参构造函数的类对象。</span></span><br><span class="line">	</span><br><span class="line">		System.out.println(<span class="string">&quot;con = &quot;</span> + con);</span><br><span class="line">		<span class="comment">//调用构造方法</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">	<span class="comment">//	System.out.println(&quot;obj = &quot; + obj);</span></span><br><span class="line">	<span class="comment">//	Student stu = (Student)obj;</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;******************获取私有构造方法，并调用*******************************&quot;</span>);</span><br><span class="line">		con = clazz.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line">		System.out.println(con);</span><br><span class="line">		<span class="comment">//调用构造方法</span></span><br><span class="line">		con.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力访问(忽略掉访问修饰符)</span></span><br><span class="line">		obj = con.newInstance(<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**********************所有公有构造方法*********************************</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">************所有的构造方法(包括：私有、受保护、默认、公有)***************</span><br><span class="line"><span class="keyword">private</span> fanshe.Student(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> fanshe.Student(<span class="type">boolean</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(java.lang.String,<span class="type">int</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line"><span class="keyword">public</span> fanshe.Student()</span><br><span class="line">fanshe.Student(java.lang.String)</span><br><span class="line">*****************获取公有、无参的构造方法*******************************</span><br><span class="line">con = <span class="keyword">public</span> fanshe.Student()</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">******************获取私有构造方法，并调用*******************************</span><br><span class="line"><span class="keyword">public</span> fanshe.Student(<span class="type">char</span>)</span><br><span class="line">姓名：男</span><br></pre></td></tr></table></figure>
<p><strong>调用方法：</strong></p>
<blockquote>
<p>1.获取构造方法：<br>1).批量的方法：<br>public Constructor[] getConstructors()：所有”公有的”构造方法<br>      public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</p>
<p>  2).获取单个的方法，并调用：<br>  public Constructor getConstructor(Class… parameterTypes):获取单个的”公有的”构造方法：<br>  public Constructor getDeclaredConstructor(Class… parameterTypes):获取”某个构造方法”可以是私有的，或受保护、默认、公有；</p>
<p>  调用构造方法：<br>  Constructor—&gt;newInstance(Object… initargs)</p>
<p>2、 newInstance是 Constructor类的方法（管理构造函数的类）<br>api的解释为：<br>newInstance(Object… initargs)<br>     使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<br>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</p>
</blockquote>
<h4 id="3、获取成员变量并调用"><a href="#3、获取成员变量并调用" class="headerlink" title="3、获取成员变量并调用"></a>3、获取成员变量并调用</h4><p><strong>student类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//**********字段*************//</span></span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">	<span class="keyword">private</span> String phoneNum;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, sex=&quot;</span> + sex</span><br><span class="line">				+ <span class="string">&quot;, phoneNum=&quot;</span> + phoneNum + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取成员变量并调用：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.批量的</span></span><br><span class="line"><span class="comment"> * 		1).Field[] getFields():获取所有的&quot;公有字段&quot;</span></span><br><span class="line"><span class="comment"> * 		2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span></span><br><span class="line"><span class="comment"> * 2.获取单个的：</span></span><br><span class="line"><span class="comment"> * 		1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span></span><br><span class="line"><span class="comment"> * 		2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	 设置字段的值：</span></span><br><span class="line"><span class="comment"> * 		Field --&gt; public void set(Object obj,Object value):</span></span><br><span class="line"><span class="comment"> * 					参数说明：</span></span><br><span class="line"><span class="comment"> * 					1.obj:要设置的字段所在的对象；</span></span><br><span class="line"><span class="comment"> * 					2.value:要为字段设置的值；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fields</span> &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			<span class="comment">//1.获取Class对象</span></span><br><span class="line">			<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.field.Student&quot;</span>);</span><br><span class="line">			<span class="comment">//2.获取字段</span></span><br><span class="line">			System.out.println(<span class="string">&quot;************获取所有公有的字段********************&quot;</span>);</span><br><span class="line">			Field[] fieldArray = stuClass.getFields();</span><br><span class="line">			<span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;</span>);</span><br><span class="line">			fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">			<span class="keyword">for</span>(Field f : fieldArray)&#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;*************获取公有字段**并调用***********************************&quot;</span>);</span><br><span class="line">			<span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">			System.out.println(f);</span><br><span class="line">			<span class="comment">//获取一个对象</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> stuClass.getConstructor().newInstance();<span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line">			<span class="comment">//为字段设置值</span></span><br><span class="line">			f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line">			<span class="comment">//验证</span></span><br><span class="line">			<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student)obj;</span><br><span class="line">			System.out.println(<span class="string">&quot;验证姓名：&quot;</span> + stu.name);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">&quot;**************获取私有字段****并调用********************************&quot;</span>);</span><br><span class="line">			f = stuClass.getDeclaredField(<span class="string">&quot;phoneNum&quot;</span>);</span><br><span class="line">			System.out.println(f);</span><br><span class="line">			f.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力反射，解除私有限定</span></span><br><span class="line">			f.set(obj, <span class="string">&quot;18888889999&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;验证电话：&quot;</span> + stu);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">************获取所有公有的字段********************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">************获取所有的字段(包括私有、受保护、默认的)********************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> fanshe.field.Student.age</span><br><span class="line"><span class="type">char</span> fanshe.field.Student.sex</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">*************获取公有字段**并调用***********************************</span><br><span class="line"><span class="keyword">public</span> java.lang.String fanshe.field.Student.name</span><br><span class="line">验证姓名：刘德华</span><br><span class="line">**************获取私有字段****并调用********************************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">验证电话：Student [name=刘德华, age=<span class="number">0</span>, sex=</span><br></pre></td></tr></table></figure>
<p>由此可见<br>调用字段时：需要传递两个参数：</p>
<blockquote>
<p>Object obj = stuClass.getConstructor().newInstance();//产生Student对象—》Student stu = new Student();<br>//为字段设置值<br>f.set(obj, “刘德华”);//为Student对象中的name属性赋值—》stu.name = “刘德华”<br>第一个参数：要传入设置的对象，第二个参数：要传入实参</p>
</blockquote>
<h4 id="4、获取成员方法并调用"><a href="#4、获取成员方法并调用" class="headerlink" title="4、获取成员方法并调用"></a>4、获取成员方法并调用</h4><p><strong>student类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="comment">//**************成员方法***************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(String s)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：公有的，String参数的show1(): s = &quot;</span> + s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：受保护的，无参的show2()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show3</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了：默认的，无参的show3()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">show4</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot;</span> + age);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.method;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取成员方法并调用：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.批量的：</span></span><br><span class="line"><span class="comment"> * 		public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）</span></span><br><span class="line"><span class="comment"> * 		public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span></span><br><span class="line"><span class="comment"> * 2.获取单个的：</span></span><br><span class="line"><span class="comment"> * 		public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):</span></span><br><span class="line"><span class="comment"> * 					参数：</span></span><br><span class="line"><span class="comment"> * 						name : 方法名；</span></span><br><span class="line"><span class="comment"> * 						Class ... : 形参的Class类型对象</span></span><br><span class="line"><span class="comment"> * 		public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	 调用方法：</span></span><br><span class="line"><span class="comment"> * 		Method --&gt; public Object invoke(Object obj,Object... args):</span></span><br><span class="line"><span class="comment"> * 					参数说明：</span></span><br><span class="line"><span class="comment"> * 					obj : 要调用方法的对象；</span></span><br><span class="line"><span class="comment"> * 					args:调用方式时所传递的实参；</span></span><br><span class="line"><span class="comment">):</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodClass</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.获取Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.method.Student&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取所有公有方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取所有的”公有“方法*******************&quot;</span>);</span><br><span class="line">		stuClass.getMethods();</span><br><span class="line">		Method[] methodArray = stuClass.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取所有的方法，包括私有的*******************&quot;</span>);</span><br><span class="line">		methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取公有的show1()方法*******************&quot;</span>);</span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;show1&quot;</span>, String.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		<span class="comment">//实例化一个Student对象</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> stuClass.getConstructor().newInstance();</span><br><span class="line">		m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;***************获取私有的show4()方法******************&quot;</span>);</span><br><span class="line">		m = stuClass.getDeclaredMethod(<span class="string">&quot;show4&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		m.setAccessible(<span class="literal">true</span>);<span class="comment">//解除私有限定</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> m.invoke(obj, <span class="number">20</span>);<span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">		System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> fanshe.method.Student.show2()</span><br><span class="line"><span class="keyword">void</span> fanshe.method.Student.show3()</span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line">调用了，私有的，并且有返回值的，<span class="type">int</span>参数的show4(): age = <span class="number">20</span></span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure>
<p>由此可见：</p>
<blockquote>
<p>m = stuClass.getDeclaredMethod(“show4”, int.class);//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。</p>
<p> System.out.println(m);<br> m.setAccessible(true);//解除私有限定<br> Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参<br> System.out.println(“返回值：” + result);</p>
</blockquote>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>,<span class="type">int</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.wait(<span class="type">long</span>) <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> java.lang.Object.wait() <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> java.lang.Object.equals(java.lang.Object)</span><br><span class="line"><span class="keyword">public</span> java.lang.String java.lang.Object.toString()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> java.lang.Object.hashCode()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notifyAll()</span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> fanshe.method.Student.show2()</span><br><span class="line"><span class="keyword">void</span> fanshe.method.Student.show3()</span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line"><span class="keyword">private</span> java.lang.String fanshe.method.Student.show4(<span class="type">int</span>)</span><br><span class="line">调用了，私有的，并且有返回值的，<span class="type">int</span>参数的show4(): age = <span class="number">20</span></span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实这里的成员方法：在模型中有属性一词，就是那些setter（）方法和getter()方法。还有字段组成，这些内容在内省中详解</p>
</blockquote>
<h4 id="5、反射main方法"><a href="#5、反射main方法" class="headerlink" title="5、反射main方法"></a>5、反射main方法</h4><p><strong>student类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法执行了。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fanshe.main;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Student类的main方法、不要与当前的main方法搞混了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//1、获取Student对象的字节码</span></span><br><span class="line">			<span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;fanshe.main.Student&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2、获取main方法</span></span><br><span class="line">			 <span class="type">Method</span> <span class="variable">methodMain</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);<span class="comment">//第一个参数：方法名称，第二个参数：方法形参的类型，</span></span><br><span class="line">			<span class="comment">//3、调用main方法</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);</span></span><br><span class="line">			 <span class="comment">//第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数</span></span><br><span class="line">			 <span class="comment">//这里拆的时候将  new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125; 拆成3个对象。。。所以需要将它强转。</span></span><br><span class="line">			 methodMain.invoke(<span class="literal">null</span>, (Object)<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);<span class="comment">//方式一</span></span><br><span class="line">			<span class="comment">// methodMain.invoke(null, new Object[]&#123;new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;&#125;);//方式二</span></span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main方法执行了。。。</span><br></pre></td></tr></table></figure>
<h4 id="6、反射方法的其它使用之—-通过反射运行配置文件内容"><a href="#6、反射方法的其它使用之—-通过反射运行配置文件内容" class="headerlink" title="6、反射方法的其它使用之—-通过反射运行配置文件内容"></a>6、反射方法的其它使用之—-通过反射运行配置文件内容</h4><p><strong>student类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;is show()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置文件以txt文件为例子（pro.txt）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.<span class="type">Student</span></span><br><span class="line"><span class="variable">methodName</span> <span class="operator">=</span> show</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改</span></span><br><span class="line"><span class="comment"> * 我们只需要将新类发送给客户端，并修改配置文件即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//通过反射获取Class对象</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(getValue(<span class="string">&quot;className&quot;</span>));<span class="comment">//&quot;cn.fanshe.Student&quot;</span></span><br><span class="line">		<span class="comment">//2获取show()方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(getValue(<span class="string">&quot;methodName&quot;</span>));<span class="comment">//show</span></span><br><span class="line">		<span class="comment">//3.调用show()方法</span></span><br><span class="line">		m.invoke(stuClass.getConstructor().newInstance());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//此方法接收一个key，在配置文件中获取相应的value</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getValue</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//获取配置文件的对象</span></span><br><span class="line">		<span class="type">FileReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;pro.txt&quot;</span>);<span class="comment">//获取输入流</span></span><br><span class="line">		pro.load(in);<span class="comment">//将流加载到配置文件对象中</span></span><br><span class="line">		in.close();</span><br><span class="line">		<span class="keyword">return</span> pro.getProperty(key);<span class="comment">//返回根据key获取的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is <span class="title function_">show</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>需求：</strong><br>当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动</p>
<p>要替换的student2类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;is show2()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件更改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className = cn.fanshe.<span class="type">Student2</span></span><br><span class="line"><span class="variable">methodName</span> <span class="operator">=</span> show2</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is <span class="title function_">show2</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h4 id="7、反射方法的其它使用之—-通过反射越过泛型检查"><a href="#7、反射方法的其它使用之—-通过反射越过泛型检查" class="headerlink" title="7、反射方法的其它使用之—-通过反射越过泛型检查"></a>7、反射方法的其它使用之—-通过反射越过泛型检查</h4><blockquote>
<p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p>
</blockquote>
<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 通过反射越过泛型检查</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		strList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//	strList.add(100);</span></span><br><span class="line">		<span class="comment">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); <span class="comment">//得到 strList 对象的字节码 对象</span></span><br><span class="line">		<span class="comment">//获取add()方法</span></span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		<span class="comment">//调用add()方法</span></span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历集合</span></span><br><span class="line">		<span class="keyword">for</span>(Object obj : strList)&#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解的概述"><a href="#注解的概述" class="headerlink" title="注解的概述"></a>注解的概述</h3><p><strong>Annotation</strong> 中文译过来就是注解、标释的意思，在 Java 中注解是一个很重要的知识点，但经常还是有点让新手不容易理解。</p>
<p><strong>我个人认为，比较糟糕的技术文档主要特征之一就是：用专业名词来介绍专业名词。</strong><br>比如：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Java&amp;spm=1001.2101.3001.7020">Java</a> 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。<br>这是大多数网站上对于 Java 注解，解释确实正确，但是说实在话，我第一次学习的时候，头脑一片空白。这什么跟什么啊？听了像没有听一样。因为概念太过于抽象，所以初学者实在是比较吃力才能够理解，然后随着自己开发过程中不断地强化练习，才会慢慢对它形成正确的认识。</p>
</blockquote>
<p>我在写这篇文章的时候，我就在思考。如何让自己或者让读者能够比较直观地认识注解这个概念？是要去官方文档上翻译说明吗？我马上否定了这个答案。</p>
<blockquote>
<p>后来，我想到了一样东西————墨水，墨水可以挥发、可以有不同的颜色，用来解释注解正好。</p>
<p>不过，我继续发散思维后，想到了一样东西能够更好地代替墨水，那就是印章。印章可以沾上不同的墨水或者印泥，可以定制印章的文字或者图案，如果愿意它也可以被戳到你任何想戳的物体表面。</p>
<p>但是，我再继续发散思维后，又想到一样东西能够更好地代替印章，那就是标签。标签是一张便利纸，标签上的内容可以自由定义。常见的如货架上的商品价格标签、图书馆中的书本编码标签、实验室中化学材料的名称类别标签等等。</p>
<p>并且，往抽象地说，标签并不一定是一张纸，它可以是对人和事物的属性评价。也就是说，标签具备对于抽象事物的解释。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_18-07-02.png" style="zoom:150%;" /></p>
<p><strong>所以，基于如此，我完成了自我的知识认知升级，我决定用标签来解释注解。</strong></p>
<h3 id="注解如同标签"><a href="#注解如同标签" class="headerlink" title="注解如同标签"></a>注解如同标签</h3><p>之前某新闻客户端的评论有盖楼的习惯，于是 “乔布斯重新定义了手机、罗永浩重新定义了傻X” 就经常极为工整地出现在了评论楼层中，并且广大网友在相当长的一段时间内对于这种行为乐此不疲。这其实就是等同于贴标签的行为。<br>在某些网友眼中，罗永浩就成了傻X的代名词。</p>
<p>广大网友给罗永浩贴了一个名为“傻x”的标签，他们并不真正了解罗永浩，不知道他当教师、砸冰箱、办博客的壮举，但是因为“傻x”这样的标签存在，这有助于他们直接快速地对罗永浩这个人做出评价，然后基于此，罗永浩就可以成为茶余饭后的谈资，这就是标签的力量。</p>
<p>而在网络的另一边，老罗靠他的人格魅力自然收获一大批忠实的拥泵，他们对于老罗贴的又是另一种标签。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_18-08-39.png" alt=""></p>
<p>我无意于评价这两种行为，我再引个例子。</p>
<blockquote>
<p>《奇葩说》是近年网络上非常火热的辩论节目，其中辩手陈铭被另外一个辩手马薇薇攻击说是————“站在宇宙中心呼唤爱”，然后贴上了一个大大的标签————“鸡汤男”，自此以后，观众再看到陈铭的时候，首先映入脑海中便是“鸡汤男”三个大字，其实本身而言陈铭非常优秀，为人师表、作风正派、谈吐举止得体，但是在网络中，因为娱乐至上的环境所致，人们更愿意以娱乐的心态来认知一切，于是“鸡汤男”就如陈铭自己所说成了一个撕不了的标签。</p>
</blockquote>
<p><strong>我们可以抽象概括一下，标签是对事物行为的某些角度的评价与解释。</strong></p>
<p>到这里，终于可以引出本文的主角注解了。</p>
<p><strong>初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。</strong></p>
<p>在未开始学习任何注解具体语法而言，你可以把注解看成一张标签。这有助于你快速地理解它的大致作用。如果初学者在学习过程有大脑放空的时候，请不要慌张，对自己说：</p>
<p><strong>注解，标签。注解，标签。</strong></p>
<h3 id="注解的语法"><a href="#注解的语法" class="headerlink" title="注解的语法"></a>注解的语法</h3><p>因为平常开发少见，相信有不少的人员会认为注解的地位不高。其实同 classs 和 interface 一样，注解也属于一种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=类型&amp;spm=1001.2101.3001.7020">类型</a>。它是在 Java SE 5.0 版本中开始引入的概念。</p>
<h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>注解通过 @interface 关键字进行定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。</p>
</blockquote>
<p>你可以简单理解为创建了一张名字为 TestAnnotation 的标签。</p>
<h3 id="注解的应用"><a href="#注解的应用" class="headerlink" title="注解的应用"></a>注解的应用</h3><p>上面创建了一个注解，那么注解的的使用方法是什么呢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。</p>
<p>你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。</p>
<p>不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong>元注解是什么意思呢？</strong></p>
<blockquote>
<p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p>
<p>如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。</p>
<p>元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</p>
</blockquote>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。</p>
<p>它的取值如下：</p>
<blockquote>
<ul>
<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li>
<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li>
<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li>
</ul>
</blockquote>
<p>我们可以这样的方式来加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention 相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><blockquote>
<p>顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>
</blockquote>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>Target 是目标的意思，@Target 指定了注解运用的地方。</p>
<p>你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。</p>
<p>类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值</p>
<blockquote>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>
<li>ElementType.FIELD 可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>
<li>ElementType.METHOD 可以给方法进行注解</li>
<li>ElementType.PACKAGE 可以给一个包进行注解</li>
<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>
</blockquote>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><blockquote>
<p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。<br>说的比较抽象。代码来解释。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p>
<p>可以这样理解：</p>
<p>老子非常有钱，所以人们给他贴了一张标签叫做富豪。</p>
<p>老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。</p>
<p>老子的孙子长大了，自然也是富豪。</p>
<p>这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。</p>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p>
<p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p>
<p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(Persons.class)</span></span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    String role <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Person(role=&quot;artist&quot;)</span></span><br><span class="line"><span class="meta">@Person(role=&quot;coder&quot;)</span></span><br><span class="line"><span class="meta">@Person(role=&quot;PM&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperMan</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p>
</blockquote>
<p><strong>什么是容器注解呢？</strong></p>
<blockquote>
<p>就是用来存放其它注解的地方。它本身也是一个注解。</p>
<p>我们再看看代码中的相关容器注解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。</p>
<blockquote>
<p>如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 SuperMan 贴上，相当于同时给他贴了程序员、产品经理、画家的标签。</p>
<p>我们可能对于 @Person(role=”PM”) 括号里面的内容感兴趣，它其实就是给 Person 这个注解的 role 属性赋值为 PM ，大家不明白正常，马上就讲到注解的属性这一块。</p>
</blockquote>
<h3 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h3><blockquote>
<p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">msg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。</p>
<p>赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation(id=3,msg=&quot;hello annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组。</p>
</blockquote>
<p>注解中属性可以有默认值，默认值需要用 default 关键值指定。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">msg</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestAnnotation 中 id 属性默认值为 -1，msg 属性默认值为 Hi。<br>它可以这样应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因为有默认值，所以无需要再在 @TestAnnotation 后面的括号里面进行赋值了，这一步可以省略。</p>
<blockquote>
<p>另外，还有一种情况。如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接接属性值填写到括号内。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面代码中，Check 这个注解只有 value 这个属性。所以可以这样应用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check(&quot;hi&quot;)</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>和这下面的效果是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check(value=&quot;hi&quot;)</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，还需要注意的一种情况是一个注解没有任何属性。比如</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Perform &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>那么在应用这个注解的时候，括号都可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Perform</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java-预置的注解"><a href="#Java-预置的注解" class="headerlink" title="Java 预置的注解"></a>Java 预置的注解</h3><p>学习了上面相关的知识，我们已经可以自己定义一个注解了。其实 Java 语言本身已经提供了几个现成的注解。</p>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4><blockquote>
<p>这个元素是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Noting has to say!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I have a dream!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个 Hero 类，它有两个方法 say() 和 speak() ，其中 say() 被 @Deprecated 注解。然后我们在 IDE 中分别调用它们。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/Snipaste_2022-03-01_18-22-57.png" style="zoom:150%;" /></p>
<blockquote>
<p>可以看到，say() 方法上面被一条直线划了一条，这其实就是编译器识别后的提醒效果。</p>
</blockquote>
<h4 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h4><blockquote>
<p>这个大家应该很熟悉了，提示子类要复写父类中被 @Override 修饰的方法</p>
</blockquote>
<h4 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h4><blockquote>
<p>阻止警告的意思。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">    hero.say();</span><br><span class="line">    hero.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h4><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span> <span class="comment">// Not actually safe!</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(List&lt;String&gt;... stringLists)</span> &#123;</span><br><span class="line">    Object[] array = stringLists;</span><br><span class="line">    List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">    array[<span class="number">0</span>] = tmpList; <span class="comment">// Semantically invalid, but compiles without warnings</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// Oh no, ClassCastException at runtime!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，编译阶段不会报错，但是运行时会抛出 ClassCastException 这个异常，所以它虽然告诉开发者要妥善处理，但是开发者自己还是搞砸了。</p>
<p>Java 官方文档说，未来的版本会授权编译器对这种不安全的操作产生错误警告。</p>
<h4 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h4><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。</p>
<p>函数式接口 (Functional Interface) 就是一个具有一个方法的普通接口。<br>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们进行线程开发中常用的 Runnable 就是一个典型的函数式接口，上面源码可以看到它就被 @FunctionalInterface 注解。</p>
<p>可能有人会疑惑，函数式接口标记有什么用，这个原因是函数式接口可以很容易转换为 Lambda 表达式。这是另外的主题了，有兴趣的同学请自己搜索相关知识点学习。</p>
</blockquote>
<h3 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h3><p>博文前面的部分讲了注解的基本语法，现在是时候检测我们所学的内容了。</p>
<blockquote>
<p>我通过用标签来比作注解，前面的内容是讲怎么写注解，然后贴到哪个地方去，而现在我们要做的工作就是检阅这些标签内容。 形象的比喻就是你把这些注解标签在合适的时候撕下来，然后检阅上面的内容信息。</p>
<p>要想正确检阅注解，离不开一个手段，那就是反射。</p>
</blockquote>
<h4 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h4><blockquote>
<p>注解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>然后通过 getAnnotation() 方法来获取 Annotation 对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A <span class="title function_">getAnnotation</span><span class="params">(Class&lt;A&gt; annotationClass)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>或者是 getAnnotations() 方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p>
<p>如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasAnnotation</span> <span class="operator">=</span> Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">            <span class="type">TestAnnotation</span> <span class="variable">testAnnotation</span> <span class="operator">=</span> Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">            System.out.println(<span class="string">&quot;id:&quot;</span>+testAnnotation.id());</span><br><span class="line">            System.out.println(<span class="string">&quot;msg:&quot;</span>+testAnnotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id:-<span class="number">1</span></span><br><span class="line">msg:</span><br></pre></td></tr></table></figure>
<p>这个正是 TestAnnotation 中 id 和 msg 的默认值。</p>
<p>上面的例子中，只是检阅出了注解在类上的注解，其实属性、方法上的注解照样是可以的。同样还是要假手于反射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation(msg=&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@Check(value=&quot;hi&quot;)</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="meta">@Perform</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        hero.say();</span><br><span class="line">        hero.speak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasAnnotation</span> <span class="operator">=</span> Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line">        <span class="keyword">if</span> ( hasAnnotation ) &#123;</span><br><span class="line">            <span class="type">TestAnnotation</span> <span class="variable">testAnnotation</span> <span class="operator">=</span> Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">            <span class="comment">//获取类的注解</span></span><br><span class="line">            System.out.println(<span class="string">&quot;id:&quot;</span>+testAnnotation.id());</span><br><span class="line">            System.out.println(<span class="string">&quot;msg:&quot;</span>+testAnnotation.msg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> Test.class.getDeclaredField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            a.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//获取一个成员变量上的注解</span></span><br><span class="line">            <span class="type">Check</span> <span class="variable">check</span> <span class="operator">=</span> a.getAnnotation(Check.class);</span><br><span class="line">            <span class="keyword">if</span> ( check != <span class="literal">null</span> ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;check value:&quot;</span>+check.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">testMethod</span> <span class="operator">=</span> Test.class.getDeclaredMethod(<span class="string">&quot;testMethod&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( testMethod != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="comment">// 获取方法中的注解</span></span><br><span class="line">                Annotation[] ans = testMethod.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ans.length;i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;method testMethod annotation:&quot;</span>+ans[i].annotationType().getSimpleName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id:-<span class="number">1</span></span><br><span class="line">msg:hello</span><br><span class="line">check value:hi</span><br><span class="line">method testMethod annotation:Perform</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，如果一个注解要在运行时被成功提取，那么 @Retention(RetentionPolicy.RUNTIME) 是必须的。</p>
</blockquote>
<h3 id="注解的使用场景"><a href="#注解的使用场景" class="headerlink" title="注解的使用场景"></a>注解的使用场景</h3><p>我相信博文讲到这里大家都很熟悉了注解，但是有不少同学肯定会问，注解到底有什么用呢？</p>
<p>对啊注解到底有什么用？</p>
<p>我们不妨将目光放到 Java 官方文档上来。</p>
<p>文章开始的时候，我用标签来类比注解。但标签比喻只是我的手段，而不是目的。为的是让大家在初次学习注解时能够不被那些抽象的新概念搞懵。既然现在，我们已经对注解有所了解，我们不妨再仔细阅读官方最严谨的文档。</p>
<blockquote>
<p>注解是一系列<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=元数据&amp;spm=1001.2101.3001.7020">元数据</a>，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。</p>
<p>注解有许多用处，主要如下：</p>
<ul>
<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。</li>
<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取<br>值得注意的是，注解不是代码本身的一部分。</li>
</ul>
</blockquote>
<p>如果难于理解，可以这样看。罗永浩还是罗永浩，不会因为某些人对于他“傻x”的评价而改变，标签只是某些人对于其他事物的评价，但是标签不会改变事物本身，标签只是特定人群的手段。所以，注解同样无法改变代码本身，注解只是某些工具的的工具。</p>
<p>还是回到官方文档的解释上，注解主要针对的是编译器和其它工具软件(SoftWare tool)。</p>
<p>当开发者使用了Annotation 修饰了类、方法、Field 等成员之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。</p>
<p><strong>现在，我们可以给自己答案了，注解有什么用？给谁用？给 编译器或者 APT 用的。</strong></p>
<p>如果，你还是没有搞清楚的话，我亲自写一个好了。</p>
<h4 id="亲手自定义注解完成某个目的"><a href="#亲手自定义注解完成某个目的" class="headerlink" title="亲手自定义注解完成某个目的"></a>亲手自定义注解完成某个目的</h4><p>我要写一个测试框架，测试程序员的代码有无明显的异常。</p>
<p>—— 程序员 A : 我写了一个类，它的名字叫做 NoBug，因为它所有的方法都没有错误。<br>—— 我：自信是好事，不过为了防止意外，让我测试一下如何？<br>—— 程序员 A: 怎么测试？<br>—— 我：把你写的代码的方法都加上 @Jiecha 这个注解就好了。<br>—— 程序员 A: 好的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ceshi;</span><br><span class="line"><span class="keyword">import</span> ceshi.Jiecha;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoBug</span> &#123;</span><br><span class="line">    <span class="meta">@Jiecha</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">suanShu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Jiecha</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jiafa</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1+1=&quot;</span>+<span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Jiecha</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jiefa</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1-1=&quot;</span>+(<span class="number">1</span>-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Jiecha</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chengfa</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3 x 5=&quot;</span>+ <span class="number">3</span>*<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Jiecha</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chufa</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6 / 0=&quot;</span>+ <span class="number">6</span> / <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ziwojieshao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我写的程序没有 bug!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，有些方法上面运用了 @Jiecha 注解。</p>
<p>这个注解是我写的测试软件框架中定义的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ceshi;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Jiecha &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我再编写一个测试类 TestTool 就可以测试 NoBug 相应的方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ceshi;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">NoBug</span> <span class="variable">testobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoBug</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> testobj.getClass();</span><br><span class="line">        Method[] method = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//用来记录测试产生的 log 信息</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">log</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 记录异常的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">errornum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( Method m: method ) &#123;</span><br><span class="line">            <span class="comment">// 只有被 @Jiecha 标注过的方法才进行测试</span></span><br><span class="line">            <span class="keyword">if</span> ( m.isAnnotationPresent( Jiecha.class )) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    m.invoke(testobj, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                    errornum++;</span><br><span class="line">                    log.append(m.getName());</span><br><span class="line">                    log.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    log.append(<span class="string">&quot;has error:&quot;</span>);</span><br><span class="line">                    log.append(<span class="string">&quot;\n\r  caused by &quot;</span>);</span><br><span class="line">                    <span class="comment">//记录测试过程中，发生的异常的名称</span></span><br><span class="line">                    log.append(e.getCause().getClass().getSimpleName());</span><br><span class="line">                    log.append(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">                    <span class="comment">//记录测试过程中，发生的异常的具体信息</span></span><br><span class="line">                    log.append(e.getCause().getMessage());</span><br><span class="line">                    log.append(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.append(clazz.getSimpleName());</span><br><span class="line">        log.append(<span class="string">&quot; has  &quot;</span>);</span><br><span class="line">        log.append(errornum);</span><br><span class="line">        log.append(<span class="string">&quot; error.&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成测试报告</span></span><br><span class="line">        System.out.println(log.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890</span></span><br><span class="line"><span class="number">1</span>+<span class="number">1</span>=<span class="number">11</span></span><br><span class="line"><span class="number">1</span>-<span class="number">1</span>=<span class="number">0</span></span><br><span class="line"><span class="number">3</span> x <span class="number">5</span>=<span class="number">15</span></span><br><span class="line">chufa has error:</span><br><span class="line">  caused by ArithmeticException</span><br><span class="line">/ by zero</span><br><span class="line">NoBug has  <span class="number">1</span> error.</span><br></pre></td></tr></table></figure>
<p>提示 NoBug 类中的 chufa() 这个方法有异常，这个异常名称叫做 ArithmeticException，原因是运算过程中进行了除 0 的操作。</p>
<p>所以，NoBug 这个类有 Bug。</p>
<p>这样，通过注解我完成了我自己的目的，那就是对别人的代码进行测试。</p>
<p>所以，再问我注解什么时候用？我只能告诉你，这取决于你想利用它干什么用。</p>
<h3 id="注解应用实例"><a href="#注解应用实例" class="headerlink" title="注解应用实例"></a>注解应用实例</h3><p>注解运用的地方太多了，如：<br>JUnit 这个是一个测试框架，典型使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleUnitTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addition_isCorrect</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        assertEquals(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Test 标记了要进行测试的方法 addition_isCorrect().</p>
<p>还有例如ssm框架等运用了大量的注解。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://manamn.space">Gao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/08-Java%E8%BF%9B%E9%98%B6/">https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/08-Java%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://manamn.space" target="_blank">爱笑的Gao的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a><a class="post-meta__tags" href="/tags/Java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">Java自学笔记</a></div><div class="post_share"><div class="social-share" data-image="http://pic.netbian.com/uploads/allimg/220612/151918-16550183582aa7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89/"><img class="prev-cover" src="http://pic.netbian.com/uploads/allimg/220612/152947-165501898725ac.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">07  面向对象编程（OOP）</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/18/Java%E5%9F%BA%E7%A1%80/13-%E4%B8%87%E5%AD%97-C-%E8%AF%AD%E8%A8%80%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/"><img class="next-cover" src="http://pic.netbian.com/uploads/allimg/220602/001616-165410017685f8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">13 万字 C 语言从入门到精通保姆级教程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/01-Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="01  Java基础入门"><img class="cover" src="http://pic.netbian.com/uploads/allimg/211122/000739-16375108599425.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">01  Java基础入门</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/02-Java%E5%85%A5%E9%97%A8/" title="02 Java入门"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220620/235056-165574025622e4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">02 Java入门</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/03-Java%E5%9F%BA%E7%A1%80/" title="03  Java基础"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220618/000911-16554821517f03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">03  Java基础</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/04-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="04  Java流程控制"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220608/004436-165462027636ca.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">04  Java流程控制</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/05-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" title="05  数组与方法"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220605/231248-1654441968fc17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">05  数组与方法</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/06-IDEA%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" title="06  IDEA集成开发工具"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220612/154354-1655019834388a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">06  IDEA集成开发工具</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gao</div><div class="author-info__description">生活明朗 万物可爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/gaoziman"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gaoziman" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2942894660@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/692044806?spm_id_from=333.1007.0.0" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2942894660&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#08-Java%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">08  Java进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">final使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">final变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">final修饰基本数据类型变量和引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">final类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">final关键字的知识点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.</span> <span class="toc-text">final关键字的最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">final的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%A9%BA%E7%99%BDfinal"><span class="toc-number">1.2.2.</span> <span class="toc-text">关于空白final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">final内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E4%BC%9A%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6%E5%92%8C%E6%95%88%E7%8E%87%E5%90%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用final修饰方法会提高速度和效率吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8final%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E4%BC%9A%E8%AE%A9%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9B"><span class="toc-number">1.2.5.</span> <span class="toc-text">使用final修饰变量会让变量的值不能被改变吗；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E7%BB%84%E5%86%85%E9%83%A8%E4%B8%8D%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="toc-number">1.2.6.</span> <span class="toc-text">如何保证数组内部不被修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%89%E6%9D%A1%E8%A7%84%E5%88%99"><span class="toc-number">1.2.7.</span> <span class="toc-text">final方法的三条规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.</span> <span class="toc-text">抽象类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">一、抽象类的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">二、抽象类的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">三、抽象类的使用限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">一、基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">二、接口的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%88%E6%A0%87%E5%87%86%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">三、接口的实际应用（标准定义）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">四、接口的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E6%80%A7"><span class="toc-number">1.3.2.4.1.</span> <span class="toc-text">规范性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%80%A7"><span class="toc-number">1.3.2.4.2.</span> <span class="toc-text">拓展性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">五、接口中的成员特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.5.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.5.2.</span> <span class="toc-text">接口中没有构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.3.2.5.3.</span> <span class="toc-text">接口中没有构造代码块</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">六、抽象类和接口有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">七、思维导图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">Object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Object%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">一、Object类简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">二. Object类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">String类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">常用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">异常处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.7.2.</span> <span class="toc-text">异常体系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.3.</span> <span class="toc-text">初识异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF"><span class="toc-number">1.7.4.</span> <span class="toc-text">异常和错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.5.</span> <span class="toc-text">异常的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E4%B8%8D%E8%B4%9F%E8%B4%A3%E4%BB%BB%E2%80%9D%E7%9A%84throws"><span class="toc-number">1.7.6.</span> <span class="toc-text">“不负责任”的throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A0%E7%BB%93%E7%9A%84finally"><span class="toc-number">1.7.7.</span> <span class="toc-text">纠结的finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw-JRE%E4%B9%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.8.</span> <span class="toc-text">throw : JRE也使用的关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.9.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.7.10.</span> <span class="toc-text">异常的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA%E5%BC%82%E5%B8%B8%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.7.11.</span> <span class="toc-text">JAVA异常常见面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.8.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9B%86%E5%90%88%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.8.1.</span> <span class="toc-text">一、集合大纲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1. 集合和数组的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connection%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">Connection集合的方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">常用集合的分类：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81List%E5%92%8CSet%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.8.2.</span> <span class="toc-text">二、List和Set集合详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-list-%E5%92%8C-set%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1.list 和 set的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-List%EF%BC%9A"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2.List：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Set%EF%BC%9A"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">3.Set：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-List%E5%92%8CSet%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">4.List和Set总结：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">5. 何时使用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Map%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.8.3.</span> <span class="toc-text">三、Map详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1. 注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Map%EF%BC%9A"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2.Map：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HashMap%E5%92%8CHashTable%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3. HashMap和HashTable的比较：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-TreeMap%EF%BC%9A"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">4. TreeMap：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Map%E7%9A%84%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.8.3.5.</span> <span class="toc-text">5. Map的其他类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">1.8.3.6.</span> <span class="toc-text">6. 小结：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%85%B6%E4%BB%96%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">1.8.3.7.</span> <span class="toc-text">7. 其他小结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaIO%E6%B5%81"><span class="toc-number">1.9.</span> <span class="toc-text">JavaIO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8BIO%E6%B5%81"><span class="toc-number">1.9.1.</span> <span class="toc-text">一、初始IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">IO流分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.9.1.1.1.</span> <span class="toc-text">1. 输入输出流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.9.1.1.2.</span> <span class="toc-text">2. 字节流与字符流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.9.1.1.3.</span> <span class="toc-text">3、节点流和处理流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">案例实操</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81FileInputStream%E3%80%81FileOutputStream%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%89"><span class="toc-number">1.9.1.2.1.</span> <span class="toc-text">1、FileInputStream、FileOutputStream（字节流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81BufferedInputStream%E3%80%81BufferedOutputStream%EF%BC%88%E7%BC%93%E5%86%B2%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%89"><span class="toc-number">1.9.1.2.2.</span> <span class="toc-text">2、BufferedInputStream、BufferedOutputStream（缓冲字节流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81InputStreamReader%E3%80%81OutputStreamWriter%EF%BC%88%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89"><span class="toc-number">1.9.1.2.3.</span> <span class="toc-text">3、InputStreamReader、OutputStreamWriter（字符流）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BE%BF%E6%8D%B7%E7%B1%BB"><span class="toc-number">1.9.1.2.4.</span> <span class="toc-text">4、字符流便捷类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81BufferedReader%E3%80%81BufferedWriter%EF%BC%88%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%89"><span class="toc-number">1.9.1.2.5.</span> <span class="toc-text">5、BufferedReader、BufferedWriter（字符缓冲流）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81IO%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.9.2.</span> <span class="toc-text">二、IO流对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">字符流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.3.</span> <span class="toc-text">IO流方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">字节流方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">字符流方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%86%85%E5%AE%B9"><span class="toc-number">1.9.4.</span> <span class="toc-text">附加内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E3%80%81%E5%AD%97%E8%8A%82%E3%80%81%E5%AD%97%E7%AC%A6"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">位、字节、字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81%E6%95%88%E7%8E%87%E7%9B%B8%E6%AF%94"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">IO流效率相比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.10.1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">什么是进程，线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">线程的应用实例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">为什么需要使用多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">CPU调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.10.2.</span> <span class="toc-text">一、Java多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">创建线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.1.1.</span> <span class="toc-text">1.继承Thread类创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.1.2.</span> <span class="toc-text">2.实现Runnable接口创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.1.3.</span> <span class="toc-text">3.使用匿名内部类形式创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="toc-number">1.10.2.1.4.</span> <span class="toc-text">4.使用Lambda表达式创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8Callable%E5%92%8C-Future%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.1.5.</span> <span class="toc-text">5.使用Callable和 Future创建线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA"><span class="toc-number">1.10.2.1.6.</span> <span class="toc-text">6.使用线程池创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Spring%E4%B8%AD%E7%9A%84-Async%E5%88%9B%E5%BB%BA"><span class="toc-number">1.10.2.1.7.</span> <span class="toc-text">7.Spring中的@Async创建</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">Thread中的常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Thread-currentThread-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.2.1.</span> <span class="toc-text">1.Thread.currentThread() 方法可以获得当前线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-setName-getName"><span class="toc-number">1.10.2.2.2.</span> <span class="toc-text">2.setName()&#x2F;getName</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-isAlive"><span class="toc-number">1.10.2.2.3.</span> <span class="toc-text">3.isAlive()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-sleep"><span class="toc-number">1.10.2.2.4.</span> <span class="toc-text">4.sleep()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-getId-java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E7%BC%96%E5%8F%B7"><span class="toc-number">1.10.2.2.5.</span> <span class="toc-text">5.getId() java中的线程都有一个唯一编号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-yield-%E6%94%BE%E5%BC%83%E5%BD%93%E5%89%8D%E7%9A%84cpu%E8%B5%84%E6%BA%90"><span class="toc-number">1.10.2.2.6.</span> <span class="toc-text">6.yield() 放弃当前的cpu资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-setPriority-%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.10.2.2.7.</span> <span class="toc-text">7.setPriority() 设置线程的优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-interrupt-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B-Thread%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.10.2.2.8.</span> <span class="toc-text">8.interrupt()中断线程 (Thread中的方法。)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-setDaemon-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.10.2.2.9.</span> <span class="toc-text">9.setDaemon() 守护线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">线程的状态（线程的生命周期）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E7%AF%87"><span class="toc-number">1.10.3.</span> <span class="toc-text">二、线程安全原理篇</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">多线程的好处：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">多线程的问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B4%BB%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.10.3.2.1.</span> <span class="toc-text">常见的线程活性问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.10.3.2.2.</span> <span class="toc-text">什么是线程安全问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7-Atomic-%EF%BC%9A"><span class="toc-number">1.10.3.2.3.</span> <span class="toc-text">原子性(Atomic)：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7-visbility-%EF%BC%9A"><span class="toc-number">1.10.3.2.4.</span> <span class="toc-text">可见性(visbility)：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7-Ordering-%EF%BC%9A"><span class="toc-number">1.10.3.2.5.</span> <span class="toc-text">有序性(Ordering)：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E4%B8%8EJMM"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">JVM与JMM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">JVM运行时数据区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.10.3.5.</span> <span class="toc-text">出现线程不安全的例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.10.4.</span> <span class="toc-text">三、线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.4.0.1.</span> <span class="toc-text">锁的概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%94%81%EF%BC%9Asynchronized"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">内部锁：synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">synchronized的几种使用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%847%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">多线程访问同步方法的7种情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.4.4.</span> <span class="toc-text">死锁的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.10.5.</span> <span class="toc-text">四、线程之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.5.1.</span> <span class="toc-text">等待&#x2F;通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt-%E6%96%B9%E6%B3%95%E4%BC%9A%E4%B8%AD%E6%96%ADwait"><span class="toc-number">1.10.5.2.</span> <span class="toc-text">interrupt()方法会中断wait()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notify-%E4%B8%8EnotifyAll"><span class="toc-number">1.10.5.3.</span> <span class="toc-text">notify()与notifyAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-long"><span class="toc-number">1.10.5.4.</span> <span class="toc-text">wait(long)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6%E5%8F%91%E7%94%9F%E4%BA%86%E5%8F%98%E5%8C%96"><span class="toc-number">1.10.5.5.</span> <span class="toc-text">wait() 等待条件发生了变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">1.10.5.6.</span> <span class="toc-text">join()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81Callable%E4%B8%8EFuture"><span class="toc-number">1.10.6.</span> <span class="toc-text">五、Callable与Future</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.10.6.0.1.</span> <span class="toc-text">Future接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FutureTask%E7%B1%BB"><span class="toc-number">1.10.6.1.</span> <span class="toc-text">FutureTask类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.11.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">一、反射的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9F%A5%E7%9C%8BClass%E7%B1%BB%E5%9C%A8Java%E4%B8%ADapi%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3%EF%BC%89"><span class="toc-number">1.11.2.</span> <span class="toc-text">二、查看Class类在Java中api详解（查阅文档）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.3.</span> <span class="toc-text">三、反射的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">1、获取Class对象的三种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">2、通过反射获取构造方法并使用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">3、获取成员变量并调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">4、获取成员方法并调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%8F%8D%E5%B0%84main%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.3.5.</span> <span class="toc-text">5、反射main方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B6%E5%AE%83%E4%BD%BF%E7%94%A8%E4%B9%8B%E2%80%94-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-number">1.11.3.6.</span> <span class="toc-text">6、反射方法的其它使用之—-通过反射运行配置文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B6%E5%AE%83%E4%BD%BF%E7%94%A8%E4%B9%8B%E2%80%94-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B6%8A%E8%BF%87%E6%B3%9B%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">1.11.3.7.</span> <span class="toc-text">7、反射方法的其它使用之—-通过反射越过泛型检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.12.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">注解的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%A6%82%E5%90%8C%E6%A0%87%E7%AD%BE"><span class="toc-number">1.12.2.</span> <span class="toc-text">注解如同标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.12.3.</span> <span class="toc-text">注解的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.12.4.</span> <span class="toc-text">注解的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.12.5.</span> <span class="toc-text">注解的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.12.6.</span> <span class="toc-text">元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Retention"><span class="toc-number">1.12.6.1.</span> <span class="toc-text">@Retention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Documented"><span class="toc-number">1.12.6.2.</span> <span class="toc-text">@Documented</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Target"><span class="toc-number">1.12.6.3.</span> <span class="toc-text">@Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inherited"><span class="toc-number">1.12.6.4.</span> <span class="toc-text">@Inherited</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Repeatable"><span class="toc-number">1.12.6.5.</span> <span class="toc-text">@Repeatable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.12.7.</span> <span class="toc-text">注解的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E9%A2%84%E7%BD%AE%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.12.8.</span> <span class="toc-text">Java 预置的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deprecated"><span class="toc-number">1.12.8.1.</span> <span class="toc-text">@Deprecated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Override"><span class="toc-number">1.12.8.2.</span> <span class="toc-text">@Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SuppressWarnings"><span class="toc-number">1.12.8.3.</span> <span class="toc-text">@SuppressWarnings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SafeVarargs"><span class="toc-number">1.12.8.4.</span> <span class="toc-text">@SafeVarargs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FunctionalInterface"><span class="toc-number">1.12.8.5.</span> <span class="toc-text">@FunctionalInterface</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8F%90%E5%8F%96"><span class="toc-number">1.12.9.</span> <span class="toc-text">注解的提取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">1.12.9.1.</span> <span class="toc-text">注解与反射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.12.10.</span> <span class="toc-text">注解的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%B2%E6%89%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%8C%E6%88%90%E6%9F%90%E4%B8%AA%E7%9B%AE%E7%9A%84"><span class="toc-number">1.12.10.1.</span> <span class="toc-text">亲手自定义注解完成某个目的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.12.11.</span> <span class="toc-text">注解应用实例</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/" title="Web环境搭建以及Servlet入门"><img src="http://pic.netbian.com/uploads/allimg/210827/235918-1630079958392e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web环境搭建以及Servlet入门"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/" title="Web环境搭建以及Servlet入门">Web环境搭建以及Servlet入门</a><time datetime="2022-10-16T15:01:07.000Z" title="发表于 2022-10-16 23:01:07">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/" title="一文学懂JSP"><img src="http://pic.netbian.com/uploads/allimg/221002/214642-1664718402e8b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂JSP"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/" title="一文学懂JSP">一文学懂JSP</a><time datetime="2022-10-16T15:00:49.000Z" title="发表于 2022-10-16 23:00:49">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/" title="一文学懂Cookie与Session的区别"><img src="http://pic.netbian.com/uploads/allimg/210831/102129-16303764895142.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂Cookie与Session的区别"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/" title="一文学懂Cookie与Session的区别">一文学懂Cookie与Session的区别</a><time datetime="2022-10-16T15:00:28.000Z" title="发表于 2022-10-16 23:00:28">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" title="一文学懂过滤器和监听器"><img src="http://pic.netbian.com/uploads/allimg/220909/000311-16626529918d5d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂过滤器和监听器"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" title="一文学懂过滤器和监听器">一文学懂过滤器和监听器</a><time datetime="2022-10-16T15:00:12.000Z" title="发表于 2022-10-16 23:00:12">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" title="一文了解转发与重定向"><img src="http://pic.netbian.com/uploads/allimg/210423/224716-16191892361adb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文了解转发与重定向"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" title="一文了解转发与重定向">一文了解转发与重定向</a><time datetime="2022-10-16T14:59:54.000Z" title="发表于 2022-10-16 22:59:54">2022-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Gao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="/js/diytitle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在湘进行备案" title=""><img src="https://img.shields.io/badge/湘ICP备-2022004213号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/js/runtime/runtime.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_213.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/随笔⌚/&quot;);" href="javascript:void(0);">随笔⌚</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">大学学习史</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_46.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/转载/&quot;);" href="javascript:void(0);">转载</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">前端成长历程</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_53.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM上篇/&quot;);" href="javascript:void(0);">JVM上篇</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">生活欢乐多</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM下篇/&quot;);" href="javascript:void(0);">JVM下篇</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JavaSE/&quot;);" href="javascript:void(0);">JavaSE</a><span class="categoryBar-list-count">19</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM中篇/&quot;);" href="javascript:void(0);">JVM中篇</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/重学Java基础/&quot;);" href="javascript:void(0);">重学Java基础</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL-shk/&quot;);" href="javascript:void(0);">MySQL-shk</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_214.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习路线/&quot;);" href="javascript:void(0);">学习路线</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_62.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/教程/&quot;);" href="javascript:void(0);">教程</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文档/&quot;);" href="javascript:void(0);">文档</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_189.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java自学笔记/&quot;);" href="javascript:void(0);">Java自学笔记</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_61.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C语言/&quot;);" href="javascript:void(0);">C语言</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);">Java</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java知识点/&quot;);" href="javascript:void(0);">Java知识点</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MyBatis/&quot;);" href="javascript:void(0);">MyBatis</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Thymeleaf/&quot;);" href="javascript:void(0);">Thymeleaf</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/多线程/&quot;);" href="javascript:void(0);">多线程</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java-Basic/&quot;);" href="javascript:void(0);">Java-Basic</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_214.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/HTTP/&quot;);" href="javascript:void(0);">HTTP</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_62.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Web网页技术/&quot;);" href="javascript:void(0);">Web网页技术</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper_container_card" style="height: auto;width: 100%"><div id="random"><div id="random-banner"><canvas id="peoplecanvas"></canvas></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://tx2.a.yximgs.com/udata/music/music_f307a39407e74b1ab48f8409b8b0c3210.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt="">2021最新版java学习路线</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://nwjshm.cn/usr/themes/Cuteen/static/img/default-list-bg.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt="">随机图api</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper_init.js"></script><script data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/people.min.js"></script><script async src="/anzhiyu/random.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>