<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>07  面向对象编程（OOP） | 爱笑的Gao的个人博客</title><meta name="keywords" content="Java,Java基础,Java自学笔记"><meta name="author" content="Gao"><meta name="copyright" content="Gao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="07  面向对象编程（OOP）Java面向对象三大特性（基础篇）面向对象简称 OO（Object Oriented），20 世纪 80 年代以后，有了面向对象分析（OOA）、 面向对象设计（OOD）、面向对象 程序设计（OOP）等新的系统开发方式模型的研究。 对语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组 成了完整的程序设计，这些">
<meta property="og:type" content="article">
<meta property="og:title" content="07  面向对象编程（OOP）">
<meta property="og:url" content="https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89/index.html">
<meta property="og:site_name" content="爱笑的Gao的个人博客">
<meta property="og:description" content="07  面向对象编程（OOP）Java面向对象三大特性（基础篇）面向对象简称 OO（Object Oriented），20 世纪 80 年代以后，有了面向对象分析（OOA）、 面向对象设计（OOD）、面向对象 程序设计（OOP）等新的系统开发方式模型的研究。 对语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组 成了完整的程序设计，这些">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://pic.netbian.com/uploads/allimg/220612/152947-165501898725ac.jpg">
<meta property="article:published_time" content="2022-06-12T14:37:53.000Z">
<meta property="article:modified_time" content="2022-10-16T16:05:33.955Z">
<meta property="article:author" content="Gao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="Java自学笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pic.netbian.com/uploads/allimg/220612/152947-165501898725ac.jpg"><link rel="shortcut icon" href="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?"><link rel="canonical" href="https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '07  面向对象编程（OOP）',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-10-17 00:05:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="/js/title.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Jayhrn/fontawesome-pro/css/all.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/remixicon@2.5.0/fonts/remixicon.css"><script src="https://at.alicdn.com/t/c/font_3570527_dthoqrrv2tv.css"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="爱笑的Gao的个人博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#iconfont icon-xiangji1"></use></svg><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://pic.netbian.com/uploads/allimg/220612/152947-165501898725ac.jpg')"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span>JAYHRN</span></a></span><span id="page_name"><a id="page-name-text" title="回到顶部" onclick="btf.scrollToDest(0,500)"><span>爱笑的Gao的个人博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#iconfont icon-xiangji1"></use></svg><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg><span> 关于我</span></a></div></div></div><div id="hotkey"><div id="search-button"><a class="site-page social-icon search" title="搜索"><i class="ri-search-eye-line"></i></a></div><div id="randompost-button"><a class="site-page" title="随机文章" onclick="toRandomPost()"><i class="ri-subway-fill"></i></a></div><div id="mode-button"><a class="site-page" title="浅色和深色模式转换" onclick="switchDarkMode()"><i class="ri-sun-fill"></i></a></div><div id="top-button"><a class="site-page" title="回到顶部" onclick="btf.scrollToDest(0,500)"><i class="ri-plane-fill"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">07  面向对象编程（OOP）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-12T14:37:53.000Z" title="发表于 2022-06-12 22:37:53">2022-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-16T16:05:33.955Z" title="更新于 2022-10-17 00:05:33">2022-10-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">Java自学笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="07  面向对象编程（OOP）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="07-面向对象编程（OOP）"><a href="#07-面向对象编程（OOP）" class="headerlink" title="07  面向对象编程（OOP）"></a>07  面向对象编程（OOP）</h1><h2 id="Java面向对象三大特性（基础篇）"><a href="#Java面向对象三大特性（基础篇）" class="headerlink" title="Java面向对象三大特性（基础篇）"></a>Java面向对象三大特性（基础篇）</h2><p>面向对象简称 OO（Object Oriented），20 世纪 80 年代以后，有了面向对象分析（OOA）、 面向对象设计（OOD）、面向对象</p>
<p>程序设计（OOP）等新的系统开发方式模型的研究。</p>
<p>对语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组</p>
<p>成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序</p>
<p>开发。</p>
<h4 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h4><p>Java 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，</p>
<p>也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<ul>
<li><p>对象具有属性和行为。</p>
</li>
<li><p>对象具有变化的状态。</p>
</li>
<li><p>对象具有唯一性。</p>
</li>
<li><p>对象都是某个类别的实例。</p>
</li>
<li><p>一切皆为对象，真实世界中的所有事物都可以视为对象。</p>
</li>
</ul>
<h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><ul>
<li><p>面向过程：<br>一种较早的编程思想，顾名思义就是该思想是站着过程的角度思考问题，强调的就是功能行为，功能的执行过程，即先后顺序，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实现。使用的时候依次调用函数就可以了。</p>
</li>
<li><p>面向过程的设计：<br>最小的程序单元是函数，每个函数负责完成某一个功能，用于接受输入数据，函数对输入数据进行处理，然后输出结果数据，整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。<br>  面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。</p>
</li>
<li><p>面向过程的缺陷：<br>是采用自顶而下的设计模式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块又细分为更小的子模块，如此类推，直到将模块细化为一个个函数。</p>
</li>
<li><p>存在的问题</p>
<p>​        设计不够直观，与人类的思维习惯不一致<br>系统软件适应新差，可拓展性差，维护性低</p>
</li>
<li><p>面向对象：</p>
<p>​        一种基于面向过程的新编程思想，顾名思义就是该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象。</p>
<p>具备某种功能的实体，称为对象。面向对象最小的程序单元是：类。面向对象更加符合常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。</p>
</li>
</ul>
<p>在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。</p>
<h2 id="面向对象的三大核心特性简介"><a href="#面向对象的三大核心特性简介" class="headerlink" title="面向对象的三大核心特性简介"></a>面向对象的三大核心特性简介</h2><p>面向对象开发模式更有利于人们开拓思维，在具体的开发过程中便于程序的划分，方便程序员分工合作，提高开发效率。</p>
<p>该开发模式之所以使程序设计更加完善和强大，主要是因为面向对象具有继承、封装和多态 3 个核心特性。</p>
<h4 id="1、继承的概念"><a href="#1、继承的概念" class="headerlink" title="1、继承的概念"></a><strong>1、继承的概念</strong></h4><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/14B0951E-FC75-47A3-B611-4E1883887339.jpg" alt="img"></p>
<p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p>
<p>食草动物和食肉动物又是属于动物类。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
<p><strong>2、Java 多态</strong></p>
<hr>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/dt-java.png" alt="img"></p>
<p>多态性是对象多种表现形式的体现。</p>
<blockquote>
<p>现实中，比如我们按下 F1 键这个动作：</p>
<ul>
<li><p>如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；</p>
</li>
<li><p>如果当前在 Word 下弹出的就是 Word 帮助；</p>
</li>
<li><p>在 Windows 下弹出的就是 Windows 帮助和支持。</p>
</li>
</ul>
<p>同一个事件发生在不同的对象上会产生不同的结果。</p>
</blockquote>
<h4 id="3、Java-封装"><a href="#3、Java-封装" class="headerlink" title="3、Java 封装"></a><strong>3、Java 封装</strong></h4><hr>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<h2 id="面向对象编程三大特性详解"><a href="#面向对象编程三大特性详解" class="headerlink" title="面向对象编程三大特性详解"></a>面向对象编程三大特性详解</h2><p>面向对象编程是利用 类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态，封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。</p>
<h4 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h4><h4 id="1、继承的概念-1"><a href="#1、继承的概念-1" class="headerlink" title="1、继承的概念"></a>1、继承的概念</h4><p>如同生活中的子女继承父母拥有的所有财产，程序中的继承性是指子类拥有父类<a target="_blank" rel="noopener" href="http://c.biancheng.net/data_structure/">数据结构</a>的方法和机制，这是类之间的一种关系；继承只能是单继承。</p>
<p>例如定义一个语文老师类和数学老师类，如果不采用继承方式，那么两个类中需要定义的属性和方法如图 1 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/3-1Q01G40613629.jpg" alt=""><br>图1 语文老师类和数学老师类中的属性和方法</p>
<p>从图 1 能够看出，语文老师类和数学老师类中的许多属性和方法相同，这些相同的属性和方法可以提取出来放在一个父类中，这个父类用于被语文老师类和数学老师类继承。当然父类还可以继承别的类，如图 2 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/3-1Q01G40AR23.jpg" alt=""><br>图2 父类继承示例图</p>
<p>总结图 2 的继承关系，可以用概括的树形关系来表示，如图 3 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/3-1Q01G40RT47.jpg" alt=""><br>图3 类继承示例图</p>
<p>从图 3 中可以看出，学校主要人员是一个大的类别，老师和学生是学校主要人员的两个子类，而老师又可以分为语文老师和数学老师两个子类，学生也可以分为班长和组长两个子类。</p>
<p>使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。</p>
<p>继承是类与类的一种关系，是一种“is a”的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701123011243-2128400556.png" alt="img"></p>
<p>注：java中的继承是<strong>单继承</strong>，即<strong>一个类只有一个父类。</strong></p>
<p><strong>补充：Java中的继承只能单继承，但是可以通过内部类继承其他类来实现多继承。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span> <span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;son go&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span> <span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;son eat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;zzzzzz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//匿名内部类实现的多继承</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Mother</span>().cook();</span><br><span class="line"><span class="comment">//内部类继承第二个父类来实现多继承</span></span><br><span class="line"><span class="type">Mom</span> <span class="variable">mom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mom</span>();</span><br><span class="line">mom.cook();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Mom</span> <span class="keyword">extends</span> <span class="title class_">Mother</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;mom cook&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、继承的好处"><a href="#2、继承的好处" class="headerlink" title="2、继承的好处"></a>2、继承的好处</h4><p>子类拥有父类的所有属性和方法（除了private修饰的属性不能拥有）从而实现了实现代码的复用；</p>
<h4 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701123421961-647167245.png" alt="img"></p>
<hr>
<h5 id="A、方法的重写"><a href="#A、方法的重写" class="headerlink" title="A、方法的重写"></a>A、方法的重写</h5><p>子类如果对继承的父类的方法不满意（不适合），可以自己编写继承的方法，这种方式就称为<strong>方法的重写。当调用方法时会优先调用子类的方法。</strong></p>
<p><strong>重写要注意：</strong></p>
<p>a、返回值类型</p>
<p>b、方法名</p>
<p>c、参数类型及个数</p>
<p>都要与父类继承的方法相同，才叫方法的重写。</p>
<p><strong>重载和重写的区别：</strong></p>
<p>方法重载：在同一个类中处理不同数据的多个相同方法名的多态手段。</p>
<p>方法重写：相对继承而言，子类中对父类已经存在的方法进行区别化的修改。</p>
<hr>
<h5 id="B、继承的初始化顺序"><a href="#B、继承的初始化顺序" class="headerlink" title="B、继承的初始化顺序"></a>B、继承的初始化顺序</h5><p>1、初始化父类再初始化子类</p>
<p>2、先执行初始化对象中属性，再执行构造方法中的初始化。</p>
<p>基于上面两点，我们就知道实例化一个子类，java程序的执行顺序是：</p>
<p><strong>父类对象属性初始化——&gt;父类对象构造方法——&gt;子类对象属性初始化—-&gt;子类对象构造方法</strong></p>
<p>下面有个形象的图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701144019071-1063399032.png" alt="img"></p>
<hr>
<h5 id="C、final关键字"><a href="#C、final关键字" class="headerlink" title="C、final关键字"></a>C、final关键字</h5><p>使用final关键字做标识有“最终的”含义。</p>
<p>1. final 修饰类，则该类<strong>不允许被继承。</strong></p>
<p>2. final 修饰方法，则该方法不允许被<strong>覆盖(重写)</strong>。</p>
<p>3. final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的<strong>初始化属性必须有值</strong>，或在**构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，**且初始化之后就不能改了，<strong>只能赋值一次</strong>。</p>
<p>4. final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为<strong>常量</strong>。</p>
<hr>
<h5 id="D、super关键字"><a href="#D、super关键字" class="headerlink" title="D、super关键字"></a>D、super关键字</h5><p>在对象的内部使用，可以代表父类对象。</p>
<p>1、访问父类的属性：super.age</p>
<p>2、访问父类的方法：super.eat()</p>
<p>super的应用：</p>
<p>首先我们知道子类的构造的过程当中必须调用父类的构造方法。其实这个过程已经隐式地使用了我们的super关键字。</p>
<p>这是因为如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法。</p>
<p>那么如果自己用super关键字在子类里调用父类的构造方法，则必须在子类的构造方法中的<strong>第一行</strong>。</p>
<p><strong>要注意的是：如果子类构造方法中既没有显示调用父类的构造方法，而父类没有无参的构造方法，则编译出错。</strong></p>
<p>（补充说明，虽然没有显示声明父类的无参的构造方法，系统会自动默认生成一个无参构造方法，但是，如果你声明了一个有参的构造方法，而没有声明无参的构造方法，这时系统不会动默认生成一个无参构造方法，此时称为父类有没有无参的构造方法。）</p>
<hr>
<h3 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h3><h4 id="1、封装的概念"><a href="#1、封装的概念" class="headerlink" title="1、封装的概念"></a>1、封装的概念</h4><p>封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。</p>
<ul>
<li><p>保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。</p>
</li>
<li><p>隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。</p>
</li>
<li><p>有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。</p>
</li>
<li><p>提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。</p>
</li>
</ul>
<p>Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p>
<h4 id="2、封装的优点"><a href="#2、封装的优点" class="headerlink" title="2、封装的优点"></a>2、封装的优点</h4><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p>封装的优点</p>
<ol>
<li><p>良好的封装能够减少耦合。</p>
</li>
<li><p>类内部的结构可以自由修改。</p>
</li>
<li><p>可以对成员变量进行更精确的控制。</p>
</li>
<li><p>隐藏信息，实现细节。</p>
</li>
</ol>
<p>Java 封装，说白了就是将一大坨公共通用的实现逻辑玩意，装到一个盒子里（class），出入口都在这个盒子上。你要用就将这个盒子拿来用，连接出入口，就能用了，不用就可以直接扔，对你代码没什么影响。</p>
<p>对程序员来说，使用封装的目的：</p>
<ol>
<li><p>偷懒，辛苦一次，后面都能少敲很多代码，增强了代码得复用性</p>
</li>
<li><p>简化代码，看起来更容易懂</p>
</li>
<li><p>隐藏核心实现逻辑代码，简化外部逻辑，并且不让其他人修改，jar 都这么干</p>
</li>
<li><p>一对一，一个功能就只为这个功能服务；避免头发绳子一块用，导致最后一团糟</p>
</li>
</ol>
<h4 id="3、封装的实现步骤"><a href="#3、封装的实现步骤" class="headerlink" title="3、封装的实现步骤"></a>3、封装的实现步骤</h4><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170630170717493-357592353.png" alt="img"></p>
<p>需要注意：对封装的属性不一定要通过get/set方法，其他方法也可以对封装的属性进行操作。当然最好使用get/set方法，比较标准。</p>
<hr>
<h5 id="A、访问修饰符"><a href="#A、访问修饰符" class="headerlink" title="A、访问修饰符"></a>A、访问修饰符</h5><p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170630174919274-1857293801.png" alt="img"></p>
<p>从表格可以看出<strong>从上到下封装性越来越差</strong>。</p>
<h5 id="B、this关键字"><a href="#B、this关键字" class="headerlink" title="B、this关键字"></a>B、this关键字</h5><p>1.this关键字<strong>代表当前对象</strong></p>
<p>this.属性 操作当前对象的属性</p>
<p>this.方法 调用当前对象的方法。</p>
<p>2.封装对象的属性的时候，经常会使用this关键字。</p>
<p>3.当getter和setter函数参数名和成员函数名重合的时候，<strong>可以使用this****区别。如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170630180217524-833886832.png" alt="img"></p>
<h5 id="C、Java-中的内部类"><a href="#C、Java-中的内部类" class="headerlink" title="C、Java 中的内部类"></a>C、Java 中的内部类</h5><p>内部类（ Inner Class ）就是定义在另外一个类<strong>里面</strong>的类。与之对应，包含内部类的类被称为外部类。</p>
<p>那么问题来了：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！</p>
<p>答：内部类的主要作用如下：</p>
<p>1. 内部类提供了<strong>更好的封装</strong>，可以把内部类<strong>隐藏</strong>在外部类之内，<strong>不允许</strong>同一个包中的其他类访问该类。</p>
<p>2. 内部类的方法可以<strong>直接访问外部类的所有数据</strong>，包括<strong>私有的数据</strong>。</p>
<p>3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。</p>
<p>内部类可分为以下几种：</p>
<ul>
<li><p>成员内部类</p>
</li>
<li><p>静态内部类</p>
</li>
<li><p>方法内部类</p>
</li>
<li><p>匿名内部类</p>
</li>
</ul>
<h3 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h3><h4 id="1、多态的概念"><a href="#1、多态的概念" class="headerlink" title="1、多态的概念"></a>1、多态的概念</h4><p>面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。多态概念可以用树形关系来表示，如图 4 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/3-1Q01G4095bW.jpg" alt=""></p>
<p>图4 多态示例图</p>
<p>从图 4 中可以看出，老师类中的许多属性和方法可以被语文老师类和数学老师类同时使用，这样也不易出错。</p>
<h4 id="2、多态的好处"><a href="#2、多态的好处" class="headerlink" title="2、多态的好处"></a>2、多态的好处</h4><p>可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>
<p>可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>
<p>接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。</p>
<p>灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>
<p>简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<p>子代父类实例化，然后就相当于一个父亲有很多儿子，送快递的给这个父亲的儿子送东西，他只需要送到父亲的家就行了，至于具体是那个儿子的，父亲还会分不清自己的儿子么，所以你就不用操心了。</p>
<p><strong>使用多态是一种好习惯</strong><br>多态方式声明是一种好的习惯。当我们创建的类，使用时，只用到它的超类或接口定义的方法时，我们可以将其索引声明为它的超类或接口类型。</p>
<p>它的好处是，如果某天我们对这个接口方法的实现方式变了，对这个接口又有一个新的实现类，我们的程序也需要使用最新的实现方式，此时只要将对象实现修改一下，索引无需变化。</p>
<p>比如Map&lt; String,String&gt; map = new HashMap &lt; String,String&gt;();</p>
<p>想换成HashTable实现，可以Map&lt; String,String&gt; map = new HashTable &lt; String,String&gt;();</p>
<p>比如写一个方法，参数要求传递List类型，你就可以用List list = new ArrayList()中的list传递，但是你写成ArrayList list = new ArrayList()是传递不进去的。尽管方法处理时都一样。另外，方法还可以根据你传递的不同list（ArrayList或者LinkList）进行不同处理。</p>
<h4 id="3、Java中的多态"><a href="#3、Java中的多态" class="headerlink" title="3、Java中的多态"></a>3、Java中的多态</h4><p>java里的多态主要表现在两个方面：</p>
<h5 id="A、引用多态"><a href="#A、引用多态" class="headerlink" title="A、引用多态"></a>A、引用多态</h5><p>父类的引用可以指向本类的对象；</p>
<p>父类的引用可以指向子类的对象；</p>
<p>这两句话是什么意思呢，让我们用代码来体验一下，首先我们创建一个父类Animal和一个子类Dog，在主函数里如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701155536086-1897896282.png" alt="img"></p>
<p>注意：我们不能使用一个子类的引用来指向父类的对象，如：<img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701155839586-923083573.png" alt="img">。</p>
<p>这里我们必须深刻理解引用多态的意义，才能更好记忆这种多态的特性。为什么子类的引用不能用来指向父类的对象呢？我在这里通俗给大家讲解一下：就以上面的例子来说，我们能说“狗是一种动物”，但是不能说“动物是一种狗”，狗和动物是父类和子类的继承关系，它们的从属是不能颠倒的。当父类的引用指向子类的对象时，该对象将只是看成一种特殊的父类（里面有重写的方法和属性），反之，一个子类的引用来指向父类的对象是不可行的！！</p>
<h5 id="B、方法多态"><a href="#B、方法多态" class="headerlink" title="B、方法多态"></a>B、方法多态</h5><p>根据上述创建的两个对象：本类对象和子类对象，同样都是父类的引用，当我们指向不同的对象时，它们调用的方法也是多态的。</p>
<p>创建本类对象时，调用的方法为本类方法；</p>
<p>创建子类对象时，调用的方法为子类重写的方法或者继承的方法；</p>
<p>使用多态的时候要注意：<strong>如果我们在子类中编写一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法！！！</strong></p>
<p><strong>注意： 继承是多态的基础。</strong></p>
<hr>
<h5 id="C、引用类型转换"><a href="#C、引用类型转换" class="headerlink" title="C、引用类型转换"></a>C、引用类型转换</h5><p>了解了多态的含义后，我们在日常使用多态的特性时经常需要进行引用类型转换。</p>
<p>引用类型转换：</p>
<p><strong>1.向上类型转换(隐式/自动类型转换)，是小类型转换到大类型</strong></p>
<p>就以上述的父类Animal和一个子类Dog来说明，当父类的引用可以指向子类的对象时，就是<strong>向上类型转换</strong>。如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701162630508-961507659.png" alt="img"></p>
<p><strong>2. 向下类型转换(强制类型转换)，是大类型转换到小类型(有风险,可能出现数据溢出)。</strong></p>
<p>将上述代码再加上一行，我们再次将父类转换为子类引用，那么会出现错误，编译器不允许我们直接这么做**，<strong>虽然我们知道这个父类引用指向的就是子类对象，但是编译器认为这种转换是存在风险的</strong>。**如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701162926477-3857975.png" alt="img"></p>
<p>那么我们该怎么解决这个问题呢，我们可以在animal前加上（Dog）来强制类型转换。如：<img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701163408383-2003626729.png" alt="img"></p>
<p>但是如果父类引用没有指向<strong>该子类的对象</strong>，则不能向下类型转换，虽然编译器不会报错，但是运行的时候程序会出错，如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701164229899-1055190774.png" alt="img"></p>
<p>其实这就是上面所说的子类的引用指向父类的对象，而强制转换类型也不能转换！！</p>
<p>还有一种情况是父类的引用指向<strong>其他子类的对象</strong>，则不能通过强制转为<strong>该子类的对象</strong>。如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701165133289-717439360.png" alt="img"></p>
<p>这是因为我们在编译的时候进行了强制类型转换，编译时的类型是我们强制转换的类型，所以编译器不会报错，而当我们运行的时候，程序给animal开辟的是Dog类型的内存空间，这与Cat类型内存空间不匹配，所以无法正常转换。这两种情况出错的本质是一样的，所以我们在使用强制类型转换的时候要特别注意这两种错误！！下面有个更安全的方式来实现向下类型转换。。。。</p>
<p><strong>3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。</strong></p>
<p><strong>instanceof</strong>是Java的一个二元操作符，和==，&gt;，&lt;是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。<strong>它的作用是测试它左边的对象是否是它右边的类的实例</strong>，返回boolean类型的数据。</p>
<p>我们来使用instanceof运算符来规避上面的错误，代码修改如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/1189312-20170701165626571-501228254.png" alt="img"></p>
<p>利用if语句和instanceof运算符来判断两个对象的类型是否一致。</p>
<p>**补充说明：**在比较一个对象是否和另一个对象属于同一个类实例的时候，我们通常可以采用instanceof和getClass两种方法通过两者是否相等来判断，但是两者在判断上面是有差别的。Instanceof进行类型检查规则是:<strong>你属于该类吗？或者你属于该类的派生类吗？而通过getClass获得类型信息采用==来进行检查是否相等的操作是</strong>严格的判断,<strong>不会存在继承方面的考虑</strong>；</p>
<p>**总结：**在写程序的时候，如果要进行类型转换，我们最好使用instanceof运算符来判断它左边的对象是否是它右边的类的实例，再进行强制转换。</p>
<hr>
<p><strong>D、重写和重载</strong></p>
<p>多态一般可以分为两种，一个是重写override，一个是重载overload。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重写是由于继承关系中的子类有一个和父类同名同参数的方法，会覆盖掉父类的方法。重载是因为一个同名方法可以传入多个参数组合。</span><br><span class="line"></span><br><span class="line">注意，同名方法如果参数相同，即使返回值不同也是不能同时存在的，编译会出错。</span><br><span class="line"></span><br><span class="line">从jvm实现的角度来看，重写又叫运行时多态，编译时看不出子类调用的是哪个方法，但是运行时操作数栈会先根据子类的引用去子类的类信息中查找方法，找不到的话再到父类的类信息中查找方法。</span><br><span class="line"></span><br><span class="line">而重载则是编译时多态，因为编译期就可以确定传入的参数组合，决定调用的具体方法是哪一个了。</span><br></pre></td></tr></table></figure>
<p><strong>1. 向上转型和向下转型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    <span class="comment">//首先先明确一点，转型指的是左侧引用的改变。</span></span><br><span class="line">    <span class="comment">//father引用类型是Father，指向Son实例，就是向上转型，既可以使用子类的方法，也可以使用父类的方法。</span></span><br><span class="line">    <span class="comment">//向上转型,此时运行father的方法</span></span><br><span class="line">    <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> son;</span><br><span class="line">    father.smoke();</span><br><span class="line">    <span class="comment">//不能使用子类独有的方法。</span></span><br><span class="line">    <span class="comment">// father.play();编译会报错</span></span><br><span class="line">    father.drive();</span><br><span class="line">    <span class="comment">//Son类型的引用指向Father的实例，所以是向下转型，不能使用子类非重写的方法，可以使用父类的方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下转型，此时运行了son的方法</span></span><br><span class="line">    <span class="type">Son</span> <span class="variable">son1</span> <span class="operator">=</span> (Son) father;</span><br><span class="line">    <span class="comment">//转型后就是一个正常的Son实例</span></span><br><span class="line">    son1.play();</span><br><span class="line">    son1.drive();</span><br><span class="line">    son1.smoke();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为向下转型之前必须先经历向上转型。</span></span><br><span class="line">	<span class="comment">//在向下转型过程中，分为两种情况：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//情况一：如果父类引用的对象如果引用的是指向的子类对象，</span></span><br><span class="line">	<span class="comment">//那么在向下转型的过程中是安全的。也就是编译是不会出错误的。</span></span><br><span class="line">    <span class="comment">//因为运行期Son实例确实有这些方法</span></span><br><span class="line">    <span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> (Son) f1;</span><br><span class="line">    s1.smoke();</span><br><span class="line">    s1.drive();</span><br><span class="line">    s1.play();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，</span></span><br><span class="line">    <span class="comment">//但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。</span></span><br><span class="line">    <span class="comment">//因为运行期Father实例并没有这些方法。</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s2</span> <span class="operator">=</span> (Son) f2;</span><br><span class="line">        s2.drive();</span><br><span class="line">        s2.smoke();</span><br><span class="line">        s2.play();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下转型和向上转型的应用，有些人觉得这个操作没意义，何必先向上转型再向下转型呢，不是多此一举么。其实可以用于方法参数中的类型聚合，然后具体操作再进行分解。</span></span><br><span class="line">    <span class="comment">//比如add方法用List引用类型作为参数传入，传入具体类时经历了向下转型</span></span><br><span class="line">    add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>());</span><br><span class="line">    add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结</span></span><br><span class="line">    <span class="comment">//向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法</span></span><br><span class="line">    <span class="comment">//并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错。</span></span><br><span class="line">    <span class="comment">//若安全则继续执行方法。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(List list)</span> &#123;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    <span class="comment">//在操作具体集合时又经历了向上转型</span></span><br><span class="line"><span class="comment">//        ArrayList arr = (ArrayList) list;</span></span><br><span class="line"><span class="comment">//        LinkedList link = (LinkedList) list;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>向上转型和向下转型都是针对引用的转型，是编译期进行的转型，根据引用类型来判断使用哪个方法。并且在传入方法时会自动进行转型（有需要的话）。运行期将引用指向实例，如果是不安全的转型则会报错，若安全则继续执行方法。</p>
<p><strong>2. 编译期的静态分派</strong></p>
<p>其实就是根据引用类型来调用对应方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Father</span> <span class="variable">father</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    静态分派 a= <span class="keyword">new</span> 静态分派();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译期确定引用类型为Father。</span></span><br><span class="line">    <span class="comment">//所以调用的是第一个方法。</span></span><br><span class="line">    a.play(father);</span><br><span class="line">    <span class="comment">//向下转型后，引用类型为Son，此时调用第二个方法。</span></span><br><span class="line">    <span class="comment">//所以，编译期只确定了引用，运行期再进行实例化。</span></span><br><span class="line">    a.play((Son)father);</span><br><span class="line">    <span class="comment">//当没有Son引用类型的方法时，会自动向上转型调用第一个方法。</span></span><br><span class="line">    a.smoke(father);</span><br><span class="line">    <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">smoke</span><span class="params">(Father father)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;father smoke&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span> <span class="params">(Father father)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    <span class="comment">//father.drive();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span> <span class="params">(Son son)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">    <span class="comment">//son.drive();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 方法重载优先级匹配</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    方法重载优先级匹配 a = <span class="keyword">new</span> 方法重载优先级匹配();</span><br><span class="line">    <span class="comment">//普通的重载一般就是同名方法不同参数。</span></span><br><span class="line">    <span class="comment">//这里我们来讨论当同名方法只有一个参数时的情况。</span></span><br><span class="line">    <span class="comment">//此时会调用char参数的方法。</span></span><br><span class="line">    <span class="comment">//当没有char参数的方法。会调用int类型的方法，如果没有int就调用long</span></span><br><span class="line">    <span class="comment">//即存在一个调用顺序char -&gt; int -&gt; long -&gt;double -&gt; ..。</span></span><br><span class="line">    <span class="comment">//当没有基本类型对应的方法时，先自动装箱，调用包装类方法。</span></span><br><span class="line">    <span class="comment">//如果没有包装类方法，则调用包装类实现的接口的方法。</span></span><br><span class="line">    <span class="comment">//最后再调用持有多个参数的char...方法。</span></span><br><span class="line">    a.eat(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    a.eat(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">short</span> i)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">double</span> i)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;double&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Character c)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Character&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Comparable c)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Comparable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">char</span> ... c)</span> &#123;</span><br><span class="line">    System.out.println(Arrays.toString(c));</span><br><span class="line">    System.out.println(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void eat(char i) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;char&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="初始面向对象"><a href="#初始面向对象" class="headerlink" title="初始面向对象"></a>初始面向对象</h2><ul>
<li><p>属性+方法=类</p>
</li>
<li><p><strong>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</strong></p>
</li>
<li><p>面现象对象比那晨光的本质就是：<strong>以类的方式组织代码，以对象的组织（封装）数据。</strong></p>
</li>
<li><p>从认识论角度考虑是现有对象后有类。</p>
<hr>
<h2 id="回顾方法的定义以及调用"><a href="#回顾方法的定义以及调用" class="headerlink" title="回顾方法的定义以及调用"></a>回顾方法的定义以及调用</h2></li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//main 方法   </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*修饰符 返回值类型 方法名（……）&#123;    </span></span><br><span class="line"><span class="comment">//方法体    return 返回值；   </span></span><br><span class="line"><span class="comment">&#125; */</span>    </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayhello</span><span class="params">()</span>&#123;       </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;       </span><br><span class="line">    <span class="keyword">return</span>;    &#125;    </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;      </span><br><span class="line">    <span class="keyword">return</span> a&gt;b ?a :b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Students</span> <span class="variable">students</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Students</span>();</span><br><span class="line">students.say();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意值传递跟参数传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         Person person= <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">         	System.out.println(person.name);        						Demo05.change(person);        						System.out.println(person.name);</span><br><span class="line">    		 &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person person)</span>&#123;       				 person.name=<span class="string">&quot;张三&quot;</span>;  </span><br><span class="line">                                 &#125; </span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Person</span>&#123;    </span><br><span class="line">                String name;<span class="comment">//null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><ul>
<li><p>类是一种冲向的数据类型，它对某一类事物整体描述/定义但是并不能代表某一个具体的事物，类是抽象的。</p>
</li>
<li><p>对象时抽象概念的具体实例</p>
</li>
</ul>
<h3 id="创建和初始化对象"><a href="#创建和初始化对象" class="headerlink" title="创建和初始化对象"></a>创建和初始化对象</h3><ul>
<li><p>使用new关键字初始化对象时，除了分配内存空间外，还会给创建好的对象，进行默认的初始化和类中构造器的使用。</p>
</li>
<li><p>一个类即使什么都不写，他也会存在一个方法</p>
</li>
<li><p>构造器</p>
<ul>
<li><p>和类名相同</p>
</li>
<li><p>没有返回值</p>
</li>
</ul>
</li>
<li><p>核心作用：</p>
<ul>
<li><p>使用new关键字，本质在调用构造器</p>
</li>
<li><p>构造器来初始化值</p>
</li>
</ul>
</li>
<li><p>在无参构造器中，无参构造器可以实例化初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造器</span></span><br><span class="line"><span class="keyword">public</span> Person（）&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在main方法中</span></span><br><span class="line">Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li><p>有参构造器：一旦定义了有参构造，无参就必须显示定义</p>
</li>
<li><p>Alt+Inser</p>
</li>
</ul>
</li>
</ul>
<h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//类：抽象的，实例化        //类实例化会返回一个自己的对象        //student对象就是一个Students类的具体实例       </span></span><br><span class="line"><span class="type">Students</span> <span class="variable">xiaoming</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Students</span>();        </span><br><span class="line">    xiaoming.name=<span class="string">&quot;小明&quot;</span>;      </span><br><span class="line">    xiaoming.age=<span class="number">3</span>;       </span><br><span class="line">    xiaoming.study();       </span><br><span class="line">    xiaoming.play();      </span><br><span class="line">    System.out.println(xiaoming.name);        System.out.println(xiaoming.age);      </span><br><span class="line">    Students xiaohong=<span class="keyword">new</span> <span class="title class_">Students</span>();    </span><br><span class="line">    xiaohong.name=<span class="string">&quot;小红&quot;</span>;     </span><br><span class="line">    xiaohong.age=<span class="number">15</span>;       </span><br><span class="line">    xiaohong.study();        </span><br><span class="line">System.out.println(xiaohong.name);        System.out.println(xiaohong.age);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对象通过引用类型来操作：栈 - - -&gt;堆</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20210427083125469.png" alt="img" style="zoom: 67%;" /></p>
<hr>
<h3 id="创建对象时JVM的内存变化"><a href="#创建对象时JVM的内存变化" class="headerlink" title="创建对象时JVM的内存变化"></a>创建对象时JVM的内存变化</h3><p><img src="E:\BaiduNetdiskDownload\04-JavaSE零基础课堂画图\009-对象和引用.png" style="zoom:200%;" /></p>
<hr>
<h3 id="Java面向对象之各种变量详解"><a href="#Java面向对象之各种变量详解" class="headerlink" title="Java面向对象之各种变量详解"></a>Java面向对象之各种变量详解</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>在 Java语言中, 根据定义变量位置的不同,可以将变量分成两大类:</p>
</blockquote>
<ul>
<li>成员变量</li>
<li>局部变量</li>
</ul>
<blockquote>
<p>成员变量和局部变量的运行机制存在很大差异,下面我们看看差异在哪.</p>
</blockquote>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><blockquote>
<p>成员变量指的是在类里定义的变量.<br>局部变量指的是在方法里定义的变量.</p>
<p>下面我给出Java程序中的变量划分图:</p>
</blockquote>
<p>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20160720165532767" alt="img"></p>
<p>成员变量被分为类变量和实例变量两种.<br>定义成员变量时没有 static 修饰符的就是实例变量.<br>有static修饰符的就是类变量.</p>
<blockquote>
<p>其中, 类变量从该类的准备阶段起开始存在.<br>直到系统完全销毁这个类,类变量的作用域与这个类的生存范围相同.<br>而实例变量则从该类的实例被创建起开始存在,知道系统完全销毁这个实例.<br>实例变量的作用域与对应实例的生存范围相同.</p>
</blockquote>
<p>小知识: 一个类在使用之前需要经过 类加载 / 类验证 / 类准备 / 类解析 / 类初始化 等几个阶段.</p>
<p>正是基于以上原因, 可以把类变量和实例变量统称为成员变量.</p>
<blockquote>
<p>其中, 类变量可以理解为 类成员变量, 它作为类本身的一个成员, 与类本身共存亡.<br>实例变量则可以理解为 实例成员变量, 它作为实例的一个成员, 与实例共存亡.</p>
</blockquote>
<p>只要类存在, 程序就可以访问该类的类变量.<br>在程序中通过如下语法访问:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类.类变量</span><br></pre></td></tr></table></figure>
<hr>
<p>只要实例存在, 程序就可以访问该实例的实例变量.<br>在程序中通过如下语法访问:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例.实例变量</span><br></pre></td></tr></table></figure>
<hr>
<p>当然, 类变量也可以让该类的实例来访问.<br>通过实例访问类变量的语法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实例.类变量</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>但由于这个实例并不拥有这个类变量.<br>因此它访问的并不是这个实例的变量,依然是访问它对应类的类变量.<br>也就是说, 如果通过一个实例修改了类变量的值, 由于这个类变量并不属于它.<br>而是属于它对应的类. 因此, 修改的依然是类的类变量.<br>与通过该类来修改类变量的结果完全相同.<br>这会导致该类的其它实例来访问这个类变量时也获得这个被修改过的值.</p>
</blockquote>
<hr>
<p>下面我写个程序, 定义了一个 Person 类, 在这个 Person 类中定义两个成员变量.<br>一个类变量: eyeNum<br>一个实例变量: name<br>程序通过 PersonTest 类来创建 Person 实例.<br>并分别通过 Person 类 和 Person 实例来访问实例变量和类变量.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//定义一个类变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> eyeNum;</span><br><span class="line">  <span class="comment">//定义一个实例变量</span></span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//第一次主动使用 Person 类, 该类自动初始化, 则 eyeNum 变量开始起作用, 输出 0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Person 的 eyeNum 类变量的值:&quot;</span> + Person.eyeNum);</span><br><span class="line">    <span class="comment">//创建 Person 对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="comment">//通过 Person 对象的引用 p 来访问 Person 对象的 name 实例变量</span></span><br><span class="line">    <span class="comment">//并通过实例访问 eyeNum 类变量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;p 对象的 name 变量的值是:&quot;</span> + p.name + <span class="string">&quot;p 对象的 eyeNum 变量的值是:&quot;</span> + p.eyeNum);</span><br><span class="line">    <span class="comment">//直接为 name 实例变量赋值</span></span><br><span class="line">    p.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">    <span class="comment">//通过 p 访问 eyeNum 类变量, 依然是访问 Person 的 eyeNum 类变量</span></span><br><span class="line">    p.eyeNum = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//再次通过 Person 对象来访问 name 实例变量 和 eyeNum 类变量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;p 对象的 name 变量值是:&quot;</span> + p.name + <span class="string">&quot;p 对象的 eyeNum 变量值是:&quot;</span> + p.eyeNum);</span><br><span class="line">    <span class="comment">//前面通过 p 修改了 Person 的 eyeNum, 此处的 Person.eyeNum 将输出 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Person 的 eyeNum 类变量值:&quot;</span> + Person.eyeNum);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="comment">//p2 访问的 eyeNum 类变量依然引用 Person 类的, 因此依然输出 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;p2 对象的 eyeNum 类变量值:&quot;</span> + p2.eyeNum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>从上面程序可以看出, 成员变量无须显式初始化.<br>只要为一个类定义了 类变量 或 实例变量.(类变量在程序开始之前，系统会自动初始化变量)<br>系统就会在这个类的准备阶段或创建该类的实例时进行默认初始化.<br>成员变量默认初始化的赋值规则与我们之前讲的 数组动态初始化 时数组元素的赋值规则完全相同.</p>
<p>我们还可以得知, 类变量的作用域 比 实例变量的作用域 更大.<br>实例变量随实例的存在而存在.<br>而类变量则随类的存在而存在.<br>实例也可以访问类变量, 同一个类的所有实例访问类变量时.<br>实际上访问的是该类本身的同一个变量, 也就是说, 访问了同一片内存区.</p>
<blockquote>
<p>注意!!!<br>Java 允许实例访问 static 修饰的类变量本身就是一个错误.<br>因此建议你以后看到通过实例来访问 static 修饰的类变量时, 都可以将它替换成通过类本身来访问. 这样程序的可读性 / 明确性 都会大大提高!</p>
</blockquote>
<hr>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><blockquote>
<p>局部变量根据定义形式的不同, 可以分为如下三种:</p>
</blockquote>
<ul>
<li><p>形参：在方法定义签名时定义的变量，形参的作用域只在这个方法内有效。</p>
</li>
<li><p>方法的局部变量：在方法体内定义的局部变量，它的作用域就是从定义该变量的地方生效，直到方法结束时失效。</p>
</li>
<li><p>代码块局部变量：在代码块中定义的局部变量，这个局部变量的作用域从定义该变量的地方生效，直到该代码块结束时失效。    </p>
<hr>
<blockquote>
<p>​    与成员变量不同的是, 局部变量除了形参之外, 都必需显式初始化.<br>也就是说, 必需先给方法局部变量和代码块局部变量指定初始值, 否则不可以访问它们.</p>
</blockquote>
<p>下面我写个定义代码块局部变量的程序.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//定义一个代码块局部变量 a</span></span><br><span class="line">      <span class="type">int</span> a;</span><br><span class="line">      <span class="comment">//下面代码将会出现错误, 因为 a 变量没有初始化</span></span><br><span class="line">      System.out.println(<span class="string">&quot;代码块局部变量 a 的值:&quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面试图访问 a 变量, 但 a 变量的作用域根本无法涉及这里</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>上面的代码是一个错误示例, 如果你写出来还要运行的话, 只能说你 too yang to simple.<br>从上面代码可以看出, 只要离开了 代码块局部变量 所在的代码块, 这个局部变量就没法用了.</p>
</blockquote>
<p>对于方法局部变量, 其作用域从定义该变量开始, 直到该方法结束.<br>下面我写个 方法局部变量的作用域 示例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodLocalVariableTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//定义一个方法局部变量 a</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="comment">//下面代码将会出现错误, 因为 a 变量没有初始化</span></span><br><span class="line">    System.out.println(<span class="string">&quot;方法局部变量 a 的值:&quot;</span> + a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>​    下面说说形参.<br>​    形参的作用域时整个方法体内有效, 而且形参也无须显式初始化.<br>​    形参的初始化在调用该方法时由系统完成, 形参的值由方法的调用者负责指定.</p>
<blockquote>
<p>在同一个类里, 成员变量的作用域是整个类内有效.<br>一个类里不能定义两个同名的成员变量.<br>就算一个是类变量, 一个是实例变量也不行.</p>
<p>一个方法里不能定义两个同名的成员变量.<br>方法局部变量与形参名也不能同名.<br>同一个方法中不同代码块内的代码块局部变量可以同名.</p>
</blockquote>
<p>​    如果先定义代码块局部变量, 后定义方法局部变量.<br>​    前面定义的代码块局部变量与后面定义的方法局部变量是可以同名的.</p>
<blockquote>
<p>Java允许局部变量和成员变量同名.<br>如果方法里的局部变量和成员变量同名, 局部变量会覆盖成员变量.<br>如果需要在这个方法里引用被覆盖的成员变量.<br>可以使用 this (对于实例变量) 或 类名(对于类变量) 来作为调用者.</p>
</blockquote>
<p>​    下面, 我写个程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableOverrideTest</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//定义一个 name 实例变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;猪八戒&quot;</span>;</span><br><span class="line">  <span class="comment">//定义一个 price 类变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">78.0</span>;</span><br><span class="line">  <span class="comment">//主方法, 程序的入口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//方法里的局部变量, 局部变量覆盖成员变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line">    <span class="comment">//直接访问 price 变量, 将输出 price 局部变量的值.</span></span><br><span class="line">    System.out.println(price);</span><br><span class="line">    <span class="comment">//使用类名作为 price 变量的调用者, 访问被覆盖的 类变量</span></span><br><span class="line">    System.out.println(VariableOverrideTest.price);</span><br><span class="line">    <span class="comment">//运行 info 方法</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VariableOverrideTest</span>().info();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//方法里的局部变量, 局部变量覆盖成员变量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">    <span class="comment">//直接访问 name 变量, 将输出 孙悟空</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">//使用 this 来作为 name 的调用者, 访问 实例变量</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面代码可以看出, 当局部变量覆盖成员变量时.<br>依然可以在方法中显式指定 类名和this 作为调用者来访问被覆盖的成员变量, 这使得变成更加自由.<br>不过, 不过, 不过 . 你应该尽量避免这种局部变量和成员变量同名的情形. (想个名字真的有那么难么 - - )</p>
</blockquote>
<hr>
<h4 id="成员变量（属性）和局部变量的区别？"><a href="#成员变量（属性）和局部变量的区别？" class="headerlink" title="成员变量（属性）和局部变量的区别？"></a>成员变量（属性）和局部变量的区别？</h4><ul>
<li><p><strong>成员变量：</strong></p>
</li>
<li><p>成员变量定义在类中，在整个类中都可以被访问。</p>
</li>
<li><p>成员变量分为类成员变量和实例成员变量，实例变量存在于对象所在的堆内存中。</p>
</li>
<li><p>成员变量有默认初始值。</p>
</li>
<li><p>成员变量的权限修饰符可以根据需要，任意选择一个。</p>
</li>
<li><ul>
<li>如，public，private。</li>
</ul>
</li>
<li><p><strong>局部变量：</strong></p>
</li>
<li><p>局部变量只定义在局部范围内，如，方法内，代码块等。</p>
</li>
<li>局部变量存在于栈内存中。</li>
<li>作用的范围结束，变量的空间会自动释放。</li>
<li>局部变量没有默认初始值，每次必定显示初始值。</li>
<li>局部变量声明时不指定权限修饰符。</li>
</ul>
<hr>
<h4 id="成员变量的初始化和内存中的运行机制"><a href="#成员变量的初始化和内存中的运行机制" class="headerlink" title="成员变量的初始化和内存中的运行机制"></a>成员变量的初始化和内存中的运行机制</h4><blockquote>
<p>当系统加载类或创建该类的实例时.<br>系统将自动为成员变量分配内存空间.<br>并在分配内存空间后, 自动为成员变量指定初始值.</p>
<p>下面通过代码来创建两个实例(非完整代码,能明白就行).<br>同时配合示意图来说明 Java 成员变量的初始化和内存中的运行机制.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建第一个 Person 对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">//创建第二个 Person 对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">//分别为两个 Person 对象的 name 实例变量赋值</span></span><br><span class="line">p1.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">p2.name = <span class="string">&quot;皮卡丘&quot;</span>;</span><br><span class="line"><span class="comment">//分别为两个 Person 对象的 eyeNum 类变量赋值</span></span><br><span class="line">p1.eyeNum = <span class="number">2</span>;</span><br><span class="line">p2.eyeNum = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>下面开始解读:</p>
<blockquote>
<p>当程序执行第一行代码 Person p1 = new Person(); 时<br>如果这行代码是第一次使用 Person 类.<br>则系统会加载并初始化这个类.<br>在类的准备阶段.<br>系统将会为该类的类变量分配内存空间,并指定默认初始值.</p>
<p>当 Person 类初始化完成后.<br>系统将在堆内存中为 Person 类分配一块内存区.<br>在这块内存区中, 包含了 保存 eyeNum 类变量的内存.<br>并设置 eyeNum 的默认初始值为: 0</p>
<p>系统接着创建了一个 Person 对象.<br>并把这个 Person 对象赋给 p1 变量.<br>Person 对象里包含了名为 name 的实例变量.<br>实例变量是在创建实例时分配内存空间并指定初始值的.</p>
</blockquote>
<p>​    </p>
<blockquote>
<p>它是属于 Person 类的.<br>所以创建第一个 Person 对象时并不需要为 eyeNum 类变量分配内存(废话…)<br>系统只为 name 实例变量分配了内存空间.<br>并指定默认初始值: null</p>
<p>接着执行 Person p2 = new Person();<br>代码创建第二个 Person 对象.<br>此时因为 Person 类已经存在于堆内存了.<br>所以不需要对 Person 类进行初始化(废话…Java 会那么傻么…)<br>创建第二个 Person 对象 与 创建第一个 Person 对象并没有什么不同.</p>
<p>当程序执行 p1.name = “孙悟空”; 时<br>将为 p1 的 name 实例变量赋值.<br>也就是让堆内存中的 name 指向 “孙悟空” 字符串.<br>我们之前说过, 字符串也是一种引用变量. 所以你懂的.</p>
</blockquote>
<p>​    执行完成后, 两个 Person 对象在内存中的存储示意图如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20160720204021089" alt="img" style="zoom: 50%;" /></p>
<p>​    从上图可以看出, name 实例变量是属于单个 Person 实例的.</p>
<blockquote>
<p>因此, 修改第一个 Person 对象的 name 实例变量时仅仅与 p1 对象有关.<br>与 Person 类和其它 Person 对象没有任何关联.<br>同理, 修改第二个 Person 对象 p2 的 name 实例变量时, 也与 Person 类和其它 Person 对象无关.</p>
<p>直到执行 p1.eyeNum = 2 时<br>此时呢, 就是犯大忌了. 你拿 对象来操作类变量了. 不过为了教学演示, 我拿自己当典型.<br>从我们看过的图当中, 可以知道.<br>Person 的对象根本没有保存 eyeNum 这个变量.<br>通过 p1 访问的 eyeNum 类变量.<br>其实还是 Person 类的 eyeNum 类变量.<br>因此, 此时修改的是 Person 类的 eyeNum 类变量.</p>
</blockquote>
<p>​    修改成功后, 内存中的存储示意图如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20160720204812777" alt="img" style="zoom: 50%;" /></p>
<p>​    从上图可以看出.</p>
<blockquote>
<p>不管通过哪个 Person 实例来访问 eyeNum 类变量.<br>它们访问的其实都是同一块内存.<br>所以就再次提醒你.<br>当程序需要访问 类变量时.<br>尽量使用类作为主调, 而不要使用对象作为主调.<br>这样可以避免歧义, 提高程序的可读性.</p>
</blockquote>
<hr>
<h4 id="局部变量的初始化和内存中的运行机制"><a href="#局部变量的初始化和内存中的运行机制" class="headerlink" title="局部变量的初始化和内存中的运行机制"></a>局部变量的初始化和内存中的运行机制</h4><blockquote>
<p>局部变量定义后.<br>必需经过显式初始化后才能使用.<br>系统不会为局部变量执行初始化.<br>这意味着,定义局部变量之后,系统并未为这个变量分配内存控件.<br>直到等程序为这个变量赋初始值时.<br>系统才会为局部变量分配内存,并将初始值保存到这块内存中去.</p>
<p>与成员变量不同,局部变量不属于任何类或实例.<br>因此它总是保存在其所在的方法的栈内存中.<br>如果局部变量是基本类型变量,则直接把这个变量的值保存在该变量对应的内存中.<br><strong>如果局部变量是引用类型的变量,则这个变量里存放的就是地址.</strong><br><strong>通过该地址引用到该变量实际引用的对象或数组.</strong></p>
</blockquote>
<hr>
<h4 id="变量的使用规则"><a href="#变量的使用规则" class="headerlink" title="变量的使用规则"></a>变量的使用规则</h4><p>对于新手来说.<br>什么时候使用类变量?<br>什么时候使用实例变量?<br>什么时候使用方法局部变量?<br>什么时候使用代码块局部变量?<br>这种选择比较困难,如果仅仅从程序的运行结果来看,大部分时候都可以直接使用类变量或实例变量来解决问题.无须使用局部变量.<br>但实际上这种做法非常错误.<br>因为定义一个成员变量时,成员变量将被放置到堆内存中.<br>成员变量的作用域将扩大到类存在范围或对象存在范围,这种返回的扩大有两个害处.</p>
<h3 id="小结类与对象"><a href="#小结类与对象" class="headerlink" title="小结类与对象"></a>小结类与对象</h3><ol>
<li><p>类与对象</p>
<ol>
<li>类是一个模板：抽象，对象是一个具体的实例。</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li>定义：是通用的</li>
</ol>
</li>
<li><p>对象的引用</p>
<ol>
<li><p>引用类型：8个基本数据类型</p>
</li>
<li><p>对象时通过引用来操作的</p>
</li>
</ol>
</li>
<li><p>属性：字段Field的成员变量</p>
<ol>
<li><p>默认初始化：</p>
<ol>
<li><p>数字：0 0.0</p>
</li>
<li><p>char u0000</p>
</li>
<li><p>boolean：false</p>
</li>
<li><p>引用：null</p>
</li>
</ol>
</li>
<li><p>修饰符  属性类型  属性名 =属性值</p>
</li>
</ol>
</li>
<li><p>对象的创建和使用</p>
<ol>
<li><p>必须使用new关键字来创建对象，构造器Person person = new Person ()；</p>
</li>
<li><p>对象的属性 ：person.name</p>
</li>
<li><p>对象的方法 ： person.walk();</p>
</li>
</ol>
</li>
<li><p>类</p>
<ol>
<li>静态的属性是属性</li>
</ol>
</li>
<li>动态的行为是方法</li>
</ol>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul>
<li><p>构造器的特征 ：</p>
<ol>
<li><p>它具有与类相同的名称</p>
</li>
<li><p>它不声明返回值类型（跟声明void不同）</p>
</li>
<li><p>不能被static ，final ， abstract ，native 修饰 ，不能有return语句返回值</p>
</li>
</ol>
</li>
<li><p>构造器的作用 ：创建对象，给对象进行初始化</p>
</li>
<li><p><strong>Order o = new Order</strong>**（）****;   Person p = new Person(peter,15);**</p>
<p><strong>构造器：</strong></p>
<ul>
<li><strong>语法格式：</strong></li>
</ul>
<p><strong>修饰符</strong> <strong>类名</strong> <strong>（参数列表）****{</strong></p>
<p><strong>初始化语句；</strong></p>
<p><strong>}</strong></p>
</li>
<li><p>根据参数不同，构造器可以分为以下两个种类：</p>
</li>
<li><p>隐式无参构造器（系统默认）</p>
</li>
<li><p>显示定义一个或多个（无参，有参）</p>
</li>
</ul>
<p>注意 ：</p>
<ol>
<li><p>Java语言中，每个类至少有一个构造器。</p>
</li>
<li><p>默认构造器的修饰符和所属类的修饰符相同。</p>
</li>
<li><p>一旦显示定义了构造器 ，系统则不会提供默认的构造器。</p>
</li>
<li><p>一个类可以创造多个重载的构造器。</p>
</li>
<li><p>父类的构造器不可以被子类继承。</p>
<p>5、构造方法。</p>
<pre><code>5.1、当一个类中没有提供任何构造方法，系统默认提供一个无参数的构造方法。
这个无参数的构造方法叫做缺省构造器。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.2</span>、当一个类中手动的提供了构造方法，那么系统将不再默认提供无参数构造方法。</span><br><span class="line">建议将无参数构造方法手动的写出来，这样一定不会出问题。</span><br><span class="line"></span><br><span class="line"><span class="number">5.3</span>、无参数构造方法和有参数的构造方法都可以调用。</span><br><span class="line">	<span class="type">Student</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">	<span class="type">Student</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">5.4</span>、构造方法支持方法重载吗？</span><br><span class="line">	构造方法是支持方法重载的。</span><br><span class="line">	在一个类当中构造方法可以有多个。</span><br><span class="line">	并且所有的构造方法名字都是一样的。</span><br><span class="line"></span><br><span class="line">	方法重载特点：</span><br><span class="line">		在同一个类中，方法名相同，参数列表不同。</span><br><span class="line"></span><br><span class="line"><span class="number">5.5</span>、对于实例变量来说，只要你在构造方法中没有手动给它赋值，</span><br><span class="line">统一都会默认赋值。默认赋系统值。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	有了封装，才有继承，有了继承，才能说多态。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 面向对象的首要特征：封装 。什么是封装？有什么用？</span><br><span class="line">	现实生活中有很多现实的例子都是封装的，例如：</span><br><span class="line">		手机，电视机，笔记本电脑，照相机，这些都是外部有一个坚硬的壳儿。</span><br><span class="line">	封装起来，保护内部的部件。保证内部的部件是安全的。另外封装了之后，</span><br><span class="line">		对于我们使用者来说，我们是看不见内部的复杂结构的，我们也不需要关心</span><br><span class="line">		内部有多么复杂，我们只需要操作外部壳儿上的几个按钮就可以完成操作。</span><br><span class="line"></span><br><span class="line">	那么封装，你觉得有什么用呢？</span><br><span class="line">		封装的作用有两个：</span><br><span class="line">			第一个作用：保证内部结构的安全。</span><br><span class="line">			第二个作用：屏蔽复杂，暴露简单。</span><br><span class="line"></span><br><span class="line">	在代码级别上，封装有什么用？</span><br><span class="line">		一个类体当中的数据，假设封装之后，对于代码的调用人员来说，</span><br><span class="line">		不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。</span><br><span class="line">		另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，</span><br><span class="line">		来保证数据的安全性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>怎么进行封装，代码怎么实现？</span><br><span class="line">	第一步：属性私有化（使用<span class="keyword">private</span>关键字进行修饰。）</span><br><span class="line">	第二步：对外提供简单的操作入口。（提供set/get方法）</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>该露的露，该藏的藏</p>
<ul>
<li>我们程序设计要追求“<strong>高内聚，低耦合</strong>”。高内聚就是类的内部数据细节由自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</li>
</ul>
</li>
<li><p>封装 （数据的隐藏）</p>
<ul>
<li>通常，应禁止直接访问一个对象的实际表示，而应该通过操作来访问，这就是数据的隐藏，简称信息隐藏。</li>
</ul>
</li>
<li><p>应属于私有的，get/set</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名字</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//学号</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//性别</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//年龄</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (age&gt;<span class="number">120</span> || age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">this</span>.age=<span class="number">3</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.age=age;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> id;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.id = id;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> sex;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.sex = sex;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Students</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Students</span>();        s1.setAge(<span class="number">1200</span>);        System.out.println(s1.getAge());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>作用<br>1. 提高程序的安全性，保护数据<br>2. 隐藏代码的实现细节<br>3. 统一接口<br>4. 系统可维护性增强了</li>
</ul>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p><strong>静态代码块</strong>：执行优先级高于非静态的初始化块，它会在类初始化的时候执行一次，执行完成便销毁，它仅能初始化类变量，即</p>
<p><strong>static</strong>修饰的数据成员。</p>
<p>静态代码块在类加载时执行</p>
<p><strong>静态代码块语法：</strong></p>
<blockquote>
<p>static{</p>
<p>java语法；</p>
<p>java语法；</p>
<p>}</p>
<p>对应的扩展下非静态代码块</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到目前为止：你所遇到的有顺序要求的java程序有哪些？</p>
<ol>
<li>对于一个方法来说，方法体中的代码的是有顺序的，是遵循自上而下的顺序。</li>
<li>静态代码块1和静态代码块2是有先后顺序的。</li>
<li>静态代码块和静态变量是有先后顺序的。<ol>
<li><strong>只要是构造方法执行，实例语句块必定会在构造方法之前执行。</strong></li>
</ol>
</li>
</ol>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><blockquote>
<ol>
<li>this是一个关键字，是一个引用，保存内存地址指向自身。</li>
<li>this可以使用在实例方法中，也可以使用在构造方法中。</li>
<li>this出现在实例方法中其实代表的是当前对象。</li>
<li>this不能使用在静态方法中。</li>
<li>this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。</li>
<li>this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。</li>
</ol>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​          <strong>this.属性名称</strong></p>
<blockquote>
<p>​          指的是访问类中的成员变量，用来区分成员变量和局部变量（重名问题）</p>
</blockquote>
<hr>
<p>下面我写了一个关于this的例子，大家看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/2/17 16:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>(<span class="string">&quot;Java基础&quot;</span>,<span class="number">345</span>);</span><br><span class="line">        System.out.println(f1.getPageNum());</span><br><span class="line">        f1.detail();</span><br><span class="line">        <span class="type">Food</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装 进行属性私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">()</span> &#123;</span><br><span class="line">        title = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">        pageNum = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Food</span><span class="params">(String title, <span class="type">int</span> pageNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="keyword">if</span> (pageNum &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本书最少为200页,若不符合，则赋默认值200！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.pageNum = pageNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义getter and setter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pageNum &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本书最少为200页,若不符合，则赋默认值200！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.pageNum = pageNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPageNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pageNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPageNum</span><span class="params">(<span class="type">int</span> pageNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pageNum = pageNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detail</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;教材名称:&quot;</span> + title + <span class="string">&quot;,总页数为&quot;</span> + pageNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>​            运行结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/image-20220217164655152.png" alt="image-20220217164655152" style="zoom:150%;" /></p>
<p>this.方法名称<br>                                用来访问本类的成员方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       <span class="built_in">this</span>();      访问本类的构造方法</span><br><span class="line"></span><br><span class="line">()中可以有参数的 如果有参数 就是调用指定的有参构造</span><br><span class="line">    注意事项:</span><br><span class="line">                     <span class="number">1.</span><span class="built_in">this</span>() 不能使用在普通方法中 只能写在构造方法中</span><br><span class="line">                     <span class="number">2.</span>必须是构造方法中的第一条语句</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>继承的本质是对某一批类的抽象，从而实现对美好的世界的构建</p>
</li>
<li><p><strong>extends的意思是“扩展”</strong>。子类是父类的扩展，使用extends来表示</p>
</li>
<li><p><strong>Java中只有单继承</strong>，没有多继承，一个类只能继承一个父类</p>
</li>
<li><p>继承是类与类之间的关系，此外还有依赖，组合，聚合等等。</p>
</li>
<li><p>继承关系的两个类，一个是子类（派生类），一个是父类（基类），子类继承父类</p>
</li>
<li><p>在Java中，所有的类，都默认直接或间接继承<strong>Object</strong>类（Ctrl + H 可以查看类关系）</p>
</li>
<li><p>被final修饰的类，无法被继承（俗称断子绝孙）</p>
<hr>
</li>
</ul>
<h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><blockquote>
<p>Java的继承通过extends关键字实现.<br>实现继承的类被称为子类.<br>被继承的类被称为父类.<br>父类和子类的关系, 是一种一般和特殊的关系.<br>例如水果和苹果的关系, 苹果继承了水果, 苹果是水果的子类, 水果是苹果的父类.</p>
<p>Java里子类<strong>继承</strong>父类的语法格式如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//类定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>从上面的语法格式来看, 定义子类的语法非常简单, 只需要在原来的类定义上增加 extends SuperClass 即可.<br>即表明该类是 SuperClass 的子类.</p>
<p>为什么国内把 extends 翻译为 继承 而不是 扩展呢?<br>除了历史原因, 还有一点.<br>子类继承了父类, 也将获得父类的全部成员变量和方法.<br>这与我们现实中子辈从父辈那里获得一笔财富的继承关系很像.<br>但是, Java的子类不能继承父类的构造器.</p>
</blockquote>
<p>下面写个程序示范子类继承父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个水果! 重:&quot;</span> + weight + <span class="string">&quot;g!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来定义该Fruit类的子类Apple</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Apple对象</span></span><br><span class="line">        <span class="type">Apple</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        <span class="comment">//Apple 对象本身没有 weight 成员变量</span></span><br><span class="line">        <span class="comment">//因为Apple 父类有 weight 成员变量, 所以也可以访问 Apple 对象的 weight 成员变量.</span></span><br><span class="line">        a.weight = <span class="number">56</span>;</span><br><span class="line">        <span class="comment">//调用 Apple 对象的 info() 方法</span></span><br><span class="line">        a.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>上面的 Apple 类只是一个空类, 它只包含了一个 main() 方法.<br>但程序中创建了 Apple 对象之后, 可以访问该 Apple 对象的 weight 实例变量和info()方法, 这表明 Apple 对象也具有了 weight 实例变量和 info() 方法, 这就是继承的作用.</p>
</blockquote>
<p>Java类虽然只能有一个直接父类, 但它可以有无限多个间接父类.<br>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> <span class="keyword">extends</span> <span class="title class_">Plant</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;...&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>上面类定义中, Fruit 是 Apple 类的父类. </p>
<blockquote>
<p>Plant 类也是 Apple 类的父类.<br>区别是 Fruit 是 Apple 的直接父类, 而 Plant 则是 Apple 类的间接父类.</p>
<p>如果定义一个 Java类时, 并未显式指定这个类的直接父类.<br>则这个类默认继承 java.lang.Object 类.<br>因此可以得出, java.lang.Object 类时所有类的父类.<br>要么是直接父类, 要么是其间接父类.<br>因此, 所有的Java对象都可以调用 java.lang.Object 类所定义的实例方法. </p>
</blockquote>
<h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><blockquote>
<p>子类继承了父类, 所以说子类是一个特殊的父类.<br>大部分时候, 子类总是以父类为基础.<br>额外增加新的成员变量和方法.<br>但有一种情况例外: 子类需要重写父类的方法.<br>例如鸟类都包含了飞翔的方法, 但其中的鸵鸟并不会飞, 因为鸵鸟是鸟的子类, 因此它将从鸟类中获得飞翔的方法, 但这个飞翔的方法显然不适合鸵鸟, 所以鸵鸟这个子类需要重写鸟类(父类)的方法.</p>
</blockquote>
<p>​    下面先定义一个 Bird 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Bird 类的 fly() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在天空自由自在的飞翔...啦啦啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面定义一个 Ostrich 类, 这个类继承了 Bird 类, 同时重写 Bird 类的 fly() 方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ostrich</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重写 Bird 类的  fly() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;NND, 我可飞不了, 虽然我有双翅膀, 啦啦啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建 Ostrich 对象</span></span><br><span class="line">        <span class="type">Ostrich</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ostrich</span>();</span><br><span class="line">        <span class="comment">//执行 Ostrich 对象的 fly() 方法, 将会输出 &quot;...飞不了...&quot;</span></span><br><span class="line">        os.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行上面的程序, 将看到执行 os.fly() 时执行的不是 Bird 类的 fly() 方法.<br>而是执行 Ostrich 类的 fly() 方法.</p>
<p>这种子类包含与父类同名方法的现象称为方法重写(Override). 也被称为方法覆盖.<br>可以说子类重写了父类的方法, 也可以说子类覆盖了父类的方法, 都行.</p>
<p>方法的重写要遵循两同两小一大规则.</p>
</blockquote>
<ul>
<li>两同: 方法名相同 / 形参列表相同</li>
<li>两小: 子类方法返回值类型应比父类方法返回值类型小或相等. / 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等.</li>
<li>一大: 子类方法的访问权限应比父类方法的访问权限大或相等.</li>
</ul>
<blockquote>
<p>尤其需要指出, 覆盖方法和被覆盖方法要么都是类方法, 要么都是实例方法.<br>不能一个是类方法, 一个是实例方法, 例如下面代码就会报错.</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当子类覆盖了父类方法后, 子类的对象将无法访问父类中被覆盖的方法.<br>但可以在子类方法中调用父类中被覆盖的方法.<br>如果需要在子类方法中调用父类中被覆盖的方法, 则可以使用super(被覆盖的是实例方法) 或者 父类类名(被覆盖的是类方法) 来作为调用者, 调用父类中被覆盖的方法.</p>
<p>如果父类方法具有 private 访问权限, 则该方法对其子类是隐藏的.<br>因此子类无法访问该方法, 也就无法重写该方法.<br>如果子类中定义了一个与父类 private 方法具有相同的方法名 / 相同的形参列表 / 相同的返回值类型的方法, 依然不是重写.<br>这只是在子类中重新定义了一个新的方法. </p>
</blockquote>
<p>​    例如下面代码时完全正确的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//test() 方法是 private 访问权限, 子类不可访问该方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//此处并不是方法重写, 所以可以增加 static 关键字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>涨姿势:<br>方法重载和方法重写在英文中分别是 overload 和 override<br>重载和重写 并不是同一种东西, 虽然二者都是发生在方法之间, 并要求方法名相同之外, 并没有太大相似之处.<br>因为重载主要发生在同一个类的多个同名方法之间.<br>而重写发生在子类和父类的同名方法之间.<br>当然, 父类方法和子类方法之间也有可能发生重载, 因为子类会获得父类方法.<br>如果子类定义了一个与父类方法有相同方法名, 但参数列表不同的方法, 就会形成父类方法和子类方法的重载.</p>
</blockquote>
<hr>
<h4 id="继承中方法的重写的细节"><a href="#继承中方法的重写的细节" class="headerlink" title="继承中方法的重写的细节"></a>继承中方法的重写的细节</h4><ul>
<li><p>子类的方法必须与父类的方法一致，方法体不同。</p>
</li>
<li><p>参数列表必须相同</p>
</li>
<li><p>修饰符可以扩大，但是不可以缩小</p>
<ul>
<li>public &gt; protected &gt;default &gt;private</li>
</ul>
</li>
<li><p>抛出的异常范围可以缩小，但是不能扩大 ： ClassNotFoundException–&gt;Exception（大）</p>
</li>
<li><p>重写是方法的重写，与属性无关</p>
</li>
<li><p>重写方法只与非静态方法有关，与静态方法无关（静态方法不能被重写）</p>
</li>
<li><p>被 **static（属于类 ，不属于实例），final（常量方法），private（私有的）**修饰的方法不能被重写</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123; <span class="comment">//继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//方法的调用之和左边定义的类型有关</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.test(); <span class="comment">//打印 A==&gt;test()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//父类的引用指向了子类，但静态方法没有被重写</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        b.test(); <span class="comment">//打印 B==&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//非静态方法        </span></span><br><span class="line">    System.out.println(<span class="string">&quot;B==&gt;test()&quot;</span>);   </span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写了B的方法   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;     </span><br><span class="line">        System.out.println(<span class="string">&quot;A==&gt;test()&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类的引用指向了子类B b = new A(); </span></span><br><span class="line"><span class="comment">//子类重写了父类的方法，执行子类的方法b.test(); </span></span><br><span class="line"><span class="comment">//打印变成了</span></span><br><span class="line">A==&gt;test()<span class="comment">/* 静态方法是类的方法，非静态方法是对象的方法有static时，b调用了B类的方法，因为b是b类定义的没有static时，b调用的是对象的方法，而b是A类new出来的对象，调用A的方法*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重写：子类的方法必须跟父类保持一致 ：方法体不同</p>
<p>被**static(属于类，不属于实例)，final(常量方法)，private(私有)**修饰的方法不能重写</p>
<blockquote>
<p>为什么重写？</p>
<ol>
<li><p>重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作。</p>
</li>
<li><p>应用：重写以后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际上执行的是子类重写父类的方法。</p>
</li>
</ol>
<p>面试题目 ：如何区分方法的重写跟重载 ？</p>
<p>方法重载：</p>
<ol>
<li><p>在同一个类中</p>
</li>
<li><p>方法名相同，但是行参列表不同</p>
</li>
<li><p>方法的返回值，访问修饰符任意</p>
</li>
<li><p>与方法参数名无关</p>
</li>
</ol>
<p>方法的重写：</p>
<ol>
<li><p>有继承关系的子类中</p>
</li>
<li><p>方法名相同，参数列表相同（参数顺序，类型，个数），方法的返回值要相同</p>
</li>
<li><p>访问修饰符，访问范围子类需要大于父类的访问范围</p>
</li>
<li><p>与方法的参数名无关</p>
</li>
</ol>
<p>方法重写的更多理解（override/overwrite）</p>
<ol>
<li><p>方法重写 ：子类继承父类以后，可以对父类同名同参数的方法进，行覆盖操作</p>
</li>
<li><p>应用： 重写以后，当创建子类对象时，通过子类对象调用父类同名同参数的方法时，实际执行的是子类重写父类的方法</p>
</li>
<li><p>重写的规定 ：</p>
<ol>
<li><p>权限修饰符 返回值类型 类名（行参列表 ）throws 异常的类型{</p>
<p>//方法体</p>
<p>}</p>
<blockquote>
<p>约定俗称：子类中叫重写的方法，父类中叫被重写的方法。</p>
</blockquote>
<p>①子类重写的方法名和行参列表和父类被重写的方法名和行参列表相同。</p>
<p>②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。</p>
<blockquote>
<p>子类不能重写父类中声明为private的权限的方法。</p>
</blockquote>
<p>③返回值类型：</p>
<blockquote>
<p>父类被重写的方法的返回值是void，则子类中重写的方法的返回值也是void。</p>
<p>父类被重写的方法的返回值是A类型，则子类中重写的方法的返回值类型是A类型或者是A类的子类。</p>
<p>父类被重写的方法的返回值是基本数据类型（比如double），则子类重写的方法的返回值必须是相同的。</p>
<p>④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常。（具体细节在异常处理）</p>
<p>⑤子类和父类中同名同参数的方法要么都声明为非static（考虑重写），要么都声明为static（不考虑重写）</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p><strong>即同一方法可以根据发送对象的不同而采用不同的行为方式</strong></p>
</li>
<li><p>一个对象的实际类型是确定的，但可以指向对象的引用可以有很多</p>
</li>
<li><p>多态存在条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类方法</li>
<li>父类引用指向子类对象</li>
</ul>
<p><strong>注意点：</strong></p>
<ol>
<li><strong>多态是方法的多态，没有属性的多态</strong></li>
<li>父类和子类，有联系 类型转换异常: ClassCastException</li>
<li>存在条件：继承关系，方法需要重写，父类引用指向子类对象！</li>
</ol>
<hr>
</li>
</ul>
<h3 id="instanceof和类型转换"><a href="#instanceof和类型转换" class="headerlink" title="instanceof和类型转换"></a>instanceof和类型转换</h3><ul>
<li><strong>instanceof 引用类型比较</strong>，判断一个对象是什么类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();        System.out.println(object <span class="keyword">instanceof</span> Student);        System.out.println(object <span class="keyword">instanceof</span> Person);        System.out.println(object <span class="keyword">instanceof</span> Object);        System.out.println(object <span class="keyword">instanceof</span> Teacher);        System.out.println(object <span class="keyword">instanceof</span> String);        System.out.println(<span class="string">&quot;======================&quot;</span>);        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();        System.out.println(person <span class="keyword">instanceof</span> Student);        System.out.println(person <span class="keyword">instanceof</span> Person);        System.out.println(person <span class="keyword">instanceof</span> Object);        System.out.println(person <span class="keyword">instanceof</span> Teacher);<span class="comment">//        System.out.println(person instanceof String);        System.out.println(&quot;=======================&quot;);        Student student = new Student();        System.out.println(student instanceof Student);        System.out.println(student instanceof Person);        System.out.println(student instanceof Object);//        System.out.println(student instanceof Teacher);//        System.out.println(student instanceof String);，</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>类型转换</strong><ul>
<li>父类引用指向子类的对象</li>
<li>把子类转换为父类，向上转型，会丢失自己原来的一些方法</li>
<li>把父类转换为子类，向下转型，强制转换，才调用子类方法</li>
<li>方便方法的调用(转型)，减少重复的代码，简洁</li>
</ul>
</li>
</ul>
<h3 id="多态性："><a href="#多态性：" class="headerlink" title="多态性："></a>多态性：</h3><ul>
<li><p>理解多态性：可以理解为一种事物的多种形态</p>
</li>
<li><p>何为多态性：</p>
<ul>
<li><blockquote>
<p>对象的多态性：父类的引用指向子类的对象（或者子类的对象赋给父类的引用）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>多态的使用：</p>
<ul>
<li><blockquote>
<p>有了多态的使用以后，我们在编译器只能调用父类声明的方法，但是在运行期，我们实际执行的是子类的重写父类的方法</p>
</blockquote>
</li>
</ul>
</li>
<li><p>分析 s. move();</p>
<ul>
<li><p>java程序分为编译阶段 和 运行阶段</p>
<ol>
<li><p>首先来分析编译阶段：</p>
<blockquote>
<ul>
<li>对于编译器来说，编译器只知道s的类型是Animal，所以编译器在检查语法的时候，会去Animal.class字节码文件中找move()方法，找到的话，就进行绑定move()，此时编译通过，静态绑定成功。(编译阶段属于静态绑定阶段)</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
</li>
</ul>
<p>2.继续分析运行阶段:</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><blockquote>
<ul>
<li>运行阶段的时候 ,实际上在堆内存创建的 java对象 是Cat对象,所以在move()的时候, 实际上真正参与move()对象的是一只猫 ,所以运行阶段会动态执行Cat对象的move()方法 .(运行阶段属于动态绑定)</li>
<li>但是运行的时候和底层堆存中的实际对象有关 ,真正执行的时候会调用真实对象的相关方法 .</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>总结：编译，看左边。执行（运行），看右边。</p>
</li>
<li><p>对象的多态性：只适用于方法，不适用于属性。</p>
</li>
<li><p>多态性的使用前提：①类的继承关系 ② 方法的重写</p>
</li>
<li><p>instanceof     关键字的使用：</p>
</li>
<li><blockquote>
<ul>
<li>a instanceof A :判断对象a 是否为A类的实例，如果是，则返回true，如果不是，则返回false</li>
<li>使用情景：为了避免在向下转型时出现ClassCastException的异常，所以我们在向下转型之前，我们进行instanceof的判断，一旦返回true，就立即向下转型，如果返回false，就停止向下转型。</li>
<li>如果a instanceof A 返回true， 则 a instanaceof B也会返回true。</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<p>练习注意：</p>
<blockquote>
<ol>
<li>若子类重写了父类的方法，则就意味着子类定义的方法彻底覆盖了父类里同名同参数的方法，系统将不可能把父类里面的方法转移到子类中</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量：即编译看左边，运行看右边。</li>
</ol>
</blockquote>
<p>有了对象的多态性以后，内存实际上加载了子类特有的属性和方法。但是由于变量声明为父亲类型</p>
<p>导致了编译时，只能调用父类中声明的属性和方法，。子类特有的属性和方法就不能调用。</p>
<p>如何才能调用子类中的属性和方法？*</p>
<blockquote>
<p>向下转型：使用强制类型转化，缺点:会有精度的损失</p>
</blockquote>
<hr>
<h2 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h2><blockquote>
<p>如果需要在子类方法中调用父类被覆盖的实例方法.<br>则可以使用 super 限定来调用父类被覆盖的实例方法.<br>为上面的 Ostrich 类添加一个方法, 在这个方法中调用 Bird 类中被覆盖的 fly 方法.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callOverrideMethod</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在子类方法中通过 super 显式调用父类被覆盖的实例方法</span></span><br><span class="line">    <span class="built_in">super</span>.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>super 是 Java提供的一个关键字, super 用于限定该对象调用它从父类继承得到的实例变量或方法.<br>正如 this 不能出现在 static 修饰的方法中一样, super 也不能出现在 static 修饰的方法中.<br>static 修饰的方法是属于类的.<br>该方法的调用者可能是一个类, 而不是对象, 因而 super 限定也就失去了意义.</p>
<p>如果在构造器中使用 super<br>则 super 用于限定该构造器初始化的是该对象从父类继承得到的实例变量, 而不是该类自己定义的实例变量.</p>
<p>如果子类定义了和父类同名的实例变量.<br>则会发生子类实例变量隐藏父类实例变量的情形.<br>在正常情况下, 子类里定义的方法直接访问该实例变量默认会访问到子类中定义的实例变量. </p>
<p>无法访问到父类中被隐藏的实例变量.<br>在子类定义的实例方法中可以通过 super 来访问父类中被隐藏的实例变量. </p>
</blockquote>
<p>​    如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessOwner</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessBase</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过使用 super 来限定访问从父类继承得到的 a 的实例变量</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SubClass</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">        sc.accessOwner(); <span class="comment">//输出 7</span></span><br><span class="line">        sc.accessBase(); <span class="comment">//输出 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面程序的 BaseClass 和 SubClass 中都定义了名为 a 的实例变量.<br>则 SubClass 的 a 实例变量将会隐藏BaseClass 的 a 实例变量.<br>当系统创建了 SubClass 对象时, 实际上会为 SubClass 对象分配两块内存.</p>
</blockquote>
<hr>
<blockquote>
<p>如果子类里没有包含和父类同名的成员变量.<br>那么在子类实例方法中访问该成员变量时, 则无需显式使用 super 或 父类名作为调用者.<br>如果在某个方法中访问名为 a 的成员变量, 但没有显式指定调用者, 则系统查找 a 的顺序为:    </p>
</blockquote>
<ul>
<li>查找该方法是否有名为a的局部变量。</li>
<li>查找当前；类是否包含名为a的成员变量。</li>
<li>查找a的直接父类是否含有名为a的成员变量， 依次上溯 a 的所有父类. 直到 java.lang.Object 类.</li>
<li>如果最终不能找到名为 a 的成员变量, 则系统出现编译错误.</li>
</ul>
<blockquote>
<p>如果被覆盖的是类变量, 在子类的方法中则可以通过父类名作为调用者来访问被覆盖的类变量.</p>
<p>涨姿势:<br>当程序创建一个子类对象时.<br>系统不仅会为该类中定义的实例变量分配内存.<br>也会为它从父类继承得到的所有实例变量分配内存.<br>即使子类定义了与父类中同名的实例变量.<br>也就是说, 当系统创建一个 java 对象时.<br>如果该 java 类有两个父类(一个直接父类 A / 一个间接父类 B)<br>假设 A 类中定义了 2 个实例变量, B 类中定义了 3 个实例变量.<br>当前类中定义了 2 个实例变量, 那么这个 java 对象会保存 2 + 3 + 2 个实例变量.</p>
</blockquote>
<hr>
<p>因为子类中定义与父类中同名的实例变量并不会完全覆盖父类中定义的实例变量, 它只是简单的隐藏了父类中实例变量, 所以会出现如下特殊情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义一个私有的 tag 实例变量来隐藏父类的 tag 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&quot;猪八戒&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HideTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Derived</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">        <span class="comment">//程序不可访问 d 的私有变量 tag , 所以下面语句将引起编译错误</span></span><br><span class="line">        <span class="comment">//System.out.println(d.tag);</span></span><br><span class="line">        <span class="comment">//将 d 变量显式的向上转型为 Parent 后, 即可访问 tag 实例变量</span></span><br><span class="line">        <span class="comment">//程序将输出 孙悟空</span></span><br><span class="line">        System.out.println(((Parent)d).tag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面程序父类 Parent 定义了一个 tag 实例变量.<br>其子类 Derived 定义了一个 private 的 tag 实例变量.<br>子类中定义的这个实例变量将会隐藏父类中定义的 tag 实例变量.</p>
<p>程序的入口 main() 方法中先创建了一个 Derived 对象.<br>这个 Derived 对象将会保存两个 tag 实例变量.<br>一个是在 Parent 中定义的 tag 实例变量.<br>一个是在 Derived 类中定义的 tag 实例变量.<br>此时程序中包括了一个 d 变量. </p>
</blockquote>
<p>​    它引用一个 Derived 对象, 内存中的存储示意图如下:</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20160730161641818" alt="img" style="zoom:50%;" /></p>
<blockquote>
<p>接着, 程序将 Derived 对象赋给 d 变量.<br>接着, 程序试图通过 d 来访问 tag 实例变量, 程序将提示访问权限不允许.<br>接着, 将 d 变量强制向上转型为 Parent 类型.<br>再通过它来访问 tag 实例变量是允许的.</p>
</blockquote>
<h3 id="调用父类构造器"><a href="#调用父类构造器" class="headerlink" title="调用父类构造器"></a>调用父类构造器</h3><blockquote>
<p>子类不会获得父类的构造器。</p>
<p>但子类构造器里可以调用父类构造器的初始化代码。</p>
<p>类似于前面介绍的一个构造器可以调用另一个重载构造器。</p>
<p>在一个构造器中调用另一个重载的构造器使用this来调用完成。</p>
<p>在子类构造器中调用父类构造器使用super调用来完成。</p>
</blockquote>
<p>看下面程序定义了 Base 类 和 Sub 类, 其中 Sub 类是 Base 类的子类.<br>程序在 Sub 类的构造器中使用 super 来调用 Base 类的构造器初始化代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> size;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(<span class="type">double</span> size, String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">(<span class="type">double</span> size, String name, String color)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过 super 调用来调用父类构造器的初始化过程</span></span><br><span class="line">        <span class="built_in">super</span>(size, name);</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>(<span class="number">5.6</span>, <span class="string">&quot;皮卡丘&quot;</span>, <span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">        <span class="comment">//输出 Sub 对象的 三个实例变量</span></span><br><span class="line">        System.out.println(s.size + <span class="string">&quot;--&quot;</span> + s.name + <span class="string">&quot;--&quot;</span> + s.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>从上面程序中不难看出, 使用 super 调用和使用 this 调用也很像.<br>区别在于 super 调用的是其父类的构造器, 而 this 调用的是同一个类中重载的构造器.<br>因此, 使用 super 调用父类构造器也必需出现在子类构造器执行体的第一行.<br>所以 this 调用 和 super 调用不会同时出现.</p>
<p>不管是否使用 super 调用来执行父类构造器的初始化代码.<br>子类构造器总会调用父类构造器一次. </p>
</blockquote>
<p>​    子类构造器调用父类构造器分如下几种情况：</p>
<blockquote>
<ul>
<li>子类构造器执行体的第一行使用 super 显式调用父类构造器.系统将根据 super 调用里传入的实参列表调用父类对应的构造器.</li>
<li>子类构造器执行体的第一行代码使用 this 显式调用本类中重载的构造器,系统将根据 this 调用里传入的实参列表调用本类中的另一个构造器.执行本类中另一个构造器时即会调用父类构造器.</li>
<li>子类构造器执行体中既没有 super 调用, 也没有 this 调用, 系统将会在执行子类构造器之前, 隐式调用父类无参数的构造器.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>不管上面哪种情况, 当调用子类构造器来初始化子类对象时.<br>父类构造器总会在子类构造器之前执行:<br>不仅如此, 执行父类构造器时, 系统会再次上溯执行其父类构造器……以此类推.<br>创建任何 Java对象, 最先执行的总是 java.lang.Object 类的构造器.</p>
</blockquote>
<p>对于如下图所示的继承树. </p>
<blockquote>
<p>如果创建 ClassB 的对象, 系统将先执行 java.lang.Object 类的构造器.<br>再执行 ClassA 类的构造器.<br>然后才执行 ClassB 类的构造器.<br>这个执行过程还是最基本的情况.<br>如果 ClassB 显式调用 ClassA 的构造器, 而该构造器又调用了 ClassA 类中重载的构造器, 则会看到 ClassA 两个构造器先后执行的情形.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20160730171850768" alt="img" style="zoom: 50%;" /></p>
<blockquote>
<p>下面程序定义了三个类, 它们之间有严格的继承关系.<br>通过这种继承关系来让你看看构造器之间的调用关系.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Creature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Creature</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creature 无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="keyword">extends</span> <span class="title class_">Creature</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal 带一个参数的构造器,&quot;</span> + <span class="string">&quot;该动物的 name 为:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用 this 调用同一个重载的构造器</span></span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal 带两个参数的构造器,&quot;</span> + <span class="string">&quot;其 age 为:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wolf</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wolf</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//显式调用父类有两个参数的构造器</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;大灰狼&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Wolf 无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面程序的 main 方法只创建了一个 Wolf 对象.<br>但系统在底层完成了复杂的操作.<br>运行上面的程序, 看到如下运行结果:</p>
</blockquote>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creature 无参数的构造器</span><br><span class="line">Animal 带一个参数的构造器, 该动物的 name 为大灰狼</span><br><span class="line">Animal 带两个参数的构造器, 其 age 为 <span class="number">3</span></span><br><span class="line">Wolf 无参数的构造器</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>从上面的运行过程来看.<br>创建任何对象总是从该类所在继承树最顶层的类的构造器开始执行.<br>然后依次向下执行.<br>最后才执行本类的构造器.<br>如果某个父类通过 this 调用了 同类中重载的构造器.<br>就会依次执行此父类的多个构造器</p>
</blockquote>
<hr>
<h2 id="super-amp-this"><a href="#super-amp-this" class="headerlink" title="super\&amp;this"></a>super\&amp;this</h2><p>super注意点：</p>
<ol>
<li><p>super调用父类的构造方法，必须在构造方法的第一个</p>
</li>
<li><p>super必须只能出现在子类的方法或者构造方法中</p>
</li>
<li><p>super和this不能通知调用构造方法</p>
</li>
<li><p>我们可以在子类的方法或构造器中。通过使用“super.属性”或”super.方法“，显示的调用父类中的属性和方法，但是在通常情况下，通常省略“super”关键字。</p>
</li>
<li><p>特殊情况下，当子类或父类中定义了同名的属性时，我们想要在子类中调用父类声明的属性，则必须显示的使用“super.属性”的方式，表明调用的是父类中声明的属性</p>
</li>
<li><p>特殊情况，当子类重写了父类的方法以后，我们想要在子类中调用父类被重写的方法时，则必须显示的使用”super.方法“的方式，表明调用的是父类中的方法。</p>
</li>
</ol>
<p>VS this：</p>
<ul>
<li><p>代表的对象不同</p>
<ul>
<li><p>this ： 本身调用者这个对象</p>
</li>
<li><p>super ：只能在继承条件下可以试用</p>
</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li><p>this（） ：本类的构造</p>
</li>
<li><p>super（）：父类的构造</p>
</li>
<li><p>我们可以在子类的构造器中显示的适用”super.（行参列表）“的方式，调用父类中声明的指定构造器</p>
</li>
<li><p>”super.（行参列表）“的使用，必须声明在子类构造器的首行！</p>
</li>
<li><p>我们在类的构造器中，针对”this.（行参列表）“或”super.（行参列表）“只能二选一。</p>
</li>
<li><p>在构造器的首行，没有显示的声明”this.（行参列表）“或”super.（行参列表）“，则默认的调用的是父类中的空参的构造器。</p>
</li>
<li><p>super     不是引用 ,super也不保存内存地址 ,super也不指向任何对象</p>
</li>
<li><p>super只是代表当前对象内部的那一块父类的特征.</p>
</li>
</ul>
</li>
<li><p>super与this<strong>的区别</strong> ：super<strong>代表父类对象的引用</strong>，<strong>只能继承条件下使用</strong>，this调用自身的对象，没有继承关系也可以使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">//隐藏代码，默认调用了父类的无参构造，要写只能写第一行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/gaoziman/bed/img/20210427083318162.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="小结：方法的重载和重写"><a href="#小结：方法的重载和重写" class="headerlink" title="小结：方法的重载和重写"></a>小结：方法的重载和重写</h3><ul>
<li><p>从编译和运行的角度来讲：</p>
</li>
<li><blockquote>
<ul>
<li>重载，是允许多个同名的方法，而这些方法的参数不同，编译器根据方法不同的参数表，对同名方法的名称进行修饰。对于编译器而言，这些同名的方法就成了不同的方法。他们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类同名不同参数的方法。</li>
<li>所以对于重载而言，在方法调用之前，就已经确定了所要调用的方法，这称为“早绑定”或”静态绑定“</li>
<li>而对于多态，只有等到方法调用的那一刻，编译器才会确定所调用的具体方法，这称为“晚绑定”或“动态绑定”</li>
<li>“不要犯傻，只要确定他是不是晚绑定，那他就不是多态！”</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a><strong>JavaBean</strong></h3><ul>
<li><p>所谓的JavaBean，就是指符合如下的Java类：</p>
</li>
<li><p>类是公共的</p>
</li>
<li><p>有一个无参的构造器</p>
</li>
<li><p>有属性，且有相应的set，get方法。</p>
</li>
<li><p>用户可以使用JavaBean将功能，处理，数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面，Servlet其他JavaBean程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何变化。</p>
<hr>
<h2 id="面向对象阶段其他细节问题"><a href="#面向对象阶段其他细节问题" class="headerlink" title="面向对象阶段其他细节问题"></a>面向对象阶段其他细节问题</h2><h3 id="什么时候变量声明为实例的-什么时候变量声明为静态的"><a href="#什么时候变量声明为实例的-什么时候变量声明为静态的" class="headerlink" title="什么时候变量声明为实例的,什么时候变量声明为静态的?"></a>什么时候变量声明为实例的,什么时候变量声明为静态的?</h3><blockquote>
<p>如果这个类型的所有对象的属性值都是一样的,不建议定义为实例变量,浪费内存空间. 建议定义为类级别特征 ,定义为静态变量 ,在方法区中只保留一份,节省内存开销.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>一个对象一份的是实例变量</p>
<p>所有对象一份的是静态变量</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://manamn.space">Gao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89/">https://manamn.space/2022/06/12/Java%E5%9F%BA%E7%A1%80/07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://manamn.space" target="_blank">爱笑的Gao的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a><a class="post-meta__tags" href="/tags/Java%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/">Java自学笔记</a></div><div class="post_share"><div class="social-share" data-image="http://pic.netbian.com/uploads/allimg/220612/152947-165501898725ac.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/06-IDEA%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><img class="prev-cover" src="http://pic.netbian.com/uploads/allimg/220612/154354-1655019834388a.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">06  IDEA集成开发工具</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/08-Java%E8%BF%9B%E9%98%B6/"><img class="next-cover" src="http://pic.netbian.com/uploads/allimg/220612/151918-16550183582aa7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">08  Java进阶</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/01-Java%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" title="01  Java基础入门"><img class="cover" src="http://pic.netbian.com/uploads/allimg/211122/000739-16375108599425.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">01  Java基础入门</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/02-Java%E5%85%A5%E9%97%A8/" title="02 Java入门"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220620/235056-165574025622e4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">02 Java入门</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/03-Java%E5%9F%BA%E7%A1%80/" title="03  Java基础"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220618/000911-16554821517f03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">03  Java基础</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/04-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="04  Java流程控制"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220608/004436-165462027636ca.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">04  Java流程控制</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/05-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" title="05  数组与方法"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220605/231248-1654441968fc17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">05  数组与方法</div></div></a></div><div><a href="/2022/06/12/Java%E5%9F%BA%E7%A1%80/06-IDEA%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" title="06  IDEA集成开发工具"><img class="cover" src="http://pic.netbian.com/uploads/allimg/220612/154354-1655019834388a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">06  IDEA集成开发工具</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://yzf.qq.com/fsna/kf-file/kf_pic/20221016/KFPIC_38088722014365ca6_WXIMAGE_d75c047ed85544ddaded8bf8eafb054c.jpg?" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Gao</div><div class="author-info__description">生活明朗 万物可爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">142</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/gaoziman"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gaoziman" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2942894660@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/692044806?spm_id_from=333.1007.0.0" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2942894660&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#07-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">07  面向对象编程（OOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">Java面向对象三大特性（基础篇）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">对象的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象的三大核心特性简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">1、继承的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Java-%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">3、Java 封装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象编程三大特性详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">一、继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">1、继承的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">2、继承的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">3、语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">1.3.0.4.1.</span> <span class="toc-text">A、方法的重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.0.4.2.</span> <span class="toc-text">B、继承的初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.0.4.3.</span> <span class="toc-text">C、final关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.0.4.4.</span> <span class="toc-text">D、super关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.1.</span> <span class="toc-text">二、封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%B0%81%E8%A3%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">1、封装的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">2、封装的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B0%81%E8%A3%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3、封装的实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A%E3%80%81%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">A、访问修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E3%80%81this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">B、this关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E3%80%81Java-%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.1.3.3.</span> <span class="toc-text">C、Java 中的内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">三、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1、多态的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2、多态的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3、Java中的多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A%E3%80%81%E5%BC%95%E7%94%A8%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">A、引用多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E3%80%81%E6%96%B9%E6%B3%95%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">B、方法多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">C、引用类型转换</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">初始面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">回顾方法的定义以及调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.</span> <span class="toc-text">类和对象的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.1.</span> <span class="toc-text">创建和初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">1.6.2.</span> <span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96"><span class="toc-number">1.6.3.</span> <span class="toc-text">创建对象时JVM的内存变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.6.4.</span> <span class="toc-text">Java面向对象之各种变量详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E5%B1%9E%E6%80%A7%EF%BC%89%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">成员变量（属性）和局部变量的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">成员变量的初始化和内存中的运行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">局部变量的初始化和内存中的运行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.6.4.7.</span> <span class="toc-text">变量的使用规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.5.</span> <span class="toc-text">小结类与对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.8.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.9.</span> <span class="toc-text">静态代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.10.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">1.10.1.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.11.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.11.1.</span> <span class="toc-text">继承的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">1.11.2.</span> <span class="toc-text">方法的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">继承中方法的重写的细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.12.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.12.1.</span> <span class="toc-text">instanceof和类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%9A"><span class="toc-number">1.12.2.</span> <span class="toc-text">多态性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E9%99%90%E5%AE%9A"><span class="toc-number">1.13.</span> <span class="toc-text">super限定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.13.1.</span> <span class="toc-text">调用父类构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super-amp-this"><span class="toc-number">1.14.</span> <span class="toc-text">super\&amp;this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="toc-number">1.14.1.</span> <span class="toc-text">小结：方法的重载和重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">1.15.</span> <span class="toc-text">拓展知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean"><span class="toc-number">1.15.1.</span> <span class="toc-text">JavaBean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%98%B6%E6%AE%B5%E5%85%B6%E4%BB%96%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="toc-number">1.16.</span> <span class="toc-text">面向对象阶段其他细节问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%AE%9E%E4%BE%8B%E7%9A%84-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BA%E9%9D%99%E6%80%81%E7%9A%84"><span class="toc-number">1.16.1.</span> <span class="toc-text">什么时候变量声明为实例的,什么时候变量声明为静态的?</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/" title="Web环境搭建以及Servlet入门"><img src="http://pic.netbian.com/uploads/allimg/210827/235918-1630079958392e.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web环境搭建以及Servlet入门"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/" title="Web环境搭建以及Servlet入门">Web环境搭建以及Servlet入门</a><time datetime="2022-10-16T15:01:07.000Z" title="发表于 2022-10-16 23:01:07">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/" title="一文学懂JSP"><img src="http://pic.netbian.com/uploads/allimg/221002/214642-1664718402e8b8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂JSP"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/" title="一文学懂JSP">一文学懂JSP</a><time datetime="2022-10-16T15:00:49.000Z" title="发表于 2022-10-16 23:00:49">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/" title="一文学懂Cookie与Session的区别"><img src="http://pic.netbian.com/uploads/allimg/210831/102129-16303764895142.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂Cookie与Session的区别"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/" title="一文学懂Cookie与Session的区别">一文学懂Cookie与Session的区别</a><time datetime="2022-10-16T15:00:28.000Z" title="发表于 2022-10-16 23:00:28">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" title="一文学懂过滤器和监听器"><img src="http://pic.netbian.com/uploads/allimg/220909/000311-16626529918d5d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文学懂过滤器和监听器"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" title="一文学懂过滤器和监听器">一文学懂过滤器和监听器</a><time datetime="2022-10-16T15:00:12.000Z" title="发表于 2022-10-16 23:00:12">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" title="一文了解转发与重定向"><img src="http://pic.netbian.com/uploads/allimg/210423/224716-16191892361adb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="一文了解转发与重定向"/></a><div class="content"><a class="title" href="/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/" title="一文了解转发与重定向">一文了解转发与重定向</a><time datetime="2022-10-16T14:59:54.000Z" title="发表于 2022-10-16 22:59:54">2022-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Gao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="/js/diytitle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_213.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/随笔⌚/&quot;);" href="javascript:void(0);">随笔⌚</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">大学学习史</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_46.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/转载/&quot;);" href="javascript:void(0);">转载</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">前端成长历程</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_53.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM上篇/&quot;);" href="javascript:void(0);">JVM上篇</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">生活欢乐多</span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM下篇/&quot;);" href="javascript:void(0);">JVM下篇</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JavaSE/&quot;);" href="javascript:void(0);">JavaSE</a><span class="categoryBar-list-count">19</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM中篇/&quot;);" href="javascript:void(0);">JVM中篇</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/重学Java基础/&quot;);" href="javascript:void(0);">重学Java基础</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL-shk/&quot;);" href="javascript:void(0);">MySQL-shk</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_214.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习路线/&quot;);" href="javascript:void(0);">学习路线</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_62.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/教程/&quot;);" href="javascript:void(0);">教程</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文档/&quot;);" href="javascript:void(0);">文档</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_189.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java自学笔记/&quot;);" href="javascript:void(0);">Java自学笔记</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_61.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C语言/&quot;);" href="javascript:void(0);">C语言</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);">Java</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java知识点/&quot;);" href="javascript:void(0);">Java知识点</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MyBatis/&quot;);" href="javascript:void(0);">MyBatis</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Thymeleaf/&quot;);" href="javascript:void(0);">Thymeleaf</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/多线程/&quot;);" href="javascript:void(0);">多线程</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_103.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java-Basic/&quot;);" href="javascript:void(0);">Java-Basic</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_5.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_214.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/HTTP/&quot;);" href="javascript:void(0);">HTTP</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_62.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Web网页技术/&quot;);" href="javascript:void(0);">Web网页技术</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在湘进行备案" title=""><img src="https://img.shields.io/badge/湘ICP备-2022004213号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/js/runtime/runtime.min.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper_container_card" style="height: auto;width: 100%"><div id="random"><div id="random-banner"><canvas id="peoplecanvas"></canvas></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://tx2.a.yximgs.com/udata/music/music_f307a39407e74b1ab48f8409b8b0c3210.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt="">2021最新版java学习路线</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/05/16/教程/2021最新版java学习路线/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://nwjshm.cn/usr/themes/Cuteen/static/img/default-list-bg.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt="">随机图api</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/05/03/随机图api/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper_init.js"></script><script data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/people.min.js"></script><script async src="/anzhiyu/random.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>