<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱笑的Gao的个人博客</title>
  
  <subtitle>生活明朗 万物可爱</subtitle>
  <link href="https://manamn.space/atom.xml" rel="self"/>
  
  <link href="https://manamn.space/"/>
  <updated>2022-12-13T13:45:28.228Z</updated>
  <id>https://manamn.space/</id>
  
  <author>
    <name>Gao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022 12月15日 每日面试题(MyBatis)</title>
    <link href="https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-12%E6%9C%8815%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98-MyBatis/"/>
    <id>https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-12%E6%9C%8815%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98-MyBatis/</id>
    <published>2022-12-13T13:30:25.000Z</published>
    <updated>2022-12-13T13:45:28.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-12月15日-每日面试题-MyBatis"><a href="#2022-12月15日-每日面试题-MyBatis" class="headerlink" title="2022 12月15日 每日面试题(MyBatis)"></a>2022 12月15日 每日面试题(MyBatis)</h1><h1 id="1、MyBatis是什么？"><a href="#1、MyBatis是什么？" class="headerlink" title="1、MyBatis是什么？"></a>1、MyBatis是什么？</h1><blockquote><ol><li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</li><li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li></ol></blockquote><h1 id="2、Mybatis优缺点"><a href="#2、Mybatis优缺点" class="headerlink" title="2、Mybatis优缺点"></a>2、Mybatis优缺点</h1><blockquote><p><strong>优点</strong> ：</p><ul><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li><li>能够与Spring很好的集成</li></ul><p><strong>缺点</strong> ：</p><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul></blockquote><h1 id="3、Hibernate-和-MyBatis-的区别"><a href="#3、Hibernate-和-MyBatis-的区别" class="headerlink" title="3、Hibernate 和 MyBatis 的区别"></a>3、Hibernate 和 MyBatis 的区别</h1><blockquote><p><strong>相同点</strong> ：</p><ul><li>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</li></ul><p><strong>不同点</strong> ：</p><ul><li>映射关系<ul><li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li></ul></li></ul><p><strong>SQL优化和移植性</strong></p><ul><li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li></ul><p><strong>ORM是什么</strong></p><ul><li>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</li></ul></blockquote><h1 id="4、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#4、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="4、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>4、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h1><blockquote><ul><li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而 Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</li></ul></blockquote><h1 id="5、传统JDBC开发存在什么问题？"><a href="#5、传统JDBC开发存在什么问题？" class="headerlink" title="5、传统JDBC开发存在什么问题？"></a>5、传统JDBC开发存在什么问题？</h1><blockquote><ul><li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li><li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li><li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</li></ul></blockquote><h1 id="6、JDBC编程有哪些不足之处，MyBatis是如何解决的？"><a href="#6、JDBC编程有哪些不足之处，MyBatis是如何解决的？" class="headerlink" title="6、JDBC编程有哪些不足之处，MyBatis是如何解决的？"></a>6、JDBC编程有哪些不足之处，MyBatis是如何解决的？</h1><blockquote><ol><li>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。<ul><li>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</li></ul></li><li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。<ul><li>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</li></ul></li><li>向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<ul><li>解决： Mybatis自动将java对象映射至sql语句。</li></ul></li><li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<ul><li>解决：Mybatis自动将sql执行结果映射至java对象。</li></ul></li></ol></blockquote><h1 id="7、MyBatis和Hibernate的适用场景"><a href="#7、MyBatis和Hibernate的适用场景" class="headerlink" title="7、MyBatis和Hibernate的适用场景?"></a>7、MyBatis和Hibernate的适用场景?</h1><blockquote><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li><li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li></ul><p><strong>开发难易程度和学习成本</strong></p><ul><li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li><li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li></ul><p><strong>总结</strong></p><ul><li>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架。</li><li>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</li></ul></blockquote><h1 id="8、MyBatis编程步骤是什么样的？"><a href="#8、MyBatis编程步骤是什么样的？" class="headerlink" title="8、MyBatis编程步骤是什么样的？"></a>8、MyBatis编程步骤是什么样的？</h1><blockquote><ol><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过sqlsession执行数据库操作</li><li>调用session.commit()提交事务</li><li>调用session.close()关闭会话</li></ol></blockquote><h1 id="9、请说说MyBatis的工作原理"><a href="#9、请说说MyBatis的工作原理" class="headerlink" title="9、请说说MyBatis的工作原理"></a>9、请说说MyBatis的工作原理</h1><p>​                                                                <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221213173013654.png" alt=""></p><blockquote><ol><li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</li><li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</li><li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li><li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li><li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li><li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</li><li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</li><li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li></ol></blockquote><h1 id="10、MyBatis的功能架构是怎样的"><a href="#10、MyBatis的功能架构是怎样的" class="headerlink" title="10、MyBatis的功能架构是怎样的"></a>10、MyBatis的功能架构是怎样的</h1><p>​                            <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221213174016530.png" alt=""></p><blockquote><ul><li>我们把Mybatis的功能架构分为三层：<ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul></li></ul></blockquote><h1 id="11、什么是DBMS"><a href="#11、什么是DBMS" class="headerlink" title="11、什么是DBMS"></a>11、什么是DBMS</h1><blockquote><p>DBMS：数据库管理系统(database management system)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数zd据库，简称dbms。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。用户通过dbms访问数据库中的数据，数据库管理员也通过dbms进行数据库的维护工作。它可使多个应用程序和用户用不同的方法在同时版或不同时刻去建立，修改和询问数据库。DBMS提供数据定义语言DDL（Data Definition Language）与数据操作语言DML（Data Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加权、删除等操作。</p></blockquote><h1 id="12、为什么需要预编译"><a href="#12、为什么需要预编译" class="headerlink" title="12、为什么需要预编译"></a>12、为什么需要预编译</h1><blockquote><ul><li>定义 ：<ul><li>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</li></ul></li><li>为什么需要预编译<ul><li>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</li><li>防止SQL注入</li></ul></li></ul></blockquote><h1 id="13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h1><blockquote><ul><li>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</li><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p><code>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</code></p></blockquote><h1 id="14、Mybatis中如何指定使用哪一种Executor执行器？"><a href="#14、Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="14、Mybatis中如何指定使用哪一种Executor执行器？"></a>14、Mybatis中如何指定使用哪一种Executor执行器？</h1><blockquote><ul><li>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</li><li>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</li></ul></blockquote><h1 id="15、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#15、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="15、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>15、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h1><blockquote><ul><li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li><li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li><li>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</li></ul></blockquote><h1 id="16、MyBatis-和-的区别"><a href="#16、MyBatis-和-的区别" class="headerlink" title="16、MyBatis#{}和${}的区别"></a>16、MyBatis#{}和${}的区别</h1><blockquote><ul><li><h1 id="是占位符，预编译处理；-是拼接符，字符串替换，没有预编译处理。"><a href="#是占位符，预编译处理；-是拼接符，字符串替换，没有预编译处理。" class="headerlink" title="{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。"></a>{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</h1></li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li><h1 id="可以有效的防止SQL注入，提高系统安全性；-不能防止SQL-注入"><a href="#可以有效的防止SQL注入，提高系统安全性；-不能防止SQL-注入" class="headerlink" title="{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入"></a>{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</h1></li><li><h1 id="的变量替换是在DBMS-中；-的变量替换是在-DBMS-外"><a href="#的变量替换是在DBMS-中；-的变量替换是在-DBMS-外" class="headerlink" title="{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外"></a>{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</h1></li></ul></blockquote><h1 id="17、模糊查询like语句该怎么写"><a href="#17、模糊查询like语句该怎么写" class="headerlink" title="17、模糊查询like语句该怎么写"></a>17、模糊查询like语句该怎么写</h1><blockquote><ol><li><p>’%${question}%’ 可能引起SQL注入，不推荐</p></li><li><p>“%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p></li><li><p>CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，（推荐）</p></li><li><p>使用bind标签（不推荐）</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221213174700379.png" alt="image-20221213174700379"></p></li></ol></blockquote><h1 id="18、在mapper中如何传递多个参数"><a href="#18、在mapper中如何传递多个参数" class="headerlink" title="18、在mapper中如何传递多个参数"></a>18、在mapper中如何传递多个参数</h1><h2 id="方法1：顺序传参法"><a href="#方法1：顺序传参法" class="headerlink" title="方法1：顺序传参法"></a>方法1：顺序传参法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(String name, <span class="type">int</span> deptId)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;   </span><br><span class="line">    select * from user   <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;<span class="number">0</span>&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;<span class="number">1</span>&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><h1 id="里面的数字代表传入参数的顺序。"><a href="#里面的数字代表传入参数的顺序。" class="headerlink" title="{}里面的数字代表传入参数的顺序。"></a>{}里面的数字代表传入参数的顺序。</h1></li><li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li></ul><h2 id="方法2：-Param注解传参法"><a href="#方法2：-Param注解传参法" class="headerlink" title="方法2：@Param注解传参法"></a>方法2：@Param注解传参法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String name, <span class="type">int</span> <span class="meta">@Param(&quot;deptId&quot;)</span> deptId)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;   </span><br><span class="line">    select * from user   <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><h1 id="里面的名称对应的是注解-Param括号里面修饰的名称。"><a href="#里面的名称对应的是注解-Param括号里面修饰的名称。" class="headerlink" title="{}里面的名称对应的是注解@Param括号里面修饰的名称。"></a>{}里面的名称对应的是注解@Param括号里面修饰的名称。</h1></li><li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li></ul><h2 id="方法3：Map传参法"><a href="#方法3：Map传参法" class="headerlink" title="方法3：Map传参法"></a>方法3：Map传参法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;   </span><br><span class="line">    select * from user   <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><h1 id="里面的名称对应的是Map里面的key名称。"><a href="#里面的名称对应的是Map里面的key名称。" class="headerlink" title="{}里面的名称对应的是Map里面的key名称。"></a>{}里面的名称对应的是Map里面的key名称。</h1></li><li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</li></ul><h2 id="方法4：Java-Bean传参法"><a href="#方法4：Java-Bean传参法" class="headerlink" title="方法4：Java Bean传参法"></a>方法4：Java Bean传参法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public User selectUser(User user);</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.jourwon.pojo.User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span>   </span><br><span class="line">    select * from user   where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h1 id="里面的名称对应的是User类里面的成员属性。"><a href="#里面的名称对应的是User类里面的成员属性。" class="headerlink" title="{}里面的名称对应的是User类里面的成员属性。"></a>{}里面的名称对应的是User类里面的成员属性。</h1></li><li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便。</li></ul><h1 id="19、Mybatis如何执行批量操作"><a href="#19、Mybatis如何执行批量操作" class="headerlink" title="19、Mybatis如何执行批量操作"></a>19、Mybatis如何执行批量操作</h1><blockquote><ul><li>使用foreach标签</li><li>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。<ul><li>item          表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index         指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open          表示该语句以什么开始，常用“(”；</li><li>separator     表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li><li>close         表示以什么结束，常用“)”。</li></ul></li><li>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：<ol><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li><li>具体用法如下：</li></ol></li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量保存(foreach插入多条数据两种方法)      </span></span><br><span class="line"><span class="comment">    int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> </span><br><span class="line">    //推荐使用<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span>  </span><br><span class="line">    INSERT INTO emp(ename,gender,email,did)   VALUES   </span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span>       </span><br><span class="line">    (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持 如jdbc.url=jdbc:mysql://localhost:3306/mybatisallowMultiQueries=true --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span>                                        </span><br><span class="line">        INSERT INTO emp(ename,gender,email,did)       </span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;) </span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="20、如何获取生成的主键"><a href="#20、如何获取生成的主键" class="headerlink" title="20、如何获取生成的主键"></a>20、如何获取生成的主键</h1><blockquote><ul><li>新增标签中添加：keyProperty=” ID “ 即可</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;userId&quot;</span> &gt;</span>     </span><br><span class="line">    insert into user(      user_name, user_password, create_time)      </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="21、当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#21、当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="21、当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>21、当实体类中的属性名和表中的字段名不一样 ，怎么办</h1><ul><li><p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span>         </span><br><span class="line">    select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第2种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getOrder&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span>   </span><br><span class="line">    select * from orders where order_id=#&#123;id&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span> <span class="attr">id</span>=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span>  </span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;     </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>&gt;</span>  </span><br><span class="line">        &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt; </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span> =<span class="string">&quot;orderno&quot;</span> <span class="attr">column</span> =<span class="string">&quot;order_no&quot;</span>/&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;price&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_price&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">reslutMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第3种 ： 在mybatis的核心配置文件中设置全局配置信息mapUnderscoreToCamelCase为true，将表中字段的下划线自动转换为驼峰</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot; mapunderscoreTocamecase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="22、Mapper-编写有哪几种方式？"><a href="#22、Mapper-编写有哪几种方式？" class="headerlink" title="22、Mapper 编写有哪几种方式？"></a>22、Mapper 编写有哪几种方式？</h1><ul><li><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p><ol><li><p>在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义 mapper 接口</p></li><li><p>实现类集成 SqlSessionDaoSupport mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p></li><li><p>spring 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; &quot;</span> <span class="attr">class</span>=<span class="string">&quot;mapper 接口的实现&quot;</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>         <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p><ol><li><p>在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p></li><li><p>定义 mapper 接口：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mapper.xml 中的 namespace 为 mapper 接口的地址</p></li><li><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p></li><li><p>Spring 中定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper 接口地址&quot;</span> /&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>第三种：使用 mapper 扫描器：</p><ol><li><p>mapper.xml 文件编写：mapper.xml 中的 namespace 为 mapper 接口的地址；mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致； 如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p></li><li><p>定义 mapper 接口： 注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p></li><li><p>配置 mapper 扫描器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mapper 接口包地址 &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span>           <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p></li></ol></li></ul><h1 id="23、什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#23、什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="23、什么是MyBatis的接口绑定？有哪些实现方式？"></a>23、什么是MyBatis的接口绑定？有哪些实现方式？</h1><blockquote><ul><li>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</li><li>接口绑定有两种实现方式<ol><li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li><li>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</li></ol></li></ul></blockquote><h1 id="24、使用MyBatis的mapper接口调用时有哪些要求？"><a href="#24、使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="24、使用MyBatis的mapper接口调用时有哪些要求？"></a>24、使用MyBatis的mapper接口调用时有哪些要求？</h1><blockquote><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol></blockquote><h1 id="25、这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#25、这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="25、这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>25、这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h1><blockquote><ul><li>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</li><li>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li></ul></blockquote><h1 id="26、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#26、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="26、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>26、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h1><blockquote><ul><li>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</li><li>原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同</li></ul></blockquote><h1 id="27、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#27、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="27、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>27、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h1><blockquote><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p></blockquote><h1 id="28、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#28、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="28、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>28、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h1><blockquote><ul><li>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</li><li>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</li></ul><p><strong>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</strong></p></blockquote><h1 id="29、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#29、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="29、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>29、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h1><blockquote><p>还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p></blockquote><h1 id="30、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#30、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="30、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>30、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h1><blockquote><ul><li>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</li><li>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</li></ul></blockquote><h1 id="31、-Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法"><a href="#31、-Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法" class="headerlink" title="31、 Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法"></a>31、 Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法</h1><blockquote><ul><li>能，不止可以一对多，一对一还可以多对多，一对多</li><li>实现方式：<ol><li>单独发送一个SQL去查询关联对象，赋给主对象，然后返回主对象</li><li>使用嵌套查询，似JOIN查询，一部分是A对象的属性值，另一部分是关联对 象 B的属性值，好处是只要发送一个属性值，就可以把主对象和关联对象查出来</li><li>子查询</li></ol></li></ul></blockquote><h1 id="32、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？"><a href="#32、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？" class="headerlink" title="32、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？"></a>32、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？</h1><blockquote><ul><li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li></ul></blockquote><h1 id="33、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#33、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="33、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>33、Mybatis是如何进行分页的？分页插件的原理是什么？</h1><blockquote><ul><li>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</li><li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li><li>select <em> from student，拦截sql后重写为：select t.</em> from (select * from student) t limit 0, 10</li></ul></blockquote><h1 id="34、简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#34、简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="34、简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>34、简述Mybatis的插件运行原理，以及如何编写一个插件。</h1><blockquote><ul><li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li><li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li></ul></blockquote><h1 id="35、Mybatis的一级、二级缓存"><a href="#35、Mybatis的一级、二级缓存" class="headerlink" title="35、Mybatis的一级、二级缓存"></a>35、Mybatis的一级、二级缓存</h1><blockquote><ul><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/></li><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-12月15日-每日面试题-MyBatis&quot;&gt;&lt;a href=&quot;#2022-12月15日-每日面试题-MyBatis&quot; class=&quot;headerlink&quot; title=&quot;2022 12月15日 每日面试题(MyBatis)&quot;&gt;&lt;/a&gt;2022 12月15</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022 11月14日 每日面试题(SpringBoot)</title>
    <link href="https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-11%E6%9C%8814%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98-SpringBoot/"/>
    <id>https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-11%E6%9C%8814%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98-SpringBoot/</id>
    <published>2022-12-13T13:29:45.000Z</published>
    <updated>2022-12-13T13:44:42.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-11月14日-每日面试题-SpringBoot"><a href="#2022-11月14日-每日面试题-SpringBoot" class="headerlink" title="2022 11月14日 每日面试题(SpringBoot)"></a>2022 11月14日 每日面试题(SpringBoot)</h1><h1 id="1、什么是-Spring-Boot？"><a href="#1、什么是-Spring-Boot？" class="headerlink" title="1、什么是 Spring Boot？"></a>1、什么是 Spring Boot？</h1><blockquote><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</p></blockquote><h1 id="2、为什么要用SpringBoot"><a href="#2、为什么要用SpringBoot" class="headerlink" title="2、为什么要用SpringBoot"></a>2、为什么要用SpringBoot</h1><blockquote><p>快速开发，快速整合，配置简化、内嵌服务容器</p></blockquote><h1 id="3、-SpringBoot与SpringCloud-区别"><a href="#3、-SpringBoot与SpringCloud-区别" class="headerlink" title="3、 SpringBoot与SpringCloud 区别"></a>3、 SpringBoot与SpringCloud 区别</h1><blockquote><p>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</p></blockquote><h1 id="4、Spring-Boot-有哪些优点？"><a href="#4、Spring-Boot-有哪些优点？" class="headerlink" title="4、Spring Boot 有哪些优点？"></a>4、Spring Boot 有哪些优点？</h1><blockquote><ul><li>Spring Boot 主要有如下优点：<ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li></ol></li></ul></blockquote><h1 id="5、Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#5、Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>5、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h1><blockquote><ul><li>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<ul><li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li><li>@ComponentScan：Spring组件扫描。</li></ul></li></ul></blockquote><h1 id="6、Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#6、Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="6、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>6、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h1><blockquote><p>pring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</p></blockquote><h1 id="7、Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#7、Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="7、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>7、Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h1><blockquote><p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</p></blockquote><h1 id="8、SpringBoot-Starter的工作原理"><a href="#8、SpringBoot-Starter的工作原理" class="headerlink" title="8、SpringBoot Starter的工作原理"></a>8、SpringBoot Starter的工作原理</h1><blockquote><ul><li>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</li><li>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）</li></ul></blockquote><h1 id="9、Spring-Boot-2-X-有什么新特性？与-1-X-有什么区别？"><a href="#9、Spring-Boot-2-X-有什么新特性？与-1-X-有什么区别？" class="headerlink" title="9、Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？"></a>9、Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h1><blockquote><ul><li>配置变更</li><li>JDK版本变更</li><li>第三方类库进行了升级</li><li>响应式 Spring 编程支持</li><li>HTTP/2 支持</li><li>配置属性绑定</li><li>更多改进与加强</li></ul></blockquote><h1 id="10、SpringBoot支持什么前端模板"><a href="#10、SpringBoot支持什么前端模板" class="headerlink" title="10、SpringBoot支持什么前端模板"></a>10、SpringBoot支持什么前端模板</h1><blockquote><p>thymeleaf，freemarker，jsp，官方不推荐JSP，会有限制</p></blockquote><h1 id="11、SpringBoot的缺点"><a href="#11、SpringBoot的缺点" class="headerlink" title="11、SpringBoot的缺点"></a>11、SpringBoot的缺点</h1><blockquote><ol><li>传统项目微服务改造难</li><li>使用简单，极易上手、精通难。因为他把底层的细节在不知不觉中屏蔽了。但是一定要深挖源码。</li></ol></blockquote><h1 id="12、运行-Spring-Boot-有哪几种方式？"><a href="#12、运行-Spring-Boot-有哪几种方式？" class="headerlink" title="12、运行 Spring Boot 有哪几种方式？"></a>12、运行 Spring Boot 有哪几种方式？</h1><blockquote><ol><li>打包用命令或者放到容器中运行</li><li>用 Maven/ Gradle 插件运行</li><li>直接执行 main 方法运行</li></ol></blockquote><h1 id="13、Spring-Boot-需要独立的容器运行吗？"><a href="#13、Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="13、Spring Boot 需要独立的容器运行吗？"></a>13、Spring Boot 需要独立的容器运行吗？</h1><blockquote><p>可以不需要，内置了 Tomcat/ Jetty 等容器。</p></blockquote><h1 id="14、开启-Spring-Boot-特性有哪几种方式？"><a href="#14、开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="14、开启 Spring Boot 特性有哪几种方式？"></a>14、开启 Spring Boot 特性有哪几种方式？</h1><blockquote><ol><li>继承spring-boot-starter-parent项目</li><li>导入spring-boot-dependencies项目依赖</li></ol></blockquote><h1 id="15、SpringBoot-实现热部署有哪几种方式？"><a href="#15、SpringBoot-实现热部署有哪几种方式？" class="headerlink" title="15、SpringBoot 实现热部署有哪几种方式？"></a>15、SpringBoot 实现热部署有哪几种方式？</h1><blockquote><ul><li>热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中</li><li>主要有两种方式：<ul><li>Spring Loaded</li><li>Spring-boot-devtools</li></ul></li></ul></blockquote><h1 id="16、SpringBoot事物的使用"><a href="#16、SpringBoot事物的使用" class="headerlink" title="16、SpringBoot事物的使用"></a>16、SpringBoot事物的使用</h1><blockquote><p>SpringBoot的事物很简单，首先使用注解EnableTransactionManagement开启事物之后，然后在Service方法上添加注解Transactional便可。</p></blockquote><h1 id="17、Async异步调用方法"><a href="#17、Async异步调用方法" class="headerlink" title="17、Async异步调用方法"></a>17、Async异步调用方法</h1><blockquote><p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法</p></blockquote><h1 id="18、Spring-Boot-有哪几种读取配置的方式？"><a href="#18、Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="18、Spring Boot 有哪几种读取配置的方式？"></a>18、Spring Boot 有哪几种读取配置的方式？</h1><blockquote><p>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量</p></blockquote><h1 id="19、SpringBoot的自动配置原理是什么"><a href="#19、SpringBoot的自动配置原理是什么" class="headerlink" title="19、SpringBoot的自动配置原理是什么"></a>19、SpringBoot的自动配置原理是什么</h1><blockquote><ul><li>主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</li><li>有了这个EnableAutoConfiguration的话就会：<ol><li>从配置文件META_INF/Spring.factories加载可能用到的自动配置类</li><li>去重，并将exclude和excludeName属性携带的类排除</li><li>过滤，将满足条件（@Conditional）的自动配置类返回</li></ol></li></ul></blockquote><h1 id="20、你如何理解-Spring-Boot-配置加载顺序？"><a href="#20、你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="20、你如何理解 Spring Boot 配置加载顺序？"></a>20、你如何理解 Spring Boot 配置加载顺序？</h1><blockquote><ul><li>在 Spring Boot 里面，可以使用以下几种方式来加载配置。<ol><li>properties文件；</li><li>YAML文件；</li><li>系统环境变量；</li><li>命令行参数；</li><li>…..</li></ol></li></ul></blockquote><h1 id="21、什么是-YAML？"><a href="#21、什么是-YAML？" class="headerlink" title="21、什么是 YAML？"></a>21、什么是 YAML？</h1><blockquote><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p></blockquote><h1 id="22、YAML-配置的优势在哪里"><a href="#22、YAML-配置的优势在哪里" class="headerlink" title="22、YAML 配置的优势在哪里 ?"></a>22、YAML 配置的优势在哪里 ?</h1><blockquote><ul><li>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？<ul><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</li></ul></li></ul></blockquote><h1 id="23、Spring-Boot-是否可以使用-XML-配置"><a href="#23、Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="23、Spring Boot 是否可以使用 XML 配置 ?"></a>23、Spring Boot 是否可以使用 XML 配置 ?</h1><blockquote><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p></blockquote><h1 id="24、spring-boot-核心配置文件是什么？bootstrap-properties-和application-properties-有何区别"><a href="#24、spring-boot-核心配置文件是什么？bootstrap-properties-和application-properties-有何区别" class="headerlink" title="24、spring boot 核心配置文件是什么？bootstrap.properties 和application.properties 有何区别 ?"></a>24、spring boot 核心配置文件是什么？bootstrap.properties 和application.properties 有何区别 ?</h1><blockquote><ul><li>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</li><li>spring boot 核心的两个配置文件：<ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li></ul></li></ul></blockquote><h1 id="25、SpringBoot多数据源事务如何管理"><a href="#25、SpringBoot多数据源事务如何管理" class="headerlink" title="25、SpringBoot多数据源事务如何管理"></a>25、SpringBoot多数据源事务如何管理</h1><blockquote><ul><li>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</li><li>第二种是使用jta-atomikos实现分布式事务管理</li></ul></blockquote><h1 id="26、如何实现-Spring-Boot-应用程序的安全性？"><a href="#26、如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="26、如何实现 Spring Boot 应用程序的安全性？"></a>26、如何实现 Spring Boot 应用程序的安全性？</h1><blockquote><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p></blockquote><h1 id="27、比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#27、比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="27、比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>27、比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h1><blockquote><ul><li>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：<ul><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ul></li></ul></blockquote><h1 id="28、Spring-Boot-中如何解决跨域问题"><a href="#28、Spring-Boot-中如何解决跨域问题" class="headerlink" title="28、Spring Boot 中如何解决跨域问题 ?"></a>28、Spring Boot 中如何解决跨域问题 ?</h1><blockquote><ul><li>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Crossorigin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">         registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">         .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">         .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">         .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">         .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="29、Spring-Boot-中的监视器是什么？"><a href="#29、Spring-Boot-中的监视器是什么？" class="headerlink" title="29、Spring Boot 中的监视器是什么？"></a>29、Spring Boot 中的监视器是什么？</h1><blockquote><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p></blockquote><h1 id="30、如何使用-Spring-Boot-实现全局异常处理？"><a href="#30、如何使用-Spring-Boot-实现全局异常处理？" class="headerlink" title="30、如何使用 Spring Boot 实现全局异常处理？"></a>30、如何使用 Spring Boot 实现全局异常处理？</h1><blockquote><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p></blockquote><h1 id="31、我们如何监视所有-Spring-Boot-微服务？"><a href="#31、我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="31、我们如何监视所有 Spring Boot 微服务？"></a>31、我们如何监视所有 Spring Boot 微服务？</h1><blockquote><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p></blockquote><h1 id="32、SpringBoot性能如何优化"><a href="#32、SpringBoot性能如何优化" class="headerlink" title="32、SpringBoot性能如何优化"></a>32、SpringBoot性能如何优化</h1><blockquote><ul><li>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范</li><li>在项目启动时设置JVM初始内存和最大内存相同</li><li>将springboot内置服务器由tomcat设置为undertow</li></ul></blockquote><h1 id="33、如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#33、如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="33、如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>33、如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h1><blockquote><ul><li>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="34、SpringBoot微服务中如何实现-session-共享"><a href="#34、SpringBoot微服务中如何实现-session-共享" class="headerlink" title="34、SpringBoot微服务中如何实现 session 共享 ?"></a>34、SpringBoot微服务中如何实现 session 共享 ?</h1><blockquote><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p></blockquote><h1 id="35、Spring-Boot-中的-starter-到底是什么"><a href="#35、Spring-Boot-中的-starter-到底是什么" class="headerlink" title="35、Spring Boot 中的 starter 到底是什么 ?"></a>35、Spring Boot 中的 starter 到底是什么 ?</h1><blockquote><ol><li>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的）。</li><li>然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</li></ol></blockquote><h1 id="36、Spring-Boot-中如何实现定时任务"><a href="#36、Spring-Boot-中如何实现定时任务" class="headerlink" title="36、Spring Boot 中如何实现定时任务 ?"></a>36、Spring Boot 中如何实现定时任务 ?</h1><blockquote><ul><li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一-个则是使用第三方框架 Quartz。</li><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li></ul></blockquote><h1 id="37、spring-boot-starter-parent-有什么用"><a href="#37、spring-boot-starter-parent-有什么用" class="headerlink" title="37、spring-boot-starter-parent 有什么用 ?"></a>37、spring-boot-starter-parent 有什么用 ?</h1><blockquote><ul><li>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 springboot-starter-parent ，spring-boot-starter-parent 主要有如下作用：<ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol></li></ul></blockquote><h1 id="38、Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#38、Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="38、Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>38、Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h1><blockquote><ul><li>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</li><li>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOTINF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-11月14日-每日面试题-SpringBoot&quot;&gt;&lt;a href=&quot;#2022-11月14日-每日面试题-SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;2022 11月14日 每日面试题(SpringBoot)&quot;&gt;&lt;/a&gt;2</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022 12月13日 每日面试题(SpringCloud)</title>
    <link href="https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-12%E6%9C%8813%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98-SpringCloud/"/>
    <id>https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-12%E6%9C%8813%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98-SpringCloud/</id>
    <published>2022-12-13T13:28:48.000Z</published>
    <updated>2022-12-13T13:44:25.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-12月13日-每日面试题-SpringCloud"><a href="#2022-12月13日-每日面试题-SpringCloud" class="headerlink" title="2022 12月13日 每日面试题(SpringCloud)"></a>2022 12月13日 每日面试题(SpringCloud)</h1><h1 id="1、什么是微服务架构"><a href="#1、什么是微服务架构" class="headerlink" title="1、什么是微服务架构"></a>1、什么是微服务架构</h1><blockquote><ol><li>微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。</li><li>这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。</li></ol></blockquote><h1 id="2、为什么需要学习Spring-Cloud"><a href="#2、为什么需要学习Spring-Cloud" class="headerlink" title="2、为什么需要学习Spring Cloud"></a>2、为什么需要学习Spring Cloud</h1><blockquote><ul><li>首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理。</li><li>什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！</li><li>springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等</li></ul></blockquote><h1 id="3、Spring-Cloud-是什么"><a href="#3、Spring-Cloud-是什么" class="headerlink" title="3、Spring Cloud 是什么"></a>3、Spring Cloud 是什么</h1><blockquote><ul><li>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</li><li>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</li></ul></blockquote><h1 id="4、SpringCloud的优缺点"><a href="#4、SpringCloud的优缺点" class="headerlink" title="4、SpringCloud的优缺点"></a>4、SpringCloud的优缺点</h1><blockquote><p>优点 ： </p><ol><li>耦合度比较低。不会影响其他模块的开发。</li><li>减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</li><li>配置比较简单，基本用注解就能实现，不用使用过多的配置文件。 </li><li>微服务跨平台的，可以用任何一种语言开发。 </li><li>每个微服务可以有自己的独立的数据库也有用公共的数据库。</li><li>直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</li></ol><p>缺点 :</p><ol><li>部署比较麻烦，给运维工程师带来一定的麻烦。</li><li>针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。</li><li>系统集成测试比较麻烦。</li><li>性能的监控比较麻烦。【最好开发一个大屏监控系统】</li></ol></blockquote><h1 id="5、互联网应用架构演进"><a href="#5、互联网应用架构演进" class="headerlink" title="5、互联网应用架构演进"></a>5、互联网应用架构演进</h1><h2 id="1）单体应用架构"><a href="#1）单体应用架构" class="headerlink" title="1）单体应用架构"></a>1）单体应用架构</h2><p>​        在诞生之初，系统的用户量、数据量规模都比较小，项目所有的功能模块都放在一个工程中编码、编译、打包并且部署在一个Tomcat容器中的架构模式就是单体应用架构，这样的架构既简单实用、便于维护，成本又低，成为了那个时代的主流架构方式。</p><p><img src="E:\百里半Java培训\5.微服务框架\Spring Cloud-new\day01\Spring Cloud微服务讲义.assets\image-20200921104303255.png" alt="image-20200921104303255"></p><p><img src="E:\百里半Java培训\5.微服务框架\Spring Cloud-new\day01\Spring Cloud微服务讲义.assets\image-20200921105052666.png" alt="image-20200921105052666"></p><p><strong>优点：</strong></p><ul><li><strong>高效开发</strong>：项目前期开发节奏快，团队成员少的时候能够快速迭代</li><li><strong>架构简单</strong>：MVC架构，只需要借助IDE开发、调试即可</li><li><strong>易于测试</strong>：只需要通过单元测试或者浏览器完成</li><li><strong>易于部署</strong>：打包成单个可执行的jar或者打成war包放到容器内启动</li></ul><p>​    单体架构的应用比较容易部署、测试， 在项目的初期，单体应用可以很好地运行。然而，随着需求的不断增加， 越来越多的人加入开发团队，代码库也在飞速地膨胀。慢慢地，单体应用变得越来越臃肿，可维护性、灵活性逐渐降低，维护成本越来越高。</p><p><strong>缺点：</strong></p><ul><li><strong>可靠性差</strong>： 某个应用Bug，例如死循环、内存溢出等， 可能会导致整个应用的崩溃</li><li><strong>复杂性高</strong>： 以一个百万行级别的单体应用为例，整个项目包含的模块多、模块的边界模糊、 依赖关系不清晰、 代码质量参差不齐、 混乱地堆砌在一起。使得整个项目非常复杂。 </li><li><strong>扩展能力受限</strong>： 单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU； 有的模块则是IO密集型的，需要更大的内存。 由于这些模块部署在一起，不得不在硬件的选择上做出妥协。</li></ul><p>业务量上涨之后，单体应用架构进一步丰富变化，比如应用集群部署、使用Nginx进行负载均衡、增加缓存服务器、增加文件服务器、数据库集群并做读写分离等，通过以上措施增强应对高并发的能力、应对一定的复杂业务场景，但依然属于单体应用架构。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200921114214947.png" alt="image-20200921114214947" style="zoom:80%;" /></p><h2 id="2）垂直应用架构"><a href="#2）垂直应用架构" class="headerlink" title="2）垂直应用架构"></a>2）垂直应用架构</h2><p>​        为了避免上面提到的那些问题，开始做模块的垂直划分，做垂直划分的原则是基于系统现有的业务特性来做，核心目标第一个是为了业务之间互不影响，第二个是在研发团队的壮大后为了提高效率，减少组件之间的依赖。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200921115149514.png" alt="image-20200921115149514" style="zoom:80%;" /></p><p>​        <strong>优点</strong></p><ul><li><p>系统拆分实现了流量分担，解决了并发问题 </p></li><li><p>可以针对不同模块进行优化 </p></li><li><p>方便水平扩展，负载均衡，容错率提高</p></li><li><p>系统间相互独立，互不影响，新的业务迭代时更加高效</p><p><strong>缺点</strong></p></li><li><p>服务之间相互调用，如果某个服务的端扣或者ip地址发生改变，调用的系统得手动改变</p></li><li><p>搭建集群之后，实现负载均衡比较复杂，如：内网负载，在迁移机器时会影响调用方的路 由，导致线上故障</p></li><li><p>服务之间调用方式不统一，基于 httpclient 、 webservice ，接口协议不统一</p></li><li><p>服务监控不到位：除了依靠端口、进程的监控，调用的成功率、失败率、总耗时等等这些监 控指标是没有的</p></li></ul><h2 id="3）SOA应用架构"><a href="#3）SOA应用架构" class="headerlink" title="3）SOA应用架构"></a>3）SOA应用架构</h2><p>​        在做了垂直划分以后，模块随之增多，维护的成本在也变高，一些通用的业务和模块重复的越来越多，为了解决上面提到的接口协议不统一、服务无法监控、服务的负载均衡，引入了阿里巴巴开源的 Dubbo ，一款高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。它提供了三个核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p>​        SOA (Service-Oriented Architecture)，即面向服务的架构。根据实际业务，把系统拆分成合适的、独立部署的模块，模块之间相互独立（通过Webservice/Dubbo等技术进行通信）。</p><p>​        优点：分布式、松耦合、扩展灵活、可重用。</p><p>​        缺点：服务抽取粒度较大、服务调用方和提供方耦合度较高（接口耦合度）</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200921115445100.png" alt="image-20200921115445100" style="zoom:80%;" /></p><h2 id="4）微服务应用架构"><a href="#4）微服务应用架构" class="headerlink" title="4）微服务应用架构"></a>4）微服务应用架构</h2><p>​        微服务架构可以说是SOA架构的一种拓展，这种架构模式下它<strong>拆分粒度更小</strong>、服务更独立。把应用拆分成为一个个微小的服务，不同的服务可以使用不同的开发语言和存储，服务之间往往通过Restful等轻量级通信。微服务架构关键在于<strong>微小、独立、轻量级通信</strong>。</p><p>​        微服务是在 SOA 上做的升华粒度更加细致，微服务架构强调的⼀个重点是<strong>业务需要彻底的组件化和服务化</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200921115721307.png" alt="image-20200921115721307"></p><p>微服务架构和SOA架构相似又不同</p><blockquote><p>​    微服务架构和SOA架构很明显的一个区别就是<strong>服务拆分粒度的不同</strong>，但是对于系统的架构发展来说，我们所看到的SOA阶段其实服务拆分粒度相对来说已经比较细了（超前哦！），所以上述系统SOA到系统微服务，从服务拆分上来说变化并不大，只是引入了相对完整的新一代Spring Cloud微服务技术。自然，上述我们看到的都是系统架构演变的阶段结果，每一个阶段其实都经历了很多变化，系统的服务拆分其实也是走过了从粗到细，并非绝对的一步到位。</p></blockquote><p>举个系统案例来说明SOA和微服务拆分粒度不同</p><blockquote><p>​    我们在SOA架构的初期，“简历投递模块”和“人才搜索模块”都有简历内容展示的需求，只不过说可能略有区别，一开始在两个模块中各维护了一套简历查询和展示的代码；后期我们将服务更细粒度拆分，拆分出简历基础服务，那么不同模块调用这个基础服务即可。</p></blockquote><h1 id="6、SpringBoot和SpringCloud的区别？"><a href="#6、SpringBoot和SpringCloud的区别？" class="headerlink" title="6、SpringBoot和SpringCloud的区别？"></a>6、SpringBoot和SpringCloud的区别？</h1><blockquote><ul><li>SpringBoot专注于快速方便的开发单个个体微服务。</li><li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来。</li><li>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。</li><li>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系。</li><li>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</li></ul></blockquote><h1 id="7、Spring-Cloud和SpringBoot版本对应关系"><a href="#7、Spring-Cloud和SpringBoot版本对应关系" class="headerlink" title="7、Spring Cloud和SpringBoot版本对应关系"></a>7、Spring Cloud和SpringBoot版本对应关系</h1><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221213152642867.png" alt="image-20221213152642867"></p><h1 id="8、SpringCloud由什么组成"><a href="#8、SpringCloud由什么组成" class="headerlink" title="8、SpringCloud由什么组成"></a>8、SpringCloud由什么组成</h1><blockquote><ul><li>Spring Cloud Eureka：服务注册与发现</li><li>Spring Cloud Zuul：服务网关</li><li>Spring Cloud Ribbon：客户端负载均衡</li><li>Spring Cloud Feign：声明性的Web服务客户端</li><li>Spring Cloud Hystrix：断路器</li><li>Spring Cloud Config：分布式统一配置管理</li><li>等20几个框架，开源一直在更新</li></ul></blockquote><h1 id="9、使用-Spring-Boot-开发分布式微服务时，我们面临什么问题"><a href="#9、使用-Spring-Boot-开发分布式微服务时，我们面临什么问题" class="headerlink" title="9、使用 Spring Boot 开发分布式微服务时，我们面临什么问题"></a>9、使用 Spring Boot 开发分布式微服务时，我们面临什么问题</h1><blockquote><ol><li>与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。</li><li>服务发现-服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。</li><li>冗余-分布式系统中的冗余问题。</li><li>负载平衡 —负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。</li><li>性能-问题 由于各种运营开销导致的性能问题。</li></ol></blockquote><h1 id="10、Spring-Cloud-和dubbo区别"><a href="#10、Spring-Cloud-和dubbo区别" class="headerlink" title="10、Spring Cloud 和dubbo区别?"></a>10、Spring Cloud 和dubbo区别?</h1><blockquote><ol><li>服务调用方式：dubbo是RPC springcloud Rest Api</li><li>注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</li><li>服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。</li></ol></blockquote><h1 id="11、服务注册和服务发现是什么意思？Spring-Cloud-如何实现？"><a href="#11、服务注册和服务发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="11、服务注册和服务发现是什么意思？Spring Cloud 如何实现？"></a>11、服务注册和服务发现是什么意思？Spring Cloud 如何实现？</h1><blockquote><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p></blockquote><h1 id="12、-什么是Eureka"><a href="#12、-什么是Eureka" class="headerlink" title="12、 什么是Eureka"></a>12、 什么是Eureka</h1><blockquote><p>Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。</p></blockquote><h1 id="13、Eureka怎么实现高可用"><a href="#13、Eureka怎么实现高可用" class="headerlink" title="13、Eureka怎么实现高可用"></a>13、Eureka怎么实现高可用</h1><blockquote><p>通过集群，注册多台Eureka，然后把SpringCloud服务互相注册，客户端从Eureka获取信息时，按照Eureka的顺序来访问。</p></blockquote><h1 id="14、什么是Eureka的自我保护模式"><a href="#14、什么是Eureka的自我保护模式" class="headerlink" title="14、什么是Eureka的自我保护模式"></a>14、什么是Eureka的自我保护模式</h1><blockquote><p>默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式。</p></blockquote><h1 id="15、DiscoveryClient的作用"><a href="#15、DiscoveryClient的作用" class="headerlink" title="15、DiscoveryClient的作用"></a>15、DiscoveryClient的作用</h1><blockquote><p>可以从注册中心中根据服务别名获取注册的服务器信息。</p></blockquote><h1 id="16、Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别"><a href="#16、Eureka和ZooKeeper都可以提供服务注册与发现的功能-请说说两个的区别" class="headerlink" title="16、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别"></a>16、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别</h1><blockquote><ol><li>ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从</li><li>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</li><li>Eureka本质上是一个工程,而ZooKeeper只是一个进程</li><li>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</li><li>ZooKeeper保证的是CP，Eureka保证的是AP</li><li>CAP： C：一致性&gt;Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性&gt;Availability; P：分区容错性&gt;Partition tolerance;</li></ol></blockquote><h1 id="17、什么是网关"><a href="#17、什么是网关" class="headerlink" title="17、什么是网关?"></a>17、什么是网关?</h1><blockquote><p>网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。</p></blockquote><h1 id="18、网关的作用是什么"><a href="#18、网关的作用是什么" class="headerlink" title="18、网关的作用是什么"></a>18、网关的作用是什么</h1><blockquote><p>统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等</p></blockquote><h1 id="19、什么是Spring-Cloud-Zuul（服务网关）？"><a href="#19、什么是Spring-Cloud-Zuul（服务网关）？" class="headerlink" title="19、什么是Spring Cloud Zuul（服务网关）？"></a>19、什么是Spring Cloud Zuul（服务网关）？</h1><blockquote><ul><li>Zuul是对SpringCloud提供的成熟对的路由方案，他会根据请求的路径不同，网关会定位到指定的微服务，并代理请求到不同的微服务接口，他对外隐蔽了微服务的真正接口地址。 三个重要概念：动态路由表，路由定位，反向代理：<ul><li>动态路由表：Zuul支持Eureka路由，手动配置路由，这俩种都支持自动更新</li><li>路由定位：根据请求路径，Zuul有自己的一套定位服务规则以及路由表达式匹配</li><li>反向代理：客户端请求到路由网关，网关受理之后，在对目标发送请求，拿到响应之后在 给客户端</li></ul></li><li>它可以和Eureka,Ribbon,Hystrix等组件配合使用，</li><li>Zuul的应用场景：<ul><li>对外暴露，权限校验，服务聚合，日志审计等</li></ul></li></ul></blockquote><h1 id="20、网关与过滤器有什么区别"><a href="#20、网关与过滤器有什么区别" class="headerlink" title="20、网关与过滤器有什么区别"></a>20、网关与过滤器有什么区别</h1><blockquote><p>网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。</p></blockquote><h1 id="21、常用网关框架有那些？"><a href="#21、常用网关框架有那些？" class="headerlink" title="21、常用网关框架有那些？"></a>21、常用网关框架有那些？</h1><blockquote><p>Nginx、Zuul、Gateway</p></blockquote><h1 id="22、Zuul与Nginx有什么区别？"><a href="#22、Zuul与Nginx有什么区别？" class="headerlink" title="22、Zuul与Nginx有什么区别？"></a>22、Zuul与Nginx有什么区别？</h1><blockquote><p>Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。</p></blockquote><h1 id="23、既然Nginx可以实现网关？为什么还需要使用Zuul框架"><a href="#23、既然Nginx可以实现网关？为什么还需要使用Zuul框架" class="headerlink" title="23、既然Nginx可以实现网关？为什么还需要使用Zuul框架"></a>23、既然Nginx可以实现网关？为什么还需要使用Zuul框架</h1><blockquote><p>Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。</p></blockquote><h1 id="24、如何设计一套API接口"><a href="#24、如何设计一套API接口" class="headerlink" title="24、如何设计一套API接口"></a>24、如何设计一套API接口</h1><blockquote><p>考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。</p></blockquote><h1 id="25、ZuulFilter常用有那些方法"><a href="#25、ZuulFilter常用有那些方法" class="headerlink" title="25、ZuulFilter常用有那些方法"></a>25、ZuulFilter常用有那些方法</h1><blockquote><ul><li>Run()：过滤器的具体业务逻辑</li><li>shouldFilter()：判断过滤器是否有效</li><li>filterOrder()：过滤器执行顺序</li><li>filterType()：过滤器拦截位置</li></ul></blockquote><h1 id="26、如何实现动态Zuul网关路由转发"><a href="#26、如何实现动态Zuul网关路由转发" class="headerlink" title="26、如何实现动态Zuul网关路由转发"></a>26、如何实现动态Zuul网关路由转发</h1><blockquote><p>通过path配置拦截请求，通过ServiceId到配置中心获取转发的服务列表，Zuul内部使用Ribbon实现本地负载均衡和转发。</p></blockquote><h1 id="27、Zuul网关如何搭建集群"><a href="#27、Zuul网关如何搭建集群" class="headerlink" title="27、Zuul网关如何搭建集群"></a>27、Zuul网关如何搭建集群</h1><blockquote><p>使用Nginx的upstream设置Zuul服务集群，通过location拦截请求并转发到upstream，默认使用轮询机制对Zuul集群发送请求。</p></blockquote><h1 id="28、负载平衡的意义什么？"><a href="#28、负载平衡的意义什么？" class="headerlink" title="28、负载平衡的意义什么？"></a>28、负载平衡的意义什么？</h1><blockquote><ul><li>简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。</li><li>在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</li></ul></blockquote><h1 id="29、Ribbon是什么？"><a href="#29、Ribbon是什么？" class="headerlink" title="29、Ribbon是什么？"></a>29、Ribbon是什么？</h1><blockquote><ul><li>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法</li><li>Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）</li></ul></blockquote><h1 id="30、Nginx与Ribbon的区别"><a href="#30、Nginx与Ribbon的区别" class="headerlink" title="30、Nginx与Ribbon的区别"></a>30、Nginx与Ribbon的区别</h1><blockquote><p>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</p></blockquote><h1 id="31、Ribbon底层实现原理"><a href="#31、Ribbon底层实现原理" class="headerlink" title="31、Ribbon底层实现原理"></a>31、Ribbon底层实现原理</h1><blockquote><p>Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。</p></blockquote><p><code>@LoadBalanced注解的作用</code></p><blockquote><p>开启客户端负载均衡</p></blockquote><h1 id="32、什么是断路器"><a href="#32、什么是断路器" class="headerlink" title="32、什么是断路器"></a>32、什么是断路器</h1><blockquote><ul><li>当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）</li><li>断路器有三种状态<ul><li>打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</li><li>半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭</li><li>关闭状态：当服务一直处于正常状态 能正常调用</li></ul></li></ul></blockquote><h1 id="33、什么是-Hystrix？"><a href="#33、什么是-Hystrix？" class="headerlink" title="33、什么是 Hystrix？"></a>33、什么是 Hystrix？</h1><blockquote><ul><li>在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。</li><li>Hystrix有四种防雪崩方式:<ul><li>服务降级：接口调用失败就调用本地的方法返回一个空</li><li>服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</li><li>服务隔离：隔离服务之间相互影响</li><li>服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。</li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-12月13日-每日面试题-SpringCloud&quot;&gt;&lt;a href=&quot;#2022-12月13日-每日面试题-SpringCloud&quot; class=&quot;headerlink&quot; title=&quot;2022 12月13日 每日面试题(SpringCloud)&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022 12月7日 每日面试题</title>
    <link href="https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-12%E6%9C%887%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022-12%E6%9C%887%E6%97%A5-%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-12-13T13:24:55.000Z</published>
    <updated>2022-12-13T13:28:30.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-12月7日-每日面试题"><a href="#2022-12月7日-每日面试题" class="headerlink" title="2022 12月7日 每日面试题"></a>2022 12月7日 每日面试题</h1><h1 id="1、谈谈你对面向对象的理解-？"><a href="#1、谈谈你对面向对象的理解-？" class="headerlink" title="1、谈谈你对面向对象的理解 ？"></a>1、谈谈你对面向对象的理解 ？</h1><blockquote><ol><li>面向对象的三大基本特征 ：封装、继承、多态。</li><li>其中,封装是指将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部信息,让外部程序通过该类提供的方法来实现对内部信息的操作和访问,这种做法有助于规范使用者的行为,让使用者只能通过事先预定的方法访问数据,提高了代码的可维护性；</li><li>继承是面向对象实现代码复用的重要手段,Java通过extends作为关键字实现类的继承,实现继承的类被称为子类,被继承的类称为父类（有的也被称为基类和超类）,父类和子类的关系是一种一般和特殊的关系；</li><li>多态的实现离不开继承,在设计程序时,我们可以将参数的类型定义为父类型。在调用程序时,则可以根据实际情况,传入该父类型的某个子类型的实例,这样就实现了多态。对于父类型,可以有三种形式,即普通的类、抽象类、接口。对于子类型,则要根据它自身的特征,重写父类的某些方法,或实现抽象类/接口的某些抽象方法。</li></ol></blockquote><h1 id="2、类中静态代码块、实例代码块、构造方法执行次序-？"><a href="#2、类中静态代码块、实例代码块、构造方法执行次序-？" class="headerlink" title="2、类中静态代码块、实例代码块、构造方法执行次序 ？"></a>2、类中静态代码块、实例代码块、构造方法执行次序 ？</h1><blockquote><p>1、父类静态代码块优先于子类静态代码块执行，而且是最早执行</p><p>2、父类实例方法和父类构造方法紧接着执行</p><p>3、子类的实例代码块和子类的构造方法紧接着再执行</p><p>4、第二次实例化对象时，父类和子类的静态代码块都将不会再执行</p><p>5、静态代码块先执行，并且只执行一次，在类加载阶段执行</p><p>6、如果类没有加载，先加载类：先加载基类，后加载子类，基类的静态代码块先执行，子类的代码块后执行，并且都只执行一次</p><p>7、当有对象创建的时候，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行</p><p>注意：</p><ol><li>new哪个类的对象，编译器就会调用该类的构 造方法</li><li>new子类对象：编译器会调用子类的构造方法<ol><li>从基类继承下来的成员变量，通过super（）调用基类构造方法</li><li>子类新增加的成员</li></ol></li><li>基类构造方法中的内容先打印，然后子类构造方法中的内容后打印</li></ol></blockquote><h1 id="3、说说你对AOP的理解"><a href="#3、说说你对AOP的理解" class="headerlink" title="3、说说你对AOP的理解"></a>3、说说你对AOP的理解</h1><blockquote><ol><li>AOP是一种编程思想，是通过预编译方式和运行期间动态代理的方式实现不修改源码的情况下给程序动态统一添加功能的技术。面向对象编程将程序抽象成各个层次的对象，而面向切面编程则将程序抽象成各个切面。所谓切面，相当于应用对象之间的横切点，我们可以将其单独    抽象为单独的模块。</li><li>AOP技术利用一种称为<strong>横切</strong>的技术剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命名为切面。所谓的切面,简单来说就是与业务无关,却为业务模块所共同调用的逻辑,将其封装起来便于减少系统的重复代码,降低模块的耦合度,有利用未来的可操作性和可维护性。</li><li>利用AOP可以对业务逻辑各个部分进行隔离开来，从而使业务逻辑部分之间的耦合度降低，提高程序的可重用性，提高开发效率。</li><li>AOP可以有多种实现方式,而Spring AOP支持如下两种实现方式。<ol><li>JDK动态代理 ： 这是Java提供的动态代理技术，可以在运行时创建接口的动态实例。Spring AOP默认采用这种方式,在接口的代理实例中织入代码。</li><li>CGLIB动态代理 ：采用底层的字节码技术，在运行时创建子类的代理的实例。当目标对象不存在接口的时候，Spring AOP就会采用这种方式,在子类实例中织入代码。</li></ol></li><li>在应用场景方面,Spring AOP为IOC的使用提供了更多的便利,一方面,应用可以直接使用AOP的功能,设计应用的横切关注点,把跨越应用程序多个模块的功能抽象出来,并通过简单的AOP的使用,灵活地编制到模块中,比如可以通过AOP实现应用程序中的日志功能。另一方面,在Spring内部,例如事务处理之类的一些支持模块也是通过Spring AOP来实现的。</li></ol></blockquote><h1 id="4、谈谈你对IOC的理解"><a href="#4、谈谈你对IOC的理解" class="headerlink" title="4、谈谈你对IOC的理解"></a>4、谈谈你对IOC的理解</h1><blockquote><ol><li>IOC是控制反转的意思，是一种面向对象编程的设计思想。在不采用这种思想的情况下,我们需要自己维护对象与对象之间的依赖关系,很容易造成对象之间的耦合度过高,在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题,它可以帮我们维护对象与对象之间的依赖关系,并且降低对象之间的耦合度。</li><li>说到IOC就不得不说说DI，DI是依赖注入的意思，它是IOC实现的实现方式。由于IOC这个词汇比较抽象而DI比较直观,所以很多时候我们就用DI来代替它,在很多时候我们简单地将IOC和DI划等号,这是一种习惯。实现依赖注入的关键是IOC容器,它的本质就是一个工厂。</li></ol></blockquote><h1 id="5、请说说你对反射的了解"><a href="#5、请说说你对反射的了解" class="headerlink" title="5、请说说你对反射的了解"></a>5、请说说你对反射的了解</h1><blockquote><ol><li>Java程序中，许多对象在运行时都会有编译时异常和运行时异常两种。例如多态的情况下Car c = new Animal(); 这行代码运行时会生成一个c变量,在编译时该变量的类型是Car,运行时该变量类型为Animal；另外还有更极端的情况,例如程序在运行时接收到了外部传入的一个对象,这个对象的编译时类型是Object,但程序又需要调用这个对象运行时类型的方法,这种情况下,有两种解决方法：第一种做法是假设在编译时和运行时都完全知道类型的具体信息,在这种情况下,可以先使用instanceof运算符进行判断,再利用强制类型转换将其转换成其运行时类型的变量。第二种做法是编译时根本无法预知该对象和类可能属于哪些类,程序只依靠运行时信息来发现该对象和类的真实信息,这就必须使用反射。    </li><li>具体来说,通过反射机制,我们可以实现如下的操作：<ol><li>程序运行中，可以通过反射创建任意一个类的实例，并访问该实例的成员。</li><li>程序运行中，可以通过反射机制生成一个类的动态代理类或动态代理对象。</li></ol></li><li>Java的反射机制在实际项目中应用广泛,常见的应用场景有：<ol><li>使用JDBC时,如果要创建数据库的连接,则需要先通过反射机制加载数据库的驱动程序。</li><li>多数框架都支持注解/XML配置,从配置中解析出来的类是字符串,需要利用反射机制实例化；</li><li>面向切面编程（AOP）的实现方案,是在程序运行时创建目标对象的代理类,这必须由反射机制来实现。</li></ol></li></ol></blockquote><h1 id="6、说说你对ArrayList的理解"><a href="#6、说说你对ArrayList的理解" class="headerlink" title="6、说说你对ArrayList的理解"></a>6、说说你对ArrayList的理解</h1><blockquote><ol><li>ArrayList是基于数组实现的，它的内部封装了一个Object[]数组。通过默认的构造器创建容器时，该数组首先被初始化为空数组，之后在首次添加数据时初始化长度为10。我们也可以使用有参构造器来创建容器，并通过参数来显示的指定数组的容量，此时该数组被初始化为指定容量的数组。</li><li>如果向ArrayList中添加数据会造成超出数组长度限制，则会触发自动扩容，然后再添加数据。扩容就是数组拷贝，将旧数组的内容拷贝到新的数组中，而新数组的长度为原来数组长度的1.5倍。</li><li>ArrayList支持缩容，但不会自动缩容,即便是ArrayList中只剩下少量数据时也不会主动缩容。如果我们希望缩减ArrayList的容量,则需要自己调用它的trimToSize()方法,届时数组将按照元素的实际个数进行缩减。</li><li>Set、List、Queue都是Collection的子接口,它们都继承了父接口的iterator()方法,从而具备了迭代的能力。但是,相比于另外两个接口,List还单独提供了listIterator()方法,增强了迭代能力。iterator()方法返回Iterator迭代器,listIterator()方法返回ListIterator迭代器,并且ListIterator是Iterator的子接口。ListIterator在Iterator的基础上,增加了向前遍历的支持,增加了在迭代过程中修改数据的支持。</li></ol></blockquote><h1 id="7、说说Spring-Boot的自动装配"><a href="#7、说说Spring-Boot的自动装配" class="headerlink" title="7、说说Spring Boot的自动装配"></a>7、说说Spring Boot的自动装配</h1><blockquote><ol><li>使用Spring Boot时,我们需要引入对应的Starters,Spring Boot启动时便会自动加载相关依赖,配置相应的初始化参数,以最快捷、简单的形式对第三方软件进行集成,这便是Spring Boot的自动配置功能。</li><li>整个自动装配的过程是 ： SpringBoot 通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类,当某个AutoConfiguration类满足其注解@Conditional指定的生效条件时，实例化该AutoConfiguration类中定义的Bean（组件等）,注入Spring容器，就可以完成依赖框架的自动配置</li><li>@EnableAutoConfiguration 作用 从classpath中搜索所有META-INF/spring.factories配置文件然后,将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器 只有spring.boot.enableautoconfiguration为true（默认为true）的时候,才启用自动配置 @EnableAutoConfiguration还可以根据class来排除（exclude）,或是根据class name（excludeName）来排除 其内部实现的关键点有 1. ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中 2. SpringFactoriesLoader 该类可以从classpath中搜索所有META-INF/spring.factories配置文件,并读取配置</li></ol></blockquote><h1 id="8、请你说说Java的特点和优点-为什么要选择Java？"><a href="#8、请你说说Java的特点和优点-为什么要选择Java？" class="headerlink" title="8、请你说说Java的特点和优点,为什么要选择Java？"></a>8、请你说说Java的特点和优点,为什么要选择Java？</h1><blockquote><ol><li>Java是一门非常纯粹的面向对象的编程语言，它在吸收C++语言优点的同时去除了C语言中令人难以理解的多继承，指针等概念。所以Java语言在保证了强大功能的基础上,还比C++语言更为简单易用。</li><li>Java语言极好的实现了面向对象理论，是静态面向对象语言的代表，它的存在保证了程序员可以用优雅的思维方式进行复杂的编程 。</li><li>Java还拥有平台的独立性，可以做到”一次编译,到处运行”。Java还提供了很多内置的类库，,通过这些类库,简化了开发人员的程序设计工作,缩短了项目的开发时间,最重要的是Java提供了垃圾回收器,这也将开发人员从对内存的管理中解脱出来。同时Java拥有良好的安全性和健壮性，Java语言常常使用在网络环境中，为了增强程序的安全性,java语言提供了一个防止恶意代码攻击的安全机制（数组边界检测和Bytecode校验等）。Java的强类型机制、垃圾回收器、异常处理和安全检查机制使用Java语言编写的程序有很好的健壮性</li><li>此外，Java还提供了对Web应用开发的支持。例如Applet、Servlet和JSP可以用来开发Web应用程序；Socket、RMI可以用来开发分布式应用程序的类库。 </li><li>JVM（Java虚拟机）是Java跨平台的关键。在运行程序之前，Java源代码(.java)需要经过编译器，将源代码翻译为字节码(.class)，但字节码不能直接运行，所以必须通过JVM将字节码翻译为特定平台的机器码运行程序。但跨平台的是Java程序、而不是JVM,所以需要在不同平台下安装不同版本的JVM。</li></ol></blockquote><h1 id="9、介绍一下Spring-MVC的执行流程"><a href="#9、介绍一下Spring-MVC的执行流程" class="headerlink" title="9、介绍一下Spring MVC的执行流程"></a>9、介绍一下Spring MVC的执行流程</h1><blockquote><ol><li>用户点击某个路径，发起HttpRequest请求，该请求会被提交到DispacherServelet；</li><li>由 DispatcherServlet 请求一个或多个处理器映射器(HandlerMapping),并返回一个执行链(HandlerExecutionChn)。</li><li>DispatcherServlet将执行链返回的Handle信息发送给处理器适配器(HandlerAdapter)；</li><li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler方法(常称为 Controller)；</li><li>Handle执行完毕之后会返回给HandleAdapter一个ModelAndView对象(Spring MVC的底层对象,包括 Model 数据模型和 View 视图信息)；</li><li>HandlerAdapter 接收到 ModelAndView 对象后,将其返回给 DispatcherServlet ；</li><li>DispatcherServlet接收到ModelAndView 对象后，会请求视图解析器(ViewResolver)对视图进行解析； </li><li>ViewResolver 根据 View 信息匹配到相应的视图结果,并返回给 DispatcherServlet；</li><li>DispatcherServlet 接收到具体的 View 视图后,进行视图渲染。</li><li>最后将渲染的视图返回给用户。</li></ol></blockquote><h1 id="10、在MyBatis中-和-有什么区别"><a href="#10、在MyBatis中-和-有什么区别" class="headerlink" title="10、在MyBatis中$和#有什么区别"></a>10、在MyBatis中$和#有什么区别</h1><blockquote><p>使用$设置参数时,MyBatis会创建普通的SQL语句,然后在执行SQL 语句时将参数拼入SQL,而使用#设置参数时,MyBatis会创建预编译的SQL语句,然后在执行SQL时MyBatis会为预编译SQL中的占位符赋值。预编译的SQL语句执行效率高,并且可以防止注入攻击,效率和安全性都大大优于前者，但在解决一些特殊问题,如在一些根据不同的条件产生不同的动态列中,我们要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL就只能使用￥。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-12月7日-每日面试题&quot;&gt;&lt;a href=&quot;#2022-12月7日-每日面试题&quot; class=&quot;headerlink&quot; title=&quot;2022 12月7日 每日面试题&quot;&gt;&lt;/a&gt;2022 12月7日 每日面试题&lt;/h1&gt;&lt;h1 id=&quot;1、谈谈你对面向对</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础36讲</title>
    <link href="https://manamn.space/2022/12/13/Java%E5%9F%BA%E7%A1%8036%E8%AE%B2/"/>
    <id>https://manamn.space/2022/12/13/Java%E5%9F%BA%E7%A1%8036%E8%AE%B2/</id>
    <published>2022-12-13T13:21:09.000Z</published>
    <updated>2022-12-13T13:22:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础36讲"><a href="#Java基础36讲" class="headerlink" title="Java基础36讲"></a>Java基础36讲</h1><h1 id="开篇词-以面试题为切入点，有效提升你的Java内功"><a href="#开篇词-以面试题为切入点，有效提升你的Java内功" class="headerlink" title="开篇词 以面试题为切入点，有效提升你的Java内功"></a>开篇词 以面试题为切入点，有效提升你的Java内功</h1><p>Java 是一门历史悠久的编程语言，可以毫无争议地说，Java 是最主流的编程语言之一。全球有 1200 万以上 Java 程序员以及海量的设备，还有无所不能的 Java 生态圈。</p><p>我所知道的诸如阿里巴巴、京东、百度、腾讯、美团、去哪儿等互联网公司，基本都是以 Java 为首要编程语言的。即使在最新的云计算领域，Java 仍然是 AWS、Google App Engine 等平台上，使用最多的编程语言；甚至是微软 Azure 云上，Java 也以微弱劣势排在前三位。所以，在这些大公司的面试中，基本都会以 Java 为切入点，考评一个面试者的技术能力。</p><p>应聘初级、中级 Java 工程师，通常只要求扎实的 Java 和计算机科学基础，掌握主流开源框架的使用；Java 高级工程师或者技术专家，则往往全面考察 Java IO/NIO、并发、虚拟机等，不仅仅是了解，<strong>更要求对底层源代码层面的掌握，并对分布式、安全、性能等领域能力有进一步的要求</strong>。</p><p>我在 Oracle 已经工作了近 7 年，负责过北京 Java 核心类库、国际化、分发服务等技术团队的组建，面试过从初级到非常资深的 Java 开发工程师。由于 Java 组工作任务的特点，我非常注重面试者的计算机科学基础和编程语言的理解深度，我甚至不要求面试者非要精通 Java，如果对 C/C++ 等其他语言能够掌握得非常系统和深入，也是符合需求的。</p><p>工作多年以及在面试中，我经常能体会到，有些面试者确实是认真努力工作，<strong>但坦白说表现出的能力水平却不足以通过面试</strong>，通常是两方面原因：</p><ul><li>“知其然不知其所以然”。做了多年技术，开发了很多业务应用，但似乎并未思考过种种<strong>技术选择背后的逻辑</strong>。坦白说，我并不放心把具有一定深度的任务交给他。更重要的是，我并不确定他未来技术能力的成长潜力有多大。团队所从事的是公司核心产品，工作于基础技术领域，<strong>我们不需要那些“差不多”或“还行”的代码，而是需要达到一定水准的高质量设计与实现</strong>。我相信很多其他技术团队的要求会更多、更高。</li><li>知识碎片化，不成系统。在面试中，面试者似乎无法完整、清晰地描述自己所开发的系统，或者使用的相关技术。平时可能埋头苦干，或者过于死磕某个实现细节，并没有抬头审视这些技术。比如，有的面试者，有一些并发编程经验，但对基本的并发类库掌握却并不扎实，似乎觉得在用的时候进行“面向搜索引擎的编程”就足够了。这种情况下，我没有信心这个面试者有高效解决复杂问题、设计复杂系统的能力。</li></ul><p>前人已经掉过的坑，后来的同学就别再“前仆后继”了！</p><p>起初，极客时间邀请我写《Java 核心技术 36 讲》专栏，我一开始心里是怀疑其形式和必要性的。经典的书籍一大堆呀，网上也能搜到所谓的“面试宝典”呀，为什么还需要我“指手画脚”？</p><p>但随着深入交流，我逐渐被说服了。我发现很多面试者其实是很努力的，只是</p><ul><li>很难甑别出各种技术的核心与要点，技术书籍这么庞杂，对于经验有限的同学，找到高效归纳自己知识体系的方法并不容易。</li><li>各种“宝典”更专注于问题，解答大多点到即止，甚至有些解答准确性都值得商榷，缺乏系统性的分析与举一反三的讲解。</li></ul><p>我在极客时间推出这个专栏，就是为了让更多没有经验或者经验有限的开发者，在准备面试时：</p><ul><li><strong>少走弯路，利用有限的精力，能够更加高效地准备和学习</strong>。</li><li><strong>提纲挈领，在知识点讲解的同时，为你梳理一个相对完整的 Java 开发技术能力图谱，将基础夯实</strong>。</li></ul><p>Java 面试题目千奇百怪，有的面试官甚至会以黑魔法一样的态度，刨根问底 JVM 底层，似乎不深挖 JVM 源代码、不谈谈计算机指令，就是不爱学习，这是仁者见仁智者见智的事儿。我会根据自己的经验，围绕 Java 开发技术的方方面面，精选出 5 大模块，共 36 道题目，给出典型的回答，并层层深入剖析。</p><p>5 大模块分为：</p><ul><li><strong>Java 基础</strong>：我会围绕 Java 语言基本特性和机制，由点带面，让你构建牢固的 Java 技术工底。</li><li><strong>Java 进阶</strong>：将围绕并发编程、Java 虚拟机等领域展开，助你攻坚大厂 Java 面试的核心阵地。</li><li><strong>Java 应用开发扩展</strong>：从数据库编程、主流开源框架、分布式开发等，帮你掌握 Java 开发的十八般兵器。</li><li><strong>Java 安全基础</strong>：让你理解常见的应用安全问题和处理方法，掌握如何写出符合大厂规范的安全代码。</li><li><strong>Java 性能基础</strong>：你将掌握相关工具、方法论与基础实践。</li></ul><p>这几年我从业务系统或产品开发，切换到 Java 平台自身，接触了更多 Java 领域的核心技术，我相信我的分享能够提供一些独到的内容，而不是简单的人云亦云。</p><p>时移世易，很多大家耳熟能知的问题，其实在现代 Java 里已经发生了根本性的改变。在技术领域，即使你打算或已经转为技术管理等，扎实的技术功底也是必须的。希望通过我的专栏，不仅可以让你面试成功，还能帮助你未来职业发展更进一步。</p><h1 id="第01讲-谈谈你对Java平台的理解？"><a href="#第01讲-谈谈你对Java平台的理解？" class="headerlink" title="第01讲 谈谈你对Java平台的理解？"></a>第01讲 谈谈你对Java平台的理解？</h1><p>从你接触 Java 开发到现在，你对 Java 最直观的印象是什么呢？是它宣传的 “Write once, run anywhere”，还是目前看已经有些过于形式主义的语法呢？你对于 Java 平台到底了解到什么程度？请你先停下来总结思考一下。</p><p>今天我要问你的问题是，谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</p><h2 id="典型回答"><a href="#典型回答" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“<strong>书写一次，到处运行</strong>”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是<strong>垃圾收集</strong>（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</p><p>我们日常会接触到 JRE（Java Runtime Environment）或者 JDK（Java Development Kit）。 JRE，也就是 Java 运行环境，包含了 JVM 和 Java 类库，以及一些模块等。而 JDK 可以看作是 JRE 的一个超集，提供了更多工具，比如编译器、各种诊断工具等。</p><p>对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于<strong>编译执行</strong>，而不是解释执行了。</p><h2 id="考点分析"><a href="#考点分析" class="headerlink" title="考点分析"></a>考点分析</h2><p>其实这个问题，问得有点笼统。题目本身是非常开放的，往往考察的是多个方面，比如，基础知识理解是否很清楚；是否掌握 Java 平台主要模块和运行原理等。很多面试者会在这种问题上吃亏，稍微紧张了一下，不知道从何说起，就给出个很简略的回答。</p><p>对于这类笼统的问题，你需要尽量<strong>表现出自己的思维深入并系统化，Java 知识理解得也比较全面</strong>，一定要避免让面试官觉得你是个“知其然不知其所以然”的人。毕竟明白基本组成和机制，是日常工作中进行问题诊断或者性能调优等很多事情的基础，相信没有招聘方会不喜欢“热爱学习和思考”的面试者。</p><p>即使感觉自己的回答不是非常完善，也不用担心。我个人觉得这种笼统的问题，有时候回答得稍微片面也很正常，大多数有经验的面试官，不会因为一道题就对面试者轻易地下结论。通常会尽量引导面试者，把他的真实水平展现出来，这种问题就是做个开场热身，面试官经常会根据你的回答扩展相关问题。</p><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>回归正题，对于 Java 平台的理解，可以从很多方面简明扼要地谈一下，例如：Java 语言特性，包括泛型、Lambda 等语言特性；基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。对于我们日常工作应用较多的类库，面试前可以系统化总结一下，有助于临场发挥。</p><p>或者谈谈 JVM 的一些基础概念和机制，比如 Java 的类加载机制，常用版本 JDK（如 JDK 8）内嵌的 Class-Loader，例如 Bootstrap、 Application 和 Extension Class-loader；类加载大致过程：加载、验证、链接、初始化（这里参考了周志明的《深入理解 Java 虚拟机》，非常棒的 JVM 上手书籍）；自定义 Class-Loader 等。还有垃圾收集的基本原理，最常见的垃圾收集器，如 SerialGC、Parallel GC、 CMS、 G1 等，对于适用于什么样的工作负载最好也心里有数。这些都是可以扩展开的领域，我会在后面的专栏对此进行更系统的介绍。</p><p>当然还有 JDK 包含哪些工具或者 Java 领域内其他工具等，如编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。</p><p>下图是我总结的一个相对宽泛的蓝图供你参考。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/20bc6a900fc0b829c2f0e723df050732.png" alt="img"></p><p>不再扩展了，回到前面问到的解释执行和编译执行的问题。有些面试官喜欢在特定问题上“刨根问底儿”，因为这是进一步了解面试者对知识掌握程度的有效方法，我稍微深入探讨一下。</p><p>众所周知，我们通常把 Java 分为编译期和运行时。这里说的 Java 的编译和 C/C++ 是有着不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。Java 通过字节码和 Java 虚拟机（JVM）这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。</p><p>在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。就像我前面提到的，主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。Oracle Hotspot JVM 内置了两个不同的 JIT compiler，C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的。默认是采用所谓的分层编译（TieredCompilation）。这里不再展开更多 JIT 的细节，没必要一下子就钻进去，我会在后面介绍分层编译的内容。</p><p>Java 虚拟机启动时，可以指定不同的参数对运行模式进行选择。 比如，指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译，这种模式抛弃了 JIT 可能带来的性能优势。毕竟解释器（interpreter）是逐条读入，逐条解释运行的。与其相对应的，还有一个“-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别。那你可能会问这种模式是不是最高效啊？简单说，还真未必。“-Xcomp”会导致 JVM 启动变慢非常多，同时有些 JIT 编译器优化方式，比如分支预测，如果不进行 profiling，往往并不能进行有效优化。</p><p>除了我们日常最常见的 Java 使用模式，其实还有一种新的编译方式，即所谓的 AOT（Ahead-of-Time Compilation），直接将字节码编译成机器代码，这样就避免了 JIT 预热等各方面的开销，比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。利用下面的命令把某个类或者某个模块编译成为 AOT 库。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jaotc --output libHelloWorld.so HelloWorld.<span class="keyword">class</span></span><br><span class="line">jaotc --output libjava.<span class="keyword">base</span>.so --module java.<span class="keyword">base</span></span><br></pre></td></tr></table></figure><p>然后，在启动时直接指定就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld</span><br></pre></td></tr></table></figure><p>而且，Oracle JDK 支持分层编译和 AOT 协作使用，这两者并不是二选一的关系。如果你有兴趣，可以参考相关文档：<a href="https://openjdk.java.net/jeps/295">http://openjdk.java.net/jeps/295</a>。AOT 也不仅仅是只有这一种方式，业界早就有第三方工具（如 GCJ、Excelsior JET）提供相关功能。</p><p>另外，JVM 作为一个强大的平台，不仅仅只有 Java 语言可以运行在 JVM 上，本质上合规的字节码都可以运行，Java 语言自身也为此提供了便利，我们可以看到类似 Clojure、Scala、Groovy、JRuby、Jython 等大量 JVM 语言，活跃在不同的场景。</p><p>今天，我简单介绍了一下 Java 平台相关的一些内容，目的是提纲挈领地构建一个整体的印象，包括 Java 语言特性、 核心类库与常用第三方类库、Java 虚拟机基本原理和相关工具，希望对你有所帮助。</p><h2 id="一课一练"><a href="#一课一练" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？知道不如做到，请你也在留言区写写自己对 Java 平台的理解。我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p><h1 id="第02讲-Exception和Error有什么区别？"><a href="#第02讲-Exception和Error有什么区别？" class="headerlink" title="第02讲 Exception和Error有什么区别？"></a>第02讲 Exception和Error有什么区别？</h1><p>世界上存在永远不会出错的程序吗？也许这只会出现在程序员的梦中。随着编程语言和软件的诞生，异常情况就如影随形地纠缠着我们，只有正确处理好意外情况，才能保证程序的可靠性。</p><p>Java 语言在设计之初就提供了相对完善的异常处理机制，这也是 Java 得以大行其道的原因之一，因为这种机制大大降低了编写和维护可靠程序的门槛。如今，异常处理机制已经成为现代编程语言的标配。</p><p>今天我要问你的问题是，请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</p><h2 id="典型回答-1"><a href="#典型回答-1" class="headerlink" title="典型回答"></a>典型回答</h2><p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p><p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p><p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p><p>Exception 又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p><p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p><h2 id="考点分析-1"><a href="#考点分析-1" class="headerlink" title="考点分析"></a>考点分析</h2><p>分析 Exception 和 Error 的区别，是从概念角度考察了 Java 处理机制。总的来说，还处于理解的层面，面试者只要阐述清楚就好了。</p><p>我们在日常编程中，如何处理好异常是比较考验功底的，我觉得需要掌握两个方面。</p><p>第一，<strong>理解 Throwable、Exception、Error 的设计和分类</strong>。比如，掌握那些应用最为广泛的子类，以及如何自定义异常等。</p><p>很多面试官会进一步追问一些细节，比如，你了解哪些 Error、Exception 或者 RuntimeException？我画了一个简单的类图，并列出来典型例子，可以给你作为参考，至少做到基本心里有数。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/accba531a365e6ae39614ebfa3273900.png" alt="img"></p><p>其中有些子类型，最好重点理解一下，比如 NoClassDefFoundError 和 ClassNotFoundException 有什么区别，这也是个经典的入门题目。</p><p>第二，<strong>理解 Java 语言中操作 Throwable 的元素和实践</strong>。掌握最基本的语法是必须的，如 try-catch-finally 块，throw、throws 关键字等。与此同时，也要懂得如何处理典型场景。</p><p>异常处理代码比较繁琐，比如我们需要写很多千篇一律的捕获代码，或者在 finally 里面做一些资源回收工作。随着 Java 语言的发展，引入了一些更加便利的特性，比如 try-with-resources 和 multiple catch，具体可以参考下面的代码段。在编译时期，会自动生成相应的处理逻辑，比如，自动按照约定俗成 close 那些扩展了 AutoCloseable 或者 Closeable 的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(…);</span><br><span class="line">     <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(…)) &#123;<span class="comment">// Try-with-resources</span></span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">catch</span> ( IOException | XEception e) &#123;<span class="comment">// Multiple catch</span></span><br><span class="line">   <span class="comment">// Handle it</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="知识扩展-1"><a href="#知识扩展-1" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>前面谈的大多是概念性的东西，下面我来谈些实践中的选择，我会结合一些代码用例进行分析。</p><p>先开看第一个吧，下面的代码反映了异常处理中哪些不当之处？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 业务代码</span></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  Thread.<span class="title function_ invoke__">sleep</span>(<span class="number">1000</span>L);</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> e) &#123;</span><br><span class="line">  <span class="comment">// Ignore it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然很短，但是已经违反了异常处理的两个基本原则。</p><p>第一，<strong>尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常</strong>，在这里是 Thread.sleep() 抛出的 InterruptedException。</p><p>这是因为在日常的开发和合作中，我们读代码的机会往往超过写代码，软件工程是门协作的艺术，所以我们有义务让自己的代码能够直观地体现出尽量多的信息，而泛泛的 Exception 之类，恰恰隐藏了我们的目的。另外，我们也要保证程序不会捕获到我们不希望捕获的异常。比如，你可能更希望 RuntimeException 被扩散出来，而不是被捕获。</p><p>进一步讲，除非深思熟虑了，否则不要捕获 Throwable 或者 Error，这样很难保证我们能够正确程序处理 OutOfMemoryError。</p><p>第二，<strong>不要生吞（swallow）异常</strong>。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况。</p><p>生吞异常，往往是基于假设这段代码可能不会发生，或者感觉忽略异常是无所谓的，但是千万不要在产品代码做这种假设！</p><p>如果我们不把异常抛出来，或者也没有输出到日志（Logger）之类，程序可能在后续代码以不可控的方式结束。没人能够轻易判断究竟是哪里抛出了异常，以及是什么原因产生了异常。</p><p>再来看看第二段代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 业务代码</span></span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码作为一段实验代码，它是没有任何问题的，但是在产品代码中，通常都不允许这样处理。你先思考一下这是为什么呢？</p><p>我们先来看看<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Throwable.html#printStackTrace--">printStackTrace()</a>的文档，开头就是“Prints this throwable and its backtrace to the <strong>standard error stream</strong>”。问题就在这里，在稍微复杂一点的生产系统中，标准出错（STERR）不是个合适的输出选项，因为你很难判断出到底输出到哪里去了。</p><p>尤其是对于分布式系统，如果发生异常，但是无法找到堆栈轨迹（stacktrace），这纯属是为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。</p><p>我们接下来看下面的代码段，体会一下<strong>Throw early, catch late 原则</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">readPreferences</span>(<span class="params"><span class="built_in">String</span> fileName</span>)&#123;</span><br><span class="line"> <span class="comment">//...perform operations... </span></span><br><span class="line"><span class="title class_">InputStream</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line"> <span class="comment">//...read the preferences file...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。</p><p>我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">readPreferences</span>(<span class="params"><span class="built_in">String</span> filename</span>) &#123;</span><br><span class="line"><span class="title class_">Objects</span>. requireNonNull(filename);</span><br><span class="line"><span class="comment">//...perform other operations... </span></span><br><span class="line"><span class="title class_">InputStream</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line"> <span class="comment">//...read the preferences file...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的 cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。</p><p>有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：</p><ul><li>是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。</li><li>在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。</li></ul><p>业界有一种争论（甚至可以算是某种程度的共识），Java 语言的 Checked Exception 也许是个设计错误，反对者列举了几点：</p><ul><li>Checked Exception 的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception 的使用，已经大大偏离了最初的设计目的。</li><li>Checked Exception 不兼容 functional 编程，如果你写过 Lambda/Stream 代码，相信深有体会。</li></ul><p>很多开源项目，已经采纳了这种实践，比如 Spring、Hibernate 等，甚至反映在新的编程语言设计中，比如 Scala 等。 如果有兴趣，你可以参考：</p><p><a href="http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/。">http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/。</a></p><p>当然，很多人也觉得没有必要矫枉过正，因为确实有一些异常，比如和环境相关的 IO、网络等，其实是存在可恢复性的，而且 Java 已经通过业界的海量实践，证明了其构建高质量软件的能力。我就不再进一步解读了，感兴趣的同学可以点击<strong>链接</strong>，观看 Bruce Eckel 在 2018 年全球软件开发大会 QCon 的分享 Failing at Failing: How and Why We’ve Been Nonchalantly Moving Away From Exception Handling。</p><p>我们从性能角度来审视一下 Java 的异常处理机制，这里有两个可能会相对昂贵的地方：</p><ul><li>try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。</li><li>Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。</li></ul><p>所以，对于部分追求极致性能的底层类库，有种方式是尝试创建不进行栈快照的 Exception。这本身也存在争议，因为这样做的假设在于，我创建异常时知道未来是否需要堆栈。问题是，实际上可能吗？小范围或许可能，但是在大规模项目中，这么做可能不是个理智的选择。如果需要堆栈，但又没有收集这些信息，在复杂情况下，尤其是类似微服务这种分布式系统，这会大大增加诊断的难度。</p><p>当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。关于诊断后台变慢的问题，我会在后面的 Java 性能基础模块中系统探讨。</p><p>今天，我从一个常见的异常处理概念问题，简单总结了 Java 异常处理的机制。并结合代码，分析了一些普遍认可的最佳实践，以及业界最新的一些异常使用共识。最后，我分析了异常性能开销，希望对你有所帮助。</p><h2 id="一课一练-1"><a href="#一课一练-1" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？可以思考一个问题，对于异常处理编程，不同的编程范式也会影响到异常处理策略，比如，现在非常火热的反应式编程（Reactive Stream），因为其本身是异步、基于事件机制的，所以出现异常情况，决不能简单抛出去；另外，由于代码堆栈不再是同步调用那种垂直的结构，这里的异常处理和日志需要更加小心，我们看到的往往是特定 executor 的堆栈，而不是业务方法调用关系。对于这种情况，你有什么好的办法吗？</p><h1 id="第03讲-谈谈final、finally、-finalize有什么不同？"><a href="#第03讲-谈谈final、finally、-finalize有什么不同？" class="headerlink" title="第03讲 谈谈final、finally、 finalize有什么不同？"></a>第03讲 谈谈final、finally、 finalize有什么不同？</h1><p>Java 语言有很多看起来很相似，但是用途却完全不同的语言要素，这些内容往往容易成为面试官考察你知识掌握程度的切入点。</p><p>今天，我要问你的是一个经典的 Java 基础题目，谈谈 final、finally、 finalize 有什么不同？</p><h2 id="典型回答-2"><a href="#典型回答-2" class="headerlink" title="典型回答"></a>典型回答</h2><p>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p><p>finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p><p>finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p><h2 id="考点分析-2"><a href="#考点分析-2" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是一个非常经典的 Java 基础问题，我上面的回答主要是从语法和使用实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察你对性能、并发、对象生命周期或垃圾收集基本过程等方面的理解。</p><p>推荐使用 final 关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：</p><ul><li>我们可以将方法或者类声明为 final，这样就可以明确告知别人，这些行为是不许修改的。</li></ul><p>如果你关注过 Java 核心类库的定义或源码， 有没有发现 java.lang 包下面的很多类，相当一部分都被声明成为 final class？在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</p><ul><li>使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。</li><li>final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li></ul><p>final 也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景提高性能，比如，利用 final 可能有助于 JVM 将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能 JVM（如 HotSpot）判断内联未必依赖 final 的提示，要相信 JVM 还是非常智能的。类似的，final 字段对性能的影响，大部分情况下，并没有考虑的必要。</p><p>从开发实践的角度，我不想过度强调这一点，这是和 JVM 的实现很相关的，未经验证比较难以把握。我的建议是，在日常开发中，除非有特别考虑，不然最好不要指望这种小技巧带来的所谓性能好处，程序最好是体现它的语义目的。如果你确实对这方面有兴趣，可以查阅相关资料，我就不再赘述了，不过千万别忘了验证一下。</p><p>对于 finally，明确知道怎么使用就足够了。需要关闭的连接等资源，更推荐使用 Java 7 中添加的 try-with-resources 语句，因为通常 Java 平台能够更好地处理异常情况，编码量也要少很多，何乐而不为呢。</p><p>另外，我注意到有一些常被考到的 finally 问题（也比较偏门），至少需要了解一下。比如，下面代码会输出什么？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  System.<span class="keyword">out</span>.println(“Print <span class="keyword">from</span> <span class="keyword">finally</span>”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 finally 里面的代码可不会被执行的哦，这是一个特例。</p><p>对于 finalize，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，在 Java 9 中，甚至明确将 Object.finalize() 标记为 deprecated！如果没有特别的原因，不要实现 finalize 方法，也不要指望利用它来进行资源回收。</p><p>为什么呢？简单说，你无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。</p><p>通常来说，利用上面的提到的 try-with-resources 或者 try-finally 机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑 Java 提供的 Cleaner 机制或者其他替代方法。接下来，我来介绍更多设计考虑和实践细节。</p><h2 id="知识扩展-2"><a href="#知识扩展-2" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>\1. 注意，final 不是 immutable！</p><p>我在前面介绍了 final 在实践中的益处，需要注意的是，<strong>final 并不等同于 immutable</strong>，比如下面这段代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">strList.<span class="keyword">add</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">strList.<span class="keyword">add</span>(<span class="string">&quot;world&quot;</span>);  </span><br><span class="line">List&lt;String&gt; unmodifiableStrList = List.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">unmodifiableStrList.<span class="keyword">add</span>(<span class="string">&quot;again&quot;</span>);</span><br></pre></td></tr></table></figure><p>final 只能约束 strList 这个引用不可以被赋值，但是 strList 对象行为不被 final 影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面这个例子中，<a href="https://openjdk.java.net/jeps/269">List.of 方法</a>创建的本身就是不可变 List，最后那句 add 是会在运行时抛出异常的。</p><p>Immutable 在很多场景是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，如果要实现 immutable 的类，我们需要做到：</p><ul><li>将 class 自身声明为 final，这样别人就不能扩展来绕过限制了。</li><li>将所有成员变量定义为 private 和 final，并且不要实现 setter 方法。</li><li>通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。</li><li>如果确实需要实现 getter 方法，或者其他可能会返回内部状态的方法，使用 copy-on-write 原则，创建私有的 copy。</li></ul><p>这些原则是不是在并发编程实践中经常被提到？的确如此。</p><p>关于 setter/getter 方法，很多人喜欢直接用 IDE 一次全部生成，建议最好是你确定有需要时再实现。</p><p>2.finalize 真的那么不堪？</p><p>前面简单介绍了 finalize 是一种已经被业界证明了的非常不好的实践，那么为什么会导致那些问题呢？</p><p>finalize 的执行是和垃圾收集关联在一起的，一旦实现了非空的 finalize 方法，就会导致相应对象回收呈现数量级上的变慢，有人专门做过 benchmark，大概是 40~50 倍的下降。</p><p>因为，finalize 被设计成在对象<strong>被垃圾收集前</strong>调用，这就意味着实现了 finalize 方法的对象是个“特殊公民”，JVM 要对它进行额外处理。finalize 本质上成为了快速回收的阻碍者，可能导致你的对象经过多个垃圾收集周期才能被回收。</p><p>有人也许会问，我用 System.runFinalization() 告诉 JVM 积极一点，是不是就可以了？也许有点用，但是问题在于，这还是不可预测、不能保证的，所以本质上还是不能指望。实践中，因为 finalize 拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致 OOM 的原因。</p><p>从另一个角度，我们要确保回收资源就是因为资源都是有限的，垃圾收集时间的不可预测，可能会极大加剧资源占用。这意味着对于消耗非常高频的资源，千万不要指望 finalize 去承担资源释放的主要职责，最多让 finalize 作为最后的“守门员”，况且它已经暴露了如此多的问题。这也是为什么我推荐，<strong>资源用完即显式释放，或者利用资源池来尽量重用</strong>。</p><p>finalize 还会掩盖资源回收时的出错信息，我们看下面一段 JDK 的源代码，截取自 java.lang.ref.Finalizer</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">runFinalizer</span>(<span class="params">JavaLangAccess jla</span>) &#123;</span><br><span class="line"><span class="comment">//  ... 省略部分代码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="title class_">Object</span> finalizee = <span class="variable language_">this</span>.<span class="title function_">get</span>(); </span><br><span class="line">   <span class="keyword">if</span> (finalizee != <span class="literal">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.<span class="property">lang</span>.<span class="property">Enum</span>)) &#123;</span><br><span class="line">      jla.<span class="title function_">invokeFinalize</span>(finalizee);</span><br><span class="line">      <span class="comment">// Clear stack slot containing this variable, to decrease</span></span><br><span class="line">      <span class="comment">// the chances of false retention with a conservative GC</span></span><br><span class="line">      finalizee = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (<span class="title class_">Throwable</span> x) &#123; &#125;</span><br><span class="line">   <span class="variable language_">super</span>.<span class="title function_">clear</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合我上期专栏介绍的异常处理实践，你认为这段代码会导致什么问题？</p><p>是的，你没有看错，这里的<strong>Throwable 是被生吞了的！</strong>也就意味着一旦出现异常或者出错，你得不到任何有效信息。况且，Java 在 finalize 阶段也没有好的方式处理任何信息，不然更加不可预测。</p><p>\3. 有什么机制可以替换 finalize 吗？</p><p>Java 平台目前在逐步使用 java.lang.ref.Cleaner 来替换掉原有的 finalize 实现。Cleaner 的实现利用了幻象引用（PhantomReference），这是一种常见的所谓 post-mortem 清理机制。我会在后面的专栏系统介绍 Java 的各种引用，利用幻象引用和引用队列，我们可以保证对象被彻底销毁前做一些类似资源回收的工作，比如关闭文件描述符（操作系统有限的资源），它比 finalize 更加轻量、更加可靠。</p><p>吸取了 finalize 里的教训，每个 Cleaner 的操作都是独立的，它有自己的运行线程，所以可以避免意外死锁等问题。</p><p>实践中，我们可以为自己的模块构建一个 Cleaner，然后实现相应的清理逻辑。下面是 JDK 自身提供的样例程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CleaningExample</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">        <span class="comment">// A cleaner, preferably one shared within a library</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> &lt;cleaner&gt;;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">            State(...) &#123;</span><br><span class="line">                <span class="comment">// initialize State needed for cleaning action</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// cleanup action accessing State, executed at most once</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> State;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CleaningExample</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">State</span>(...);</span><br><span class="line">            <span class="built_in">this</span>.cleanable = cleaner.register(<span class="built_in">this</span>, state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            cleanable.clean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致幻象引用堆积，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。</p><p>我也注意到很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的 MySQL JDBC driver 之一的 mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。</p><p>另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的 MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。</p><p>今天，我从语法角度分析了 final、finally、finalize，并从安全、性能、垃圾收集等方面逐步深入，探讨了实践中的注意事项，希望对你有所帮助。</p><h2 id="一课一练-2"><a href="#一课一练-2" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？也许你已经注意到了，JDK 自身使用的 Cleaner 机制仍然是有缺陷的，你有什么更好的建议吗？</p><h1 id="第04讲-强引用、软引用、弱引用、幻象引用有什么区别？"><a href="#第04讲-强引用、软引用、弱引用、幻象引用有什么区别？" class="headerlink" title="第04讲 强引用、软引用、弱引用、幻象引用有什么区别？"></a>第04讲 强引用、软引用、弱引用、幻象引用有什么区别？</h1><p>在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象生命周期和 JVM 内部相关机制非常有帮助。</p><p>今天我要问你的问题是，强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</p><h2 id="典型回答-3"><a href="#典型回答-3" class="headerlink" title="典型回答"></a>典型回答</h2><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。</p><p>所谓强引用（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p><p>软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>弱引用（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p><p>对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。</p><h2 id="考点分析-3"><a href="#考点分析-3" class="headerlink" title="考点分析"></a>考点分析</h2><p>这道面试题，属于既偏门又非常高频的一道题目。说它偏门，是因为在大多数应用开发中，很少直接操作各种不同引用，虽然我们使用的类库、框架可能利用了其机制。它被频繁问到，是因为这是一个综合性的题目，既考察了我们对基础概念的理解，也考察了对底层对象生命周期、垃圾收集机制等的掌握。</p><p>充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用 OOM 等问题，会很有帮助。比如，诊断 MySQL connector-j 驱动在特定模式下（useCompression=true）的内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题。</p><h2 id="知识扩展-3"><a href="#知识扩展-3" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>\1. 对象可达性状态流转分析</p><p>首先，请你看下面流程图，我这里简单总结了对象生命周期和不同可达性状态，以及不同状态可能的改变关系，可能未必 100% 严谨，来阐述下可达性的变化。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/36d3c7b158eda9421ef32463cb4d4fb0.png" alt="img"></p><p>我来解释一下上图的具体状态，这是 Java 定义的不同可达性级别（reachability level），具体如下：</p><ul><li>强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。</li><li>软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。</li><li>弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。</li><li>幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。</li><li>当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。</li></ul><p>判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。</p><p>所有引用类型，都是抽象类 java.lang.ref.Reference 的子类，你可能注意到它提供了 get() 方法：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/bae702d46c665e12113f5abd876eb53e.png" alt="img"></p><p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！这也是为什么我在上面图里有些地方画了双向箭头。</p><p>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p><p>但是，你觉得这里有没有可能出现什么问题呢？</p><p>不错，如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。</p><p>\2. 引用队列（ReferenceQueue）使用</p><p>谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，我们可以从队列里获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get 方法只返回 null，如果再不指定引用队列，基本就没有意义了。看看下面的示例代码。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被 finalize 了，处于幻象可达状态），执行后期处理逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span> counter = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">ReferenceQueue</span> refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"><span class="title class_">PhantomReference</span>&lt;<span class="title class_">Object</span>&gt; p = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(counter, refQueue);</span><br><span class="line">counter = <span class="literal">null</span>;</span><br><span class="line"><span class="title class_">System</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Remove 是一个阻塞方法，可以指定 timeout，或者选择一直阻塞</span></span><br><span class="line">    <span class="title class_">Reference</span>&lt;<span class="title class_">Object</span>&gt; ref = refQueue.<span class="title function_">remove</span>(1000L);</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;</span><br><span class="line">    <span class="comment">// Handle it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\3. 显式地影响软引用垃圾收集</p><p>前面泛泛提到了引用对垃圾收集的影响，尤其是软引用，到底 JVM 内部是怎么处理它的，其实并不是非常明确。那么我们能不能使用什么方法来影响软引用的垃圾收集呢？</p><p>答案是有的。软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为 3 秒（3000 毫秒）。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:SoftRefLRUPolicyMSPerMB=3000</span></span><br></pre></td></tr></table></figure><p>这个剩余空间，其实会受不同 JVM 模式影响，对于 Client 模式，比如通常的 Windows 32 bit JDK，剩余空间是计算当前堆里空闲的大小，所以更加倾向于回收；而对于 server 模式 JVM，则是根据 -Xmx 指定的最大值来计算。</p><p>本质上，这个行为还是个黑盒，取决于 JVM 实现，即使是上面提到的参数，在新版的 JDK 上也未必有效，另外 Client 模式的 JDK 已经逐步退出历史舞台。所以在我们应用时，可以参考类似设置，但不要过于依赖它。</p><p>\4. 诊断 JVM 引用情况</p><p>如果你怀疑应用存在引用（或 finalize）导致的回收问题，可以有很多工具或者选项可供选择，比如 HotSpot JVM 自身便提供了明确的选项（PrintReferenceGC）去获取相关信息，我指定了下面选项去使用 JDK 8 运行一个样例应用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDetails</span> -<span class="variable constant_">XX</span><span class="symbol">:+PrintGCTimeStamps</span> -<span class="variable constant_">XX</span><span class="symbol">:+PrintReferenceGC</span></span><br></pre></td></tr></table></figure><p>这是 JDK 8 使用 ParrallelGC 收集的垃圾收集日志，各种引用数量非常清晰。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0.403:</span> [<span class="string">GC</span> <span class="string">(Allocation</span> <span class="string">Failure)</span> <span class="attr">0.871:</span> [<span class="string">SoftReference</span>, <span class="number">0</span> <span class="string">refs</span>, <span class="number">0.0000393</span> <span class="string">secs</span>]<span class="attr">0.871:</span> [<span class="string">WeakReference</span>, <span class="number">8</span> <span class="string">refs</span>, <span class="number">0.0000138</span> <span class="string">secs</span>]<span class="attr">0.871:</span> [<span class="string">FinalReference</span>, <span class="number">4</span> <span class="string">refs</span>, <span class="number">0.0000094</span> <span class="string">secs</span>]<span class="attr">0.871:</span> [<span class="string">PhantomReference</span>, <span class="number">0</span> <span class="string">refs</span>, <span class="number">0</span> <span class="string">refs</span>, <span class="number">0.0000085</span> <span class="string">secs</span>]<span class="attr">0.871:</span> [<span class="string">JNI</span> <span class="string">Weak</span> <span class="string">Reference</span>, <span class="number">0.0000071</span> <span class="string">secs</span>][<span class="attr">PSYoungGen:</span> <span class="string">76272K-&gt;10720K(141824K)</span>] <span class="string">128286K-&gt;128422K(316928K)</span>, <span class="number">0.4683919</span> <span class="string">secs</span>] [<span class="attr">Times:</span> <span class="string">user=1.17</span> <span class="string">sys=0.03</span>, <span class="string">real=0.47</span> <span class="string">secs</span>] </span><br></pre></td></tr></table></figure><p><strong>注意：JDK 9 对 JVM 和垃圾收集日志进行了广泛的重构</strong>，类似 PrintGCTimeStamps 和 PrintReferenceGC 已经不再存在，我在专栏后面的垃圾收集主题里会更加系统的阐述。</p><p>5.Reachability Fence</p><p>除了我前面介绍的几种基本引用类型，我们也可以通过底层 API 来达到强引用的效果，这就是所谓的设置<strong>reachability fence</strong>。</p><p>为什么需要这种机制呢？考虑一下这样的场景，按照 Java 语言规范，如果一个对象没有指向强引用，就符合垃圾收集的标准，有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用，这样就导致诡异的问题，所以我们需要一个方法，在没有强引用情况下，通知 JVM 对象是在被使用的。说起来有点绕，我们来看看 Java 9 中提供的案例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Resource</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ExternalResource[] externalResourceArray = ...</span><br><span class="line"> <span class="built_in">int</span> myIndex; Resource(...) &#123;</span><br><span class="line">     myIndex = ...</span><br><span class="line">     externalResourceArray[myIndex] = ...;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>()</span> &#123;</span><br><span class="line">     externalResourceArray[myIndex] = <span class="literal">null</span>;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span>()</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 需要被保护的代码</span></span><br><span class="line">     <span class="built_in">int</span> i = myIndex;</span><br><span class="line">     Resource.update(externalResourceArray[i]);</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 调用 reachbilityFence，明确保障对象 strongly reachable</span></span><br><span class="line">     Reference.reachabilityFence(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span>(<span class="params">ExternalResource ext</span>)</span> &#123;</span><br><span class="line">    ext.status = ...;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>方法 action 的执行，依赖于对象的部分属性，所以被特定保护了起来。否则，如果我们在代码中像下面这样调用，那么就可能会出现困扰，因为没有强引用指向我们创建出来的 Resource 对象，JVM 对它进行 finalize 操作是完全合法的。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new <span class="built_in">Resource</span>()<span class="selector-class">.action</span>()</span><br></pre></td></tr></table></figure><p>类似的书写结构，在异步编程中似乎是很普遍的，因为异步编程中往往不会用传统的“执行 -&gt; 返回 -&gt; 使用”的结构。</p><p>在 Java 9 之前，实现类似类似功能相对比较繁琐，有的时候需要采取一些比较隐晦的小技巧。幸好，java.lang.ref.Reference 给我们提供了新方法，它是 JEP 193: Variable Handles 的一部分，将 Java 平台底层的一些能力暴露出来：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reachabilityFence</span>(<span class="params">Object <span class="keyword">ref</span></span>)</span></span><br></pre></td></tr></table></figure><p>在 JDK 源码中，reachabilityFence 大多使用在 Executors 或者类似新的 HTTP/2 客户端代码中，大部分都是异步调用的情况。编程中，可以按照上面这个例子，将需要 reachability 保障的代码段利用 try-finally 包围起来，在 finally 里明确声明对象强可达。</p><p>今天，我总结了 Java 语言提供的几种引用类型、相应可达状态以及对于 JVM 工作的意义，并分析了引用队列使用的一些实际情况，最后介绍了在新的编程模式下，如何利用 API 去保障对象不被以为意外回收，希望对你有所帮助。</p><h2 id="一课一练-3"><a href="#一课一练-3" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？给你留一道练习题，你能从自己的产品或者第三方类库中找到使用各种引用的案例吗？它们都试图解决什么问题？</p><h1 id="第05讲-String、StringBuffer、StringBuilder有什么区别？"><a href="#第05讲-String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="第05讲 String、StringBuffer、StringBuilder有什么区别？"></a>第05讲 String、StringBuffer、StringBuilder有什么区别？</h1><p>今天我会聊聊日常使用的字符串，别看它似乎很简单，但其实字符串几乎在所有编程语言里都是个特殊的存在，因为不管是数量还是体积，字符串都是大多数应用中的重要组成。</p><p>今天我要问你的问题是，理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？</p><h2 id="典型回答-4"><a href="#典型回答-4" class="headerlink" title="典型回答"></a>典型回答</h2><p>String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p><p>StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p><p>StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p><h2 id="考点分析-4"><a href="#考点分析-4" class="headerlink" title="考点分析"></a>考点分析</h2><p>几乎所有的应用开发都离不开操作字符串，理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。关于这个问题，我前面的回答是一个通常的概要性回答，至少你要知道 String 是 Immutable 的，字符串操作不当可能会产生大量临时字符串，以及线程安全方面的区别。</p><p>如果继续深入，面试官可以从各种不同的角度考察，比如可以：</p><ul><li>通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。</li><li>考察 JVM 对象缓存机制的理解以及如何良好地使用。</li><li>考察 JVM 优化 Java 代码的一些技巧。</li><li>String 相关类的演进，比如 Java 9 中实现的巨大变化。</li><li>…</li></ul><p>针对上面这几方面，我会在知识扩展部分与你详细聊聊。</p><h2 id="知识扩展-4"><a href="#知识扩展-4" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>\1. 字符串设计和实现考量</p><p>我在前面介绍过，String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</p><p>我们再来看看 StringBuffer 实现的一些细节，它的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常直白。其实，这种简单粗暴的实现方式，非常适合我们常见的线程安全类实现，不必纠结于 synchronized 性能之类的，有人说“过早优化是万恶之源”，考虑可靠性、正确性和代码可读性才是大多数应用开发最重要的因素。</p><p>为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。</p><p>另外，这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。</p><p>前面我讲的这些内容，在具体的代码书写中，应该如何选择呢？</p><p>在没有线程安全问题的情况下，全部拼接操作是应该都用 StringBuilder 实现吗？毕竟这样书写的代码，还是要多敲很多字的，可读性也不理想，下面的对比非常明显。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String strByBuilder  = <span class="built_in">new</span></span><br><span class="line">StringBuilder().<span class="built_in">append</span>(<span class="string">&quot;aa&quot;</span>).<span class="built_in">append</span>(<span class="string">&quot;bb&quot;</span>).<span class="built_in">append</span>(<span class="string">&quot;cc&quot;</span>).<span class="built_in">append</span></span><br><span class="line">            (<span class="string">&quot;dd&quot;</span>).toString();</span><br><span class="line">             </span><br><span class="line">String strByConcat = <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span> + <span class="string">&quot;cc&quot;</span> + <span class="string">&quot;dd&quot;</span>;</span><br></pre></td></tr></table></figure><p>其实，在通常情况下，没有必要过于担心，要相信 Java 还是非常智能的。</p><p>我们来做个实验，把下面一段代码，利用不同版本的 JDK 编译，然后再反编译，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcat</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">          <span class="title class_">String</span> myStr = <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span> + <span class="string">&quot;cc&quot;</span> + <span class="string">&quot;dd&quot;</span>;   </span><br><span class="line">           <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;My String:&quot;</span> + myStr);   </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先编译再反编译，比如使用不同版本的 JDK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;JAVA_HOME&#125;</span>/bin/javac StringConcat.java</span><br><span class="line"><span class="variable">$&#123;JAVA_HOME&#125;</span>/bin/javap -v StringConcat.class</span><br></pre></td></tr></table></figure><p>JDK 8 的输出片段是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#2                  // String aabbccdd</span></span><br><span class="line"> <span class="attr">2:</span> <span class="string">astore_1</span></span><br><span class="line"> <span class="attr">3:</span> <span class="string">getstatic</span>     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"> <span class="attr">6:</span> <span class="string">new</span>           <span class="comment">#4                  // class java/lang/StringBuilder</span></span><br><span class="line"> <span class="attr">9:</span> <span class="string">dup</span></span><br><span class="line"><span class="attr">10:</span> <span class="string">invokespecial</span> <span class="comment">#5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"><span class="attr">13:</span> <span class="string">ldc</span>           <span class="comment">#6                  // String My String:</span></span><br><span class="line"><span class="attr">15:</span> <span class="string">invokevirtual</span> <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="attr">18:</span> <span class="string">aload_1</span></span><br><span class="line"><span class="attr">19:</span> <span class="string">invokevirtual</span> <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line"><span class="attr">22:</span> <span class="string">invokevirtual</span> <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br></pre></td></tr></table></figure><p>而在 JDK 9 中，反编译的结果就非常简单了，片段是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         <span class="attr">0:</span> <span class="string">ldc</span>           <span class="comment">#2                  // String aabbccdd</span></span><br><span class="line">         <span class="attr">2:</span> <span class="string">astore_1</span></span><br><span class="line">         <span class="attr">3:</span> <span class="string">getstatic</span>     <span class="comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="attr">6:</span> <span class="string">aload_1</span></span><br><span class="line"><span class="attr">7:</span> <span class="string">invokedynamic</span> <span class="comment">#4,  0              // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span></span><br></pre></td></tr></table></figure><p>你可以看到，在 JDK 8 中，字符串拼接操作会自动被 javac 转换为 StringBuilder 操作，而在 JDK 9 里面则是因为 Java 9 为了更加统一字符串操作优化，提供了 StringConcatFactory，作为一个统一的入口。javac 自动生成的代码，虽然未必是最优化的，但普通场景也足够了，你可以酌情选择。</p><p>\2. 字符串缓存</p><p>我们粗略统计过，把常见应用进行堆转储（Dump Heap），然后分析对象组成，会发现平均 25% 的对象是字符串，并且其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。</p><p>String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。</p><p>看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。所以，如果使用不当，OOM 就会光顾。</p><p>在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。你可以使用下面的参数直接打印具体数字，可以拿自己的 JDK 立刻试验一下。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintStringTableStatistics</span></span><br></pre></td></tr></table></figure><p>你也可以使用下面的 JVM 参数手动调整大小，但是绝大部分情况下并不需要调整，除非你确定它的大小已经影响了操作效率。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:StringTableSize=N</span></span><br></pre></td></tr></table></figure><p>Intern 是一种<strong>显式地排重机制</strong>，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。</p><p>幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。</p><p>注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseStringDeduplication</span> </span><br></pre></td></tr></table></figure><p>前面说到的几个方面，只是 Java 底层对字符串各种优化的一角，在运行时，字符串的一些基础操作会直接利用 JVM 内部的 Intrinsic 机制，往往运行的就是特殊优化的本地代码，而根本就不是 Java 代码生成的字节码。Intrinsic 可以简单理解为，是一种利用 native 方式 hard-coded 的逻辑，算是一种特别的内联，很多优化还是需要直接使用特定的 CPU 指令，具体可以看相关<a href="http://hg.openjdk.java.net/jdk/jdk/file/44b64fc0baa3/src/hotspot/share/classfile/vmSymbols.hpp">源码</a>，搜索“string”以查找相关 Intrinsic 定义。当然，你也可以在启动实验应用时，使用下面参数，了解 intrinsic 发生的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</span><br><span class="line">    // 样例输出片段    </span><br><span class="line">        <span class="number">180</span>    <span class="number">3</span>       <span class="number">3</span>       java.lang.String::charAt (<span class="number">25</span> <span class="built_in">bytes</span>)  </span><br><span class="line"><span class="meta">                                  @ <span class="number">1</span>   java.lang.String::isLatin1 (<span class="params"><span class="number">19</span> <span class="built_in">bytes</span></span>)   </span></span><br><span class="line">                                  ...  </span><br><span class="line"><span class="meta">                                  @ <span class="number">7</span> java.lang.StringUTF16::getChar (<span class="params"><span class="number">60</span> <span class="built_in">bytes</span></span>) intrinsic </span></span><br></pre></td></tr></table></figure><p>可以看出，仅仅是字符串一个实现，就需要 Java 平台工程师和科学家付出如此大且默默无闻的努力，我们得到的很多便利都是来源于此。</p><p>我会在专栏后面的 JVM 和性能等主题，详细介绍 JVM 内部优化的一些方法，如果你有兴趣可以再深入学习。即使你不做 JVM 开发或者暂时还没有使用到特别的性能优化，这些知识也能帮助你增加技术深度。</p><p>3.String 自身的演化</p><p>如果你仔细观察过 Java 的字符串，在历史版本中，它是使用 char 数组来存数据的，这样非常直接。但是 Java 中的 char 是两个 bytes 大小，拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。密度是编程语言平台永恒的话题，因为归根结底绝大部分任务是要来操作数据的。</p><p>其实在 Java 6 的时候，Oracle JDK 就提供了压缩字符串的特性，但是这个特性的实现并不是开源的，而且在实践中也暴露出了一些问题，所以在最新的 JDK 版本中已经将它移除了。</p><p>在 Java 9 中，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并且将相关字符串操作类都进行了修改。另外，所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。</p><p>虽然底层实现发生了这么大的改变，但是 Java 字符串的行为并没有任何大的变化，所以这个特性对于绝大部分应用来说是透明的，绝大部分情况不需要修改已有代码。</p><p>当然，在极端情况下，字符串也出现了一些能力退化，比如最大字符串的大小。你可以思考下，原来 char 数组的实现，字符串的最大长度就是数组本身的长度限制，但是替换成 byte 数组，同样数组长度下，存储能力是退化了一倍的！还好这是存在于理论中的极限，还没有发现现实应用受此影响。</p><p>在通用的性能测试和产品实验中，我们能非常明显地看到紧凑字符串带来的优势，<strong>即更小的内存占用、更快的操作速度</strong>。</p><p>今天我从 String、StringBuffer 和 StringBuilder 的主要设计和实现特点开始，分析了字符串缓存的 intern 机制、非代码侵入性的虚拟机层面排重、Java 9 中紧凑字符的改进，并且初步接触了 JVM 的底层优化机制 intrinsic。从实践的角度，不管是 Compact Strings 还是底层 intrinsic 优化，都说明了使用 Java 基础类库的优势，它们往往能够得到最大程度、最高质量的优化，而且只要升级 JDK 版本，就能零成本地享受这些益处。</p><h2 id="一课一练-4"><a href="#一课一练-4" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？限于篇幅有限，还有很多字符相关的问题没有来得及讨论，比如编码相关的问题。可以思考一下，很多字符串操作，比如 getBytes()/<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#String-byte:A-">String</a>(byte[] bytes) 等都是隐含着使用平台默认编码，这是一种好的实践吗？是否有利于避免乱码？</p><h1 id="第06讲-动态代理是基于什么原理？"><a href="#第06讲-动态代理是基于什么原理？" class="headerlink" title="第06讲 动态代理是基于什么原理？"></a>第06讲 动态代理是基于什么原理？</h1><p>编程语言通常有各种不同的分类角度，动态类型和静态类型就是其中一种分类角度，简单区分就是语言类型信息是在运行时检查，还是编译期检查。</p><p>与其近似的还有一个对比，就是所谓强类型和弱类型，就是不同类型变量赋值时，是否需要显式地（强制）进行类型转换。</p><p>那么，如何分类 Java 语言呢？通常认为，Java 是静态的强类型语言，但是因为提供了类似反射等机制，也具备了部分动态类型语言的能力。</p><p>言归正传，今天我要问你的问题是，谈谈 Java 反射机制，动态代理是基于什么原理？</p><h2 id="典型回答-5"><a href="#典型回答-5" class="headerlink" title="典型回答"></a>典型回答</h2><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时<strong>自省</strong>（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p><p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p><h2 id="考点分析-5"><a href="#考点分析-5" class="headerlink" title="考点分析"></a>考点分析</h2><p>这个题目给我的第一印象是稍微有点诱导的嫌疑，可能会下意识地以为动态代理就是利用反射机制实现的，这么说也不算错但稍微有些不全面。功能才是目的，实现的方法有很多。总的来说，这道题目考察的是 Java 语言的另外一种基础机制： 反射，它就像是一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。</p><p>从考察知识点的角度，这道题涉及的知识点比较庞杂，所以面试官能够扩展或者深挖的内容非常多，比如：</p><ul><li>考察你对反射机制的了解和掌握程度。</li><li>动态代理解决了什么问题，在你业务系统中的应用场景是什么？</li><li>JDK 动态代理在设计和实现上与 cglib 等方式有什么不同，进而如何取舍？</li></ul><p>这些考点似乎不是短短一篇文章能够囊括的，我会在知识扩展部分尽量梳理一下。</p><h2 id="知识扩展-5"><a href="#知识扩展-5" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>\1. 反射机制及其演进</p><p>对于 Java 语言的反射机制本身，如果你去看一下 java.lang 或 java.lang.reflect 包下的相关抽象，就会有一个很直观的印象了。Class、Field、Method、Constructor 等，这些完全就是我们去操作类和对象的元数据对应。反射各种典型用例的编程，相信有太多文章或书籍进行过详细的介绍，我就不再赘述了，至少你需要掌握基本场景编程，这里是官方提供的参考文档：<a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">https://docs.oracle.com/javase/tutorial/reflect/index.html</a> 。</p><p>关于反射，有一点我需要特意提一下，就是反射提供的 AccessibleObject.setAccessible(boolean flag)。它的子类也大都重写了这个方法，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在运行时修改成员访问限制！</p><p>setAccessible 的应用场景非常普遍，遍布我们的日常开发、测试、依赖注入等各种框架中。比如，在 O/R Mapping 框架中，我们为一个 Java 实体对象，运行时自动生成 setter、getter 的逻辑，这是加载或者持久化数据非常必要的，框架通常可以利用反射做这个事情，而不需要开发者手动写类似的重复代码。</p><p>另一个典型场景就是绕过 API 访问控制。我们日常开发时可能被迫要调用内部 API 去做些事情，比如，自定义的高性能 NIO 框架需要显式地释放 DirectBuffer，使用反射绕开限制是一种常见办法。</p><p>但是，在 Java 9 以后，这个方法的使用可能会存在一些争议，因为 Jigsaw 项目新增的模块化系统，出于强封装性的考虑，对反射访问进行了限制。Jigsaw 引入了所谓 Open 的概念，只有当被反射操作的模块和指定的包对反射调用者模块 Open，才能使用 setAccessible；否则，被认为是不合法（illegal）操作。如果我们的实体类是定义在模块里面，我们需要在模块描述符中明确声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MyEntities &#123;</span><br><span class="line">    <span class="comment">// Open for reflection</span></span><br><span class="line">    opens com.mycorp to java.persistence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为反射机制使用广泛，根据社区讨论，目前，Java 9 仍然保留了兼容 Java 8 的行为，但是很有可能在未来版本，完全启用前面提到的针对 setAccessible 的限制，即只有当被反射操作的模块和指定的包对反射调用者模块 Open，才能使用 setAccessible，我们可以使用下面参数显式设置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--illegal-access</span>=&#123; permit | warn | deny &#125;</span><br></pre></td></tr></table></figure><p>\2. 动态代理</p><p>前面的问题问到了动态代理，我们一起看看，它到底是解决什么问题？</p><p>首先，它是一个<strong>代理机制</strong>。如果熟悉设计模式中的代理模式，我们会知道，代理可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成。其实很多动态代理场景，我认为也可以看作是装饰器（Decorator）模式的应用，我会在后面的专栏设计模式主题予以补充。</p><p>通过代理可以让调用者与实现者之间<strong>解耦</strong>。比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，可以提供更加友善的界面。</p><p>代理的发展经历了静态到动态的过程，源于静态代理引入的额外工作。类似早期的 RMI 之类古董技术，还需要 rmic 之类工具生成静态 stub 等各种文件，增加了很多繁琐的准备工作，而这又和我们的业务逻辑没有关系。利用动态代理机制，相应的 stub 等类，可以在运行时生成，对应的调用操作也是动态完成，极大地提高了我们的生产力。改进后的 RMI 已经不再需要手动去准备这些了，虽然它仍然是相对古老落后的技术，未来也许会逐步被移除。</p><p>这么说可能不够直观，我们可以看 JDK 动态代理的一个简单例子。下面只是加了一句 print，在生产系统中，我们可以轻松扩展类似逻辑进行诊断、限流等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDynamicProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloImpl</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloImpl</span>();</span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(hello);</span><br><span class="line">        <span class="comment">// 构造代码实例</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">proxyHello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(), HelloImpl.class.getInterfaces(), handler);</span><br><span class="line">        <span class="comment">// 调用代理方法</span></span><br><span class="line">        proxyHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span>  <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Invoking sayHello&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面的 JDK Proxy 例子，非常简单地实现了动态代理的构建和代理操作。首先，实现对应的 InvocationHandler；然后，以接口 Hello 为纽带，为被调用目标构建代理对象，进而应用程序就可以使用代理对象间接运行调用目标的逻辑，代理为应用插入额外逻辑（这里是 println）提供了便利的入口。</p><p>从 API 设计和实现的角度，这种实现仍然有局限性，因为它是以接口为中心的，相当于添加了一种对于被调用者没有太大意义的限制。我们实例化的是 Proxy 对象，而不是真正的被调用类型，这在实践中还是可能带来各种不便和能力退化。</p><p>如果被调用者没有实现接口，而我们还是希望利用动态代理机制，那么可以考虑其他方式。我们知道 Spring AOP 支持两种模式的动态代理，JDK Proxy 或者 cglib，如果我们选择 cglib 方式，你会发现对接口的依赖被克服了。</p><p>cglib 动态代理采取的是创建目标类的子类的方式，因为是子类化，我们可以达到近似使用被调用者本身的效果。在 Spring 编程中，框架通常会处理这种情况，当然我们也可以<a href="http://cliffmeyers.com/blog/2006/12/29/spring-aop-cglib-or-jdk-dynamic-proxies.html">显式指定</a>。关于类似方案的实现细节，我就不再详细讨论了。</p><p>那我们在开发中怎样选择呢？我来简单对比下两种方式各自优势。</p><p>JDK Proxy 的优势：</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li><li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单。</li></ul><p>基于类似 cglib 框架的优势：</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。</li><li>只操作我们关心的类，而不必为其他相关类增加工作量。</li><li>高性能。</li></ul><p>另外，从性能角度，我想补充几句。记得有人曾经得出结论说 JDK Proxy 比 cglib 或者 Javassist 慢几十倍。坦白说，不去争论具体的 benchmark 细节，在主流 JDK 版本中，JDK Proxy 在典型场景可以提供对等的性能水平，数量级的差距基本上不是广泛存在的。而且，反射机制性能在现代 JDK 中，自身已经得到了极大的改进和优化，同时，JDK 很多功能也不完全是反射，同样使用了 ASM 进行字节码操作。</p><p>我们在选型中，性能未必是唯一考量，可靠性、可维护性、编程工作量等往往是更主要的考虑因素，毕竟标准类库和反射编程的门槛要低得多，代码量也是更加可控的，如果我们比较下不同开源项目在动态代理开发上的投入，也能看到这一点。</p><p>动态代理应用非常广泛，虽然最初多是因为 RPC 等使用进入我们视线，但是动态代理的使用场景远远不仅如此，它完美符合 Spring AOP 等切面编程。我在后面的专栏还会进一步详细分析 AOP 的目的和能力。简单来说它可以看作是对 OOP 的一个补充，因为 OOP 对于跨越不同对象或类的分散、纠缠逻辑表现力不够，比如在不同模块的特定阶段做一些事情，类似日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等，你可以参考下面这张图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/ba9a5b6228b188f5b9b15017e29a302b.png" alt="img"></p><p>AOP 通过（动态）代理机制可以让开发者从这些繁琐事项中抽身出来，大幅度提高了代码的抽象程度和复用度。从逻辑上来说，我们在软件设计和实现中的类似代理，如 Facade、Observer 等很多设计目的，都可以通过动态代理优雅地实现。</p><p>今天我简要回顾了反射机制，谈了反射在 Java 语言演进中正在发生的变化，并且进一步探讨了动态代理机制和相关的切面编程，分析了其解决的问题，并探讨了生产实践中的选择考量。</p><h2 id="一课一练-5"><a href="#一课一练-5" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，你在工作中哪些场景使用到了动态代理？相应选择了什么实现技术？选择的依据是什么？�-</p><h1 id="第07讲-int和Integer有什么区别？"><a href="#第07讲-int和Integer有什么区别？" class="headerlink" title="第07讲 int和Integer有什么区别？"></a>第07讲 int和Integer有什么区别？</h1><p>Java 虽然号称是面向对象的语言，但是原始数据类型仍然是重要的组成元素，所以在面试中，经常考察原始数据类型和包装类等 Java 语言特性。</p><p>今天我要问你的问题是，int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</p><h2 id="典型回答-6"><a href="#典型回答-6" class="headerlink" title="典型回答"></a>典型回答</h2><p>int 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。<strong>Java 语言虽然号称一切都是对象，但原始数据类型是例外。</strong></p><p>Integer 是 int 对应的包装类，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p><p>关于 Integer 的值缓存，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了静态工厂方法 valueOf，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，<strong>这个值默认缓存是 -128 到 127 之间。</strong></p><h2 id="考点分析-6"><a href="#考点分析-6" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天这个问题涵盖了 Java 里的两个基础要素：原始数据类型、包装类。谈到这里，就可以非常自然地扩展到自动装箱、自动拆箱机制，进而考察封装类的一些设计和实践。坦白说，理解基本原理和用法已经足够日常工作需求了，但是要落实到具体场景，还是有很多问题需要仔细思考才能确定。</p><p>面试官可以结合其他方面，来考察面试者的掌握程度和思考逻辑，比如：</p><ul><li>我在专栏第 1 讲中介绍的 Java 使用的不同阶段：编译阶段、运行时，自动装箱 / 自动拆箱是发生在什么阶段？</li><li>我在前面提到使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？</li><li>为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？</li><li>阅读过 Integer 源码吗？分析下类或某些方法的设计要点。</li></ul><p>似乎有太多内容可以探讨，我们一起来分析一下。</p><h2 id="知识扩展-6"><a href="#知识扩展-6" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>\1. 理解自动装箱、拆箱</p><p>自动装箱实际上算是一种<strong>语法糖</strong>。什么是语法糖？可以简单理解为 Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它们发生在编译阶段，也就是生成的字节码是一致的。</p><p>像前面提到的整数，javac 替我们自动把装箱转换为 Integer.valueOf()，把拆箱替换为 Integer.intValue()，这似乎这也顺道回答了另一个问题，既然调用的是 Integer.valueOf，自然能够得到缓存的好处啊。</p><p>如何程序化的验证上面的结论呢？</p><p>你可以写一段简单的程序包含下面两句代码，然后反编译一下。当然，这是一种从表现倒推的方法，大多数情况下，我们还是直接参考规范文档会更加可靠，毕竟软件承诺的是遵循规范，而不是保持当前行为。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="type">integer</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> unboxing <span class="operator">=</span> <span class="type">integer</span> <span class="operator">+</span><span class="operator">+</span>;</span><br></pre></td></tr></table></figure><p>反编译输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1: invokestatic  <span class="comment">#2                  // Method</span></span><br><span class="line">java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">8: invokevirtual <span class="comment">#3                  // Method</span></span><br><span class="line">java/lang/Integer.intValue:()I</span><br></pre></td></tr></table></figure><p>这种缓存机制并不是只有 Integer 才有，同样存在于其他的一些包装类，比如：</p><ul><li>Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE/FALSE。</li><li>Short，同样是缓存了 -128 到 127 之间的数值。</li><li>Byte，数值有限，所以全部都被缓存。</li><li>Character，缓存范围’\u0000’ 到 ‘\u007F’。</li></ul><p>自动装箱 / 自动拆箱似乎很酷，在编程实践中，有什么需要注意的吗？</p><p>原则上，<strong>建议避免无意中的装箱、拆箱行为</strong>，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</p><p>我们其实可以把这个观点扩展开，使用原始数据类型、数组甚至本地代码实现等，在性能极度敏感的场景往往具有比较大的优势，用其替换掉包装类、动态数组（如 ArrayList）等可以作为性能优化的备选项。一些追求极致性能的产品或者类库，会极力避免创建过多对象。当然，在大多数产品代码里，并没有必要这么做，还是以开发效率优先。以我们经常会使用到的计数器实现为例，下面是一个常见的线程安全计数器实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如果利用原始数据类型，可以将其修改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">CompactCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;CompactCounter&gt; updater = AtomicLongFieldUpdater.<span class="built_in">newUpdater</span>(CompactCounter.<span class="keyword">class</span>, <span class="string">&quot;counter&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updater.<span class="built_in">incrementAndGet</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>\2. 源码分析</p><p>考察是否阅读过、是否理解 JDK 源代码可能是部分面试官的关注点，这并不完全是一种苛刻要求，阅读并实践高质量代码也是程序员成长的必经之路，下面我来分析下 Integer 的源码。</p><p>整体看一下 Integer 的职责，它主要包括各种基础的常量，比如最大值、最小值、位数等；前面提到的各种静态工厂方法 valueOf()；获取环境变量数值的方法；各种转换方法，比如转换为不同进制的字符串，如 8 进制，或者反过来的解析方法等。我们进一步来看一些有意思的地方。</p><p>首先，继续深挖缓存，Integer 的缓存范围虽然默认是 -128 到 127，但是在特别的应用场景，比如我们明确知道应用会频繁使用更大的数值，这时候应该怎么办呢？</p><p>缓存上限值实际是可以根据需要调整的，JVM 提供了参数设置：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:AutoBoxCacheMax=N</span></span><br></pre></td></tr></table></figure><p>这些实现，都体现在<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/lang/Integer.java">java.lang.Integer</a>源码之中，并实现在 IntegerCache 的静态初始化块里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>                VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二，我们在分析字符串的设计实现时，提到过字符串是不可变的，保证了基本的信息安全和并发编程中的线程安全。如果你去看包装类里存储数值的成员变量“value”，你会发现，不管是 Integer 还 Boolean 等，都被声明为“private final”，所以，它们同样是不可变类型！</p><p>这种设计是可以理解的，或者说是必须的选择。想象一下这个应用场景，比如 Integer 提供了 getInteger() 方法，用于方便地读取系统属性，我们可以用属性来设置服务器某个服务的端口，如果我可以轻易地把获取到的 Integer 对象改变为其他数值，这会带来产品可靠性方面的严重问题。</p><p>第三，Integer 等包装类，定义了类似 SIZE 或者 BYTES 这样的常量，这反映了什么样的设计考虑呢？如果你使用过其他语言，比如 C、C++，类似整数的位数，其实是不确定的，可能在不同的平台，比如 32 位或者 64 位平台，存在非常大的不同。那么，在 32 位 JDK 或者 64 位 JDK 里，数据位数会有不同吗？或者说，这个问题可以扩展为，我使用 32 位 JDK 开发编译的程序，运行在 64 位 JDK 上，需要做什么特别的移植工作吗？</p><p>其实，这种移植对于 Java 来说相对要简单些，因为原始数据类型是不存在差异的，这些明确定义在<a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-4.html#jls-4.2">Java 语言规范</a>里面，不管是 32 位还是 64 位环境，开发者无需担心数据的位数差异。</p><p>对于应用移植，虽然存在一些底层实现的差异，比如 64 位 HotSpot JVM 里的对象要比 32 位 HotSpot JVM 大（具体区别取决于不同 JVM 实现的选择），但是总体来说，并没有行为差异，应用移植还是可以做到宣称的“一次书写，到处执行”，应用开发者更多需要考虑的是容量、能力等方面的差异。</p><p>\3. 原始类型线程安全</p><p>前面提到了线程安全设计，你有没有想过，原始数据类型操作是不是线程安全的呢？</p><p>这里可能存在着不同层面的问题：</p><ul><li>原始数据类型的变量，显然要使用并发相关手段，才能保证线程安全，这些我会在专栏后面的并发主题详细介绍。如果有线程安全的计算需要，建议考虑使用类似 AtomicInteger、AtomicLong 这样的线程安全类。</li><li>特别的是，部分比较宽的数据类型，比如 float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值！</li></ul><p>4.Java 原始数据类型和引用类型局限性</p><p>前面我谈了非常多的技术细节，最后再从 Java 平台发展的角度来看看，原始数据类型、对象的局限性和演进。</p><p>对于 Java 应用开发者，设计复杂而灵活的类型系统似乎已经习以为常了。但是坦白说，毕竟这种类型系统的设计是源于很多年前的技术决定，现在已经逐渐暴露出了一些副作用，例如：</p><ul><li>原始数据类型和 Java 泛型并不能配合使用</li></ul><p>这是因为 Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为 Object。</p><ul><li>无法高效地表达数据，也不便于表达复杂的数据结构，比如 vector 和 tuple</li></ul><p>我们知道 Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</p><p>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。</p><p>针对这些方面的增强，目前正在 OpenJDK 领域紧锣密鼓地进行开发，有兴趣的话你可以关注相关工程：<a href="https://openjdk.java.net/projects/valhalla/">http://openjdk.java.net/projects/valhalla/</a> 。</p><p>今天，我梳理了原始数据类型及其包装类，从源码级别分析了缓存机制等设计和实现细节，并且针对构建极致性能的场景，分析了一些可以借鉴的实践。</p><h2 id="一课一练-6"><a href="#一课一练-6" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，前面提到了从空间角度，Java 对象要比原始数据类型开销大的多。你知道对象的内存结构是什么样的吗？比如，对象头的结构。如何计算或者获取某个 Java 对象的大小?</p><h1 id="第08讲-对比Vector、ArrayList、LinkedList有何区别？"><a href="#第08讲-对比Vector、ArrayList、LinkedList有何区别？" class="headerlink" title="第08讲 对比Vector、ArrayList、LinkedList有何区别？"></a>第08讲 对比Vector、ArrayList、LinkedList有何区别？</h1><p>我们在日常的工作中，能够高效地管理和操作数据是非常重要的。由于每个编程语言支持的数据结构不尽相同，比如我最早学习的 C 语言，需要自己实现很多基础数据结构，管理和操作会比较麻烦。相比之下，Java 则要方便的多，针对通用场景的需求，Java 提供了强大的集合框架，大大提高了开发者的生产力。</p><p>今天我要问你的是有关集合框架方面的问题，对比 Vector、ArrayList、LinkedList 有何区别？</p><h2 id="典型回答-7"><a href="#典型回答-7" class="headerlink" title="典型回答"></a>典型回答</h2><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><p>Vector 是 Java 早期提供的<strong>线程安全的动态数组</strong>，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p><p>ArrayList 是应用更加广泛的<strong>动态数组</strong>实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p><p>LinkedList 顾名思义是 Java 提供的<strong>双向链表</strong>，所以它不需要像上面两种那样调整容量，它也不是线程安全的。</p><h2 id="考点分析-7"><a href="#考点分析-7" class="headerlink" title="考点分析"></a>考点分析</h2><p>似乎从我接触 Java 开始，这个问题就一直是经典的面试题，前面我的回答覆盖了三者的一些基本的设计和实现。</p><p>一般来说，也可以补充一下不同容器类型适合的场景：</p><ul><li>Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。</li><li>而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。</li></ul><p>所以，在应用开发中，如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。这也是面试最常见的一个考察角度，给定一个场景，选择适合的数据结构，所以对于这种典型选择一定要掌握清楚。</p><p>考察 Java 集合框架，我觉得有很多方面需要掌握：</p><ul><li>Java 集合框架的设计结构，至少要有一个整体印象。</li><li>Java 提供的主要容器（集合和 Map）类型，了解或掌握对应的<strong>数据结构、算法</strong>，思考具体技术选择。</li><li>将问题扩展到性能、并发等领域。</li><li>集合框架的演进与发展。</li></ul><p>作为 Java 专栏，我会在尽量围绕 Java 相关进行扩展，否则光是罗列集合部分涉及的数据结构就要占用很大篇幅。这并不代表那些不重要，数据结构和算法是基本功，往往也是必考的点，有些公司甚至以考察这些方面而非常知名（甚至是“臭名昭著”）。我这里以需要掌握典型排序算法为例，你至少需要熟知：</p><ul><li>内部排序，至少掌握基础算法如归并排序、交换排序（冒泡、快排）、选择排序、插入排序等。</li><li>外部排序，掌握利用内存和外部存储处理超大数据集，至少要理解过程和思路。</li></ul><p>考察算法不仅仅是如何简单实现，面试官往往会刨根问底，比如哪些是排序是不稳定的呢（快排、堆排），或者思考稳定意味着什么；对不同数据集，各种排序的最好或最差情况；从某个角度如何进一步优化（比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并优异）等，从简单的了解，到进一步的思考，面试官通常还会观察面试者处理问题和沟通时的思路。</p><p>以上只是一个方面的例子，建议学习相关书籍，如《算法导论》《编程珠玑》等，或相关<a href="https://www.coursera.org/learn/algorithms-part1">教程</a>。对于特定领域，比如推荐系统，建议咨询领域专家。单纯从面试的角度，很多朋友推荐使用一些算法网站如 LeetCode 等，帮助复习和准备面试，但坦白说我并没有刷过这些算法题，这也是仁者见仁智者见智的事情，招聘时我更倾向于考察面试者自身最擅长的东西，免得招到纯面试高手。</p><h2 id="知识扩展-7"><a href="#知识扩展-7" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我们先一起来理解集合框架的整体设计，为了有个直观的印象，我画了一个简要的类图。注意，为了避免混淆，我这里没有把 java.util.concurrent 下面的线程安全容器添加进来；也没有列出 Map 容器，虽然通常概念上我们也会把 Map 作为集合框架的一部分，但是它本身并不是真正的集合（Collection）。</p><p>所以，我今天主要围绕狭义的集合框架，其他都会在专栏后面的内容进行讲解。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/675536edf1563b11ab7ead0def1215c7.png" alt="img"></p><p>我们可以看到 Java 的集合框架，Collection 接口是所有集合的根，然后扩展开提供了三大类集合，分别是：</p><ul><li>List，也就是我们前面介绍最多的有序集合，它提供了方便的访问、插入、删除等操作。</li><li>Set，Set 是不允许重复元素的，这是和 List 最明显的区别，也就是不存在两个对象 equals 返回 true。我们在日常开发中有很多需要保证元素唯一性的场合。</li><li>Queue/Deque，则是 Java 提供的标准队列结构的实现，除了集合的基本功能，它还支持类似先入先出（FIFO， First-in-First-Out）或者后入先出（LIFO，Last-In-First-Out）等特定行为。这里不包括 BlockingQueue，因为通常是并发编程场合，所以被放置在并发包里。</li></ul><p>每种集合的通用逻辑，都被抽象到相应的抽象类之中，比如 AbstractList 就集中了各种 List 操作的通用部分。这些集合不是完全孤立的，比如，LinkedList 本身，既是 List，也是 Deque 哦。</p><p>如果阅读过更多<a href="http://hg.openjdk.java.net/jdk/jdk/file/bf9177eac58d/src/java.base/share/classes/java/util/TreeSet.java">源码</a>，你会发现，其实，TreeSet 代码里实际默认是利用 TreeMap 实现的，Java 类库创建了一个 Dummy 对象“PRESENT”作为 value，然后所有插入的元素其实是以键的形式放入了 TreeMap 里面；同理，HashSet 其实也是以 HashMap 为基础实现的，原来他们只是 Map 类的马甲！</p><p>就像前面提到过的，我们需要对各种具体集合实现，至少了解基本特征和典型使用场景，以 Set 的几个实现为例：</p><ul><li>TreeSet 支持自然顺序访问，但是添加、删除、包含等操作要相对低效（log(n) 时间）。</li><li>HashSet 则是利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添加、删除、包含等操作，但是它不保证有序。</li><li>LinkedHashSet，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作性能略低于 HashSet，因为需要维护链表的开销。</li><li>在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要将其背后的 HashMap 容量设置过大。而对于 LinkedHashSet，由于其内部链表提供的方便，遍历性能只和元素多少有关系。</li></ul><p>我今天介绍的这些集合类，都不是线程安全的，对于 java.util.concurrent 里面的线程安全容器，我在专栏后面会去介绍。但是，并不代表这些集合完全不能支持并发编程的场景，在 Collections 工具类中，提供了一系列的 synchronized 方法，比如</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static <span class="tag">&lt;<span class="name">T</span>&gt;</span> List<span class="tag">&lt;<span class="name">T</span>&gt;</span> synchronizedList(List<span class="tag">&lt;<span class="name">T</span>&gt;</span> list)</span><br></pre></td></tr></table></figure><p>我们完全可以利用类似方法来实现基本的线程安全集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br></pre></td></tr></table></figure><p>它的实现，基本就是将每个基本方法，比如 get、set、add 之类，都通过 synchronizd 添加基本的同步支持，非常简单粗暴，但也非常实用。注意这些方法创建的线程安全集合，都符合迭代时 fail-fast 行为，当发生意外的并发修改时，尽早抛出 ConcurrentModificationException 异常，以避免不可预计的行为。</p><p>另外一个经常会被考察到的问题，就是理解 Java 提供的默认排序算法，具体是什么排序方式以及设计思路等。</p><p>这个问题本身就是有点陷阱的意味，因为需要区分是 Arrays.sort() 还是 Collections.sort() （底层是调用 Arrays.sort()）；什么数据类型；多大的数据集（太小的数据集，复杂排序是没必要的，Java 会直接进行二分插入排序）等。</p><ul><li>对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序，你可以阅读<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/DualPivotQuicksort.java">源码</a>。</li><li>而对于对象数据类型，目前则是使用<a href="http://hg.openjdk.java.net/jdk/jdk/file/26ac622a4cab/src/java.base/share/classes/java/util/TimSort.java">TimSort</a>，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。</li></ul><p>另外，Java 8 引入了并行排序算法（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架（专栏后面会对 fork-join 进行相对详细的介绍），当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。</p><p>排序算法仍然在不断改进，最近双轴快速排序实现的作者提交了一个更进一步的改进，历时多年的研究，目前正在审核和验证阶段。根据作者的性能测试对比，相比于基于归并排序的实现，新改进可以提高随机数据排序速度提高 10%～20%，甚至在其他特征的数据集上也有几倍的提高，有兴趣的话你可以参考具体代码和介绍： <a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html">http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051000.html</a> 。</p><p>在 Java 8 之中，Java 平台支持了 Lambda 和 Stream，相应的 Java 集合框架也进行了大范围的增强，以支持类似为集合创建相应 stream 或者 parallelStream 的方法实现，我们可以非常方便的实现函数式代码。</p><p>阅读 Java 源代码，你会发现，这些 API 的设计和实现比较独特，它们并不是实现在抽象类里面，而是以<strong>默认方法</strong>的形式实现在 Collection 这样的接口里！这是 Java 8 在语言层面的新特性，允许接口实现默认方法，理论上来说，我们原来实现在类似 Collections 这种工具类中的方法，大多可以转换到相应的接口上。针对这一点，我在面向对象主题，会专门梳理 Java 语言面向对象基本机制的演进。</p><p>在 Java 9 中，Java 标准类库提供了一系列的静态工厂方法，比如，List.of()、Set.of()，大大简化了构建小的容器实例的代码量。根据业界实践经验，我们发现相当一部分集合实例都是容量非常有限的，而且在生命周期中并不会进行修改。但是，在原有的 Java 类库中，我们可能不得不写成：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.<span class="keyword">add</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.<span class="keyword">add</span>(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure><p>而利用新的容器静态工厂方法，一句代码就够了，并且保证了不可变性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; simpleList = <span class="title class_">List</span>.<span class="title function_">of</span>(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>更进一步，通过各种 of 静态工厂方法创建的实例，还应用了一些我们所谓的最佳实践，比如，它是不可变的，符合我们对线程安全的需求；它因为不需要考虑扩容，所以空间上更加紧凑等。</p><p>如果我们去看 of 方法的源码，你还会发现一个特别有意思的地方：我们知道 Java 已经支持所谓的可变参数（varargs），但是官方类库还是提供了一系列特定参数长度的方法，看起来似乎非常不优雅，为什么呢？这其实是为了最优的性能，JVM 在处理变长参数的时候会有明显的额外开销，如果你需要实现性能敏感的 API，也可以进行参考。</p><p>今天我从 Verctor、ArrayList、LinkedList 开始，逐步分析其设计实现区别、适合的应用场景等，并进一步对集合框架进行了简单的归纳，介绍了集合框架从基础算法到 API 设计实现的各种改进，希望能对你的日常开发和 API 设计能够有帮助。</p><h2 id="一课一练-7"><a href="#一课一练-7" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，先思考一个应用场景，比如你需要实现一个云计算任务调度系统，希望可以保证 VIP 客户的任务被优先处理，你可以利用哪些数据结构或者标准的集合类型呢？更进一步讲，类似场景大多是基于什么数据结构呢？</p><h1 id="第09讲-对比Hashtable、HashMap、TreeMap有什么不同？"><a href="#第09讲-对比Hashtable、HashMap、TreeMap有什么不同？" class="headerlink" title="第09讲 对比Hashtable、HashMap、TreeMap有什么不同？"></a>第09讲 对比Hashtable、HashMap、TreeMap有什么不同？</h1><p>Map 是广义 Java 集合框架中的另外一部分，HashMap 作为框架中使用频率最高的类型之一，它本身以及相关类型自然也是面试考察的热点。</p><p>今天我要问你的问题是，对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。</p><h2 id="典型回答-8"><a href="#典型回答-8" class="headerlink" title="典型回答"></a>典型回答</h2><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以<strong>键值对</strong>的形式存储和操作数据的容器类型。</p><p>Hashtable 是早期 Java 类库提供的一个<a href="https://zh.wikipedia.org/wiki/哈希表">哈希表</a>实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p><p>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以<strong>它是绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p><p>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p><h2 id="考点分析-8"><a href="#考点分析-8" class="headerlink" title="考点分析"></a>考点分析</h2><p>上面的回答，只是对一些基本特征的简单总结，针对 Map 相关可以扩展的问题很多，从各种数据结构、典型应用场景，到程序设计实现的技术考量，尤其是在 Java 8 里，HashMap 本身发生了非常大的变化，这些都是经常考察的方面。</p><p>很多朋友向我反馈，面试官似乎钟爱考察 HashMap 的设计和实现细节，所以今天我会增加相应的源码解读，主要专注于下面几个方面：</p><ul><li>理解 Map 相关类似整体结构，尤其是有序数据结构的一些要点。</li><li>从源码去分析 HashMap 的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响 Map 的性能，实践中如何取舍等。</li><li>理解树化改造的相关原理和改进原因。</li></ul><p>除了典型的代码分析，还有一些有意思的并发相关问题也经常会被提到，如 HashMap 在并发环境可能出现<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6423457">无限循环占用 CPU</a>、size 不准确等诡异的问题。</p><p>我认为这是一种典型的使用错误，因为 HashMap 明确声明不是线程安全的数据结构，如果忽略这一点，简单用在多线程场景里，难免会出现问题。</p><p>理解导致这种错误的原因，也是深入理解并发程序运行的好办法。对于具体发生了什么，你可以参考这篇很久以前的<a href="https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html">分析</a>，里面甚至提供了示意图，我就不再重复别人写好的内容了。</p><h2 id="知识扩展-8"><a href="#知识扩展-8" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>1.Map 整体结构</p><p>首先，我们先对 Map 相关类型有个整体了解，Map 虽然通常被包括在 Java 集合框架里，但是其本身并不是狭义上的集合类型（Collection），具体你可以参考下面这个简单类图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/266cfaab2573c9777b1157816784727c.png" alt="img"></p><p>Hashtable 比较特别，作为类似 Vector、Stack 的早期集合相关类型，它是扩展了 Dictionary 类的，类结构上与 HashMap 之类明显不同。</p><p>HashMap 等其他 Map 实现则是都扩展了 AbstractMap，里面包含了通用方法抽象。不同 Map 的用途，从类图结构就能体现出来，设计目的已经体现在不同接口上。</p><p>大部分使用 Map 的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。<strong>HashMap 的性能表现非常依赖于哈希码的有效性，请务必掌握 hashCode 和 equals 的一些基本约定</strong>，比如：</p><ul><li>equals 相等，hashCode 一定要相等。</li><li>重写了 hashCode 也要重写 equals。</li><li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li><li>equals 的对称、反射、传递等特性。</li></ul><p>这方面内容网上有很多资料，我就不在这里详细展开了。</p><p>针对有序 Map 的分析内容比较有限，我再补充一些，虽然 LinkedHashMap 和 TreeMap 都可以保证某种顺序，但二者还是非常不同的。</p><ul><li>LinkedHashMap 通常提供的是遍历顺序符合插入顺序，它的实现是通过为条目（键值对）维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的 put、get、compute 等，都算作“访问”。</li></ul><p>这种行为适用于一些特定应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常被访问的对象释放掉，这就可以利用 LinkedHashMap 提供的机制来实现，参考下面的示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">LinkedHashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">Map</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">LinkedHashMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt; accessOrderedMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt;(<span class="number">16</span>, <span class="number">0.</span>75F, <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="built_in">boolean</span> <span class="title function_">removeEldestEntry</span>(<span class="params"><span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; eldest</span>) &#123; <span class="comment">// 实现自定义删除策略，否则行为就和普遍 Map 没有区别</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">size</span>() &gt; <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        accessOrderedMap.<span class="title function_">put</span>(<span class="string">&quot;Project1&quot;</span>, <span class="string">&quot;Valhalla&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">put</span>(<span class="string">&quot;Project2&quot;</span>, <span class="string">&quot;Panama&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">put</span>(<span class="string">&quot;Project3&quot;</span>, <span class="string">&quot;Loom&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">forEach</span>( (k,v) -&gt; &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(k +<span class="string">&quot;:&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 模拟访问</span></span><br><span class="line">        accessOrderedMap.<span class="title function_">get</span>(<span class="string">&quot;Project2&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">get</span>(<span class="string">&quot;Project2&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">get</span>(<span class="string">&quot;Project3&quot;</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Iterate over should be not affected:&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">forEach</span>( (k,v) -&gt; &#123;</span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(k +<span class="string">&quot;:&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 触发删除</span></span><br><span class="line">        accessOrderedMap.<span class="title function_">put</span>(<span class="string">&quot;Project4&quot;</span>, <span class="string">&quot;Mission Control&quot;</span>);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;Oldest entry should be removed:&quot;</span>);</span><br><span class="line">        accessOrderedMap.<span class="title function_">forEach</span>( (k,v) -&gt; &#123;<span class="comment">// 遍历顺序不变</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(k +<span class="string">&quot;:&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>对于 TreeMap，它的整体顺序是由键的顺序关系决定的，通过 Comparator 或 Comparable（自然顺序）来决定。</li></ul><p>我在上一讲留给你的思考题提到了，构建一个具有优先级的调度系统的问题，其本质就是个典型的优先队列场景，Java 标准库提供了基于二叉堆实现的 PriorityQueue，它们都是依赖于同一种排序机制，当然也包括 TreeMap 的马甲 TreeSet。</p><p>类似 hashCode 和 equals 的约定，为了避免模棱两可的情况，自然顺序同样需要符合一个约定，就是 compareTo 的返回值需要和 equals 一致，否则就会出现模棱两可情况。</p><p>我们可以分析 TreeMap 的 put 方法实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span>(<span class="params">K key, V value</span>) &#123;</span><br><span class="line">    <span class="title class_">Entry</span>&lt;K,V&gt; t = …</span><br><span class="line">    cmp = k.<span class="title function_">compareTo</span>(t.<span class="property">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.<span class="property">right</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.<span class="title function_">setValue</span>(value);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从代码里，你可以看出什么呢？ 当我不遵守约定时，两个不符合唯一性（equals）要求的对象被当作是同一个（因为，compareTo 返回 0），这会导致歧义的行为表现。</p><p>2.HashMap 源码分析</p><p>前面提到，HashMap 设计与实现是个非常高频的面试题，所以我会在这进行相对详细的源码解读，主要围绕：</p><ul><li>HashMap 内部实现基本点分析。</li><li>容量（capacity）和负载系数（load factor）。</li><li>树化 。</li></ul><p>首先，我们来一起看看 HashMap 内部的结构，它可以看作是数组（Node<K,V>[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，你可以参考下面的示意图。这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），图中的链表就会被改造为树形结构。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/1f72306a9d8719c66790b56ef7977c56.png" alt="img"></p><p>从非拷贝构造函数的实现来看，这个表格（数组）似乎并没有在最初就初始化好，仅仅设置了一些初始值而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = <span class="built_in">tableSizeFor</span>(initialCapacity);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所以，我们深刻怀疑，HashMap 也许是按照 lazy-load 原则，在首次使用时被初始化（拷贝构造函数除外，我这里仅介绍最通用的场景）。既然如此，我们去看看 put 方法实现，似乎只有一个 putVal 的调用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span>(<span class="params">K key, V value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">putVal</span>(<span class="title function_">hash</span>(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来主要的密码似乎藏在 putVal 里面，到底有什么秘密呢？为了节省空间，我这里只截取了 putVal 比较关键的几部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evit)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> , i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) = <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span><br><span class="line">        tab[i] = newNode(hash, key, value, nll);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for first </span></span><br><span class="line">           treeifyBin(tab, hash);</span><br><span class="line">        <span class="comment">//  ... </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从 putVal 方法最初的几行，我们就可以发现几个有意思的地方：</p><ul><li>如果表格是 null，resize 方法会负责初始化它，这从 tab = resize() 可以看出。</li><li>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</li><li>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">    <span class="attribute">resize</span>();</span><br></pre></td></tr></table></figure><ul><li>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i</span> = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>仔细观察哈希值的源头，我们会发现，它并不是 key 本身的 hashCode，而是来自于 HashMap 内部的另外一个 hash 方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢？<strong>这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object kye)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我前面提到的链表结构（这里叫 bin），会在达到一定门限值时，发生树化，我稍后会分析为什么 HashMap 需要对 bin 进行处理。</li></ul><p>可以看到，putVal 方法本身逻辑非常集中，从初始化、扩容到树化，全部都和它有关，推荐你阅读源码的时候，可以参考上面的主要逻辑。</p><p>我进一步分析一下身兼多职的 resize 方法，很多朋友都反馈经常被面试官追问它的源码设计。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">final Node&lt;K,V&gt;[] <span class="title">resize</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACIY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)</span><br><span class="line">        newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double there</span></span><br><span class="line">       <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// zero initial threshold signifies using defaultsfults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPAITY;</span><br><span class="line">        newThr = (<span class="built_in">int</span>)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr ==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">float</span> ft = (<span class="built_in">float</span>)newCap * loadFator;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="built_in">float</span>)MAXIMUM_CAPACITY ?(<span class="built_in">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = neThr;</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newap];</span><br><span class="line">    table = n；</span><br><span class="line">    <span class="comment">// 移动到新的数组结构 e 数组结构 </span></span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><p>依据 resize 源码，不考虑极端情况（容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 1&lt;&lt;30，也就是 2 的 30 次方），我们可以归纳为：</p><ul><li>门限值等于（负载因子）x（容量），如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li><li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），我前面提到，根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><p>\3. 容量、负载因子和树化</p><p>前面我们快速梳理了一下 HashMap 从创建到放入键值对的相关逻辑，现在思考一下，为什么我们需要在乎容量和负载因子呢？</p><p>这是因为容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。</p><p>既然容量和负载因子这么重要，我们在实践中应该如何选择呢？</p><p>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。具体数值我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合计算条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">负载因子 * 容量 &gt; 元素数量 </span><br></pre></td></tr></table></figure><p>所以，预先设置的容量需要满足，大于“预估元素数量 / 负载因子”，同时它是 2 的幂数，结论已经非常清晰了。</p><p>而对于负载因子，我建议：</p><ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul><p>我们前面提到了树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 树化改造逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面是精简过的 treeifyBin 示意，综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当 bin 的数量大于 TREEIFY_THRESHOLD 时：</p><ul><li>如果容量小于 MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</li><li>如果容量大于 MIN_TREEIFY_CAPACITY ，则会进行树化改造。</li></ul><p>那么，为什么 HashMap 要树化呢？</p><p><strong>本质上这是个安全问题。</strong>因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。</p><p>而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端 CPU 大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p><p>今天我从 Map 相关的几种实现对比，对各种 Map 进行了分析，讲解了有序集合类型容易混淆的地方，并从源码级别分析了 HashMap 的基本结构，希望对你有所帮助。</p><h2 id="一课一练-8"><a href="#一课一练-8" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，解决哈希冲突有哪些典型方法呢？</p><h1 id="第10讲-如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？"><a href="#第10讲-如何保证集合是线程安全的-ConcurrentHashMap如何实现高效地线程安全？" class="headerlink" title="第10讲 如何保证集合是线程安全的 ConcurrentHashMap如何实现高效地线程安全？"></a>第10讲 如何保证集合是线程安全的 ConcurrentHashMap如何实现高效地线程安全？</h1><p>我在之前两讲介绍了 Java 集合框架的典型容器类，它们绝大部分都不是线程安全的，仅有的线程安全实现，比如 Vector、Stack，在性能方面也远不尽如人意。幸好 Java 语言提供了并发包（java.util.concurrent），为高度并发需求提供了更加全面的工具支持。</p><p>今天我要问你的问题是，如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</p><h2 id="典型回答-9"><a href="#典型回答-9" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 Hashtable 等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</p><p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p><ul><li>各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList。</li><li>各种线程安全队列（Queue/Deque），如 ArrayBlockingQueue、SynchronousQueue。</li><li>各种有序容器的线程安全版本等。</li></ul><p>具体保证线程安全的方式，包括有从简单的 synchronize 方式，到基于更加精细化的，比如基于分离锁实现的 ConcurrentHashMap 等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p><h2 id="考点分析-9"><a href="#考点分析-9" class="headerlink" title="考点分析"></a>考点分析</h2><p>谈到线程安全和并发，可以说是 Java 面试中必考的考点，我上面给出的回答是一个相对宽泛的总结，而且 ConcurrentHashMap 等并发容器实现也在不断演进，不能一概而论。</p><p>如果要深入思考并回答这个问题及其扩展方面，至少需要：</p><ul><li>理解基本的线程安全工具。</li><li>理解传统集合框架并发编程中 Map 存在的问题，清楚简单同步方式的不足。</li><li>梳理并发包内，尤其是 ConcurrentHashMap 采取了哪些方法来提高并发表现。</li><li>最好能够掌握 ConcurrentHashMap 自身的演进，目前的很多分析资料还是基于其早期版本。</li></ul><p>今天我主要是延续专栏之前两讲的内容，重点解读经常被同时考察的 HashMap 和 ConcurrentHashMap。今天这一讲并不是对并发方面的全面梳理，毕竟这也不是专栏一讲可以介绍完整的，算是个开胃菜吧，类似 CAS 等更加底层的机制，后面会在 Java 进阶模块中的并发主题有更加系统的介绍。</p><h2 id="知识扩展-9"><a href="#知识扩展-9" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol><li>为什么需要 ConcurrentHashMap？</li></ol><p>Hashtable 本身比较低效，因为它的实现基本就是将 put、get、size 等各种方法加上“synchronized”。简单来说，这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。</p><p>前面已经提过 HashMap 不是线程安全的，并发情况会导致类似 CPU 占用 100% 等一些问题，那么能不能利用 Collections 提供的同步包装器来解决问题呢？</p><p>看看下面的代码片段，我们发现同步包装器只是利用输入 Map 构造了另一个同步版本，所有操作虽然不再声明成为 synchronized 方法，但是还是利用了“this”作为互斥的 mutex，没有真正意义上的改进！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMap</span>&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">    <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">size</span>();&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// … </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所以，Hashtable 或者同步包装版本，都只是适合在非高度并发的场景下。</p><p>2.ConcurrentHashMap 分析</p><p>我们再来看看 ConcurrentHashMap 是如何设计实现的，为什么它能大大提高并发效率。</p><p>首先，我这里强调，<strong>ConcurrentHashMap 的设计实现其实一直在演化</strong>，比如在 Java 8 中就发生了非常大的变化（Java 7 其实也有不少更新），所以，我这里将比较分析结构、实现机制等方面，对比不同版本的主要区别。</p><p>早期 ConcurrentHashMap，其实现是基于：</p><ul><li>分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。</li><li>HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。</li></ul><p>你可以参考下面这个早期 ConcurrentHashMap 内部结构的示意图，其核心是利用分段设计，在进行并发操作的时候，只需要锁定相应段，这样就有效避免了类似 Hashtable 整体同步的问题，大大提高了性能。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/d45bcf9a34da2ef1ef335532b0198bd9.png" alt="img"></p><p>在构造的时候，Segment 的数量由所谓的 concurrentcyLevel 决定，默认是 16，也可以在相应构造函数直接指定。注意，Java 需要它是 2 的幂数值，如果输入是类似 15 这种非幂值，会被自动调整到 16 之类 2 的幂数值。</p><p>具体情况，我们一起看看一些 Map 基本操作的<a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/concurrent/ConcurrentHashMap.java">源码</a>，这是 JDK 7 比较新的 get 代码。针对具体的优化部分，为方便理解，我直接注释在代码段里，get 操作需要保证的是可见性，所以并没有什么同步逻辑。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span>(<span class="params">Object key</span>)</span> &#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="built_in">int</span> h = hash(key.hashCode());</span><br><span class="line">       <span class="comment">// 利用位操作替换普通数学运算</span></span><br><span class="line">       <span class="built_in">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="comment">// 以 Segment 为单位，进行定位</span></span><br><span class="line">        <span class="comment">// 利用 Unsafe 直接进行 volatile access</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 省略</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而对于 put 操作，首先是通过二次哈希避免哈希冲突，然后以 Unsafe 调用方式，直接获取相应的 Segment，然后进行线程安全的 put 操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">       Segment&lt;K,V&gt; s;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">// 二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">       <span class="built_in">int</span> hash = hash(key.hashCode());</span><br><span class="line">       <span class="built_in">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">       <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">           s = ensureSegment(j);</span><br><span class="line">       <span class="keyword">return</span> s.put(key, hash, <span class="keyword">value</span>, <span class="literal">false</span>);</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><p>其核心逻辑实现在下面的内部方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">            <span class="comment">// scanAndLockForPut 会去查找是否有 key 相同 Node</span></span><br><span class="line">            <span class="comment">// 无论如何，确保获取锁</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">// 更新已有 value...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 放置 HashEntry 到特定位置，如果超过阈值，进行 rehash</span></span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><p>所以，从上面的源码清晰的看出，在进行并发写操作时：</p><ul><li>ConcurrentHashMap 会获取再入锁，以保证数据一致性，Segment 本身就是基于 ReentrantLock 的扩展实现，所以，在并发修改期间，相应 Segment 是被锁定的。</li><li>在最初阶段，进行重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作，你可以在代码里看到相应的注释。重复扫描、检测冲突是 ConcurrentHashMap 的常见技巧。</li><li>我在专栏上一讲介绍 HashMap 时，提到了可能发生的扩容问题，在 ConcurrentHashMap 中同样存在。不过有一个明显区别，就是它进行的不是整体的扩容，而是单独对 Segment 进行扩容，细节就不介绍了。</li></ul><p>另外一个 Map 的 size 方法同样需要关注，它的实现涉及分离锁的一个副作用。</p><p>试想，如果不进行同步，简单的计算所有 Segment 的总值，可能会因为并发 put，导致结果不准确，但是直接锁定所有 Segment 进行计算，就会变得非常昂贵。其实，分离锁也限制了 Map 的初始化等操作。</p><p>所以，ConcurrentHashMap 的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数 2），来试图获得可靠值。如果没有监控到发生变化（通过对比 Segment.modCount），就直接返回，否则获取锁进行操作。</p><p>下面我来对比一下，<strong>在 Java 8 和之后的版本中，ConcurrentHashMap 发生了哪些变化呢？</strong></p><ul><li>总体结构上，它的内部存储变得和我在专栏上一讲介绍的 HashMap 结构非常相似，同样是大的桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。</li><li>其内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。</li><li>因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销，解决了老版本很多人抱怨的这一点。</li><li>数据存储利用 volatile 来保证可见性。</li><li>使用 CAS 等操作，在特定场景进行无锁并发操作。</li><li>使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li></ul><p>先看看现在的数据存储内部实现，我们可以发现 Key 是 final 的，因为在生命周期中，一个条目的 Key 发生变化是不可能的；与此同时 val，则声明为 volatile，以保证可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       <span class="keyword">volatile</span> V val;</span><br><span class="line">       <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">       <span class="comment">// … </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我这里就不再介绍 get 方法和构造函数了，相对比较简单，直接看并发的 put 是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123; <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 利用 CAS 去进行无锁线程安全操作，如果 bin 是空的</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// 不加锁，进行检查</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="comment">// 细粒度的同步修改操作... </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Bin 超过阈值，进行树化</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>初始化操作实现在 initTable 里面，这是一个典型的 CAS 使用场景，利用 volatile 的 sizeCtl 作为互斥手段：如果发现竞争性的初始化，就 spin 在那里，等待条件恢复；否则利用 CAS 设置排他标志。如果成功则进行初始化；否则重试。</p><p>请参考下面代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> final Node&lt;K,V&gt;[] <span class="title">initTable</span>()</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="built_in">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果发现冲突，进行 spin 等待</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        <span class="comment">// CAS 成功返回 true，则进入真正的初始化逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, <span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当 bin 为空时，同样是没有必要锁定，也是以 CAS 操作去放置。</p><p>你有没有注意到，在同步逻辑上，它使用的是 synchronized，而不是通常建议的 ReentrantLock 之类，这是为什么呢？现代 JDK 中，synchronized 已经被不断优化，可以不再过分担心性能差异，另外，相比于 ReentrantLock，它可以减少内存消耗，这是个非常大的优势。</p><p>与此同时，更多细节实现通过使用 Unsafe 进行了优化，例如 tabAt 就是直接利用 getObjectAcquire，避免间接调用的开销。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.<span class="built_in">getObjectAcquire</span>(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>再看看，现在是如何实现 size 操作的。<a href="http://hg.openjdk.java.net/jdk/jdk/file/12fc7bf488ec/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java">阅读代码</a>你会发现，真正的逻辑是在 sumCount 方法中， 那么 sumCount 做了什么呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">final <span class="built_in">long</span> <span class="title">sumCount</span>()</span> &#123;</span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="built_in">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们发现，虽然思路仍然和以前类似，都是分而治之的进行计数，然后求和处理，但实现却基于一个奇怪的 CounterCell。 难道它的数值，就更加准确吗？数据一致性是怎么保证的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="built_in">CounterCell</span>(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，对于 CounterCell 的操作，是基于 java.util.concurrent.atomic.LongAdder 进行的，是一种 JVM 利用空间换取更高效率的方法，利用了<a href="http://hg.openjdk.java.net/jdk/jdk/file/12fc7bf488ec/src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java">Striped64</a>内部的复杂逻辑。这个东西非常小众，大多数情况下，建议还是使用 AtomicLong，足以满足绝大部分应用的性能需求。</p><p>今天我从线程安全问题开始，概念性的总结了基本容器工具，分析了早期同步容器的问题，进而分析了 Java 7 和 Java 8 中 ConcurrentHashMap 是如何设计实现的，希望 ConcurrentHashMap 的并发技巧对你在日常开发可以有所帮助。</p><h2 id="一课一练-9"><a href="#一课一练-9" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一个道思考题给你，在产品代码中，有没有典型的场景需要使用类似 ConcurrentHashMap 这样的并发容器呢？</p><h1 id="第11讲-Java提供了哪些IO方式？-NIO如何实现多路复用？"><a href="#第11讲-Java提供了哪些IO方式？-NIO如何实现多路复用？" class="headerlink" title="第11讲 Java提供了哪些IO方式？ NIO如何实现多路复用？"></a>第11讲 Java提供了哪些IO方式？ NIO如何实现多路复用？</h1><p>IO 一直是软件开发中的核心部分之一，伴随着海量数据增长和分布式系统的发展，IO 扩展能力愈发重要。幸运的是，Java 平台 IO 机制经过不断完善，虽然在某些方面仍有不足，但已经在实践中证明了其构建高扩展性应用的能力。</p><p>今天我要问你的问题是，Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</p><h2 id="典型回答-10"><a href="#典型回答-10" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p><p>首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p><p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p><p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p><p>第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p><p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p><h2 id="考点分析-10"><a href="#考点分析-10" class="headerlink" title="考点分析"></a>考点分析</h2><p>我上面列出的回答是基于一种常见分类方式，即所谓的 BIO、NIO、NIO 2（AIO）。</p><p>在实际面试中，从传统 IO 到 NIO、NIO 2，其中有很多地方可以扩展开来，考察点涉及方方面面，比如：</p><ul><li>基础 API 功能与设计， InputStream/OutputStream 和 Reader/Writer 的关系和区别。</li><li>NIO、NIO 2 的基本组成。</li><li>给定场景，分别用不同模型实现，分析 BIO、NIO 等模式的设计和实现原理。</li><li>NIO 提供的高性能数据操作方式是基于什么原理，如何使用？</li><li>或者，从开发者的角度来看，你觉得 NIO 自身实现存在哪些问题？有什么改进的想法吗？</li></ul><p>IO 的内容比较多，专栏一讲很难能够说清楚。IO 不仅仅是多路复用，NIO 2 也不仅仅是异步 IO，尤其是数据操作部分，会在专栏下一讲详细分析。</p><h2 id="知识扩展-10"><a href="#知识扩展-10" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，需要澄清一些基本概念：</p><ul><li>区分同步或异步（synchronous/asynchronous）。简单来说，同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li><li>区分阻塞与非阻塞（blocking/non-blocking）。在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。</li></ul><p>不能一概而论认为同步或阻塞就是低效，具体还要看应用和系统特征。</p><p><a href="http://xn--java-ut5ft42e.io/">对于 java.io</a>，我们都非常熟悉，我这里就从总体上进行一下总结，如果需要学习更加具体的操作，你可以通过<a href="https://docs.oracle.com/javase/tutorial/essential/io/streams.html">教程</a>等途径完成。总体上，我认为你至少需要理解：</p><ul><li>IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。</li><li>输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。</li><li>而 Reader/Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。</li><li>BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，将批量数据进行一次操作，但在使用中千万别忘了 flush。</li><li>参考下面这张类图，很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符（FileDescriptor），需要利用 try-with-resources、 try-finally 等机制保证 FileInputStream 被明确关闭，进而相应文件描述符也会失效，否则将导致资源无法被释放。利用专栏前面的内容提到的 Cleaner 或 finalize 机制作为资源释放的最后把关，也是必要的。</li></ul><p>下面是我整理的一个简化版的类图，阐述了日常开发应用较多的类型和结构关系。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/4338e26731db0df390896ab305506d8b.png" alt="img"></p><p>1.Java NIO 概览</p><p>首先，熟悉一下 NIO 的主要组成部分：</p><ul><li><p>Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的 Buffer 实现。</p></li><li><p>Channel，类似在 Linux 之类操作系统上看到的文件描述符，是 NIO 中被用来支持批量式 IO 操作的一种抽象。</p><p>File 或者 Socket，通常被认为是比较高层次的抽象，而 Channel 则是更加操作系统底层的一种抽象，这也使得 NIO 得以充分利用现代操作系统底层机制，获得特定场景的性能优化，例如，DMA（Direct Memory Access）等。不同层次的抽象是相互关联的，我们可以通过 Socket 获取 Channel，反之亦然。</p></li><li><p>Selector，是 NIO 实现多路复用的基础，它提供了一种高效的机制，可以检测到注册在 Selector 上的多个 Channel 中，是否有 Channel 处于就绪状态，进而实现了单线程对多 Channel 的高效管理。</p></li></ul><p>Selector 同样是基于底层操作系统机制，不同模式、不同版本都存在区别，例如，在最新的代码库里，相关实现如下：</p><p>Linux 上依赖于 epoll（<a href="http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/linux/classes/sun/nio/ch/EPollSelectorImpl.java）。">http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/linux/classes/sun/nio/ch/EPollSelectorImpl.java）。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows 上 NIO2（AIO）模式则是依赖于 iocp（http://hg.openjdk.java.net/jdk/jdk/file/d8327f838b88/src/java.base/windows/classes/sun/nio/ch/Iocp.java）。</span><br></pre></td></tr></table></figure><ul><li>Chartset，提供 Unicode 字符串定义，NIO 也提供了相应的编解码器等，例如，通过下面的方式进行字符串到 ByteBuffer 的转换：</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset<span class="selector-class">.defaultCharset</span>()<span class="selector-class">.encode</span>(&quot;Hello world!&quot;));</span><br></pre></td></tr></table></figure><p>2.NIO 能解决什么问题？</p><p>下面我通过一个典型场景，来分析为什么需要 NIO，为什么需要多路复用。设想，我们需要实现一个服务器应用，只简单要求能够同时服务多个客户端请求即可。</p><p>使用 java.io 和 java.net 中的同步、阻塞式 API，可以简单实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  serverSocket.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">RequestHandler</span> <span class="variable">requestHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHandler</span>(socket);</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DemoServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoServer</span>();</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span>                   <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 简化实现，不做读取，直接发送字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestHandler(Socket socket) &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream());) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>其实现要点是：</p><ul><li>服务器端启动 ServerSocket，端口 0 表示自动绑定一个空闲端口。</li><li>调用 accept 方法，阻塞等待客户端连接。</li><li>利用 Socket 模拟了一个简单的客户端，只进行连接、读取、打印。</li><li>当连接建立后，启动一个单独线程负责回复客户端请求。</li></ul><p>这样，一个简单的 Socket 服务器就被实现出来了。</p><p>思考一下，这个解决方案在扩展性方面，可能存在什么潜在问题呢？</p><p>大家知道 Java 语言目前的线程实现是比较重量级的，启动或者销毁一个线程是有明显开销的，每个线程都有单独的线程栈等结构，需要占用非常明显的内存，所以，每一个 Client 启动一个线程似乎都有些浪费。</p><p>那么，稍微修正一下这个问题，我们引入线程池机制来避免浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">0</span>);</span><br><span class="line">executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">    <span class="type">RequestHandler</span> <span class="variable">requestHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHandler</span>(socket);</span><br><span class="line">    executor.execute(requestHandler);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这样做似乎好了很多，通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是我们构建并发服务的典型方式。这种工作方式，可以参考下图来理解。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/da7e1ecfd3c3ee0263b8892342dbc629.png" alt="img"></p><p>如果连接数并不是非常多，只有最多几百个连接的普通应用，这种模式往往可以工作的很好。但是，如果连接数量急剧上升，这种实现方式就无法很好地工作了，因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</p><p>NIO 引入的多路复用机制，提供了另外一种思路，请参考我下面提供的新的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">             <span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();) &#123;<span class="comment">// 创建 Selector 和 Channel</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(InetAddress.getLocalHost(), <span class="number">8888</span>));</span><br><span class="line">            serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 注册到 Selector，并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                selector.select();<span class="comment">// 阻塞等待就绪的 Channel，这是关键点之一</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                   <span class="comment">// 生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel) key.channel());</span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();) &#123;          client.write(Charset.defaultCharset().encode(<span class="string">&quot;Hello world!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 省略了与前面类似的 main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个非常精简的样例掀开了 NIO 多路复用的面纱，我们可以分析下主要步骤和元素：</p><ul><li><p>首先，通过 Selector.open() 创建一个 Selector，作为类似调度员的角色。</p></li><li><p>然后，创建一个 ServerSocketChannel，并且向 Selector 注册，通过指定 SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</p><p><strong>注意</strong>，为什么我们要明确配置非阻塞模式呢？这是因为阻塞模式下，注册操作是不允许的，会抛出 IllegalBlockingModeException 异常。</p></li><li><p>Selector 阻塞在 select 操作，当有 Channel 发生接入请求，就会被唤醒。</p></li><li><p>在 sayHelloWorld 方法中，通过 SocketChannel 和 Buffer 进行数据操作，在本例中是发送了一段字符串。</p></li></ul><p>可以看到，在前面两个样例中，IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高。下面这张图对这种实现思路进行了形象地说明。</p><p>在 Java 7 引入的 NIO 2 中，又增添了一种额外的异步 IO 模式，利用事件和回调，处理 Accept、Read 等操作。 AIO 实现看起来是类似这样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverSock</span> <span class="operator">=</span>        AsynchronousServerSocketChannel.open().bind(sockAddr);</span><br><span class="line">serverSock.accept(serverSock, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;&gt;() &#123; <span class="comment">// 为异步操作指定 CompletionHandler 回调函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sockChannel, AsynchronousServerSocketChannel serverSock)</span> &#123;</span><br><span class="line">        serverSock.accept(serverSock, <span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 另外一个 write（sock，CompletionHandler&#123;&#125;）</span></span><br><span class="line">        sayHelloWorld(sockChannel, Charset.defaultCharset().encode</span><br><span class="line">                (<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 省略其他路径处理方法...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>鉴于其编程要素（如 Future、CompletionHandler 等），我们还没有进行准备工作，为避免理解困难，我会在专栏后面相关概念补充后的再进行介绍，尤其是 Reactor、Proactor 模式等方面将在 Netty 主题一起分析，这里我先进行概念性的对比：</p><ul><li>基本抽象很相似，AsynchronousServerSocketChannel 对应于上面例子中的 ServerSocketChannel；AsynchronousSocketChannel 则对应 SocketChannel。</li><li>业务逻辑的关键在于，通过指定 CompletionHandler 回调接口，在 accept/read/write 等关键节点，通过事件机制调用，这是非常不同的一种编程思路。</li></ul><p>今天我初步对 Java 提供的 IO 机制进行了介绍，概要地分析了传统同步 IO 和 NIO 的主要组成，并根据典型场景，通过不同的 IO 模式进行了实现与拆解。专栏下一讲，我还将继续分析 Java IO 的主题。</p><h2 id="一课一练-10"><a href="#一课一练-10" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，NIO 多路复用的局限性是什么呢？你遇到过相关的问题吗？</p><h1 id="第12讲-Java有几种文件拷贝方式？哪一种最高效？"><a href="#第12讲-Java有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="第12讲 Java有几种文件拷贝方式？哪一种最高效？"></a>第12讲 Java有几种文件拷贝方式？哪一种最高效？</h1><p>我在专栏上一讲提到，NIO 不止是多路复用，NIO 2 也不只是异步 IO，今天我们来看看 Java IO 体系中，其他不可忽略的部分。</p><p>今天我要问你的问题是，Java 有几种文件拷贝方式？哪一种最高效？</p><h2 id="典型回答-11"><a href="#典型回答-11" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 有多种比较典型的文件拷贝实现方式，比如：</p><p>利用 java.io 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByStream</span>(<span class="params">File source, File dest</span>) throws</span></span><br><span class="line"><span class="function">        IOException</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream <span class="keyword">is</span> = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">         OutputStream os = <span class="keyword">new</span> FileOutputStream(dest);)&#123;</span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">int</span> length;</span><br><span class="line">        <span class="keyword">while</span> ((length = <span class="keyword">is</span>.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>或者，利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source)</span><br><span class="line">            .getChannel();</span><br><span class="line">         <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel</span><br><span class="line">                 ();)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size() ;count&gt;<span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(</span><br><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>当然，Java 标准类库本身已经提供了几种 Files.copy 的实现。</p><p>对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo/From 的方式<strong>可能更快</strong>，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p><h2 id="考点分析-11"><a href="#考点分析-11" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天这个问题，从面试的角度来看，确实是一个面试考察的点，针对我上面的典型回答，面试官还可能会从实践角度，或者 IO 底层实现机制等方面进一步提问。这一讲的内容从面试题出发，主要还是为了让你进一步加深对 Java IO 类库设计和实现的了解。</p><p>从实践角度，我前面并没有明确说 NIO transfer 的方案一定最快，真实情况也确实未必如此。我们可以根据理论分析给出可行的推断，保持合理的怀疑，给出验证结论的思路，有时候面试官考察的就是如何将猜测变成可验证的结论，思考方式远比记住结论重要。</p><p>从技术角度展开，下面这些方面值得注意：</p><ul><li>不同的 copy 方式，底层机制有什么区别？</li><li>为什么零拷贝（zero-copy）可能有性能优势？</li><li>Buffer 分类与使用。</li><li>Direct Buffer 对垃圾收集等方面的影响与实践选择。</li></ul><p>接下来，我们一起来分析一下吧。</p><h2 id="知识扩展-11"><a href="#知识扩展-11" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>\1. 拷贝实现机制分析</p><p>先来理解一下，前面实现的不同拷贝方法，本质上有什么明显的区别。</p><p>首先，你需要理解用户态空间（User Space）和内核态空间（Kernel Space），这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间，具有相对高的特权；而用户态空间，则是给普通应用和服务使用。你可以参考：<a href="https://en.wikipedia.org/wiki/User_space。">https://en.wikipedia.org/wiki/User_space。</a></p><p>当我们使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。</p><p>写入操作也是类似，仅仅是步骤相反，你可以参考下面这张图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/6d2368424431f1b0d2b935386324b585.png" alt="img"></p><p>所以，这种方式会带来一定的额外开销，可能会降低 IO 效率。</p><p>而基于 NIO transferTo 的实现方式，在 Linux 和 Unix 上，则会使用到零拷贝技术，数据传输并不需要用户态参与，省去了上下文切换的开销和不必要的内存拷贝，进而可能提高应用拷贝性能。注意，transferTo 不仅仅是可以用在文件拷贝中，与其类似的，例如读取磁盘文件，然后进行 Socket 发送，同样可以享受这种机制带来的性能和扩展性提高。</p><p>transferTo 的传输过程是：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/b0c8226992bb97adda5ad84fe25372ea.png" alt="img"></p><p>2.Java IO/NIO 源码结构</p><p>前面我在典型回答中提了第三种方式，即 Java 标准库也提供了文件拷贝方法（java.nio.file.Files.copy）。如果你这样回答，就一定要小心了，因为很少有问题的答案是仅仅调用某个方法。从面试的角度，面试官往往会追问：既然你提到了标准库，那么它是怎么实现的呢？有的公司面试官以喜欢追问而出名，直到追问到你说不知道。</p><p>其实，这个问题的答案还真不是那么直观，因为实际上有几个不同的 copy 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title function_">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">copy</span><span class="params">(InputStream in, Path target, CopyOption... options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">copy</span><span class="params">(Path source, OutputStream out)</span> </span><br><span class="line"><span class="keyword">throws</span> IOException </span><br></pre></td></tr></table></figure><p>可以看到，copy 不仅仅是支持文件之间操作，没有人限定输入输出流一定是针对文件的，这是两个很实用的工具方法。</p><p>后面两种 copy 实现，能够在方法实现里直接看到使用的是 InputStream.transferTo()，你可以直接看源码，其内部实现其实是 stream 在用户态的读写；而对于第一种方法的分析过程要相对麻烦一些，可以参考下面片段。简单起见，我只分析同类型文件系统拷贝过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title function_">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="type">FileSystemProvider</span> <span class="variable">provider</span> <span class="operator">=</span> provider(source);</span><br><span class="line">    <span class="keyword">if</span> (provider(target) == provider) &#123;</span><br><span class="line">        <span class="comment">// same provider</span></span><br><span class="line">        provider.copy(source, target, options);<span class="comment">// 这是本文分析的路径</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// different providers</span></span><br><span class="line">        CopyMoveHelper.copyToForeignTarget(source, target, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我把源码分析过程简单记录如下，JDK 的源代码中，内部实现和公共 API 定义也不是可以能够简单关联上的，NIO 部分代码甚至是定义为模板而不是 Java 源文件，在 build 过程自动生成源码，下面顺便介绍一下部分 JDK 代码机制和如何绕过隐藏障碍。</p><ul><li>首先，直接跟踪，发现 FileSystemProvider 只是个抽象类，阅读它的<a href="http://hg.openjdk.java.net/jdk/jdk/file/f84ae8aa5d88/src/java.base/share/classes/java/nio/file/spi/FileSystemProvider.java">源码</a>能够理解到，原来文件系统实际逻辑存在于 JDK 内部实现里，公共 API 其实是通过 ServiceLoader 机制加载一系列文件系统实现，然后提供服务。</li><li>我们可以在 JDK 源码里搜索 FileSystemProvider 和 nio，可以定位到<a href="http://hg.openjdk.java.net/jdk/jdk/file/f84ae8aa5d88/src/java.base/share/classes/sun/nio/fs">sun/nio/fs</a>，我们知道 NIO 底层是和操作系统紧密相关的，所以每个平台都有自己的部分特有文件系统逻辑。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/5e0bf3130dffa8e56f398f0856eb76f7.png" alt="img"></p><ul><li>省略掉一些细节，最后我们一步步定位到 UnixFileSystemProvider → UnixCopyFile.Transfer，发现这是个本地方法。</li><li>最后，明确定位到<a href="http://hg.openjdk.java.net/jdk/jdk/file/f84ae8aa5d88/src/java.base/unix/native/libnio/fs/UnixCopyFile.c">UnixCopyFile.c</a>，其内部实现清楚说明竟然只是简单的用户态空间拷贝！</li></ul><p>所以，我们明确这个最常见的 copy 方法其实不是利用 transferTo，而是本地技术实现的用户态拷贝。</p><p>前面谈了不少机制和源码，我简单从实践角度总结一下，如何提高类似拷贝等 IO 操作的性能，有一些宽泛的原则：</p><ul><li>在程序中，使用缓存等机制，合理减少 IO 次数（在网络通信中，如 TCP 传输，window 大小也可以看作是类似思路）。</li><li>使用 transferTo 等机制，减少上下文切换和额外 IO 操作。</li><li>尽量减少不必要的转换过程，比如编解码；对象序列化和反序列化，比如操作文本文件或者网络通信，如果不是过程中需要使用文本信息，可以考虑不要将二进制信息转换成字符串，直接传输二进制信息。</li></ul><p>\3. 掌握 NIO Buffer</p><p>我在上一讲提到 Buffer 是 NIO 操作数据的基本工具，Java 为每种原始数据类型都提供了相应的 Buffer 实现（布尔除外），所以掌握和使用 Buffer 是十分必要的，尤其是涉及 Direct Buffer 等使用，因为其在垃圾收集等方面的特殊性，更要重点掌握。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/5220029e92bc21e99920937a8210276e.png" alt="img"></p><p>Buffer 有几个基本属性：</p><ul><li>capcity，它反映这个 Buffer 到底有多大，也就是数组的长度。</li><li>position，要操作的数据起始位置。</li><li>limit，相当于操作的限额。在读取或者写入时，limit 的意义很明显是不一样的。比如，读取操作时，很可能将 limit 设置到所容纳数据的上限；而在写入时，则会设置容量或容量以下的可写限度。</li><li>mark，记录上一次 postion 的位置，默认是 0，算是一个便利性的考虑，往往不是必须的。</li></ul><p>前面三个是我们日常使用最频繁的，我简单梳理下 Buffer 的基本操作：</p><ul><li>我们创建了一个 ByteBuffer，准备放入数据，capcity 当然就是缓冲区大小，而 position 就是 0，limit 默认就是 capcity 的大小。</li><li>当我们写入几个字节的数据时，position 就会跟着水涨船高，但是它不可能超过 limit 的大小。</li><li>如果我们想把前面写入的数据读出来，需要调用 flip 方法，将 position 设置为 0，limit 设置为以前的 position 那里。</li><li>如果还想从头再读一遍，可以调用 rewind，让 limit 不变，position 再次设置为 0。</li></ul><p>更进一步的详细使用，我建议参考相关<a href="http://tutorials.jenkov.com/java-nio/buffers.html">教程</a>。</p><p>4.Direct Buffer 和垃圾收集</p><p>我这里重点介绍两种特别的 Buffer。</p><ul><li>Direct Buffer：如果我们看 Buffer 的方法定义，你会发现它定义了 isDirect() 方法，返回当前 Buffer 是否是 Direct 类型。这是因为 Java 提供了堆内和堆外（Direct）Buffer，我们可以以它的 allocate 或者 allocateDirect 方法直接创建。</li><li>MappedByteBuffer：它将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块儿文件数据，省去了将数据从内核空间向用户空间传输的损耗。我们可以使用<a href="https://docs.oracle.com/javase/9/docs/api/java/nio/channels/FileChannel.html#map-java.nio.channels.FileChannel.MapMode-long-long-">FileChannel.map</a>创建 MappedByteBuffer，它本质上也是种 Direct Buffer。</li></ul><p>在实际使用中，Java 会尽量对 Direct Buffer 仅做本地 IO 操作，对于很多大数据量的 IO 密集操作，可能会带来非常大的性能优势，因为：</p><ul><li>Direct Buffer 生命周期内内存地址都不会再发生更改，进而内核可以安全地对其进行访问，很多 IO 操作会很高效。</li><li>减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高。</li></ul><p>但是请注意，Direct Buffer 创建和销毁过程中，都会比一般的堆内 Buffer 增加部分开销，所以通常都建议用于长期使用、数据较大的场景。</p><p>使用 Direct Buffer，我们需要清楚它对内存和 JVM 参数的影响。首先，因为它不在堆上，所以 Xmx 之类参数，其实并不能影响 Direct Buffer 等堆外成员所使用的内存额度，我们可以使用下面参数设置大小：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:MaxDirectMemorySize=512M</span></span><br></pre></td></tr></table></figure><p>从参数设置和内存问题排查角度来看，这意味着我们在计算 Java 可以使用的内存大小的时候，不能只考虑堆的需要，还有 Direct Buffer 等一系列堆外因素。如果出现内存不足，堆外内存占用也是一种可能性。</p><p>另外，大多数垃圾收集过程中，都不会主动收集 Direct Buffer，它的垃圾收集过程，就是基于我在专栏前面所介绍的 Cleaner（一个内部实现）和幻象引用（PhantomReference）机制，其本身不是 public 类型，内部实现了一个 Deallocator 负责销毁的逻辑。对它的销毁往往要拖到 full GC 的时候，所以使用不当很容易导致 OutOfMemoryError。</p><p>对于 Direct Buffer 的回收，我有几个建议：</p><ul><li>在应用程序中，显式地调用 System.gc() 来强制触发。</li><li>另外一种思路是，在大量使用 Direct Buffer 的部分框架中，框架会自己在程序中调用释放方法，Netty 就是这么做的，有兴趣可以参考其实现（PlatformDependent0）。</li><li>重复使用 Direct Buffer。</li></ul><p>\5. 跟踪和诊断 Direct Buffer 内存占用？</p><p>因为通常的垃圾收集日志等记录，并不包含 Direct Buffer 等信息，所以 Direct Buffer 内存诊断也是个比较头疼的事情。幸好，在 JDK 8 之后的版本，我们可以方便地使用 Native Memory Tracking（NMT）特性来进行诊断，你可以在程序启动时加上下面参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:NativeMemoryTracking=&#123;summary|detail&#125;</span></span><br></pre></td></tr></table></figure><p>注意，激活 NMT 通常都会导致 JVM 出现 5%~10% 的性能下降，请谨慎考虑。</p><p>运行时，可以采用下面命令进行交互式对比：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 NMT 信息</span></span><br><span class="line">jcmd &lt;pid&gt; VM<span class="selector-class">.native_memory</span> detail  </span><br><span class="line"><span class="comment">// 进行 baseline，以对比分配内存变化</span></span><br><span class="line">jcmd &lt;pid&gt; VM<span class="selector-class">.native_memory</span> baseline </span><br><span class="line"><span class="comment">// 进行 baseline，以对比分配内存变化</span></span><br><span class="line">jcmd &lt;pid&gt; VM<span class="selector-class">.native_memory</span> detail<span class="selector-class">.diff</span></span><br></pre></td></tr></table></figure><p>我们可以在 Internal 部分发现 Direct Buffer 内存使用的信息，这是因为其底层实际是利用 unsafe_allocatememory。严格说，这不是 JVM 内部使用的内存，所以在 JDK 11 以后，其实它是归类在 other 部分里。</p><p>JDK 9 的输出片段如下，“+”表示的就是 diff 命令发现的分配变化：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Internal (reserved=<span class="number">679</span>KB +<span class="number">4</span>KB, committed=<span class="number">679</span>KB +<span class="number">4</span>KB)</span><br><span class="line">              (malloc=<span class="number">615</span>KB +<span class="number">4</span>KB #<span class="number">1571</span> +<span class="number">4</span>)</span><br><span class="line">              (mmap: reserved=<span class="number">64</span>KB, committed=<span class="number">64</span>KB) </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：JVM 的堆外内存远不止 Direct Buffer，NMT 输出的信息当然也远不止这些，我在专栏后面有综合分析更加具体的内存结构的主题。</p><p>今天我分析了 Java IO/NIO 底层文件操作数据的机制，以及如何实现零拷贝的高性能操作，梳理了 Buffer 的使用和类型，并针对 Direct Buffer 的生命周期管理和诊断进行了较详细的分析。</p><h2 id="一课一练-11"><a href="#一课一练-11" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？你可以思考下，如果我们需要在 channel 读取的过程中，将不同片段写入到相应的 Buffer 里面（类似二进制消息分拆成消息头、消息体等），可以采用 NIO 的什么机制做到呢？</p><h1 id="第13讲-谈谈接口和抽象类有什么区别？"><a href="#第13讲-谈谈接口和抽象类有什么区别？" class="headerlink" title="第13讲 谈谈接口和抽象类有什么区别？"></a>第13讲 谈谈接口和抽象类有什么区别？</h1><p>ava 是非常典型的面向对象语言，曾经有一段时间，程序员整天把面向对象、设计模式挂在嘴边。虽然如今大家对这方面已经不再那么狂热，但是不可否认，掌握面向对象设计原则和技巧，是保证高质量代码的基础之一。</p><p>面向对象提供的基本机制，对于提高开发、沟通等各方面效率至关重要。考察面向对象也是面试中的常见一环，下面我来聊聊<strong>面向对象设计基础</strong>。</p><p>今天我要问你的问题是，谈谈接口和抽象类有什么区别？</p><h2 id="典型回答-12"><a href="#典型回答-12" class="headerlink" title="典型回答"></a>典型回答</h2><p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。Java 标准类库中，定义了非常多的接口，比如 java.util.List。</p><p>抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。</p><p>Java 类实现 interface 使用 implements 关键词，继承 abstract class 则是使用 extends 关键词，我们可以参考 Java 标准库中的 ArrayList。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="title">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">        <span class="title">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java.io.Serializable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点分析-12"><a href="#考点分析-12" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是个非常高频的 Java 面向对象基础问题，看起来非常简单的问题，如果面试官稍微深入一些，你会发现很多有意思的地方，可以从不同角度全面地考察你对基本机制的理解和掌握。比如:</p><ul><li>对于 Java 的基本元素的语法是否理解准确。能否定义出语法基本正确的接口、抽象类或者相关继承实现，涉及重载（Overload）、重写（Override）更是有各种不同的题目。</li><li>在软件设计开发中妥善地使用接口和抽象类。你至少知道典型应用场景，掌握基础类库重要接口的使用；掌握设计方法，能够在 review 代码的时候看出明显的不利于未来维护的设计。</li><li>掌握 Java 语言特性演进。现在非常多的框架已经是基于 Java 8，并逐渐支持更新版本，掌握相关语法，理解设计目的是很有必要的。</li></ul><h2 id="知识扩展-12"><a href="#知识扩展-12" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我会从接口、抽象类的一些实践，以及语言变化方面去阐述一些扩展知识点。</p><p>Java 相比于其他面向对象语言，如 C++，设计上有一些基本区别，比如<strong>Java 不支持多继承</strong>。这种限制，在规范了代码实现的同时，也产生了一些局限性，影响着程序设计结构。Java 类可以实现多个接口，因为接口是抽象方法的集合，所以这是声明性的，但不能通过扩展多个抽象类来重用逻辑。</p><p>在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如 java.util.Collections。</p><p>设想，为接口添加任何抽象方法，相应的所有实现了这个接口的类，也必须实现新增方法，否则会出现编译错误。对于抽象类，如果我们添加非抽象方法，其子类只会享受到能力扩展，而不用担心编译出问题。</p><p>接口的职责也不仅仅限于抽象方法的集合，其实有各种不同的实践。有一类没有任何方法的接口，通常叫作 Marker Interface，顾名思义，它的目的就是为了声明某些东西，比如我们熟知的 Cloneable、Serializable 等。这种用法，也存在于业界其他的 Java 产品代码中。</p><p>从表面看，这似乎和 Annotation 异曲同工，也确实如此，它的好处是简单直接。对于 Annotation，因为可以指定参数和值，在表达能力上要更强大一些，所以更多人选择使用 Annotation。</p><p>Java 8 增加了函数式编程的支持，所以又增加了一类定义，即所谓 functional interface，简单说就是只有一个抽象方法的接口，通常建议使用 @FunctionalInterface Annotation 来标记。Lambda 表达式本身可以看作是一类 functional interface，某种程度上这和面向对象可以算是两码事。我们熟知的 Runnable、Callable 之类，都是 functional interface，这里不再多介绍了，有兴趣你可以参考：<a href="https://www.oreilly.com/learning/java-8-functional-interfaces">https://www.oreilly.com/learning/java-8-functional-interfaces</a> 。</p><p>还有一点可能让人感到意外，严格说，<strong>Java 8 以后，接口也是可以有方法实现的！</strong></p><p>从 Java 8 开始，interface 增加了对 default method 的支持。Java 9 以后，甚至可以定义 private default method。Default method 提供了一种二进制兼容的扩展已有接口的办法。比如，我们熟知的 java.util.Collection，它是 collection 体系的 root interface，在 Java 8 中添加了一系列 default method，主要是增加 Lambda、Stream 相关的功能。我在专栏前面提到的类似 Collections 之类的工具类，很多方法都适合作为 default method 实现在基础接口里面。</p><p>你可以参考下面代码片段：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="title">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a sequential Stream with this collection as its source </span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">     <span class="function"><span class="literal">default</span> Stream&lt;E&gt; <span class="title">stream</span>()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>面向对象设计</strong></p><p>谈到面向对象，很多人就会想起设计模式，那些是非常经典的问题和设计方法的总结。我今天来夯实一下基础，先来聊聊面向对象设计的基本方面。</p><p>我们一定要清楚面向对象的基本要素：封装、继承、多态。</p><p><strong>封装</strong>的目的是隐藏事务内部的实现细节，以便提高安全性和简化编程。封装提供了合理的边界，避免外部调用者接触到内部的细节。我们在日常开发中，因为无意间暴露了细节导致的难缠 bug 太多了，比如在多线程环境暴露内部状态，导致的并发修改问题。从另外一个角度看，封装这种隐藏，也提供了简化的界面，避免太多无意义的细节浪费调用者的精力。</p><p><strong>继承</strong>是代码复用的基础机制，类似于我们对于马、白马、黑马的归纳总结。但要注意，继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。</p><p><strong>多态</strong>，你可能立即会想到重写（override）和重载（overload）、向上转型。简单说，重写是父子类中相同名字和参数的方法，不同的实现；重载则是相同名字的方法，但是不同的参数，本质上这些方法签名是不一样的，为了更好说明，请参考下面的样例代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">doSomething</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入参数不同，意味着方法签名不同，重载的体现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">doSomething</span>(<span class="params">List&lt;String&gt; strs</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return 类型不一样，编译不能通过</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">short</span> <span class="title">doSomething</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里你可以思考一个小问题，方法名称和参数一致，但是返回值不同，这种情况在 Java 代码中算是有效的重载吗？ 答案是不是的，编译都会出错的。</p><p>进行面向对象编程，掌握基本的设计原则是必须的，我今天介绍最通用的部分，也就是所谓的 S.O.L.I.D 原则。</p><ul><li>单一职责（Single Responsibility），类或者对象最好是只有单一职责，在程序设计中如果发现某个类承担着多种义务，可以考虑进行拆分。</li><li>开关原则（Open-Close, Open for extension, close for modification），设计要对扩展开放，对修改关闭。换句话说，程序设计应保证平滑的扩展性，尽量避免因为新增同类功能而修改已有实现，这样可以少产出些回归（regression）问题。</li><li>里氏替换（Liskov Substitution），这是面向对象的基本要素之一，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类替换。</li><li>接口分离（Interface Segregation），我们在进行类和接口设计时，如果在一个接口里定义了太多方法，其子类很可能面临两难，就是只有部分方法对它是有意义的，这就破坏了程序的内聚性。 对于这种情况，可以通过拆分成功能单一的多个接口，将行为进行解耦。在未来维护中，如果某个接口设计有变，不会对使用其他接口的子类构成影响。</li><li>依赖反转（Dependency Inversion），实体应该依赖于抽象而不是实现。也就是说高层次模块，不应该依赖于低层次模块，而是应该基于抽象。实践这一原则是保证产品代码之间适当耦合度的法宝。</li></ul><p><strong>OOP 原则实践中的取舍</strong></p><p>值得注意的是，现代语言的发展，很多时候并不是完全遵守前面的原则的，比如，Java 10 中引入了本地方法类型推断和 var 类型。按照，里氏替换原则，我们通常这样定义变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">List</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>如果使用 var 类型，可以简化为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">String</span>&gt;(); </span><br></pre></td></tr></table></figure><p>但是，list 实际会被推断为“ArrayList &lt; String &gt;”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ArrayList</span>&lt;<span class="title class_">String</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">String</span>&gt;();</span><br></pre></td></tr></table></figure><p>理论上，这种语法上的便利，其实是增强了程序对实现的依赖，但是微小的类型泄漏却带来了书写的便利和代码可读性的提高，所以，实践中我们还是要按照得失利弊进行选择，而不是一味得遵循原则。</p><p><strong>OOP 原则在面试题目中的分析</strong></p><p>我在以往面试中发现，即使是有多年编程经验的工程师，也还没有真正掌握面向对象设计的基本的原则，如开关原则（Open-Close）。看看下面这段代码，改编自朋友圈盛传的某伟大公司产品代码，你觉得可以利用面向对象设计原则如何改进？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPCenter</span> &#123;</span><br><span class="line">  <span class="built_in">void</span> <span class="title function_">serviceVIP</span>(<span class="params">T extend User user&gt;</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (user <span class="keyword">instanceof</span> <span class="title class_">SlumDogVIP</span>) &#123;</span><br><span class="line">        <span class="comment">// 穷 X VIP，活动抢的那种</span></span><br><span class="line">        <span class="comment">// do somthing</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(user <span class="keyword">instanceof</span> <span class="title class_">RealVIP</span>) &#123;</span><br><span class="line">        <span class="comment">// do somthing</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码的一个问题是，业务逻辑集中在一起，当出现新的用户类型时，比如，大数据发现了我们是肥羊，需要去收获一下， 这就需要直接去修改服务方法代码实现，这可能会意外影响不相关的某个用户类型逻辑。</p><p>利用开关原则，我们可以尝试改造为下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPCenter</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="title class_">Map</span>&lt;<span class="title class_">User</span>.<span class="property">TYPE</span>, <span class="title class_">ServiceProvider</span>&gt; providers;</span><br><span class="line">   <span class="built_in">void</span> <span class="title function_">serviceVIP</span>(T extend <span class="title class_">User</span> user） &#123;</span><br><span class="line">      providers.<span class="title function_">get</span>(user.<span class="title function_">getType</span>()).<span class="title function_">service</span>(user);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">ServiceProvider</span>&#123;</span><br><span class="line">   <span class="built_in">void</span> <span class="title function_">service</span>(T extend <span class="title class_">User</span> user) ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">SlumDogVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title class_">ServiceProvider</span>&#123;</span><br><span class="line">   <span class="built_in">void</span> <span class="title function_">service</span>(<span class="params">T extend User user</span>)&#123;</span><br><span class="line">     <span class="comment">// do somthing</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">RealVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title class_">ServiceProvider</span>&#123;</span><br><span class="line">   <span class="built_in">void</span> <span class="title function_">service</span>(<span class="params">T extend User user</span>) &#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p>上面的示例，将不同对象分类的服务方法进行抽象，把业务逻辑的紧耦合关系拆开，实现代码的隔离保证了方便的扩展。</p><p>今天我对 Java 面向对象技术进行了梳理，对比了抽象类和接口，分析了 Java 语言在接口层面的演进和相应程序设计实现，最后回顾并实践了面向对象设计的基本原则，希望对你有所帮助。</p><h2 id="一课一练-12"><a href="#一课一练-12" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于接口和抽象类的区别，你做到心中有数了吗？给你布置一个思考题，思考一下自己的产品代码，有没有什么地方违反了基本设计原则？那些一改就崩的代码，是否遵循了开关原则？</p><h1 id="第14讲-谈谈你知道的设计模式？"><a href="#第14讲-谈谈你知道的设计模式？" class="headerlink" title="第14讲 谈谈你知道的设计模式？"></a>第14讲 谈谈你知道的设计模式？</h1><p>设计模式是人们为软件开发中相同表征的问题，抽象出的可重复利用的解决方案。在某种程度上，设计模式已经代表了一些特定情况的最佳实践，同时也起到了软件工程师之间沟通的“行话”的作用。理解和掌握典型的设计模式，有利于我们提高沟通、设计的效率和质量。</p><p>今天我要问你的问题是，谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</p><h2 id="典型回答-13"><a href="#典型回答-13" class="headerlink" title="典型回答"></a>典型回答</h2><p>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。</p><ul><li>创建型模式，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li><li>结构型模式，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li><li>行为型模式，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li></ul><h2 id="考点分析-13"><a href="#考点分析-13" class="headerlink" title="考点分析"></a>考点分析</h2><p>这个问题主要是考察你对设计模式的了解和掌握程度，更多相关内容你可以参考：<a href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns。</a></p><p>我建议可以在回答时适当地举些例子，更加清晰地说明典型模式到底是什么样子，典型使用场景是怎样的。这里举个 Java 基础类库中的例子供你参考。</p><p>首先，<a href="http://time.geekbang.org/column/article/8369">专栏第 11 讲</a>刚介绍过 IO 框架，我们知道 InputStream 是一个抽象类，标准类库中提供了 FileInputStream、ByteArrayInputStream 等各种不同的子类，分别从不同角度对 InputStream 进行了功能扩展，这是典型的装饰器模式应用案例。</p><p>识别装饰器模式，可以通过<strong>识别类设计特征</strong>来进行判断，也就是其类构造函数以<strong>相同的</strong>抽象类或者接口为输入参数。</p><p>因为装饰器模式本质上是包装同类型实例，我们对目标对象的调用，往往会通过包装类覆盖过的方法，迂回调用被包装的实例，这就可以很自然地实现增加额外逻辑的目的，也就是所谓的“装饰”。</p><p>例如，BufferedInputStream 经过包装，为输入流过程增加缓存，类似这种装饰器还可以多次嵌套，不断地增加不同层次的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure><p>我在下面的类图里，简单总结了 InputStream 的装饰模式实践。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/77ad2dc2513da8155a3781e8291fac33.png" alt="img"></p><p>接下来再看第二个例子。创建型模式尤其是工厂模式，在我们的代码中随处可见，我举个相对不同的 API 设计实践。比如，JDK 最新版本中 HTTP/2 Client API，下面这个创建 HttpRequest 的过程，就是典型的构建器模式（Builder），通常会被实现成<a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent 风格</a>的 API，也有人叫它方法链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder(<span class="keyword">new</span> <span class="title class_">URI</span>(uri))</span><br><span class="line">                     .header(headerAlice, valueAlice)</span><br><span class="line">                     .headers(headerBob, value1Bob,</span><br><span class="line">                      headerCarl, valueCarl,</span><br><span class="line">                      headerBob, value2Bob)</span><br><span class="line">                     .GET()</span><br><span class="line">                     .build();</span><br></pre></td></tr></table></figure><p>使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。</p><p>上面的分析也进一步反映了创建型模式的初衷，即，将对象创建过程单独抽象出来，从结构上把对象使用逻辑和创建逻辑相互独立，隐藏对象实例的细节，进而为使用者实现了更加规范、统一的逻辑。</p><p>更进一步进行设计模式考察，面试官可能会：</p><ul><li>希望你写一个典型的设计模式实现。这虽然看似简单，但即使是最简单的单例，也能够综合考察代码基本功。</li><li>考察典型的设计模式使用，尤其是结合标准库或者主流开源框架，考察你对业界良好实践的掌握程度。</li></ul><p>在面试时如果恰好问到你不熟悉的模式，你可以稍微引导一下，比如介绍你在产品中使用了什么自己相对熟悉的模式，试图解决什么问题，它们的优点和缺点等。</p><p>下面，我会针对前面两点，结合代码实例进行分析。</p><h2 id="知识扩展-13"><a href="#知识扩展-13" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我们来实现一个日常非常熟悉的单例设计模式。看起来似乎很简单，那么下面这个样例符合基本需求吗？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>是不是总感觉缺了点什么？原来，Java 会自动为没有明确声明构造函数的类，定义一个 public 的无参数的构造函数，所以上面的例子并不能保证额外的对象不被创建出来，别人完全可以直接“new Singleton()”，那我们应该怎么处理呢？</p><p>不错，可以为单例定义一个 private 的构造函数（也有建议声明为枚举，这是有争议的，我个人不建议选择相对复杂的枚举，毕竟日常开发不是学术研究）。这样还有什么改进的余地吗？</p><p><a href="http://time.geekbang.org/column/article/8137">专栏第 10 讲</a>介绍 ConcurrentHashMap 时，提到过标准类库中很多地方使用懒加载（lazy-load），改善初始内存开销，单例同样适用，下面是修正后的改进版本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个实现在单线程环境不存在问题，但是如果处于并发场景，就需要考虑线程安全，最熟悉的就莫过于“双检锁”，其要点在于：</p><ul><li>这里的 volatile 能够提供可见性，以及保证 getInstance 返回的是初始化<strong>完全</strong>的对象。</li><li>在同步之前进行 null 检查，以尽量避免进入相对昂贵的同步块。</li><li>直接在 class 级别进行同步，保证线程安全的类方法调用。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 尽量避免重复进入同步块</span></span><br><span class="line">        synchronized (Singleton.<span class="keyword">class</span>) &#123; <span class="comment">// 同步.class，意味着对同步类方法调用</span></span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在这段代码中，争论较多的是 volatile 修饰静态变量，当 Singleton 类本身有多个成员变量时，需要保证初始化过程完成后，才能被 get 到。</p><p>在现代 Java 中，内存排序模型（JMM）已经非常完善，通过 volatile 的 write 或者 read，能保证所谓的 happen-before，也就是避免常被提到的指令重排。换句话说，构造对象的 store 指令能够被保证一定在 volatile read 之前。</p><p>当然，也有一些人推荐利用内部类持有静态对象的方式实现，其理论依据是对象初始化过程中隐含的初始化锁（有兴趣的话你可以参考<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4.2">jls-12.4.2</a> 中对 LC 的说明），这种和前面的双检锁实现都能保证线程安全，不过语法稍显晦涩，未必有特别的优势。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，可以看出，即使是看似最简单的单例模式，在增加各种高标准需求之后，同样需要非常多的实现考量。</p><p>上面是比较学究的考察，其实实践中未必需要如此复杂，如果我们看 Java 核心类库自己的单例实现，比如<a href="http://hg.openjdk.java.net/jdk/jdk/file/18fba780c1d1/src/java.base/share/classes/java/lang/Runtime.java">java.lang.Runtime</a>，你会发现：</p><ul><li>它并没使用复杂的双检锁之类。</li><li>静态实例被声明为 final，这是被通常实践忽略的，一定程度保证了实例不被篡改（<a href="http://time.geekbang.org/column/article/7489">专栏第 6 讲</a>介绍过，反射之类可以绕过私有访问限制），也有有限的保证执行顺序的语义。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Version version;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span>()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Runtime</span>()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>前面说了不少代码实践，下面一起来简要看看主流开源框架，如 Spring 等如何在 API 设计中使用设计模式。你至少要有个大体的印象，如：</p><ul><li><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java">BeanFactory</a>和<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationContext.java">ApplicationContext</a>应用了工厂模式。</li><li>在 Bean 的创建中，Spring 也为不同 scope 定义的对象，提供了单例和原型等模式实现。</li><li>我在<a href="http://time.geekbang.org/column/article/7489">专栏第 6 讲</a>介绍的 AOP 领域则是使用了代理模式、装饰器模式、适配器模式等。</li><li>各种事件监听器，是观察者模式的典型应用。</li><li>类似 JdbcTemplate 等则是应用了模板模式。</li></ul><p>今天，我与你回顾了设计模式的分类和主要类型，并从 Java 核心类库、开源框架等不同角度分析了其采用的模式，并结合单例的不同实现，分析了如何实现符合线程安全等需求的单例，希望可以对你的工程实践有所帮助。另外，我想最后补充的是，设计模式也不是银弹，要避免滥用或者过度设计。</p><h2 id="一课一练-13"><a href="#一课一练-13" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于设计模式你做到心中有数了吗？你可以思考下，在业务代码中，经常发现大量 XXFacade，外观模式是解决什么问题？适用于什么场景？</p><h1 id="第15讲-synchronized和ReentrantLock有什么区别呢？"><a href="#第15讲-synchronized和ReentrantLock有什么区别呢？" class="headerlink" title="第15讲 synchronized和ReentrantLock有什么区别呢？"></a>第15讲 synchronized和ReentrantLock有什么区别呢？</h1><p>从今天开始，我们将进入 Java 并发学习阶段。软件并发已经成为现代软件开发的基础能力，而 Java 精心设计的高效并发机制，正是构建大规模应用的基础之一，所以考察并发基本功也成为各个公司面试 Java 工程师的必选项。</p><p>今天我要问你的问题是， synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？</p><h2 id="典型回答-14"><a href="#典型回答-14" class="headerlink" title="典型回答"></a>典型回答</h2><p>synchronized 是 Java 内建的同步机制，所以也有人称其为 Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p><p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起来。</p><p>ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p><p>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock。</p><h2 id="考点分析-14"><a href="#考点分析-14" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的题目是考察并发编程的常见基础题，我给出的典型回答算是一个相对全面的总结。</p><p>对于并发编程，不同公司或者面试官面试风格也不一样，有个别大厂喜欢一直追问你相关机制的扩展或者底层，有的喜欢从实用角度出发，所以你在准备并发编程方面需要一定的耐心。</p><p>我认为，锁作为并发的基础工具之一，你至少需要掌握：</p><ul><li>理解什么是线程安全。</li><li>synchronized、ReentrantLock 等机制的基本使用与案例。</li></ul><p>更近一步，你还需要：</p><ul><li>掌握 synchronized、ReentrantLock 底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁等概念。</li><li>掌握并发包中 java.util.concurrent.lock 各种不同实现和案例分析。</li></ul><h2 id="知识扩展-14"><a href="#知识扩展-14" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>专栏前面几期穿插了一些并发的概念，有同学反馈理解起来有点困难，尤其对一些并发相关概念比较陌生，所以在这一讲，我也对会一些基础的概念进行补充。</p><p>首先，我们需要理解什么是线程安全。</p><p>我建议阅读 Brain Goetz 等专家撰写的《Java 并发编程实战》（Java Concurrency in Practice），虽然可能稍显学究，但不可否认这是一本非常系统和全面的 Java 并发编程书籍。按照其中的定义，线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改的</strong>状态的正确性，这里的状态反映在程序中其实可以看作是数据。</p><p>换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：</p><ul><li>封装：通过封装，我们可以将对象内部状态隐藏、保护起来。</li><li>不可变：还记得我们在<a href="http://time.geekbang.org/column/article/6906">专栏第 3 讲</a>强调的 final 和 immutable 吗，就是这个道理，Java 语言目前还没有真正意义上的原生不可变，但是未来也许会引入。</li></ul><p>线程安全需要保证几个基本特性：</p><ul><li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li><li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li><li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li></ul><p>可能有点晦涩，那么我们看看下面的代码段，分析一下原子性需求体现在哪里。这个例子通过取两次数值然后进行对比，来模拟两次对共享状态的操作。</p><p>你可以编译并执行，可以看到，仅仅是两个线程的低度并发，就非常容易碰到 former 和 latter 不相等的情况。这是因为，在两次取值的过程中，其他线程可能已经修改了 sharedState。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreadSafeSample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> sharedState;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSafeAction</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (sharedState &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> former = sharedState++;</span><br><span class="line">        <span class="built_in">int</span> latter = sharedState;</span><br><span class="line">        <span class="keyword">if</span> (former != latter - <span class="number">1</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.printf(<span class="string">&quot;Observed data race, former is &quot;</span> +</span><br><span class="line">                    former + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;latter is &quot;</span> + latter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">    ThreadSafeSample sample = <span class="keyword">new</span> ThreadSafeSample();</span><br><span class="line">    Thread threadA = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">            sample.nonSafeAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread threadB = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span>&#123;</span><br><span class="line">            sample.nonSafeAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    threadA.start();</span><br><span class="line">    threadB.start();</span><br><span class="line">    threadA.<span class="keyword">join</span>();</span><br><span class="line">    threadB.<span class="keyword">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是在我的电脑上的运行结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;c:\jdk-<span class="number">9</span>\bin\java ThreadSafeSample</span><br><span class="line">Observed <span class="keyword">data</span> race, former <span class="keyword">is</span> <span class="number">13097</span>, latter <span class="keyword">is</span> <span class="number">13099</span></span><br></pre></td></tr></table></figure><p>将两次赋值过程用 synchronized 保护起来，使用 this 作为互斥单元，就可以避免别的线程并发的去修改 sharedState。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">former</span> <span class="operator">=</span> sharedState ++;</span><br><span class="line"><span class="type">int</span> <span class="variable">latter</span> <span class="operator">=</span> sharedState;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用 javap 反编译，可以看到类似片段，利用 monitorenter/monitorexit 对实现了同步的语义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">11:</span> <span class="string">astore_1</span></span><br><span class="line"><span class="attr">12:</span> <span class="string">monitorenter</span></span><br><span class="line"><span class="attr">13:</span> <span class="string">aload_0</span></span><br><span class="line"><span class="attr">14:</span> <span class="string">dup</span></span><br><span class="line"><span class="attr">15:</span> <span class="string">getfield</span>  <span class="comment">#2              // Field sharedState:I</span></span><br><span class="line"><span class="attr">18:</span> <span class="string">dup_x1</span></span><br><span class="line"><span class="string">…</span></span><br><span class="line"><span class="attr">56:</span> <span class="string">monitorexit</span></span><br></pre></td></tr></table></figure><p>我会在下一讲，对 synchronized 和其他锁实现的更多底层细节进行深入分析。</p><p>代码中使用 synchronized 非常便利，如果用来修饰静态方法，其等同于利用下面代码将方法体囊括进来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">synchronized</span> (ClassName.<span class="keyword">class</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>再来看看 ReentrantLock。你可能好奇什么是再入？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数。Java 锁实现强调再入性是为了和 pthread 的行为进行区分。</p><p>再入锁可以设置公平性（fairness），我们可在创建再入锁时选择是否是公平的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p><p>如果使用 synchronized，我们根本<strong>无法进行</strong>公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java 默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。所以，我建议<strong>只有</strong>当你的程序确实有公平性需要的时候，才有必要指定它。</p><p>我们再从日常编码的角度学习下再入锁。为保证锁释放，每一个 lock() 动作，我建议都立即对应一个 try-catch-finally，典型的代码结构如下，这是个良好的习惯。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="literal">true</span>);<span class="comment">// 这里是演示创建公平锁，一般情况不需要。</span></span><br><span class="line">fairLock.<span class="keyword">lock</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> fairLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 相比 synchronized，因为可以像普通对象一样使用，所以可以利用其提供的各种便利方法，进行精细的同步操作，甚至是实现 synchronized 难以表达的用例，如：</p><ul><li>带超时的获取锁尝试。</li><li>可以判断是否有线程，或者某个特定线程，在排队等待获取锁。</li><li>可以响应中断请求。</li><li>…</li></ul><p>这里我特别想强调<strong>条件变量</strong>（java.util.concurrent.Condition），如果说 ReentrantLock 是 synchronized 的替代选择，Condition 则是将 wait、notify、notifyAll 等操作转化为相应的对象，将复杂而晦涩的同步操作转变为直观可控的对象行为。</p><p>条件变量最为典型的应用场景就是标准类库中的 ArrayBlockingQueue 等。</p><p>我们参考下面的源码，首先，通过再入锁获取条件变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty; </span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> final Condition notFull; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span>(<span class="params"><span class="built_in">int</span> capacity, boolean fair</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line"><span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">notEmpty = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">notFull =  <span class="keyword">lock</span>.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个条件变量是从<strong>同一再入锁</strong>创建出来，然后使用在特定操作中，如下面的 take 方法，判断和等待条件满足：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span>() throws InterruptedException</span> &#123;</span><br><span class="line">final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">lock</span>.lockInterruptibly();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.<span class="keyword">await</span>();</span><br><span class="line">    <span class="keyword">return</span> dequeue();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当队列为空时，试图 take 的线程的正确行为应该是等待入队发生，而不是直接返回，这是 BlockingQueue 的语义，使用条件 notEmpty 就可以优雅地实现这一逻辑。</p><p>那么，怎么保证入队触发后续 take 操作呢？请看 enqueue 实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">enqueue</span>(<span class="params">E e</span>) &#123;</span><br><span class="line"><span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line"><span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line"><span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">final <span class="title class_">Object</span>[] items = <span class="variable language_">this</span>.<span class="property">items</span>;</span><br><span class="line">items[putIndex] = e;</span><br><span class="line"><span class="keyword">if</span> (++putIndex == items.<span class="property">length</span>) putIndex = <span class="number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">notEmpty.<span class="title function_">signal</span>(); <span class="comment">// 通知等待的线程，非空条件已经满足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 signal/await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt）。</p><p>从性能角度，synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大。但是在 Java 6 中对其进行了非常多的改进，可以参考性能<a href="https://dzone.com/articles/synchronized-vs-lock">对比</a>，在高竞争情况下，ReentrantLock 仍然有一定优势。我在下一讲进行详细分析，会更有助于理解性能差异产生的内在原因。在大多数情况下，无需纠结于性能，还是考虑代码书写结构的便利性、可维护性等。</p><p>今天，作为专栏进入并发阶段的第一讲，我介绍了什么是线程安全，对比和分析了 synchronized 和 ReentrantLock，并针对条件变量等方面结合案例代码进行了介绍。下一讲，我将对锁的进阶内容进行源码和案例分析。</p><h2 id="一课一练-14"><a href="#一课一练-14" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的 synchronized 和 ReentrantLock 你做到心中有数了吗？思考一下，你使用过 ReentrantLock 中的哪些方法呢？分别解决什么问题？</p><h1 id="第16讲-synchronized底层如何实现？什么是锁的升级、降级？"><a href="#第16讲-synchronized底层如何实现？什么是锁的升级、降级？" class="headerlink" title="第16讲 synchronized底层如何实现？什么是锁的升级、降级？"></a>第16讲 synchronized底层如何实现？什么是锁的升级、降级？</h1><p>我在<a href="http://time.geekbang.org/column/article/8799">上一讲</a>对比和分析了 synchronized 和 ReentrantLock，算是专栏进入并发编程阶段的热身，相信你已经对线程安全，以及如何使用基本的同步机制有了基础，今天我们将深入了解 synchronize 底层机制，分析其他锁实现和应用场景。</p><p>今天我要问你的问题是 ，synchronized 底层如何实现？什么是锁的升级、降级？</p><h2 id="典型回答-15"><a href="#典型回答-15" class="headerlink" title="典型回答"></a>典型回答</h2><p>在回答这个问题前，先简单复习一下上一讲的知识点。synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现<a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#d5e13622">单元</a>。</p><p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p><p>现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p><p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（<a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare and swap</a>），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p><p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p><p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（<a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">SafePoint</a>）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p><h2 id="考点分析-15"><a href="#考点分析-15" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题主要是考察你对 Java 内置锁实现的掌握，也是并发的经典题目。我在前面给出的典型回答，涵盖了一些基本概念。如果基础不牢，有些概念理解起来就比较晦涩，我建议还是尽量理解和掌握，即使有不懂的也不用担心，在后续学习中还会逐步加深认识。</p><p>我个人认为，能够基础性地理解这些概念和机制，其实对于大多数并发编程已经足够了，毕竟大部分工程师未必会进行更底层、更基础的研发，很多时候解决的是知道与否，真正的提高还要靠实践踩坑。</p><p>后面我会进一步分析：</p><ul><li>从源码层面，稍微展开一些 synchronized 的底层实现，并补充一些上面答案中欠缺的细节，有同学反馈这部分容易被问到。如果你对 Java 底层源码有兴趣，但还没有找到入手点，这里可以成为一个切入点。</li><li>理解并发包中 java.util.concurrent.lock 提供的其他锁实现，毕竟 Java 可不是只有 ReentrantLock 一种显式的锁类型，我会结合代码分析其使用。</li></ul><h2 id="知识扩展-15"><a href="#知识扩展-15" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>我在<a href="http://time.geekbang.org/column/article/8799">上一讲</a>提到过 synchronized 是 JVM 内部的 Intrinsic Lock，所以偏斜锁、轻量级锁、重量级锁的代码实现，并不在核心类库部分，而是在 JVM 的代码中。</p><p>Java 代码运行可能是解释模式也可能是编译模式（如果不记得，请复习<a href="http://time.geekbang.org/column/article/6845">专栏第 1 讲</a>），所以对应的同步逻辑实现，也会分散在不同模块下，比如，解释器版本就是：</p><p><a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/interpreter/interpreterRuntime.cpp">src/hotspot/share/interpreter/interpreterRuntime.cpp</a></p><p>为了简化便于理解，我这里会专注于通用的基类实现：</p><p><a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/">src/hotspot/share/runtime/</a></p><p>另外请注意，链接指向的是最新 JDK 代码库，所以可能某些实现与历史版本有所不同。</p><p>首先，synchronized 的行为是 JVM runtime 的一部分，所以我们需要先找到 Runtime 相关的功能实现。通过在代码中查询类似“monitor_enter”或“Monitor Enter”，很直观的就可以定位到：</p><ul><li><a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/sharedRuntime.cpp">sharedRuntime.cpp</a>/hpp，它是解释器和编译器运行时的基类。</li><li><a href="https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp">synchronizer.cpp</a>/hpp，JVM 同步相关的各种基础逻辑。</li></ul><p>在 sharedRuntime.cpp 中，下面代码体现了 synchronized 的主要逻辑。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Handle <span class="built_in">h_obj</span>(THREAD, obj);</span><br><span class="line">  if (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, lock, true, CHECK);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, lock, CHECK);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实现可以简单进行分解：</p><ul><li>UseBiasedLocking 是一个检查，因为，在 JVM 启动时，我们可以指定是否开启偏斜锁。</li></ul><p>偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的 synchronized 块儿时，才能体现出明显改善。实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。从具体选择来看，我还是建议需要在实践中进行测试，根据结果再决定是否使用。</p><p>还有一方面是，偏斜锁会延缓 JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:-UseBiasedLocking</span> </span><br></pre></td></tr></table></figure><ul><li>fast_enter 是我们熟悉的完整锁获取路径，slow_enter 则是绕过偏斜锁，直接进入轻量级锁获取逻辑。</li></ul><p>那么 fast_enter 是如何实现的呢？同样是通过在代码库搜索，我们可以定位到 synchronizer.cpp。 类似 fast_enter 这种实现，解释器或者动态编译器，都是拷贝这段基础逻辑，所以如果我们修改这部分逻辑，要保证一致性。这部分代码是非常敏感的，微小的问题都可能导致死锁或者正确性问题。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::<span class="built_in">fast_enter</span>(Handle obj, BasicLock* lock,</span><br><span class="line">                                bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  if (UseBiasedLocking) &#123;</span><br><span class="line">    if (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;mark()-&gt;<span class="built_in">has_bias_pattern</span>(), &quot;biases should be revoked by now&quot;);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">slow_enter</span>(obj, lock, THREAD);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我来分析下这段逻辑实现：</p><ul><li><a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp">biasedLocking</a>定义了偏斜锁相关操作，revoke_and_rebias 是获取偏斜锁的入口方法，revoke_at_safepoint 则定义了当检测到安全点时的处理逻辑。</li><li>如果获取偏斜锁失败，则进入 slow_enter。</li><li>这个方法里面同样检查是否开启了偏斜锁，但是从代码路径来看，其实如果关闭了偏斜锁，是不会进入这个方法的，所以算是个额外的保障性检查吧。</li></ul><p>另外，如果你仔细查看<a href="https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp">synchronizer.cpp</a>里，会发现不仅仅是 synchronized 的逻辑，包括从本地代码，也就是 JNI，触发的 Monitor 动作，全都可以在里面找到（jni_enter/jni_exit）。</p><p>关于<a href="http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp">biasedLocking</a>的更多细节我就不展开了，明白它是通过 CAS 设置 Mark Word 就完全够用了，对象头中 Mark Word 的结构，可以参考下图：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/b1221c308d2aaf13d0d677033ee406fc.png" alt="img"></p><p>顺着锁升降级的过程分析下去，偏斜锁到轻量级锁的过程是如何实现的呢？</p><p>我们来看看 slow_enter 到底做了什么。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::<span class="title function_ invoke__">slow_enter</span>(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = obj<span class="punctuation">-&gt;</span><span class="title function_ invoke__">mark</span>();</span><br><span class="line"> <span class="title function_ invoke__">if</span> (mark<span class="punctuation">-&gt;</span><span class="title function_ invoke__">is_neutral</span>()) &#123;</span><br><span class="line">       <span class="comment">// 将目前的 Mark Word 复制到 Displaced Header 上</span></span><br><span class="line">lock<span class="punctuation">-&gt;</span><span class="title function_ invoke__">set_displaced_header</span>(mark);</span><br><span class="line"><span class="comment">// 利用 CAS 设置对象的 Mark Word</span></span><br><span class="line">    <span class="title function_ invoke__">if</span> (mark == <span class="title function_ invoke__">obj</span>()<span class="punctuation">-&gt;</span><span class="title function_ invoke__">cas_set_mark</span>((markOop) lock, mark)) &#123;</span><br><span class="line">      <span class="title function_ invoke__">TEVENT</span>(slow_enter: release stacklock);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查存在竞争</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="title function_ invoke__">if</span> (mark<span class="punctuation">-&gt;</span><span class="title function_ invoke__">has_locker</span>() &amp;&amp;</span><br><span class="line">             THREAD<span class="punctuation">-&gt;</span><span class="title function_ invoke__">is_lock_owned</span>((address)mark<span class="punctuation">-&gt;</span><span class="title function_ invoke__">locker</span>())) &#123;</span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line">    lock<span class="punctuation">-&gt;</span><span class="title function_ invoke__">set_displaced_header</span>(NULL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 重置 Displaced Header</span></span><br><span class="line">  lock<span class="punctuation">-&gt;</span><span class="title function_ invoke__">set_displaced_header</span>(markOopDesc::<span class="title function_ invoke__">unused_mark</span>());</span><br><span class="line">  ObjectSynchronizer::<span class="title function_ invoke__">inflate</span>(THREAD,</span><br><span class="line">                          <span class="title function_ invoke__">obj</span>(),</span><br><span class="line">                              inflate_cause_monitor_enter)<span class="punctuation">-&gt;</span><span class="title function_ invoke__">enter</span>(THREAD);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>请结合我在代码中添加的注释，来理解如何从试图获取轻量级锁，逐步进入锁膨胀的过程。你可以发现这个处理逻辑，和我在这一讲最初介绍的过程是十分吻合的。</p><ul><li>设置 Displaced Header，然后利用 cas_set_mark 设置对象 Mark Word，如果成功就成功获取轻量级锁。</li><li>否则 Displaced Header，然后进入锁膨胀阶段，具体实现在 inflate 方法中。</li></ul><p>今天就不介绍膨胀的细节了，我这里提供了源代码分析的思路和样例，考虑到应用实践，再进一步增加源代码解读意义不大，有兴趣的同学可以参考我提供的[synchronizer.cpp]，例如：</p><ul><li><strong>deflate_idle_monitors</strong>是分析<strong>锁降级</strong>逻辑的入口，这部分行为还在进行持续改进，因为其逻辑是在安全点内运行，处理不当可能拖长 JVM 停顿（STW，stop-the-world）的时间。</li><li>fast_exit 或者 slow_exit 是对应的锁释放逻辑。</li></ul><p>前面分析了 synchronized 的底层实现，理解起来有一定难度，下面我们来看一些相对轻松的内容。 我在上一讲对比了 synchronized 和 ReentrantLock，Java 核心类库中还有其他一些特别的锁类型，具体请参考下面的图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/f5753a4695fd771f8178120858086811.png" alt="img"></p><p>你可能注意到了，这些锁竟然不都是实现了 Lock 接口，ReadWriteLock 是一个单独的接口，它通常是代表了一对儿锁，分别对应只读和写操作，标准类库中提供了再入版本的读写锁实现（ReentrantReadWriteLock），对应的语义和 ReentrantLock 比较相似。</p><p>StampedLock 竟然也是个单独的类型，从类图结构可以看出它是不支持再入性的语义的，也就是它不是以持有锁的线程为单位。</p><p>为什么我们需要读写锁（ReadWriteLock）等其他锁呢？</p><p>这是因为，虽然 ReentrantLock 和 synchronized 简单实用，但是行为上有一定局限性，通俗点说就是“太霸道”，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争的写操作，而是以并发读取为主，如何进一步优化并发操作的粒度呢？</p><p>Java 并发包提供的读写锁等扩展了锁的能力，它所基于的原理是多个读操作是不需要互斥的，因为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问题，所以写线程之间、读写线程之间，需要精心设计的互斥逻辑。</p><p>下面是一个基于读写锁实现的数据结构，当数据量较大，并发读多、并发写少的时候，能够比纯同步版本凸显出优势。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RWSample</span> &#123;</span><br><span class="line"><span class="keyword">private</span> final <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">String</span>&gt; m = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> final <span class="title class_">ReentrantReadWriteLock</span> rwl = <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="keyword">private</span> final <span class="title class_">Lock</span> r = rwl.<span class="title function_">readLock</span>();</span><br><span class="line"><span class="keyword">private</span> final <span class="title class_">Lock</span> w = rwl.<span class="title function_">writeLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">get</span>(<span class="params"><span class="built_in">String</span> key</span>) &#123;</span><br><span class="line">    r.<span class="title function_">lock</span>();</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot; 读锁锁定！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="title function_">get</span>(key);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        r.<span class="title function_">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">put</span>(<span class="params"><span class="built_in">String</span> key, <span class="built_in">String</span> entry</span>) &#123;</span><br><span class="line">    w.<span class="title function_">lock</span>();</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot; 写锁锁定！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="title function_">put</span>(key, entry);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        w.<span class="title function_">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在运行过程中，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到有争议的数据。</p><p>读写锁看起来比 synchronized 的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意，主要还是因为相对比较大的开销。</p><p>所以，JDK 在后期引入了 StampedLock，在提供类似读写锁的同时，还支持优化读模式。优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着读，然后通过 validate 方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。请参考我下面的样例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedSample</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>(); </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mutate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        write();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sl.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Data <span class="title function_">access</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line">    <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> read();</span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">        stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = read();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意，这里的 writeLock 和 unLockWrite 一定要保证成对调用。</p><p>你可能很好奇这些显式锁的实现机制，Java 并发包内的各种同步工具，不仅仅是各种 Lock，其他的如<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a>、<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>，甚至是早期的<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/FutureTask.html">FutureTask</a>等，都是基于一种<a href="https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AQS</a>框架。</p><p>今天，我全面分析了 synchronized 相关实现和内部运行机制，简单介绍了并发包中提供的其他显式锁，并结合样例代码介绍了其使用方法，希望对你有所帮助。</p><h2 id="一课一练-15"><a href="#一课一练-15" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的你做到心中有数了吗？思考一个问题，你知道“自旋锁”是做什么的吗？它的使用场景是什么？�K</p><h1 id="第17讲-一个线程两次调用start-方法会出现什么情况？"><a href="#第17讲-一个线程两次调用start-方法会出现什么情况？" class="headerlink" title="第17讲 一个线程两次调用start()方法会出现什么情况？"></a>第17讲 一个线程两次调用start()方法会出现什么情况？</h1><p>今天我们来深入聊聊线程，相信大家对于线程这个概念都不陌生，它是 Java 并发的基础元素，理解、操纵、诊断线程是 Java 工程师的必修课，但是你真的掌握线程了吗？</p><p>今天我要问你的问题是，一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</p><h2 id="典型回答-16"><a href="#典型回答-16" class="headerlink" title="典型回答"></a>典型回答</h2><p>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。</p><p>关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State 中，分别是：</p><ul><li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</li><li>就绪（RUNNABLE），表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。</li><li>在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。</li><li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li><li>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。</li><li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><ul><li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</li></ul><p>在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。</p><h2 id="考点分析-16"><a href="#考点分析-16" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题可以算是个常见的面试热身题目，前面的给出的典型回答，算是对基本状态和简单流转的一个介绍，如果觉得还不够直观，我在下面分析会对比一个状态图进行介绍。总的来说，理解线程对于我们日常开发或者诊断分析，都是不可或缺的基础。</p><p>面试官可能会以此为契机，从各种不同角度考察你对线程的掌握：</p><ul><li>相对理论一些的面试官可以会问你线程到底是什么以及 Java 底层实现方式。</li><li>线程状态的切换，以及和锁等并发工具类的互动。</li><li>线程编程时容易踩的坑与建议等。</li></ul><p>可以看出，仅仅是一个线程，就有非常多的内容需要掌握。我们选择重点内容，开始进入详细分析。</p><h2 id="知识扩展-16"><a href="#知识扩展-16" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来整体看一下线程是什么？</p><p>从操作系统的角度，可以简单认为，线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。</p><p>在具体实现中，线程还分为内核线程、用户线程，Java 的线程实现其实是与虚拟机相关的。对于我们最熟悉的 Sun/Oracle JDK，其线程也经历了一个演进过程，基本上在 Java 1.2 之后，JDK 已经抛弃了所谓的<a href="https://en.wikipedia.org/wiki/Green_threads">Green Thread</a>，也就是用户调度的线程，现在的模型是一对一映射到操作系统内核线程。</p><p>如果我们来看 Thread 的源码，你会发现其基本操作逻辑大都是以 JNI 形式调用的本地代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>这种实现有利有弊，总体上来说，Java 语言得益于精细粒度的线程和相关的并发操作，其构建高扩展性的大型应用的能力已经毋庸置疑。但是，其复杂性也提高了并发编程的门槛，近几年的 Go 语言等提供了协程（<a href="https://en.wikipedia.org/wiki/Coroutine">coroutine</a>），大大提高了构建并发应用的效率。于此同时，Java 也在<a href="https://openjdk.java.net/projects/loom/">Loom</a>项目中，孕育新的类似轻量级用户线程（Fiber）等机制，也许在不久的将来就可以在新版 JDK 中使用到它。</p><p>下面，我来分析下线程的基本操作。如何创建线程想必你已经非常熟悉了，请看下面的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = () -&gt; &#123;System.<span class="keyword">out</span>.println(<span class="string">&quot;Hello World!&quot;</span>);&#125;;</span><br><span class="line">Thread myThread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread.<span class="keyword">join</span>();</span><br></pre></td></tr></table></figure><p>我们可以直接扩展 Thread 类，然后实例化。但在本例中，我选取了另外一种方式，就是实现一个 Runnable，将代码逻放在 Runnable 中，然后构建 Thread 并启动（start），等待结束（join）。</p><p>Runnable 的好处是，不会受 Java 不支持类多继承的限制，重用代码实现，当我们需要重复执行相应逻辑时优点明显。而且，也能更好的与现代 Java 并发库中的 Executor 之类框架结合使用，比如将上面 start 和 join 的逻辑完全写成下面的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future future = Executors.<span class="built_in">newFixedThreadPool</span>(<span class="number">1</span>)</span><br><span class="line">.<span class="built_in">submit</span>(task)</span><br><span class="line">.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><p>这样我们就不用操心线程的创建和管理，也能利用 Future 等机制更好地处理执行结果。线程生命周期通常和业务之间没有本质联系，混淆实现需求和业务需求，就会降低开发的效率。</p><p>从线程生命周期的状态开始展开，那么在 Java 编程中，有哪些因素可能影响线程的状态呢？主要有：</p><ul><li>线程自身的方法，除了 start，还有多个 join 方法，等待线程结束；yield 是告诉调度器，主动让出 CPU；另外，就是一些已经被标记为过时的 resume、stop、suspend 之类，据我所知，在 JDK 最新版本中，destory/stop 方法将被直接移除。</li><li>基类 Object 提供了一些基础的 wait/notify/notifyAll 方法。如果我们持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify 或者 notifyAll。所以，本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式。</li><li>并发类库中的工具，比如 CountDownLatch.await() 会让当前线程进入等待状态，直到 latch 被基数为 0，这可以看作是线程间通信的 Signal。</li></ul><p>我这里画了一个状态和方法之间的对应图：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/3169b7ca899afeb0359f132fb77c29dc.png" alt="img"></p><p>Thread 和 Object 的方法，听起来简单，但是实际应用中被证明非常晦涩、易错，这也是为什么 Java 后来又引入了并发包。总的来说，有了并发包，大多数情况下，我们已经不再需要去调用 wait/notify 之类的方法了。</p><p>前面谈了不少理论，下面谈谈线程 API 使用，我会侧重于平时工作学习中，容易被忽略的一些方面。</p><p>先来看看守护线程（Daemon Thread），有的时候应用中需要一个长期驻留的服务程序，但是不希望其影响应用退出，就可以将其设置为守护线程，如果 JVM 发现只有守护线程存在时，将结束进程，具体可以参考下面代码段。<strong>注意，必须在线程启动之前设置。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">daemonThread.start();</span><br></pre></td></tr></table></figure><p>再来看看<a href="https://en.wikipedia.org/wiki/Spurious_wakeup">Spurious wakeup</a>。尤其是在多核 CPU 的系统中，线程等待存在一种可能，就是在没有任何线程广播或者发出信号的情况下，线程就被唤醒，如果处理不当就可能出现诡异的并发问题，所以我们在等待条件过程中，建议采用下面模式来书写。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">while ( isCondition()) &#123;</span><br><span class="line"><span class="built_in">waitForAConfition</span>(...);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 不推荐，可能引入 bug</span></span><br><span class="line">if ( isCondition()) &#123;</span><br><span class="line"><span class="built_in">waitForAConfition</span>(...);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Thread.onSpinWait()，这是 Java 9 中引入的特性。我在<a href="http://time.geekbang.org/column/article/9042">专栏第 16 讲</a>给你留的思考题中，提到“自旋锁”（spin-wait, busy-waiting），也可以认为其不算是一种锁，而是一种针对短期等待的性能优化技术。“onSpinWait()”没有任何行为上的保证，而是对 JVM 的一个暗示，JVM 可能会利用 CPU 的 pause 指令进一步提高性能，性能特别敏感的应用可以关注。</p><p>再有就是慎用<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a>，这是 Java 提供的一种保存线程私有信息的机制，因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息。</p><p>它的实现结构，可以参考<a href="http://hg.openjdk.java.net/jdk/jdk/file/ee8524126794/src/java.base/share/classes/java/lang/ThreadLocal.java">源码</a>，数据存储于线程相关的 ThreadLocalMap，其内部条目是弱引用，如下面片段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_ inherited__">WeakReference</span>&lt;<span class="title class_">ThreadLocal</span>&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    <span class="title class_">Object</span> value;</span><br><span class="line">    <span class="title class_">Entry</span>(<span class="title class_">ThreadLocal</span>&lt;?&gt; k, <span class="title class_">Object</span> v) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Key 为 null 时，该条目就变成“废弃条目”，相关“value”的回收，往往依赖于几个关键点，即 set、remove、rehash。</p><p>下面是 set 的示例，我进行了精简和注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">Entry[] tab = table;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];; …) &#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 替换废弃条目</span></span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       &#125; </span><br><span class="line">tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"><span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line"><span class="comment">//  扫描并清理发现的废弃条目，并检查容量是否超限</span></span><br><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();<span class="comment">// 清理废弃条目，如果仍然超限，则扩容（加倍）</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>具体的清理逻辑是实现在 cleanSomeSlots 和 expungeStaleEntry 之中，如果你有兴趣可以自行阅读。</p><p>结合<a href="http://time.geekbang.org/column/article/6970">专栏第 4 讲</a>介绍的引用类型，我们会发现一个特别的地方，通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。</p><p>这意味着，废弃项目的回收<strong>依赖于显式地触发，否则就要等待线程结束</strong>，进而回收相应 ThreadLocalMap！这就是很多 OOM 的来源，所以通常都会建议，应用一定要自己负责 remove，并且不要和线程池配合，因为 worker 线程往往是不会退出的。</p><p>今天，我介绍了线程基础，分析了生命周期中的状态和各种方法之间的对应关系，这也有助于我们更好地理解 synchronized 和锁的影响，并介绍了一些需要注意的操作，希望对你有所帮助。</p><h2 id="一课一练-16"><a href="#一课一练-16" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天我准备了一个有意思的问题，写一个最简单的打印 HelloWorld 的程序，说说看，运行这个应用，Java 至少会创建几个线程呢？然后思考一下，如何明确验证你的结论，真实情况很可能令你大跌眼镜哦。�Q</p><h1 id="第18讲-什么情况下Java程序会产生死锁？如何定位、修复？"><a href="#第18讲-什么情况下Java程序会产生死锁？如何定位、修复？" class="headerlink" title="第18讲 什么情况下Java程序会产生死锁？如何定位、修复？"></a>第18讲 什么情况下Java程序会产生死锁？如何定位、修复？</h1><p>今天，我会介绍一些日常开发中类似线程死锁等问题的排查经验，并选择一两个我自己修复过或者诊断过的核心类库死锁问题作为例子，希望不仅能在面试时，包括在日常工作中也能对你有所帮助。</p><p>今天我要问你的问题是，什么情况下 Java 程序会产生死锁？如何定位、修复？</p><h2 id="典型回答-17"><a href="#典型回答-17" class="headerlink" title="典型回答"></a>典型回答</h2><p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p><p>你可以利用下面的示例图理解基本的死锁问题：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/ea88719ec112dead21334034c9ef8a6c.png" alt="img"></p><p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p><p>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。</p><h2 id="考点分析-17"><a href="#考点分析-17" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题偏向于实用场景，大部分死锁本身并不难定位，掌握基本思路和工具使用，理解线程相关的基本概念，比如各种线程状态和同步、锁、Latch 等并发工具，就已经足够解决大多数问题了。</p><p>针对死锁，面试官可以深入考察：</p><ul><li>抛开字面上的概念，让面试者写一个可能死锁的程序，顺便也考察下基本的线程编程。</li><li>诊断死锁有哪些工具，如果是分布式环境，可能更关心能否用 API 实现吗？</li><li>后期诊断死锁还是挺痛苦的，经常加班，如何在编程中尽量避免一些典型场景的死锁，有其他工具辅助吗？</li></ul><h2 id="知识扩展-17"><a href="#知识扩展-17" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>在分析开始之前，先以一个基本的死锁程序为例，我在这里只用了两个嵌套的 synchronized 去获取锁，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockSample</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String first;</span><br><span class="line"><span class="keyword">private</span> String second;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DeadLockSample</span><span class="params">(String name, String first, String second)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.first = first;</span><br><span class="line">    <span class="built_in">this</span>.second = second;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (first) &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; obtained: &quot;</span> + first);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (second) &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; obtained: &quot;</span> + second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">    <span class="type">DeadLockSample</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockSample</span>(<span class="string">&quot;Thread1&quot;</span>, lockA, lockB);</span><br><span class="line">    <span class="type">DeadLockSample</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockSample</span>(<span class="string">&quot;Thread2&quot;</span>, lockB, lockA);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序编译执行后，几乎每次都可以重现死锁，请看下面截取的输出。另外，这里有个比较有意思的地方，为什么我先调用 Thread1 的 start，但是 Thread2 却先打印出来了呢？这就是因为线程调度依赖于（操作系统）调度器，虽然你可以通过优先级之类进行影响，但是具体情况是不确定的。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/869f3a3d7b759fbfb794f8c81047f30e.png" alt="img"></p><p>下面来模拟问题定位，我就选取最常见的 jstack，其他一些类似 JConsole 等图形化的工具，请自行查找。</p><p>首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID。</p><p>其次，调用 jstack 获取线程栈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;JAVA_HOME&#125;</span>\bin\jstack your_pid</span><br></pre></td></tr></table></figure><p>然后，分析得到的输出，具体片段如下：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/1fcc1a521b801a5f7428d5229525a38b.png" alt="img"></p><p>最后，结合代码分析线程栈信息。上面这个输出非常明显，找到处于 BLOCKED 状态的线程，按照试图获取（waiting）的锁 ID（请看我标记为相同颜色的数字）查找，很快就定位问题。 jstack 本身也会把类似的简单死锁抽取出来，直接打印出来。</p><p>在实际应用中，类死锁情况未必有如此清晰的输出，但是总体上可以理解为：</p><p><strong>区分线程状态 -&gt; 查看等待目标 -&gt; 对比 Monitor 等持有状态</strong></p><p>所以，理解线程基本状态和并发相关元素是定位问题的关键，然后配合程序调用栈结构，基本就可以定位到具体的问题代码。</p><p>如果我们是开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 Java 提供的标准管理 API，<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/management/ThreadMXBean.html#findDeadlockedThreads--">ThreadMXBean</a>，其直接就提供了 findDeadlockedThreads() 方法用于定位。为方便说明，我修改了 DeadLockSample，请看下面的代码片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line"><span class="type">ThreadMXBean</span> <span class="variable">mbean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">dlCheck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">        <span class="keyword">if</span> (threadIds != <span class="literal">null</span>) &#123;</span><br><span class="line">                     ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                     System.out.println(<span class="string">&quot;Detected deadlock threads:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">                System.out.println(threadInfo.getThreadName());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;; </span><br><span class="line">       <span class="type">ScheduledExecutorService</span> <span class="variable">scheduler</span> <span class="operator">=</span>Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 稍等 5 秒，然后每 10 秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck, <span class="number">5L</span>, <span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 死锁样例代码…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译执行，你就能看到死锁被定位到的输出。在实际应用中，就可以据此收集进一步的信息，然后进行预警等后续处理。但是要注意的是，对线程进行快照本身是一个相对重量级的操作，还是要慎重选择频度和时机。</p><p><strong>如何在编程中尽量预防死锁呢？</strong></p><p>首先，我们来总结一下前面例子中死锁的产生包含哪些基本元素。基本上死锁的发生是因为：</p><ul><li>互斥条件，类似 Java 中 Monitor 都是独占的，要么是我用，要么是你用。</li><li>互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占。</li><li>循环依赖关系，两个或者多个个体之间出现了锁的链条环。</li></ul><p>所以，我们可以据此分析可能的避免死锁的思路和方法。</p><p><strong>第一种方法</strong></p><p>如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁。否则，即使是非常精通并发编程的工程师，也难免会掉进坑里，嵌套的 synchronized 或者 lock 非常容易出问题。</p><p>我举个<a href="https://bugs.openjdk.java.net/browse/JDK-8198928">例子</a>， Java NIO 的实现代码向来以锁多著称，一个原因是，其本身模型就非常复杂，某种程度上是不得不如此；另外是在设计时，考虑到既要支持阻塞模式，又要支持非阻塞模式。直接结果就是，一些基本操作如 connect，需要操作三个锁以上，在最近的一个 JDK 改进中，就发生了死锁现象。</p><p>我将其简化为下面的伪代码，问题是暴露在 HTTP/2 客户端中，这是个非常现代的反应式风格的 API，非常推荐学习使用。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Thread HttpClient-6-SelectorManager:</span></span><br><span class="line">readLock<span class="selector-class">.lock</span>();</span><br><span class="line">writeLock<span class="selector-class">.lock</span>();</span><br><span class="line"><span class="comment">// 持有 readLock/writeLock，调用 close（）需要获得 closeLock</span></span><br><span class="line"><span class="built_in">close</span>();</span><br><span class="line"><span class="comment">// Thread HttpClient-6-Worker-2 持有 closeLock</span></span><br><span class="line">implCloseSelectableChannel (); <span class="comment">// 想获得 readLock </span></span><br></pre></td></tr></table></figure><p>在 close 发生时， HttpClient-6-SelectorManager 线程持有 readLock/writeLock，试图获得 closeLock；与此同时，另一个 HttpClient-6-Worker-2 线程，持有 closeLock，试图获得 readLock，这就不可避免地进入了死锁。</p><p>这里比较难懂的地方在于，closeLock 的持有状态（就是我标记为绿色的部分）<strong>并没有在线程栈中显示出来</strong>，请参考我在下图中标记的部分。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/b7961a84838b5429a8f59826b91ed724.png" alt="img">﻿ 更加具体来说，请查看<a href="http://hg.openjdk.java.net/jdk/jdk/file/ce06058197a4/src/java.base/share/classes/sun/nio/ch/SocketChannelImpl.java">SocketChannelImpl</a>的 663 行，对比 implCloseSelectableChannel() 方法实现和<a href="http://hg.openjdk.java.net/jdk/jdk/file/ce06058197a4/src/java.base/share/classes/java/nio/channels/spi/AbstractInterruptibleChannel.java">AbstractInterruptibleChannel.close()</a>在 109 行的代码，这里就不展示代码了。</p><p>所以，从程序设计的角度反思，如果我们赋予一段程序太多的职责，出现“既要…又要…”的情况时，可能就需要我们审视下设计思路或目的是否合理了。对于类库，因为其基础、共享的定位，比应用开发往往更加令人苦恼，需要仔细斟酌之间的平衡。</p><p><strong>第二种方法</strong></p><p>如果必须使用多个锁，尽量设计好锁的获取顺序，这个说起来简单，做起来可不容易，你可以参看著名的<a href="https://en.wikipedia.org/wiki/Banker&#39;s_algorithm">银行家算法</a>。</p><p>一般的情况，我建议可以采取些简单的辅助手段，比如：</p><ul><li>将对象（方法）和锁之间的关系，用图形化的方式表示分别抽取出来，以今天最初讲的死锁为例，因为是调用了同一个线程所以更加简单。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/1e23562b6ff34206b11c5ec07608fb59.png" alt="img"></p><ul><li>然后根据对象之间组合、调用的关系对比和组合，考虑可能调用时序。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/ee413b86e8775c63e7947955646db975.png" alt="img"></p><ul><li>按照可能时序合并，发现可能死锁的场景。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/9bbad67e205e54e8f7ec8ad37872a9e7.png" alt="img">﻿ <strong>第三种方法</strong></p><p>使用带超时的方法，为程序带来更多可控性。</p><p>类似 Object.wait(…) 或者 CountDownLatch.await(…)，都支持所谓的 timed_wait，我们完全可以就不假定该锁一定会获得，指定超时时间，并为无法得到锁时准备退出逻辑。</p><p>并发 Lock 实现，如 ReentrantLock 还支持非阻塞式的获取锁操作 tryLock()，这是一个插队行为（barging），并不在乎等待的公平性，如果执行时对象恰好没有被独占，则直接获取锁。有时，我们希望条件允许就尝试插队，不然就按照现有公平性规则等待，一般采用下面的方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">lock</span>.tryLock() || <span class="keyword">lock</span>.tryLock(timeout, unit)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><p><strong>第四种方法</strong></p><p>业界也有一些其他方面的尝试，比如通过静态代码分析（如 FindBugs）去查找固定的模式，进而定位可能的死锁或者竞争情况。实践证明这种方法也有一定作用，请参考<a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea">相关文档</a>。</p><p>除了典型应用中的死锁场景，其实还有一些更令人头疼的死锁，比如类加载过程发生的死锁，尤其是在框架大量使用自定义类加载时，因为往往不是在应用本身的代码库中，jstack 等工具也不见得能够显示全部锁信息，所以处理起来比较棘手。对此，Java 有<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/lang/cl-mt.html">官方文档</a>进行了详细解释，并针对特定情况提供了相应 JVM 参数和基本原则。</p><p>今天，我从样例程序出发，介绍了死锁产生原因，并帮你熟悉了排查死锁基本工具的使用和典型思路，最后结合实例介绍了实际场景中的死锁分析方法与预防措施，希望对你有所帮助。</p><h2 id="一课一练-17"><a href="#一课一练-17" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，有时候并不是阻塞导致的死锁，只是某个线程进入了死循环，导致其他线程一直等待，这种问题如何诊断呢？�&lt;</p><h1 id="第19讲-Java并发包提供了哪些并发工具类？"><a href="#第19讲-Java并发包提供了哪些并发工具类？" class="headerlink" title="第19讲 Java并发包提供了哪些并发工具类？"></a>第19讲 Java并发包提供了哪些并发工具类？</h1><p>通过前面的学习，我们一起回顾了线程、锁等各种并发编程的基本元素，也逐步涉及了 Java 并发包中的部分内容，相信经过前面的热身，我们能够更快地理解 Java 并发包。</p><p>今天我要问你的问题是，Java 并发包提供了哪些并发工具类？</p><h2 id="典型回答-18"><a href="#典型回答-18" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：</p><ul><li>提供了比 synchronized 更加高级的各种同步结构，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</li><li>各种线程安全的容器，比如最常见的 ConcurrentHashMap、有序的 ConcunrrentSkipListMap，或者通过类似快照机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</li><li>各种并发队列实现，如各种 BlockedQueue 实现，比较典型的 ArrayBlockingQueue、 SynchorousQueue 或针对特定场景的 PriorityBlockingQueue 等。</li><li>强大的 Executor 框架，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li></ul><h2 id="考点分析-18"><a href="#考点分析-18" class="headerlink" title="考点分析"></a>考点分析</h2><p>这个题目主要考察你对并发包了解程度，以及是否有实际使用经验。我们进行多线程编程，无非是达到几个目的：</p><ul><li>利用多线程提高程序的扩展能力，以达到业务对吞吐量的要求。</li><li>协调线程间调度、交互，以完成业务逻辑。</li><li>线程间传递数据和状态，这同样是实现业务逻辑的需要。</li></ul><p>所以，这道题目只能算作简单的开始，往往面试官还会进一步考察如何利用并发包实现某个特定的用例，分析实现的优缺点等。</p><p>如果你在这方面的基础比较薄弱，我的建议是：</p><ul><li>从总体上，把握住几个主要组成部分（前面回答中已经简要介绍）。</li><li>理解具体设计、实现和能力。</li><li>再深入掌握一些比较典型工具类的适用场景、用法甚至是原理，并熟练写出典型的代码用例。</li></ul><p>掌握这些通常就够用了，毕竟并发包提供了方方面面的工具，其实很少有机会能在应用中全面使用过，扎实地掌握核心功能就非常不错了。真正特别深入的经验，还是得靠在实际场景中踩坑来获得。</p><h2 id="知识扩展-18"><a href="#知识扩展-18" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来看看并发包提供的丰富同步结构。前面几讲已经分析过各种不同的显式锁，今天我将专注于</p><ul><li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>，允许一个或多个线程等待某些操作完成。</li><li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CyclicBarrier.html">CyclicBarrier</a>，一种辅助性的同步结构，允许多个线程等待到达某个屏障。</li><li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Semaphore.html">Semaphore</a>，Java 版本的信号量实现。</li></ul><p>Java 提供了经典信号量（<a href="https://en.wikipedia.org/wiki/Semaphore_(programming">Semaphore</a>)）的实现，它通过控制一定数量的允许（permit）的方式，来达到限制通用资源访问的目的。你可以想象一下这个场景，在车站、机场等出租车时，当很多空出租车就位时，为防止过度拥挤，调度员指挥排队等待坐车的队伍一次进来 5 个人上车，等这 5 个人坐车出发，再放进去下一批，这和 Semaphore 的工作原理有些类似。</p><p>你可以试试使用 Semaphore 来模拟实现这个调度过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsualSemaphoreSample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Action...GO!&quot;</span>);</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SemaphoreWorker</span>(semaphore));</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SemaphoreWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SemaphoreWorker</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;is waiting for a permit!&quot;</span>);</span><br><span class="line">       semaphore.acquire();</span><br><span class="line">        log(<span class="string">&quot;acquired a permit!&quot;</span>);</span><br><span class="line">        log(<span class="string">&quot;executed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;released a permit!&quot;</span>);</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        name = Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(name + <span class="string">&quot; &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是比较典型的 Semaphore 示例，其逻辑是，线程试图获得工作允许，得到许可则进行任务，然后释放许可，这时等待许可的其他线程，就可获得许可进入工作状态，直到全部处理结束。编译运行，我们就能看到 Semaphore 的允许机制对工作线程的限制。</p><p>但是，从具体节奏来看，其实并不符合我们前面场景的需求，因为本例中 Semaphore 的用法实际是保证，一直有 5 个人可以试图乘车，如果有 1 个人出发了，立即就有排队的人获得许可，而这并不完全符合我们前面的要求。</p><p>那么，我再修改一下，演示个非典型的 Semaphore 用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbnormalSemaphoreSample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyWorker</span>(semaphore));</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Action...GO!&quot;</span>);</span><br><span class="line">    semaphore.release(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Wait for permits off&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (semaphore.availablePermits()!=<span class="number">0</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Action...GO again!&quot;</span>);</span><br><span class="line">    semaphore.release(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyWorker</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;Executed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意，上面的代码，更侧重的是演示 Semaphore 的功能以及局限性，其实有很多线程编程中的反实践，比如使用了 sleep 来协调任务执行，而且使用轮询调用 availalePermits 来检测信号量获取情况，这都是很低效并且脆弱的，通常只是用在测试或者诊断场景。</p><p>总的来说，我们可以看出 Semaphore 就是个<strong>计数器</strong>，<strong>其基本逻辑基于 acquire/release</strong>，并没有太复杂的同步逻辑。</p><p>如果 Semaphore 的数值被初始化为 1，那么一个线程就可以通过 acquire 进入互斥状态，本质上和互斥锁是非常相似的。但是区别也非常明显，比如互斥锁是有持有者的，而对于 Semaphore 这种计数器结构，虽然有类似功能，但其实不存在真正意义的持有者，除非我们进行扩展包装。</p><p>下面，来看看 CountDownLatch 和 CyclicBarrier，它们的行为有一定的相似度，经常会被考察二者有什么区别，我来简单总结一下。</p><ul><li>CountDownLatch 是不可以重置的，所以无法重用；而 CyclicBarrier 则没有这种限制，可以重用。</li><li>CountDownLatch 的基本操作组合是 countDown/await。调用 await 的线程阻塞等待 countDown 足够的次数，不管你是在一个线程还是多个线程里 countDown，只要次数足够即可。所以就像 Brain Goetz 说过的，CountDownLatch 操作的是事件。</li><li>CyclicBarrier 的基本操作组合，则就是 await，当所有的伙伴（parties）都调用了 await，才会继续进行任务，并自动进行重置。<strong>注意</strong>，正常情况下，CyclicBarrier 的重置都是自动发生的，如果我们调用 reset 方法，但还有线程在等待，就会导致等待线程被打扰，抛出 BrokenBarrierException 异常。CyclicBarrier 侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。</li></ul><p>如果用 CountDownLatch 去实现上面的排队场景，该怎么做呢？假设有 10 个人排队，我们将其分成 5 个人一批，通过 CountDownLatch 来协调批次，你可以试试下面的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatchSample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FirstBatchWorker</span>(latch));</span><br><span class="line">                t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">SecondBatchWorker</span>(latch));</span><br><span class="line">            t.start();</span><br><span class="line">    &#125;</span><br><span class="line">           <span class="comment">// 注意这里也是演示目的的逻辑，并不是推荐的协调方式</span></span><br><span class="line">    <span class="keyword">while</span> ( latch.getCount() != <span class="number">1</span> )&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Wait for first batch finish&quot;</span>);</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstBatchWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FirstBatchWorker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First batch executed!&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondBatchWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SecondBatchWorker</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.latch = latch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;Second batch executed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>CountDownLatch 的调度方式相对简单，后一批次的线程进行 await，等待前一批 countDown 足够多次。这个例子也从侧面体现出了它的局限性，虽然它也能够支持 10 个人排队的情况，但是因为不能重用，如果要支持更多人排队，就不能依赖一个 CountDownLatch 进行了。其编译运行输出如下：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/46c88c7d8e0507465bddb677e4eac5b9.png" alt="img"></p><p>在实际应用中的条件依赖，往往没有这么别扭，CountDownLatch 用于线程间等待操作结束是非常简单普遍的用法。通过 countDown/await 组合进行通信是很高效的，通常不建议使用例子里那个循环等待方式。</p><p>如果用 CyclicBarrier 来表达这个场景呢？我们知道 CyclicBarrier 其实反映的是线程并行运行时的协调，在下面的示例里，从逻辑上，5 个工作线程其实更像是代表了 5 个可以就绪的空车，而不再是 5 个乘客，对比前面 CountDownLatch 的例子更有助于我们区别它们的抽象模型，请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierSample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Action...GO again!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">CyclicWorker</span>(barrier));</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CyclicWorker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CyclicWorker</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span> ; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Executed!&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让输出更能表达运行时序，我使用了 CyclicBarrier 特有的 barrierAction，当屏障被触发时，Java 会自动调度该动作。因为 CyclicBarrier 会<strong>自动</strong>进行重置，所以这个逻辑其实可以非常自然的支持更多排队人数。其编译输出如下：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/eff56d3219ce5493ecacc70a168b2b9f.png" alt="img"></p><p>Java 并发类库还提供了<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Phaser.html">Phaser</a>，功能与 CountDownLatch 很接近，但是它允许线程动态地注册到 Phaser 上面，而 CountDownLatch 显然是不能动态设置的。Phaser 的设计初衷是，实现多个线程类似步骤、阶段场景的协调，线程注册等待屏障条件触发，进而协调彼此间行动，具体请参考这个<a href="http://www.baeldung.com/java-phaser">例子</a>。</p><p>接下来，我来梳理下并发包里提供的线程安全 Map、List 和 Set。首先，请参考下面的类图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/35390aa8a6e6f9c92fda086a1b95b457.png" alt="img"></p><p>你可以看到，总体上种类和结构还是比较简单的，如果我们的应用侧重于 Map 放入或者获取的速度，而不在乎顺序，大多推荐使用 ConcurrentHashMap，反之则使用 ConcurrentSkipListMap；如果我们需要对大量数据进行非常频繁地修改，ConcurrentSkipListMap 也可能表现出优势。</p><p>我在前面的专栏，谈到了普通无顺序场景选择 HashMap，有顺序场景则可以选择类似 TreeMap 等，但是为什么并发容器里面没有 ConcurrentTreeMap 呢？</p><p>这是因为 TreeMap 要实现高效的线程安全是非常困难的，它的实现基于复杂的红黑树。为保证访问效率，当我们插入或删除节点时，会移动节点进行平衡操作，这导致在并发场景中难以进行合理粒度的同步。而 SkipList 结构则要相对简单很多，通过层次结构提高访问速度，虽然不够紧凑，空间使用有一定提高（O(nlogn)），但是在增删元素时线程安全的开销要好很多。为了方便你理解 SkipList 的内部结构，我画了一个示意图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/63b94b5b1d002bb191c75d2c48af767b.png" alt="img"></p><p>关于两个 CopyOnWrite 容器，其实 CopyOnWriteArraySet 是通过包装了 CopyOnWriteArrayList 来实现的，所以在学习时，我们可以专注于理解一种。</p><p>首先，CopyOnWrite 到底是什么意思呢？它的原理是，任何修改操作，如 add、set、remove，都会拷贝原数组，修改后替换原来的数组，通过这种防御性的方式，实现另类的线程安全。请看下面的代码片段，我进行注释的地方，可以清晰地理解其逻辑。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">add</span>(<span class="params">E e</span>) &#123;</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    <span class="title class_">Object</span>[] elements = <span class="title function_">getArray</span>();</span><br><span class="line">    int len = elements.<span class="property">length</span>;</span><br><span class="line">           <span class="comment">// 拷贝</span></span><br><span class="line">    <span class="title class_">Object</span>[] newElements = <span class="title class_">Arrays</span>.<span class="title function_">copyOf</span>(elements, len + <span class="number">1</span>);</span><br><span class="line">    newElements[len] = e;</span><br><span class="line">           <span class="comment">// 替换</span></span><br><span class="line">    <span class="title function_">setArray</span>(newElements);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">final <span class="built_in">void</span> <span class="title function_">setArray</span>(<span class="params"><span class="built_in">Object</span>[] a</span>) &#123;</span><br><span class="line">array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这种数据结构，相对比较适合读多写少的操作，不然修改的开销还是非常明显的。</p><p>今天我对 Java 并发包进行了总结，并且结合实例分析了各种同步结构和部分线程安全容器，希望对你有所帮助。</p><h2 id="一课一练-18"><a href="#一课一练-18" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？留给你的思考题是，你使用过类似 CountDownLatch 的同步结构解决实际问题吗？谈谈你的使用场景和心得。�Z</p><h1 id="第20讲-并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"><a href="#第20讲-并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？" class="headerlink" title="第20讲 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？"></a>第20讲 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</h1><p>在上一讲中，我分析了 Java 并发包中的部分内容，今天我来介绍一下线程安全队列。Java 标准库提供了非常多的线程安全队列，很容易混淆。</p><p>今天我要问你的问题是，并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</p><h2 id="典型回答-19"><a href="#典型回答-19" class="headerlink" title="典型回答"></a>典型回答</h2><p>有时候我们把并发包下面的所有容器都习惯叫作并发容器，但是严格来讲，类似 ConcurrentLinkedQueue 这种“Concurrent*”容器，才是真正代表并发。</p><p>关于问题中它们的区别：</p><ul><li>Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li><li>而 LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。</li></ul><p>不知道你有没有注意到，java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent<em>、CopyOnWrite</em>和 Blocking*等三类，同样是线程安全容器，可以简单认为：</p><ul><li>Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。</li><li>但是，凡事都是有代价的，Concurrent 往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。</li><li>与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。</li><li>弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是 100% 准确。</li><li>与此同时，读取的性能具有一定的不确定性。</li></ul><h2 id="考点分析-19"><a href="#考点分析-19" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是又是一个引子，考察你是否了解并发包内部不同容器实现的设计目的和实现区别。</p><p>队列是非常重要的数据结构，我们日常开发中很多线程间数据传递都要依赖于它，Executor 框架提供的各种线程池，同样无法离开队列。面试官可以从不同角度考察，比如：</p><ul><li>哪些队列是有界的，哪些是无界的？（很多同学反馈了这个问题）</li><li>针对特定场景需求，如何选择合适的队列实现？</li><li>从源码的角度，常见的线程安全队列是如何实现的，并进行了哪些改进以提高性能表现？</li></ul><p>为了能更好地理解这一讲，需要你掌握一些基本的队列本身和数据结构方面知识，如果这方面知识比较薄弱，《数据结构与算法分析》是一本比较全面的参考书，专栏还是尽量专注于 Java 领域的特性。</p><h2 id="知识扩展-19"><a href="#知识扩展-19" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>线程安全队列一览</strong></p><p>我在<a href="http://time.geekbang.org/column/article/7810">专栏第 8 讲</a>中介绍过，常见的集合中如 LinkedList 是个 Deque，只不过不是线程安全的。下面这张图是 Java 并发类库提供的各种各样的<strong>线程安全</strong>队列实现，注意，图中并未将非线程安全部分包含进来。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/791750d6fe7ef88ecb3897e1d029f079.png" alt="img"></p><p>我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html">Deque</a>实现，ConcurrentLinkedDeque 和 LinkedBlockingDeque。Deque 的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:</p><ul><li>尾部插入时需要的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#addLast-E-">addLast(e)</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#offerLast-E-">offerLast(e)</a>。</li><li>尾部删除所需要的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#removeLast--">removeLast()</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#pollLast--">pollLast()</a>。</li></ul><p>从上面这些角度，能够理解 ConcurrentLinkedDeque 和 LinkedBlockingQueue 的主要功能区别，也就足够日常开发的需要了。但是如果我们深入一些，通常会更加关注下面这些方面。</p><p>从行为特征来看，绝大部分 Queue 都是实现了 BlockingQueue 接口。在常规队列操作基础上，Blocking 意味着其提供了特定的等待性操作，获取时（take）等待元素进队，或者插入时（put）等待队列出现空位。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并移除队列头结点，如果必要，其会等待直到队列出现元素</span></span><br><span class="line"><span class="comment">…</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">take</span>() throws InterruptedException</span>; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素，如果队列已满，则等待直到队列出现空闲空间</span></span><br><span class="line"><span class="comment">   …</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException</span>;  </span><br></pre></td></tr></table></figure><p>另一个 BlockingQueue 经常被考察的点，就是是否有界（Bounded、Unbounded），这一点也往往会影响我们在应用开发中的选择，我这里简单总结一下。</p><ul><li>ArrayBlockingQueue 是最典型的的有界队列，其内部以 final 的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建 ArrayBlockingQueue 时，都要指定容量，如</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure><ul><li>LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为 Integer.MAX_VALUE，成为了无界队列。</li><li>SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是 1 吗？其实不是的，其内部容量是 0。</li><li>PriorityBlockingQueue 是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。</li><li>DelayedQueue 和 LinkedTransferQueue 同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是 put 操作永远也不会发生其他 BlockingQueue 的那种等待情况。</li></ul><p>如果我们分析不同队列的底层实现，BlockingQueue 基本都是基于锁实现，一起来看看典型的 LinkedBlockingQueue。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> <span class="built_in">ReentrantLock</span>(); </span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.<span class="built_in">newCondition</span>(); </span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> <span class="built_in">ReentrantLock</span>(); </span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.<span class="built_in">newCondition</span>();</span><br></pre></td></tr></table></figure><p>我在介绍 ReentrantLock 的条件变量用法的时候分析过 ArrayBlockingQueue，不知道你有没有注意到，其条件变量与 LinkedBlockingQueue 版本的实现是有区别的。notEmpty、notFull 都是同一个再入锁的条件变量，而 LinkedBlockingQueue 则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。</p><p>下面的 take 方法与 ArrayBlockingQueue 中的实现，也是有不同的，由于其内部结构是链表，需要自己维护元素数量值，请参考下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> E x;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 ConcurrentLinkedQueue 等，则是基于 CAS 的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异。</p><p>相对比较另类的 SynchronousQueue，在 Java 6 中，其实现发生了非常大的变化，利用 CAS 替换掉了原本基于锁的逻辑，同步开销比较小。它是 Executors.newCachedThreadPool() 的默认队列。</p><p><strong>队列使用场景与典型用例</strong></p><p>在实际开发中，我提到过 Queue 被广泛使用在生产者 - 消费者场景，比如利用 BlockingQueue 来实现，由于其提供的等待机制，我们可以少操心很多协调工作，你可以参考下面样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXIT_MSG</span>  <span class="operator">=</span> <span class="string">&quot;Good bye!&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 使用较小的队列，以更好地在输出中展示其影响</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = q;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5L</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Message&quot;</span> + i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced new item: &quot;</span> + msg);</span><br><span class="line">                    queue.put(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Time to say good bye!&quot;</span>);</span><br><span class="line">                queue.put(EXIT_MSG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.queue=q;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String msg;</span><br><span class="line">                <span class="keyword">while</span>(!EXIT_MSG.equalsIgnoreCase( (msg = queue.take())))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed item: &quot;</span> + msg);</span><br><span class="line">                    Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Got exit message, bye!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个典型的生产者 - 消费者样例，如果使用非 Blocking 的队列，那么我们就要自己去实现轮询、条件判断（如检查 poll 返回值是否 null）等逻辑，如果没有特别的场景要求，Blocking 实现起来代码更加简单、直观。</p><p>前面介绍了各种队列实现，在日常的应用开发中，如何进行选择呢？</p><p>以 LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue 为例，我们一起来分析一下，根据需求可以从很多方面考量：</p><ul><li>考虑应用场景中对队列边界的要求。ArrayBlockingQueue 是有明确的容量限制的，而 LinkedBlockingQueue 则取决于我们是否在创建时指定，SynchronousQueue 则干脆不能缓存任何元素。</li><li>从空间利用角度，数组结构的 ArrayBlockingQueue 要比 LinkedBlockingQueue 紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</li><li>通用场景中，LinkedBlockingQueue 的吞吐量一般优于 ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。</li><li>ArrayBlockingQueue 实现比较简单，性能更好预测，属于表现稳定的“选手”。</li><li>如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照<a href="http://time.geekbang.org/column/article/9373">专栏上一讲</a>的例子，你可能会选择 CountDownLatch，但是<a href="http://www.baeldung.com/java-synchronous-queue">SynchronousQueue</a>也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</li><li>可能令人意外的是，很多时候 SynchronousQueue 的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。</li></ul><p>今天我分析了 Java 中让人眼花缭乱的各种线程安全队列，试图从几个角度，让每个队列的特点更加明确，进而希望减少你在日常工作中使用时的困扰。</p><h2 id="一课一练-19"><a href="#一课一练-19" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？ 今天的内容侧重于 Java 自身的角度，面试官也可能从算法的角度来考察，所以今天留给你的思考题是，指定某种结构，比如栈，用它实现一个 BlockingQueue，实现思路是怎样的呢？�X</p><h1 id="第21讲-Java并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#第21讲-Java并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="第21讲 Java并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>第21讲 Java并发类库提供的线程池有哪几种？ 分别有什么特点？</h1><p>我在[专栏第 17 讲]中介绍过线程是不能够重复启动的，创建或销毁线程存在一定的开销，所以利用线程池技术来提高系统资源利用效率，并简化线程管理，已经是非常成熟的选择。</p><p>今天我要问你的问题是，Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</p><h2 id="典型回答-20"><a href="#典型回答-20" class="headerlink" title="典型回答"></a>典型回答</h2><p>通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。</p><p>Executors 目前提供了 5 种不同的线程池创建配置：</p><ul><li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li><li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li><li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li><li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li><li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>，利用<a href="https://en.wikipedia.org/wiki/Work_stealing">Work-Stealing</a>算法，并行地处理任务，不保证处理顺序。</li></ul><h2 id="考点分析-20"><a href="#考点分析-20" class="headerlink" title="考点分析"></a>考点分析</h2><p>Java 并发包中的 Executor 框架无疑是并发编程中的重点，今天的题目考察的是对几种标准线程池的了解，我提供的是一个针对最常见的应用方式的回答。</p><p>在大多数应用场景下，使用 Executors 提供的 5 个静态工厂方法就足够了，但是仍然可能需要直接利用 ThreadPoolExecutor 等构造函数创建，这就要求你对线程构造方式有进一步的了解，你需要明白线程池的设计和结构。</p><p>另外，线程池这个定义就是个容易让人误解的术语，因为 ExecutorService 除了通常意义上“池”的功能，还提供了更全面的线程管理、任务提交等方法。</p><p>Executor 框架可不仅仅是线程池，我觉得至少下面几点值得深入学习：</p><ul><li>掌握 Executor 框架的主要内容，至少要了解组成与职责，掌握基本开发用例中的使用。</li><li>对线程池和相关并发工具类型的理解，甚至是源码层面的掌握。</li><li>实践中有哪些常见问题，基本的诊断思路是怎样的。</li><li>如何根据自身应用特点合理使用线程池。</li></ul><h2 id="知识扩展-20"><a href="#知识扩展-20" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来看看 Executor 框架的基本组成，请参考下面的类图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/fc70c37867c7fbfb672fa3e37fe14b5b.png" alt="img"></p><p>我们从整体上把握一下各个类型的主要设计目的：</p><ul><li>Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦，这一点可以体会其定义的唯一方法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure><p>Executor 的设计是源于 Java 早期线程 API 使用的教训，开发者在实现应用逻辑时，被太多线程创建、调度等不相关细节所打扰。就像我们进行 HTTP 通信，如果还需要自己操作 TCP 握手，开发效率低下，质量也难以保证。</p><ul><li>ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown 等方法，也提供了更加全面的提交任务机制，如返回<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Future.html">Future</a>而不是 void 的 submit 方法。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">T</span>&gt;</span> Future<span class="tag">&lt;<span class="name">T</span>&gt;</span> submit(Callable<span class="tag">&lt;<span class="name">T</span>&gt;</span> task);</span><br></pre></td></tr></table></figure><p>注意，这个例子输入的可是<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Callable.html">Callable</a>，它解决了 Runnable 无法返回结果的困扰。</p><ul><li>Java 标准类库提供了几种基础实现，比如<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a>、<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>。这些线程池的设计特点在于其高度的可调节性和灵活性，以尽量满足复杂多变的实际应用场景，我会进一步分析其构建部分的源码，剖析这种灵活性的源头。</li><li>Executors 则从简化使用的角度，为我们提供了各种方便的静态工厂方法。</li></ul><p>下面我就从源码角度，分析线程池的设计与实现，我将主要围绕最基础的 ThreadPoolExecutor 源码。ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的扩展，主要是增加了调度逻辑，如想深入了解，你可以参考相关<a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example">教程</a>。而 ForkJoinPool 则是为 ForkJoinTask 定制的线程池，与通常意义的线程池有所不同。</p><p>这部分内容比较晦涩，罗列概念也不利于你去理解，所以我会配合一些示意图来说明。在现实应用中，理解应用与线程池的交互和线程池的内部工作过程，你可以参考下图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/18b64aee22c67f488171a73133e4d465.png" alt="img"></p><p>简单理解一下：</p><ul><li>工作队列负责存储用户提交的各个任务，这个工作队列，可以是容量为 0 的 SynchronousQueue（使用 newCachedThreadPool），也可以是像固定大小线程池（newFixedThreadPool）那样使用 LinkedBlockingQueue。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BlockingQueue</span>&lt;<span class="type">Runnable</span>&gt; workQueue; </span><br></pre></td></tr></table></figure><ul><li>内部的“线程池”，这是指保持工作线程的集合，线程池需要在运行过程中管理线程创建、销毁。例如，对于带缓存的线程池，当任务压力较大时，线程池会创建新的工作线程；当业务压力退去，线程池会在闲置一段时间（默认 60 秒）后结束线程。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">HashSet</span>&lt;<span class="type">Worker</span>&gt; workers <span class="operator">=</span> new <span class="type">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>线程池的工作线程被抽象为静态内部类 Worker，基于<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">AQS</a>实现。</p><ul><li>ThreadFactory 提供上面所需要的创建线程逻辑。</li><li>如果任务提交时被拒绝，比如线程池已经处于 SHUTDOWN 状态，需要为其提供处理逻辑，Java 标准库提供了类似<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html">ThreadPoolExecutor.AbortPolicy</a>等默认实现，也可以按照实际需求自定义。</li></ul><p>从上面的分析，就可以看出线程池的几个基本组成部分，一起都体现在线程池的构造函数中，从字面我们就可以大概猜测到其用意：</p><ul><li>corePoolSize，所谓的核心线程数，可以大致理解为长期驻留的线程数目（除非设置了 allowCoreThreadTimeOut）。对于不同的线程池，这个值可能会有很大区别，比如 newFixedThreadPool 会将其设置为 nThreads，而对于 newCachedThreadPool 则是为 0。</li><li>maximumPoolSize，顾名思义，就是线程不够时能够创建的最大线程数。同样进行对比，对于 newFixedThreadPool，当然就是 nThreads，因为其要求是固定大小，而 newCachedThreadPool 则是 Integer.MAX_VALUE。</li><li>keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，显然有些线程池不需要它。</li><li>workQueue，工作队列，必须是 BlockingQueue。</li></ul><p>通过配置不同的参数，我们就可以创建出行为大相径庭的线程池，这就是线程池高度灵活性的基础。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                      TimeUnit unit,</span></span><br><span class="line"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                      ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                      RejectedExecutionHandler handler)</span> </span><br></pre></td></tr></table></figure><p>进一步分析，线程池既然有生命周期，它的状态是如何表征的呢？</p><p>这里有一个非常有意思的设计，ctl 变量被赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。试想，实际系统中，虽然我们可以指定线程极限为 Integer.MAX_VALUE，但是因为资源限制，这只是个理论值，所以完全可以将空闲位赋予其他意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 真正决定了工作线程数的理论上限 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 线程池状态，存储在数字的高位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">…</span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; ~COUNT_MASK; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>为了让你能对线程生命周期有个更加清晰的印象，我这里画了一个简单的状态流转图，对线程池的可能状态和其内部方法之间进行了对应，如果有不理解的方法，请参考 Javadoc。<strong>注意</strong>，实际 Java 代码中并不存在所谓 Idle 状态，我添加它仅仅是便于理解。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/c50ce5f2ff4ae723c6267185699ccda1.png" alt="img"></p><p>前面都是对线程池属性和构建等方面的分析，下面我选择典型的 execute 方法，来看看其是如何工作的，具体逻辑请参考我添加的注释，配合代码更加容易理解。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>)</span> &#123;</span><br><span class="line">…</span><br><span class="line"><span class="built_in">int</span> c = ctl.<span class="keyword">get</span>();</span><br><span class="line"><span class="comment">// 检查工作线程数目，低于 corePoolSize 则添加 Worker</span></span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.<span class="keyword">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// isRunning 就是检查线程池是否被 shutdown</span></span><br><span class="line"><span class="comment">// 工作队列可能是有界的，offer 是比较友好的入队方式</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="built_in">int</span> recheck = ctl.<span class="keyword">get</span>();</span><br><span class="line"><span class="comment">// 再次进行防御性检查</span></span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试添加一个 worker，如果失败意味着已经饱和或者被 shutdown 了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池实践</strong></p><p>线程池虽然为提供了非常强大、方便的功能，但是也不是银弹，使用不当同样会导致问题。我这里介绍些典型情况，经过前面的分析，很多方面可以自然的推导出来。</p><ul><li>避免任务堆积。前面我说过 newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量系统内存，甚至是出现 OOM。诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。</li><li>避免过度扩展线程。我们通常在处理大量短时任务时，使用缓存的线程池，比如在最新的 HTTP/2 client API 中，目前的默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。</li><li>另外，如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。</li><li>避免死锁等同步问题，对于死锁的场景和排查，你可以复习<a href="http://time.geekbang.org/column/article/9266">专栏第 18 讲</a>。</li><li>尽量避免在使用线程池时操作 ThreadLocal，同样是<a href="http://time.geekbang.org/column/article/9103">专栏第 17 讲</a>已经分析过的，通过今天的线程池学习，应该更能理解其原因，工作线程的生命周期通常都会超过任务的生命周期。</li></ul><p><strong>线程池大小的选择策略</strong></p><p>上面我已经介绍过，线程池大小不合适，太多会太少，都会导致麻烦，所以我们需要去考虑一个合适的线程池大小。虽然不能完全确定，但是有一些相对普适的规则和思路。</p><ul><li>如果我们的任务主要是进行计算，那么就意味着 CPU 的处理能力是稀缺的资源，我们能够通过大量增加线程数提高计算能力吗？往往是不能的，如果线程太多，反倒可能导致大量的上下文切换开销。所以，这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。</li><li>如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 = CPU 核数 × （1 + 平均等待时间 / 平均工作时间）</span><br></pre></td></tr></table></figure><p>这些时间并不能精准预计，需要根据采样或者概要分析等方式进行计算，然后在实际中验证和调整。</p><ul><li>上面是仅仅考虑了 CPU 等限制，实际还可能受各种系统资源限制影响，例如我最近就在 Mac OS X 上遇到了大负载时<a href="https://danielmendel.github.io/blog/2013/04/07/benchmarkers-beware-the-ephemeral-port-limit/">ephemeral 端口受限</a>的情况。当然，我是通过扩大可用端口范围解决的，如果我们不能调整资源的容量，那么就只能限制工作线程的数目了。这里的资源可以是文件句柄、内存等。</li></ul><p>另外，在实际工作中，不要把解决问题的思路全部指望到调整线程池上，很多时候架构上的改变更能解决问题，比如利用背压机制的<a href="http://www.reactive-streams.org/">Reactive Stream</a>、合理的拆分等。</p><p>今天，我从 Java 创建的几种线程池开始，对 Executor 框架的主要组成、线程池结构与生命周期等方面进行了讲解和分析，希望对你有所帮助。</p><h2 id="一课一练-20"><a href="#一课一练-20" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是从逻辑上理解，线程池创建和生命周期。请谈一谈，如果利用 newSingleThreadExecutor() 创建一个线程池，corePoolSize、maxPoolSize 等都是什么数值？ThreadFactory 可能在线程池生命周期中被使用多少次？怎么验证自己的判断？�l</p><h1 id="第22讲-AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"><a href="#第22讲-AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？" class="headerlink" title="第22讲 AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？"></a>第22讲 AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</h1><p>在今天这一讲中，我来分析一下并发包内部的组成，一起来看看各种同步结构、线程池等，是基于什么原理来设计和实现的。</p><p>今天我要问你的问题是，AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？</p><h2 id="典型回答-21"><a href="#典型回答-21" class="headerlink" title="典型回答"></a>典型回答</h2><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（<a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a>）技术。</p><p>所谓 CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p><p>从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.<span class="built_in">getUnsafe</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">long</span> VALUE = U.<span class="built_in">objectFieldOffset</span>(AtomicInteger.<span class="keyword">class</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><p>具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。</p><p>Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.<span class="built_in">getAndAddInt</span>(<span class="keyword">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = <span class="built_in">getIntVolatile</span>(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="built_in">weakCompareAndSetInt</span>(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure><p>CAS 是 Java 并发中所谓 lock-free 机制的基础。</p><h2 id="考点分析-21"><a href="#考点分析-21" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题有点偏向于 Java 并发机制的底层了，虽然我们在开发中未必会涉及 CAS 的实现层面，但是理解其机制，掌握如何在 Java 中运用该技术，还是十分有必要的，尤其是这也是个并发编程的面试热点。</p><p>有的同学反馈面试官会问 CAS 更加底层是如何实现的，这依赖于 CPU 提供的特定指令，具体根据体系结构的不同还存在着明显区别。比如，x86 CPU 提供 cmpxchg 指令；而在精简指令集的体系架构中，则通常是靠一对儿指令（如“load and reserve”和“store conditional”）实现的，在大多数处理器上 CAS 都是个非常轻量级的操作，这也是其优势所在。</p><p>大部分情况下，掌握到这个程度也就够用了，我认为没有必要让每个 Java 工程师都去了解到指令级别，我们进行抽象、分工就是为了让不同层面的开发者在开发中，可以尽量屏蔽不相关的细节。</p><p>如果我作为面试官，很有可能深入考察这些方向：</p><ul><li>在什么场景下，可以采用 CAS 技术，调用 Unsafe 毕竟不是大多数场景的最好选择，有没有更加推荐的方式呢？毕竟我们掌握一个技术，cool 不是目的，更不是为了应付面试，我们还是希望能在实际产品中有价值。</li><li>对 ReentrantLock、CyclicBarrier 等并发结构底层的实现技术的理解。</li></ul><h2 id="知识扩展-21"><a href="#知识扩展-21" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>关于 CAS 的使用，你可以设想这样一个场景：在数据库产品中，为保证索引的一致性，一个常见的选择是，保证只有一个线程能够排他性地修改一个索引分区，如何在数据库抽象层面实现呢？</p><p>可以考虑为索引分区对象添加一个逻辑上的锁，例如，以当前独占的线程 ID 作为锁的数值，然后通过原子操作设置 lock 数值，来实现加锁和释放锁，伪代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AtomicBTreePartition</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="built_in">long</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span>()</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseeLock</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在 Java 代码中，我们怎么实现锁操作呢？Unsafe 似乎不是个好的选择，例如，我就注意到类似 Cassandra 等产品，因为 Java 9 中移除了 Unsafe.moniterEnter()/moniterExit()，导致无法平滑升级到新的 JDK 版本。目前 Java 提供了两种公共 API，可以实现这种 CAS 操作，比如使用 java.util.concurrent.atomic.AtomicLongFieldUpdater，它是基于反射机制创建，我们需要保证类型和字段名称正确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;AtomicBTreePartition&gt; lockFieldUpdater =</span><br><span class="line">        AtomicLongFieldUpdater.<span class="built_in">newUpdater</span>(AtomicBTreePartition.<span class="keyword">class</span>, <span class="string">&quot;lock&quot;</span>); </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">acquireLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> t = Thread.<span class="built_in">currentThread</span>().<span class="built_in">getId</span>();</span><br><span class="line">    <span class="keyword">while</span> (!lockFieldUpdater.<span class="built_in">compareAndSet</span>(<span class="keyword">this</span>, <span class="number">0L</span>, t))&#123;</span><br><span class="line">        <span class="comment">// 等待一会儿，数据库操作可能比较慢</span></span><br><span class="line">         …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/package-summary.html">Atomic 包</a>提供了最常用的原子性数据类型，甚至是引用、数组等相关原子类型和更新操作工具，是很多线程安全程序的首选。</p><p>我在专栏第七讲中曾介绍使用原子数据类型和 Atomic*FieldUpdater，创建更加紧凑的计数器实现，以替代 AtomicLong。优化永远是针对特定需求、特定目的，我这里的侧重点是介绍可能的思路，具体还是要看需求。如果仅仅创建一两个对象，其实完全没有必要进行前面的优化，但是如果对象成千上万或者更多，就要考虑紧凑性的影响了。而 atomic 包提供的<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/atomic/LongAdder.html">LongAdder</a>，在高度竞争环境下，可能就是比 AtomicLong 更佳的选择，尽管它的本质是空间换时间。</p><p>回归正题，如果是 Java 9 以后，我们完全可以采用另外一种方式实现，也就是 Variable Handle API，这是源自于<a href="https://openjdk.java.net/jeps/193">JEP 193</a>，提供了各种粒度的原子或者有序性的操作等。我将前面的代码修改为如下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> VarHandle HANDLE = MethodHandles.<span class="built_in">lookup</span>().<span class="built_in">findStaticVarHandle</span></span><br><span class="line">        (AtomicBTreePartition.<span class="keyword">class</span>, <span class="string">&quot;lock&quot;</span>); </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">acquireLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> t = Thread.<span class="built_in">currentThread</span>().<span class="built_in">getId</span>();</span><br><span class="line">    <span class="keyword">while</span> (!HANDLE.<span class="built_in">compareAndSet</span>(<span class="keyword">this</span>, <span class="number">0L</span>, t))&#123;</span><br><span class="line">        <span class="comment">// 等待一会儿，数据库操作可能比较慢</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程非常直观，首先，获取相应的变量句柄，然后直接调用其提供的 CAS 方法。</p><p>一般来说，我们进行的类似 CAS 操作，可以并且推荐使用 Variable Handle API 去实现，其提供了精细粒度的公共底层 API。我这里强调公共，是因为其 API 不会像内部 API 那样，发生不可预测的修改，这一点提供了对于未来产品维护和升级的基础保障，坦白说，很多额外工作量，都是源于我们使用了 Hack 而非 Solution 的方式解决问题。</p><p>CAS 也并不是没有副作用，试想，其常用的失败重试机制，隐含着一个假设，即竞争情况是短暂的。大多数应用场景中，确实大部分重试只会发生一次就获得了成功，但是总是有意外情况，所以在有需要的时候，还是要考虑限制自旋的次数，以免过度消耗 CPU。</p><p>另外一个就是著名的<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA</a>问题，这是通常只在 lock-free 算法下暴露的问题。我前面说过 CAS 是在更新时比较前值，如果对方只是恰好相同，例如期间发生了 A -&gt; B -&gt; A 的更新，仅仅判断数值是 A，可能导致不合理的修改操作。针对这种情况，Java 提供了 AtomicStampedReference 工具类，通过为引用建立类似版本号（stamp）的方式，来保证 CAS 的正确性，具体用法请参考这里的<a href="http://tutorials.jenkov.com/java-util-concurrent/atomicstampedreference.html">介绍</a>。</p><p>前面介绍了 CAS 的场景与实现，幸运的是，大多数情况下，Java 开发者并不需要直接利用 CAS 代码去实现线程安全容器等，更多是通过并发包等间接享受到 lock-free 机制在扩展性上的好处。</p><p>下面我来介绍一下 AbstractQueuedSynchronizer（AQS），其是 Java 并发包中，实现各种同步结构和部分其他组成单元（如线程池中的 Worker）的基础。</p><p>学习 AQS，如果上来就去看它的一系列方法（下图所示），很有可能把自己看晕，这种似懂非懂的状态也没有太大的实践意义。</p><p>我建议的思路是，尽量简化一下，理解为什么需要 AQS，如何使用 AQS，<strong>至少</strong>要做什么，再进一步结合 JDK 源代码中的实践，理解 AQS 的原理与应用。</p><p><a href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a>曾经介绍过 AQS 的设计初衷。从原理上，一种同步结构往往是可以利用其他的结构实现的，例如我在专栏第 19 讲中提到过可以使用 Semaphore 实现互斥锁。但是，对某种同步结构的倾向，会导致复杂、晦涩的实现逻辑，所以，他选择了将基础的同步相关操作抽象在 AbstractQueuedSynchronizer 中，利用 AQS 为我们构建同步结构提供了范本。</p><p>AQS 内部数据和方法，可以简单拆分为：</p><ul><li>一个 volatile 的整数成员表征状态，同时提供了 setState 和 getState 方法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure><ul><li>一个先入先出（FIFO）的等待线程队列，以实现多线程间竞争和等待，这是 AQS 机制的核心之一。</li><li>各种基于 CAS 的基础操作方法，以及各种期望具体同步结构去实现的 acquire/release 方法。</li></ul><p>利用 AQS 实现一个同步结构，至少要实现两个基本类型的方法，分别是 acquire 操作，获取资源的独占权；还有就是 release 操作，释放对某个资源的独占。</p><p>以 ReentrantLock 为例，它内部通过扩展 AQS 实现了 Sync 类型，以 AQS 的 state 来反映锁的持有情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123; …&#125;</span><br></pre></td></tr></table></figure><p>下面是 ReentrantLock 对应 acquire 和 release 操作，如果是 CountDownLatch 则可以看作是 await()/countDown()，具体实现也有区别。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>()</span> &#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span>()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>排除掉一些细节，整体地分析 acquire 方法逻辑，其直接实现是在 AQS 内部，调用了 tryAcquire 和 acquireQueued，这是两个需要搞清楚的基本部分。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void <span class="built_in">acquire</span>(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="built_in">acquireQueued</span>(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="built_in">selfInterrupt</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们来看看 tryAcquire。在 ReentrantLock 中，tryAcquire 逻辑实现在 NonfairSync 和 FairSync 中，分别提供了进一步的非公平或公平性方法，而 AQS 内部 tryAcquire 仅仅是个接近未实现的方法（直接抛异常），这是留个实现者自己定义的操作。</p><p>我们可以看到公平性在 ReentrantLock 构建时如何指定的，具体如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span>()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync(); <span class="comment">// 默认是非公平的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span>(<span class="params">boolean fair</span>)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>以非公平的 tryAcquire 为例，其内部实现了如何配合状态与 CAS 获取锁，注意，对比公平版本的 tryAcquire，它在锁无人占有时，并不检查是否有其他等待者，这里体现了非公平的语义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">// 获取当前 AQS 内部状态量</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 0 表示无人占有，则直接用 CAS 修改状态位，</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">// 不检查排队情况，直接争抢</span></span><br><span class="line">        setExclusiveOwnerThread(current);  <span class="comment">// 并设置当前线程独占锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 即使状态不是 0，也可能当前线程是锁持有者，因为这是再入锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">    <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我再来分析 acquireQueued，如果前面的 tryAcquire 失败，代表着锁争抢失败，进入排队竞争阶段。这里就是我们所说的，利用 FIFO 队列，实现线程间对锁的竞争的部分，算是是 AQS 的核心逻辑。</p><p>当前线程会被包装成为一个排他模式的节点（EXCLUSIVE），通过 addWaiter 方法添加到队列中。acquireQueued 的逻辑，简要来说，就是如果当前节点的前面是头节点，则试图获取锁，一切顺利则成为新的头节点；否则，有必要则等待，具体处理逻辑请参考我添加的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 获取前一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前一个节点是头结点，表示当前节点合适去 tryAcquire</span></span><br><span class="line">            setHead(node); <span class="comment">// acquire 成功，则设置新的头节点</span></span><br><span class="line">            p.next = <span class="literal">null</span>; <span class="comment">// 将前面节点对当前节点的引用清空</span></span><br><span class="line">            <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)) <span class="comment">// 检查是否失败后需要 park</span></span><br><span class="line">            interrupted |= parkAndCheckInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    cancelAcquire(node);<span class="comment">// 出现异常，取消</span></span><br><span class="line">    <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里线程试图获取锁的过程基本展现出来了，tryAcquire 是按照特定场景需要开发者去实现的部分，而线程间竞争则是 AQS 通过 Waiter 队列与 acquireQueued 提供的，在 release 方法中，同样会对队列进行对应操作。</p><p>今天我介绍了 Atomic 数据类型的底层技术 CAS，并通过实例演示了如何在产品代码中利用 CAS，最后介绍了并发包的基础技术 AQS，希望对你有所帮助。</p><h2 id="一课一练-21"><a href="#一课一练-21" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天布置一个源码阅读作业，AQS 中 Node 的 waitStatus 有什么作用？�G</p><h1 id="第23讲-请介绍类加载过程，什么是双亲委派模型？"><a href="#第23讲-请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="第23讲 请介绍类加载过程，什么是双亲委派模型？"></a>第23讲 请介绍类加载过程，什么是双亲委派模型？</h1><p>Java 通过引入字节码和 JVM 机制，提供了强大的跨平台能力，理解 Java 的类加载机制是深入 Java 开发的必要条件，也是个面试考察热点。</p><p>今天我要问你的问题是，请介绍类加载过程，什么是双亲委派模型？</p><h2 id="典型回答-22"><a href="#典型回答-22" class="headerlink" title="典型回答"></a>典型回答</h2><p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html">Java 虚拟机规范</a>里有非常详细的定义。</p><p>首先是加载阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p><p>第二阶段是链接（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p><ul><li>验证（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li><li>准备（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li><li>解析（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3">Java 虚拟机规范</a>中，详细介绍了类、接口、方法和字段等各个方面的解析。</li></ul><p>最后是初始化阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p><p>再来谈谈双亲委派模型，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p><h2 id="考点分析-22"><a href="#考点分析-22" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是关于 JVM 类加载方面的基础问题，我前面给出的回答参考了 Java 虚拟机规范中的主要条款。如果你在面试中回答这个问题，在这个基础上还可以举例说明。</p><p>我们来看一个经典的延伸问题，准备阶段谈到静态变量，那么对于常量和不同静态变量有什么区别？</p><p>需要明确的是，没有人能够精确的理解和记忆所有信息，如果碰到这种问题，有直接答案当然最好；没有的话，就说说自己的思路。</p><p>我们定义下面这样的类型，分别提供了普通静态变量、静态常量，常量又考虑到原始类型和引用类型可能有区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLPreparation</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并反编译一下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Javac <span class="built_in">CLPreparation</span>.java</span><br><span class="line">Javap –v <span class="built_in">CLPreparation</span>.class</span><br></pre></td></tr></table></figure><p>可以在字节码中看到这样的额外初始化逻辑：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">0:</span> <span class="string">bipush</span>    <span class="number">100</span></span><br><span class="line"><span class="attr">2:</span> <span class="string">putstatic</span> <span class="comment">#2              // Field a:I</span></span><br><span class="line"><span class="attr">5:</span> <span class="string">sipush</span>    <span class="number">10000</span></span><br><span class="line"><span class="attr">8:</span> <span class="string">invokestatic</span>  <span class="comment">#3              // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line"><span class="attr">11:</span> <span class="string">putstatic</span> <span class="comment">#4                  // Field INTEGER_CONSTANT:Ljava/lang/Integer;</span></span><br></pre></td></tr></table></figure><p>这能让我们更清楚，普通原始类型静态变量和引用类型（即使是常量），是需要额外调用 putstatic 等 JVM 指令的，这些是在显式初始化阶段执行，而不是准备阶段调用；而原始类型常量，则不需要这样的步骤。</p><p>关于类加载过程的更多细节，有非常多的优秀资料进行介绍，你可以参考大名鼎鼎的《深入理解 Java 虚拟机》，一本非常好的入门书籍。我的建议是不要仅看教程，最好能够想出代码实例去验证自己对某个方面的理解和判断，这样不仅能加深理解，还能够在未来的应用开发中使用到。</p><p>其实，类加载机制的范围实在太大，我从开发和部署的不同角度，各选取了一个典型扩展问题供你参考：</p><ul><li>如果要真正理解双亲委派模型，需要理解 Java 中类加载器的架构和职责，至少要懂具体有哪些内建的类加载器，这些是我上面的回答里没有提到的；以及如何自定义类加载器？</li><li>从应用角度，解决某些类加载问题，例如我的 Java 程序启动较慢，有没有办法尽量减小 Java 类加载的开销？</li></ul><p>另外，需要注意的是，在 Java 9 中，Jigsaw 项目为 Java 提供了原生的模块化支持，内建的类加载器结构和机制发生了明显变化。我会对此进行讲解，希望能够避免一些未来升级中可能发生的问题。</p><h2 id="知识扩展-22"><a href="#知识扩展-22" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，从架构角度，一起来看看 Java 8 以前各种类加载器的结构，下面是三种 Oracle JDK 内建的类加载器。</p><ul><li>启动类加载器（Bootstrap Class-Loader），加载 jre/lib 下面的 jar 文件，如 rt.jar。它是个超级公民，即使是在开启了 Security Manager 的时候，JDK 仍赋予了它加载的程序 AllPermission。</li></ul><p>对于做底层开发的工程师，有的时候可能不得不去试图修改 JDK 的基础代码，也就是通常意义上的核心类库，我们可以使用下面的命令行参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定新的 bootclasspath，替换 java.* 包的内部实现</span></span><br><span class="line">java -Xbootclasspath:&lt;your_boot_classpath&gt; your_App </span><br><span class="line"><span class="comment"># a 意味着 append，将指定目录添加到 bootclasspath 后面</span></span><br><span class="line">java -Xbootclasspath/a:&lt;your_dir&gt; your_App </span><br><span class="line"><span class="comment"># p 意味着 prepend，将指定目录添加到 bootclasspath 前面</span></span><br><span class="line">java -Xbootclasspath/p:&lt;your_dir&gt; your_App</span><br></pre></td></tr></table></figure><p>用法其实很易懂，例如，使用最常见的 “/p”，既然是前置，就有机会替换个别基础类的实现。</p><p>我们一般可以使用下面方法获取父加载器，但是在通常的 JDK/JRE 实现中，扩展类加载器 getParent() 都只能返回 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>扩展类加载器（Extension or Ext Class-Loader），负责加载我们放到 jre/lib/ext/ 目录下面的 jar 包，这就是所谓的 extension 机制。该目录也可以通过设置 “java.ext.dirs”来覆盖。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.ext.dirs=your_ext_dir HelloWorld</span><br></pre></td></tr></table></figure><ul><li>应用类加载器（Application or App Class-Loader），就是加载我们最熟悉的 classpath 的内容。这里有一个容易混淆的概念，系统（System）类加载器，通常来说，其默认就是 JDK 内建的应用类加载器，但是它同样是可能修改的，比如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.system.<span class="keyword">class</span>.loader=com.yourcorp.YourClassLoader HelloWorld</span><br></pre></td></tr></table></figure><p>如果我们指定了这个参数，JDK 内建的应用类加载器就会成为定制加载器的父亲，这种方式通常用在类似需要改变双亲委派模式的场景。</p><p>具体请参考下图：</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/35a3bc241d779ddcc357639547917ca1.png" alt="img"></p><p>至于前面被问到的双亲委派模型，参考这个结构图更容易理解。试想，如果不同类加载器都自己加载需要的某个类型，那么就会出现多次重复加载，完全是种浪费。</p><p>通常类加载机制有三个基本特征：</p><ul><li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如 JDK 内部的 ServiceProvider/<a href="https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。 例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的，不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li></ul><p>在 JDK 9 中，由于 Jigsaw 项目引入了 Java 平台模块化系统（JPMS），Java SE 的源代码被划分为一系列模块。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/15138305829ed15f45dd53ec38bd8379.png" alt="img"></p><p>类加载器，类文件容器等都发生了非常大的变化，我这里总结一下：</p><ul><li>前面提到的 -Xbootclasspath 参数不可用了。API 已经被划分到具体的模块，所以上文中，利用“-Xbootclasspath/p”替换某个 Java 核心类型代码，实际上变成了对相应的模块进行的修补，可以采用下面的解决方案：</li></ul><p>首先，确认要修改的类文件已经编译好，并按照对应模块（假设是 java.base）结构存放， 然后，给模块打补丁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --patch-<span class="keyword">module</span> java.base=your_patch yourApp</span><br></pre></td></tr></table></figure><ul><li>扩展类加载器被重命名为平台类加载器（Platform Class-Loader），而且 extension 机制则被移除。也就意味着，如果我们指定 java.ext.dirs 环境变量，或者 lib/ext 目录存在，JVM 将直接返回<strong>错误</strong>！建议解决办法就是将其放入 classpath 里。</li><li>部分不需要 AllPermission 的 Java 基础模块，被降级到平台类加载器中，相应的权限也被更精细粒度地限制起来。</li><li>rt.jar 和 tools.jar 同样是被移除了！JDK 的核心类库以及相关资源，被存储在 jimage 文件中，并通过新的 JRT 文件系统访问，而不是原有的 JAR 文件系统。虽然看起来很惊人，但幸好对于大部分软件的兼容性影响，其实是有限的，更直接地影响是 IDE 等软件，通常只要升级到新版本就可以了。</li><li>增加了 Layer 的抽象， JVM 启动默认创建 BootLayer，开发者也可以自己去定义和实例化 Layer，可以更加方便的实现类似容器一般的逻辑抽象。</li></ul><p>结合了 Layer，目前的 JVM 内部结构就变成了下面的层次，内建类加载器都在 BootLayer 中，其他 Layer 内部有自定义的类加载器，不同版本模块可以同时工作在不同的 Layer。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/20a6a22ae11c1be3e08c6fa0bc8a8c00.png" alt="img"></p><p>谈到类加载器，绕不过的一个话题是自定义类加载器，常见的场景有：</p><ul><li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是<a href="http://www.oracle.com/technetwork/java/javaee/overview/index.html">Java EE</a>和<a href="https://en.wikipedia.org/wiki/OSGi">OSGI</a>、<a href="https://en.wikipedia.org/wiki/Java_Platform_Module_System">JPMS</a>等框架。</li><li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。</li><li>或者是需要自己操纵字节码，动态修改或者生成类型。</li></ul><p>我们可以总体上简单理解自定义类加载过程：</p><ul><li>通过指定名称，找到其二进制实现，这里往往就是自定义类加载器会“定制”的部分，例如，在特定数据源根据名字获取字节码，或者修改或生成字节码。</li><li>然后，创建 Class 对象，并完成类加载过程。二进制信息到 Class 对象的转换，通常就依赖<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ClassLoader.html#defineClass-java.lang.String-byte:A-int-int-">defineClass</a>，我们无需自己实现，它是 final 方法。有了 Class 对象，后续完成加载过程就顺理成章了。</li></ul><p>具体实现我建议参考这个<a href="http://www.baeldung.com/java-classloaders">用例</a>。</p><p>我在<a href="http://time.geekbang.org/column/article/6845">专栏第 1 讲</a>中，就提到了由于字节码是平台无关抽象，而不是机器码，所以 Java 需要类加载和解释、编译，这些都导致 Java 启动变慢。谈了这么多类加载，有没有什么通用办法，不需要代码和其他工作量，就可以降低类加载的开销呢？</p><p>这个，可以有。</p><ul><li>在第 1 讲中提到的 AOT，相当于直接编译成机器码，降低的其实主要是解释和编译开销。但是其目前还是个试验特性，支持的平台也有限，比如，JDK 9 仅支持 Linux x64，所以局限性太大，先暂且不谈。</li><li>还有就是较少人知道的 AppCDS（Application Class-Data Sharing），CDS 在 Java 5 中被引进，但仅限于 Bootstrap Class-loader，在 8u40 中实现了 AppCDS，支持其他的类加载器，在目前 2018 年初发布的 JDK 10 中已经开源。</li></ul><p>简单来说，AppCDS 基本原理和工作过程是：</p><p>首先，JVM 将类信息加载， 解析成为元数据，并根据是否需要修改，将其分类为 Read-Only 部分和 Read-Write 部分。然后，将这些元数据直接存储在文件系统中，作为所谓的 Shared Archive。命令很简单：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java -<span class="symbol">Xshare:</span>dump -<span class="variable constant_">XX</span><span class="symbol">:+UseAppCDS</span> -<span class="variable constant_">XX</span><span class="symbol">:SharedArchiveFile=&lt;jsa&gt;</span>  \</span><br><span class="line">         -<span class="variable constant_">XX</span><span class="symbol">:SharedClassListFile=&lt;classlist&gt;</span> -<span class="variable constant_">XX</span><span class="symbol">:SharedArchiveConfigFile=&lt;config_file&gt;</span></span><br></pre></td></tr></table></figure><p>第二，在应用程序启动时，指定归档文件，并开启 AppCDS。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java -<span class="symbol">Xshare:</span>on -<span class="variable constant_">XX</span><span class="symbol">:+UseAppCDS</span> -<span class="variable constant_">XX</span><span class="symbol">:SharedArchiveFile=&lt;jsa&gt;</span> yourApp</span><br></pre></td></tr></table></figure><p>通过上面的命令，JVM 会通过内存映射技术，直接映射到相应的地址空间，免除了类加载、解析等各种开销。</p><p>AppCDS 改善启动速度非常明显，传统的 Java EE 应用，一般可以提高 20%~30% 以上；实验中使用 Spark KMeans 负载，20 个 slave，可以提高 11% 的启动速度。</p><p>与此同时，降低内存 footprint，因为同一环境的 Java 进程间可以共享部分数据结构。前面谈到的两个实验，平均可以减少 10% 以上的内存消耗。</p><p>当然，也不是没有局限性，如果恰好大量使用了运行时动态类加载，它的帮助就有限了。</p><p>今天我梳理了一下类加载的过程，并针对 Java 新版中类加载机制发生的变化，进行了相对全面的总结，最后介绍了一个改善类加载速度的特性，希望对你有所帮助。</p><h2 id="一课一练-22"><a href="#一课一练-22" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，谈谈什么是 Jar Hell 问题？你有遇到过类似情况吗，如何解决呢？�K</p><h1 id="第24讲-有哪些方法可以在运行时动态生成一个Java类？"><a href="#第24讲-有哪些方法可以在运行时动态生成一个Java类？" class="headerlink" title="第24讲 有哪些方法可以在运行时动态生成一个Java类？"></a>第24讲 有哪些方法可以在运行时动态生成一个Java类？</h1><p>在开始今天的学习前，我建议你先复习一下<a href="http://time.geekbang.org/column/article/7489">专栏第 6 讲</a>有关动态代理的内容。作为 Java 基础模块中的内容，考虑到不同基础的同学以及一个循序渐进的学习过程，我当时并没有在源码层面介绍动态代理的实现技术，仅进行了相应的技术比较。但是，有了<a href="http://time.geekbang.org/column/article/9946">上一讲</a>的类加载的学习基础后，我想是时候该进行深入分析了。</p><p>今天我要问你的问题是，有哪些方法可以在运行时动态生成一个 Java 类？</p><h2 id="典型回答-23"><a href="#典型回答-23" class="headerlink" title="典型回答"></a>典型回答</h2><p>我们可以从常见的 Java 类来源分析，通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p><p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用 Java 程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。</p><p>有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p><p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么 low 的办法呢？</p><p>你可以考虑使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考<a href="https://docs.oracle.com/javase/9/docs/api/javax/tools/package-summary.html">java.compiler</a>相关文档。</p><p>进一步思考，我们一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，是不是都可以被 JVM 加载呢？我们能不能直接生成相应的字节码，然后交给类加载器去加载呢？</p><p>当然也可以，不过直接去写字节码难度太大，通常我们可以利用 Java 字节码操纵工具和类库来实现，比如在<a href="http://time.geekbang.org/column/article/7489">专栏第 6 讲</a>中提到的<a href="https://asm.ow2.io/">ASM</a>、<a href="http://www.javassist.org/">Javassist</a>、cglib 等。</p><h2 id="考点分析-23"><a href="#考点分析-23" class="headerlink" title="考点分析"></a>考点分析</h2><p>虽然曾经被视为黑魔法，但在当前复杂多变的开发环境中，在运行时动态生成逻辑并不是什么罕见的场景。重新审视我们谈到的动态代理，本质上不就是在特定的时机，去修改已有类型实现，或者创建新的类型。</p><p>明白了基本思路后，我还是围绕类加载机制进行展开，面试过程中面试官很可能从技术原理或实践的角度考察：</p><ul><li>字节码和类加载到底是怎么无缝进行转换的？发生在整个类加载过程的哪一步？</li><li>如何利用字节码操纵技术，实现基本的动态代理逻辑？</li><li>除了动态代理，字节码操纵技术还有那些应用场景？</li></ul><h2 id="知识扩展-23"><a href="#知识扩展-23" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来理解一下，类从字节码到 Class 对象的转换，在类加载过程中，这一步是通过下面的方法提供的功能，或者 defineClass 的其他本地对等实现。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> final <span class="keyword">Class</span>&lt;?&gt; defineClass(<span class="type">String</span> name, <span class="type">byte</span>[] b, int <span class="keyword">off</span>, int len,</span><br><span class="line">                                 ProtectionDomain protectionDomain)</span><br><span class="line"><span class="keyword">protected</span> final <span class="keyword">Class</span>&lt;?&gt; defineClass(<span class="type">String</span> name, java.nio.ByteBuffer b,</span><br><span class="line">                                 ProtectionDomain protectionDomain)</span><br></pre></td></tr></table></figure><p>我这里只选取了最基础的两个典型的 defineClass 实现，Java 重载了几个不同的方法。</p><p>可以看出，只要能够生成出规范的字节码，不管是作为 byte 数组的形式，还是放到 ByteBuffer 里，都可以平滑地完成字节码到 Java 对象的转换过程。</p><p>JDK 提供的 defineClass 方法，最终都是本地代码实现的。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> native <span class="keyword">Class</span>&lt;?&gt; defineClass1(ClassLoader loader, <span class="type">String</span> name, <span class="type">byte</span>[] b, int <span class="keyword">off</span>, int len,</span><br><span class="line">                                ProtectionDomain pd, <span class="type">String</span> source); </span><br><span class="line"><span class="keyword">static</span> native <span class="keyword">Class</span>&lt;?&gt; defineClass2(ClassLoader loader, <span class="type">String</span> name, java.nio.ByteBuffer b,</span><br><span class="line">                                int <span class="keyword">off</span>, int len, ProtectionDomain pd,</span><br><span class="line">                                <span class="type">String</span> source);</span><br></pre></td></tr></table></figure><p>更进一步，我们来看看 JDK dynamic proxy 的<a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/Proxy.java">实现代码</a>。你会发现，对应逻辑是实现在 ProxyBuilder 这个静态内部类中，ProxyGenerator 生成字节码，并以 byte 数组的形式保存，然后通过调用 Unsafe 提供的 defineClass 入口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">byte[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">    proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span><br><span class="line">                                 <span class="number">0</span>, proxyClassFile.length,</span><br><span class="line">                                 loader, <span class="literal">null</span>);</span><br><span class="line">reverseProxyCache.sub(pc).putIfAbsent(loader, <span class="built_in">Boolean</span>.TRUE);</span><br><span class="line"><span class="keyword">return</span> pc;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line"><span class="comment">// 如果出现 ClassFormatError，很可能是输入参数有问题，比如，ProxyGenerator 有 bug</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面理顺了二进制的字节码信息到 Class 对象的转换过程，似乎我们还没有分析如何生成自己需要的字节码，接下来一起来看看相关的字节码操纵逻辑。</p><p>JDK 内部动态代理的逻辑，可以参考<a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/reflect/ProxyGenerator.java">java.lang.reflect.ProxyGenerator</a>的内部实现。我觉得可以认为这是种另类的字节码操纵技术，其利用了<a href="https://docs.oracle.com/javase/9/docs/api/java/io/DataOutputStream.html">DataOutputStrem</a>提供的能力，配合 hard-coded 的各种 JVM 指令实现方法，生成所需的字节码数组。你可以参考下面的示例代码。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">codeLocalLoadStore</span>(<span class="params"><span class="built_in">int</span> lvar, <span class="built_in">int</span> opcode, <span class="built_in">int</span> opcode_0,</span></span></span><br><span class="line"><span class="params"><span class="function">                            DataOutputStream <span class="keyword">out</span></span>)</span></span><br><span class="line"><span class="function">throws IOException</span></span><br><span class="line">&#123;</span><br><span class="line">assert lvar &gt;= <span class="number">0</span> &amp;&amp; lvar &lt;= <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">// 根据变量数值，以不同格式，dump 操作码</span></span><br><span class="line">    <span class="keyword">if</span> (lvar &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">out</span>.writeByte(opcode_0 + lvar);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lvar &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">out</span>.writeByte(opcode);</span><br><span class="line">    <span class="keyword">out</span>.writeByte(lvar &amp; <span class="number">0xFF</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用宽指令修饰符，如果变量索引不能用无符号 byte</span></span><br><span class="line">    <span class="keyword">out</span>.writeByte(opc_wide);</span><br><span class="line">    <span class="keyword">out</span>.writeByte(opcode);</span><br><span class="line">    <span class="keyword">out</span>.writeShort(lvar &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式的好处是没有太多依赖关系，简单实用，但是前提是你需要懂各种<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">JVM 指令</a>，知道怎么处理那些偏移地址等，实际门槛非常高，所以并不适合大多数的普通开发场景。</p><p>幸好，Java 社区专家提供了各种从底层到更高抽象水平的字节码操作类库，我们不需要什么都自己从头做。JDK 内部就集成了 ASM 类库，虽然并未作为公共 API 暴露出来，但是它广泛应用在，如<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/instrument/package-summary.html">java.lang.instrumentation</a> API 底层实现，或者<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/CallSite.html">Lambda Call Site</a>生成的内部逻辑中，这些代码的实现我就不在这里展开了，如果你确实有兴趣或有需要，可以参考类似 LamdaForm 的字节码生成逻辑：<a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java">java.lang.invoke.InvokerBytecodeGenerator</a><a href="http://hg.openjdk.java.net/jdk/jdk/file/29169633327c/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java">。</a></p><p>从相对实用的角度思考一下，实现一个简单的动态代理，都要做什么？如何使用字节码操纵技术，走通这个过程呢？</p><p>对于一个普通的 Java 动态代理，其实现过程可以简化成为：</p><ul><li>提供一个基础的接口，作为被调用类型（com.mycorp.HelloImpl）和代理类之间的统一入口，如 com.mycorp.Hello。</li><li>实现<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/reflect/InvocationHandler.html">InvocationHandler</a>，对代理对象方法的调用，会被分派到其 invoke 方法来真正实现动作。</li><li>通过 Proxy 类，调用其 newProxyInstance 方法，生成一个实现了相应基础接口的代理类实例，可以看下面的方法签名。</li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> newProxyInstance(ClassLoader loader,</span><br><span class="line">                                  <span class="keyword">Class</span>&lt;?&gt;[] interfaces,</span><br><span class="line">                                  InvocationHandler h)</span><br></pre></td></tr></table></figure><p>我们分析一下，动态代码生成是具体发生在什么阶段呢？</p><p>不错，就是在 newProxyInstance 生成代理类实例的时候。我选取了 JDK 自己采用的 ASM 作为示例，一起来看看用 ASM 实现的简要过程，请参考下面的示例代码片段。</p><p>第一步，生成对应的类，其实和我们去写 Java 代码很类似，只不过改为用 ASM 方法和指定参数，代替了我们书写的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_FRAMES); </span><br><span class="line">cw.visit(V1_8,                      <span class="comment">// 指定 Java 版本</span></span><br><span class="line">    ACC_PUBLIC,             <span class="comment">// 说明是 public 类型</span></span><br><span class="line">        <span class="string">&quot;com/mycorp/HelloProxy&quot;</span>,<span class="comment">// 指定包和类的名称</span></span><br><span class="line">    <span class="literal">null</span>,                   <span class="comment">// 签名，null 表示不是泛型</span></span><br><span class="line">    <span class="string">&quot;java/lang/Object&quot;</span>,             <span class="comment">// 指定父类</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123; <span class="string">&quot;com/mycorp/Hello&quot;</span> &#125;); <span class="comment">// 指定需要实现的接口</span></span><br></pre></td></tr></table></figure><p>更进一步，我们可以按照需要为代理对象实例，生成需要的方法和逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> cw.visitMethod(</span><br><span class="line">    ACC_PUBLIC,             <span class="comment">// 声明公共方法</span></span><br><span class="line">    <span class="string">&quot;sayHello&quot;</span>,             <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="string">&quot;()Ljava/lang/Object;&quot;</span>, <span class="comment">// 描述符</span></span><br><span class="line">    <span class="literal">null</span>,                   <span class="comment">// 签名，null 表示不是泛型</span></span><br><span class="line">    <span class="literal">null</span>);                      <span class="comment">// 可能抛出的异常，如果有，则指定字符串数组 </span></span><br><span class="line">mv.visitCode();</span><br><span class="line"><span class="comment">// 省略代码逻辑实现细节</span></span><br><span class="line">cw.visitEnd();                      <span class="comment">// 结束类字节码生成</span></span><br></pre></td></tr></table></figure><p>上面的代码虽然有些晦涩，但总体还是能多少理解其用意，不同的 visitX 方法提供了创建类型，创建各种方法等逻辑。ASM API，广泛的使用了<a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a>模式，如果你熟悉这个模式，就会知道它所针对的场景是将算法和对象结构解耦，非常适合字节码操纵的场合，因为我们大部分情况都是依赖于特定结构修改或者添加新的方法、变量或者类型等。</p><p>按照前面的分析，字节码操作最后大都应该是生成 byte 数组，ClassWriter 提供了一个简便的方法。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cw<span class="selector-class">.toByteArray</span>();</span><br></pre></td></tr></table></figure><p>然后，就可以进入我们熟知的类加载过程了，我就不再赘述了，如果你对 ASM 的具体用法感兴趣，可以参考这个<a href="http://www.baeldung.com/java-asm">教程</a>。</p><p>最后一个问题，字节码操纵技术，除了动态代理，还可以应用在什么地方？</p><p>这个技术似乎离我们日常开发遥远，但其实已经深入到各个方面，也许很多你现在正在使用的框架、工具就应用该技术，下面是我能想到的几个常见领域。</p><ul><li>各种 Mock 框架</li><li>ORM 框架</li><li>IOC 容器</li><li>部分 Profiler 工具，或者运行时诊断工具等</li><li>生成形式化代码的工具</li></ul><p>甚至可以认为，字节码操纵技术是工具和基础框架必不可少的部分，大大减少了开发者的负担。</p><p>今天我们探讨了更加深入的类加载和字节码操作方面技术。为了理解底层的原理，我选取的例子是比较偏底层的、能力全面的类库，如果实际项目中需要进行基础的字节码操作，可以考虑使用更加高层次视角的类库，例如<a href="http://bytebuddy.net/#/">Byte Buddy</a>等。</p><h2 id="一课一练-23"><a href="#一课一练-23" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？试想，假如我们有这样一个需求，需要添加某个功能，例如对某类型资源如网络通信的消耗进行统计，重点要求是，不开启时必须是<strong>零开销，而不是低开销，</strong>可以利用我们今天谈到的或者相关的技术实现吗？�W</p><h1 id="第25讲-谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"><a href="#第25讲-谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError" class="headerlink" title="第25讲 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError"></a>第25讲 谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError</h1><p>今天，我将从内存管理的角度，进一步探索 Java 虚拟机（JVM）。垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得 JVM 内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是 Java 工程师进阶的必备能力。</p><p>今天我要问你的问题是，谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</p><h2 id="典型回答-24"><a href="#典型回答-24" class="headerlink" title="典型回答"></a>典型回答</h2><p>通常可以把 JVM 内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个 JVM 进程唯一的。</p><p>首先，<strong>程序计数器</strong>（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p><p>第二，<strong>Java 虚拟机栈</strong>（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p><p>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</p><p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p><p>第三，<strong>堆</strong>（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。</p><p>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是新生代、老年代的划分。</p><p>第四，<strong>方法区</strong>（Method Area）。这也是所有线程共享的一块内存区域，用于存储所谓的元（Meta）数据，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。</p><p>由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</p><p>第五，<strong>运行时常量池</strong>（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</p><p>第六，<strong>本地方法栈</strong>（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p><h2 id="考点分析-24"><a href="#考点分析-24" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是个 JVM 领域的基础题目，我给出的答案依据的是<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-2.html#jvms-2.5">JVM 规范</a>中运行时数据区定义，这也和大多数书籍和资料解读的角度类似。</p><p>JVM 内部的概念庞杂，对于初学者比较晦涩，我的建议是在工作之余，还是要去阅读经典书籍，比如我推荐过多次的《深入理解 Java 虚拟机》。</p><p>今天这一讲作为 Java 虚拟机内存管理的开篇，我会侧重于：</p><ul><li>分析广义上的 JVM 内存结构或者说 Java 进程内存结构。</li><li>谈到 Java 内存模型，不可避免的要涉及 OutOfMemory（OOM）问题，那么在 Java 里面存在哪些种 OOM 的可能性，分别对应哪个内存区域的异常状况呢？</li></ul><p>注意，具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。我在下面的分析中，还会介绍 Oracle Hotspot JVM 的部分设计变化。</p><h2 id="知识扩展-24"><a href="#知识扩展-24" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，为了让你有个更加直观、清晰的印象，我画了一个简单的内存结构图，里面展示了我前面提到的堆、线程栈等区域，并从数量上说明了什么是线程私有，例如，程序计数器、Java 栈等，以及什么是 Java 进程唯一。另外，还额外划分出了直接内存等区域。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/360b8f453e016cb641208a6a8fb589bc.png" alt="img"></p><p>这张图反映了实际中 Java 进程内存占用，与规范中定义的 JVM 运行时数据区之间的差别，它可以看作是运行时数据区的一个超集。毕竟理论上的视角和现实中的视角是有区别的，规范侧重的是通用的、无差别的部分，而对于应用开发者来说，只要是 Java 进程在运行时会占用，都会影响到我们的工程实践。</p><p>我这里简要介绍两点区别：</p><ul><li>直接内存（Direct Memory）区域，它就是我在<a href="http://time.geekbang.org/column/article/8393">专栏第 12 讲</a>中谈到的 Direct Buffer 所直接分配的内存，也是个容易出现问题的地方。尽管，在 JVM 工程师的眼中，并不认为它是 JVM 内部内存的一部分，也并未体现 JVM 内存模型中。</li><li>JVM 本身是个本地程序，还需要其他的内存去完成各种基本任务，比如，JIT Compiler 在运行时对热点方法进行编译，就会将编译后的方法储存在 Code Cache 里面；GC 等功能需要运行在本地线程之中，类似部分都需要占用内存空间。这些是实现 JVM JIT 等功能的需要，但规范中并不涉及。</li></ul><p>如果深入到 JVM 的实现细节，你会发现一些结论似乎有些模棱两可，比如：</p><ul><li>Java 对象是不是都创建在堆上的呢？</li></ul><p>我注意到有一些观点，认为通过<a href="https://en.wikipedia.org/wiki/Escape_analysis">逃逸分析</a>，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis">文档</a>里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p><ul><li>目前很多书籍还是基于 JDK 7 以前的版本，JDK 已经发生了很大变化，Intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，Intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</li></ul><p>接下来，我们来看看什么是 OOM 问题，它可能在哪些内存区域发生？</p><p>首先，OOM 如果通俗点儿说，就是 JVM 内存不够用了，javadoc 中对<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/OutOfMemoryError.html">OutOfMemoryError</a>的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间，例如：</p><ul><li>我在[专栏第 4 讲]的引用机制分析中，已经提到了 JVM 会去尝试回收软引用指向的对象等。</li><li>在<a href="http://hg.openjdk.java.net/jdk/jdk/file/9f62267e79df/src/java.base/share/classes/java/nio/Bits.java">java.nio.BIts.reserveMemory()</a> 方法中，我们能清楚的看到，System.gc() 会被调用，以清理空间，这也是为什么在大量使用 NIO 的 Direct Buffer 之类时，通常建议不要加下面的参数，毕竟是个最后的尝试，有可能避免一定的内存不足问题。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+DisableExplictGC</span></span><br></pre></td></tr></table></figure><p>当然，也不是在任何情况下垃圾收集器都会被触发的，比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</p><p>从我前面分析的数据区的角度，除了程序计数器，其他区域都有可能会因为可能的空间不足发生 OutOfMemoryError，简单总结如下：</p><ul><li>堆内存不足是最常见的 OOM 原因之一，抛出的错误信息是“java.lang.OutOfMemoryError:Java heap space”，原因可能千奇百怪，例如，可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小；或者出现 JVM 处理引用不及时，导致堆积起来，内存无法释放等。</li><li>而对于 Java 虚拟机栈和本地方法栈，这里要稍微复杂一点。如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。</li><li>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 Intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError: PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang.OutOfMemoryError: Metaspace”。</li><li>直接内存不足，也会导致 OOM，这个已经[专栏第 11 讲]介绍过。</li></ul><p>今天是 JVM 内存部分的第一讲，算是我们先进行了热身准备，我介绍了主要的内存区域，以及在不同版本 Hotspot JVM 内部的变化，并且分析了各区域是否可能产生 OutOfMemoryError，以及 OOME 发生的典型情况。</p><h2 id="一课一练-24"><a href="#一课一练-24" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，我在试图分配一个 100M bytes 大数组的时候发生了 OOME，但是 GC 日志显示，明明堆上还有远不止 100M 的空间，你觉得可能问题的原因是什么？想要弄清楚这个问题，还需要什么信息呢？�D</p><h1 id="第26讲-如何监控和诊断JVM堆内和堆外内存使用？"><a href="#第26讲-如何监控和诊断JVM堆内和堆外内存使用？" class="headerlink" title="第26讲 如何监控和诊断JVM堆内和堆外内存使用？"></a>第26讲 如何监控和诊断JVM堆内和堆外内存使用？</h1><p>上一讲我介绍了 JVM 内存区域的划分，总结了相关的一些概念，今天我将结合 JVM 参数、工具等方面，进一步分析 JVM 内存结构，包括外部资料相对较少的堆外部分。</p><p>今天我要问你的问题是，如何监控和诊断 JVM 堆内和堆外内存使用？</p><h2 id="典型回答-25"><a href="#典型回答-25" class="headerlink" title="典型回答"></a>典型回答</h2><p>了解 JVM 内存的方法有很多，具体能力范围也有区别，简单总结如下：</p><ul><li>可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。</li></ul><p>以 JConsole 为例，其内存页面可以显示常见的<strong>堆内存</strong>和<strong>各种堆外部分</strong>使用状态。</p><ul><li>也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。</li><li>或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。</li><li>如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。</li><li>另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。</li></ul><p>这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。</p><h2 id="考点分析-25"><a href="#考点分析-25" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天选取的问题是 Java 内存管理相关的基础实践，对于普通的内存问题，掌握上面我给出的典型工具和方法就足够了。这个问题也可以理解为考察两个基本方面能力，第一，你是否真的理解了 JVM 的内部结构；第二，具体到特定内存区域，应该使用什么工具或者特性去定位，可以用什么参数调整。</p><p>对于 JConsole 等工具的使用细节，我在专栏里不再赘述，如果你还没有接触过，你可以参考<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">JConsole 官方教程</a>。我这里特别推荐<a href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">Java Mission Control</a>（JMC），这是一个非常强大的工具，不仅仅能够使用<a href="https://en.wikipedia.org/wiki/Java_Management_Extensions">JMX</a>进行普通的管理、监控任务，还可以配合<a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH171">Java Flight Recorder</a>（JFR）技术，以非常低的开销，收集和分析 JVM 底层的 Profiling 和事件等信息。目前， Oracle 已经将其开源，如果你有兴趣请可以查看 OpenJDK 的<a href="https://openjdk.java.net/projects/jmc/">Mission Control</a>项目。</p><p>关于内存监控与诊断，我会在知识扩展部分结合 JVM 参数和特性，尽量从庞杂的概念和 JVM 参数选项中，梳理出相对清晰的框架：</p><ul><li>细化对各部分内存区域的理解，堆内结构是怎样的？如何通过参数调整？</li><li>堆外内存到底包括哪些部分？具体大小受哪些因素影响？</li></ul><h2 id="知识扩展-25"><a href="#知识扩展-25" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>今天的分析，我会结合相关 JVM 参数和工具，进行对比以加深你对内存区域更细粒度的理解。</p><p>首先，堆内部是什么结构？</p><p>对于堆内存，我在上一讲介绍了最常见的新生代和老年代的划分，其内部结构随着 JVM 的发展和新 GC 方式的引入，可以有不同角度的理解，下图就是年代视角的堆结构示意图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/721e97abc93449fbdb4c071f7b3b5289.png" alt="img"></p><p>你可以看到，按照通常的 GC 年代方式划分，Java 堆内分为：</p><p>\1. 新生代</p><p>新生代是大部分对象创建和销毁的区域，在通常的 Java 应用中，绝大部分对象生命周期都是很短暂的。其内部又分为 Eden 区域，作为对象初始分配的区域；两个 Survivor，有时候也叫 from、to 区域，被用来放置从 Minor GC 中保留下来的对象。</p><ul><li><p>JVM 会随意选取一个 Survivor 区域作为“to”，然后会在 GC 过程中进行区域间拷贝，也就是将 Eden 中存活下来的对象和 from 区域的对象，拷贝到这个“to”区域。这种设计主要是为了防止内存的碎片化，并进一步清理无用对象。</p></li><li><p>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，Hotspot JVM 还有一个概念叫做 Thread Local Allocation Buffer（TLAB），据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。这是 JVM 为每个线程分配的一个私有缓存区域，否则，多线程同时分配内存时，为避免操作同一地址，可能需要使用加锁等机制，进而影响分配速度，你可以参考下面的示意图。从图中可以看出，TLAB 仍然在堆上，它是分配在 Eden 区域内的。其内部结构比较直观易懂，start、end 就是起始地址，top（指针）则表示已经分配到哪里了。所以我们分配新对象，JVM 就会移动 top，当 top 和 end 相遇时，即表示该缓存已满，JVM 会试图再从 Eden 里分配一块儿。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/f546839e98ea5d43b595235849b0f2bd.png" alt="img"></p></li></ul><p>\2. 老年代</p><p>放置长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p><p>\3. 永久代</p><p>这部分就是早期 Hotspot JVM 的方法区实现方式了，储存 Java 类元数据、常量池、Intern 字符串缓存，在 JDK 8 之后就不存在永久代这块儿了。</p><p>那么，我们如何利用 JVM 参数，直接影响堆和内部区域的大小呢？我来简单总结一下：</p><ul><li>最大堆体积</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Xmx value</span></span><br></pre></td></tr></table></figure><ul><li>初始的最小堆体积</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Xms value</span></span><br></pre></td></tr></table></figure><ul><li>老年代和新生代的比例</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:NewRatio=value</span></span><br></pre></td></tr></table></figure><p>默认情况下，这个数值是 2，意味着老年代是新生代的 2 倍大；换句话说，新生代是堆大小的 1/3。</p><ul><li>当然，也可以不用比例的方式调整新生代的大小，直接指定下面的参数，设定具体的内存大小数值。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:NewSize=value</span></span><br></pre></td></tr></table></figure><ul><li>Eden 和 Survivor 的大小是按照比例设置的，如果 SurvivorRatio 是 8，那么 Survivor 区域就是 Eden 的 1/8 大小，也就是新生代的 1/10，因为 YoungGen=Eden + 2*Survivor，JVM 参数格式是</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:SurvivorRatio=value</span></span><br></pre></td></tr></table></figure><ul><li>TLAB 当然也可以调整，JVM 实现了复杂的适应策略，如果你有兴趣可以参考这篇<a href="https://blogs.oracle.com/jonthecollector/the-real-thing">说明</a>。</li></ul><p>不知道你有没有注意到，我在年代视角的堆结构示意图也就是第一张图中，还标记出了 Virtual 区域，这是块儿什么区域呢？</p><p>在 JVM 内部，如果 Xms 小于 Xmx，堆的大小并不会直接扩展到其上限，也就是说保留的空间（reserved）大于实际能够使用的空间（committed）。当内存需求不断增长的时候，JVM 会逐渐扩展新生代等区域的大小，所以 Virtual 区域代表的就是暂时不可用（uncommitted）的空间。</p><p>第二，分析完堆内空间，我们一起来看看 JVM 堆外内存到底包括什么？</p><p>在 JMC 或 JConsole 的内存管理界面，会统计部分非堆内存，但提供的信息相对有限，下图就是 JMC 活动内存池的截图。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/fa491795ffe21c1f49982de8b7810c2e.png" alt="img"></p><p>接下来我会依赖 NMT 特性对 JVM 进行分析，它所提供的详细分类信息，非常有助于理解 JVM 内部实现。</p><p>首先来做些准备工作，开启 NMT 并选择 summary 模式，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:NativeMemoryTracking=summary</span></span><br></pre></td></tr></table></figure><p>为了方便获取和对比 NMT 输出，选择在应用退出时打印 NMT 统计信息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UnlockDiagnosticVMOptions</span> -<span class="variable constant_">XX</span><span class="symbol">:+PrintNMTStatistics</span></span><br></pre></td></tr></table></figure><p>然后，执行一个简单的在标准输出打印 HelloWorld 的程序，就可以得到下面的输出<img src="http://learn.lianglianglee.com/极客时间/assets/55f1c7f0550adbbcc885c97a4dd426bb.png" alt="img"></p><p>我来仔细分析一下，NMT 所表征的 JVM 本地内存使用：</p><ul><li>第一部分非常明显是 Java 堆，我已经分析过使用什么参数调整，不再赘述。</li><li>第二部分是 Class 内存占用，它所统计的就是 Java 类元数据所占用的空间，JVM 可以通过类似下面的参数调整其大小：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:MaxMetaspaceSize=value</span></span><br></pre></td></tr></table></figure><p>对于本例，因为 HelloWorld 没有什么用户类库，所以其内存占用主要是启动类加载器（Bootstrap）加载的核心类库。你可以使用下面的小技巧，调整启动类加载器元数据区，这主要是为了对比以加深理解，也许只有在 hack JDK 时才有实际意义。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:InitialBootClassLoaderMetaspaceSize=30720</span></span><br></pre></td></tr></table></figure><ul><li>下面是 Thread，这里既包括 Java 线程，如程序主线程、Cleaner 线程等，也包括 GC 等本地线程。你有没有注意到，即使是一个 HelloWorld 程序，这个线程数量竟然还有 25。似乎有很多浪费，设想我们要用 Java 作为 Serverless 运行时，每个 function 是非常短暂的，如何降低线程数量呢？ 如果你充分理解了专栏讲解的内容，对 JVM 内部有了充分理解，思路就很清晰了： JDK 9 的默认 GC 是 G1，虽然它在较大堆场景表现良好，但本身就会比传统的 Parallel GC 或者 Serial GC 之类复杂太多，所以要么降低其并行线程数目，要么直接切换 GC 类型； JIT 编译默认是开启了 TieredCompilation 的，将其关闭，那么 JIT 也会变得简单，相应本地线程也会减少。 我们来对比一下，这是默认参数情况的输出：<img src="http://learn.lianglianglee.com/极客时间/assets/97d060b306e44af3a8443f932a0a4d42.png" alt="img"></li></ul><p>下面是替换了默认 GC，并关闭 TieredCompilation 的命令行<img src="http://learn.lianglianglee.com/极客时间/assets/b07d6da56f588cbfadbb7b381346213b.png" alt="img"></p><p>得到的统计信息如下，线程数目从 25 降到了 17，消耗的内存也下降了大概 1/3。<img src="http://learn.lianglianglee.com/极客时间/assets/593735623f6917695602095fd249d527.png" alt="img"></p><ul><li>接下来是 Code 统计信息，显然这是 CodeCache 相关内存，也就是 JIT compiler 存储编译热点方法等信息的地方，JVM 提供了一系列参数可以限制其初始值和最大值等，例如：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:InitialCodeCacheSize=value</span></span><br><span class="line"></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:ReservedCodeCacheSize=value</span></span><br></pre></td></tr></table></figure><p>你可以设置下列 JVM 参数，也可以只设置其中一个，进一步判断不同参数对 CodeCache 大小的影响。<img src="http://learn.lianglianglee.com/极客时间/assets/945740c37433f783d2d877c67dcc1170.png" alt="img"><img src="http://192.168.73.85:8080/极客时间/Java基础36讲/assets/82d1fbc9ca09698c01ccff18fb97c8cd.png" alt="img"></p><p>很明显，CodeCache 空间下降非常大，这是因为我们关闭了复杂的 TieredCompilation，而且还限制了其初始大小。</p><ul><li>下面就是 GC 部分了，就像我前面介绍的，G1 等垃圾收集器其本身的设施和数据结构就非常复杂和庞大，例如 Remembered Set 通常都会占用 20%~30% 的堆空间。如果我把 GC 明确修改为相对简单的 Serial GC，会有什么效果呢？</li></ul><p>使用命令：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseSerialGC</span></span><br></pre></td></tr></table></figure><p><img src="http://learn.lianglianglee.com/极客时间/assets/6eeee6624c7dc6be54bfce5e93064233.png" alt="img"></p><p>可见，不仅总线程数大大降低（25 → 13），而且 GC 设施本身的内存开销就少了非常多。据我所知，AWS Lambda 中 Java 运行时就是使用的 Serial GC，可以大大降低单个 function 的启动和运行开销。</p><ul><li>Compiler 部分，就是 JIT 的开销，显然关闭 TieredCompilation 会降低内存使用。</li><li>其他一些部分占比都非常低，通常也不会出现内存使用问题，请参考<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr022.html#BABCBGFA">官方文档</a>。唯一的例外就是 Internal（JDK 11 以后在 Other 部分）部分，其统计信息<strong>包含着 Direct Buffer 的直接内存</strong>，这其实是堆外内存中比较敏感的部分，很多堆外内存 OOM 就发生在这里，请参考专栏第 12 讲的处理步骤。原则上 Direct Buffer 是不推荐频繁创建或销毁的，如果你怀疑直接内存区域有问题，通常可以通过类似 instrument 构造函数等手段，排查可能的问题。</li></ul><p>JVM 内部结构就介绍到这里，主要目的是为了加深理解，很多方面只有在定制或调优 JVM 运行时才能真正涉及，随着微服务和 Serverless 等技术的兴起，JDK 确实存在着为新特征的工作负载进行定制的需求。</p><p>今天我结合 JVM 参数和特性，系统地分析了 JVM 堆内和堆外内存结构，相信你一定对 JVM 内存结构有了比较深入的了解，在定制 Java 运行时或者处理 OOM 等问题的时候，思路也会更加清晰。JVM 问题千奇百怪，如果你能快速将问题缩小，大致就能清楚问题可能出在哪里，例如如果定位到问题可能是堆内存泄漏，往往就已经有非常清晰的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks004.html#CIHIEEFH">思路和工具</a>可以去解决了。</p><h2 id="一课一练-25"><a href="#一课一练-25" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，如果用程序的方式而不是工具，对 Java 内存使用进行监控，有哪些技术可以做到?�6</p><h1 id="第27讲-Java常见的垃圾收集器有哪些？"><a href="#第27讲-Java常见的垃圾收集器有哪些？" class="headerlink" title="第27讲 Java常见的垃圾收集器有哪些？"></a>第27讲 Java常见的垃圾收集器有哪些？</h1><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展， Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p>今天我要问你的问题是，Java 常见的垃圾收集器有哪些？</p><h2 id="典型回答-26"><a href="#典型回答-26" class="headerlink" title="典型回答"></a>典型回答</h2><p>实际上，垃圾收集器（GC，Garbage Collector）是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle），不同版本的 JVM，提供的选择也不同。接下来，我来谈谈最主流的 Oracle JDK。</p><ul><li>Serial GC，它是最古老的垃圾收集器，“Serial”体现在其收集工作是单线程的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。 从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了标记 - 整理（Mark-Compact）算法，区别于新生代的复制算法。 Serial GC 的对应 JVM 参数是：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseSerialGC</span></span><br></pre></td></tr></table></figure><ul><li>ParNew GC，很明显是个新生代 GC 实现，它实际是 Serial GC 的多线程版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseConcMarkSweepGC</span> -<span class="variable constant_">XX</span><span class="symbol">:+UseParNewGC</span></span><br></pre></td></tr></table></figure><ul><li>CMS（Concurrent Mark Sweep） GC，基于标记 - 清除（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。</li><li>Parrallel GC，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是吞吐量优先的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是新生代和老年代 GC 都是并行进行的，在常见的服务器环境中更加高效。 开启选项是：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseParallelGC</span></span><br></pre></td></tr></table></figure><p>另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:MaxGCPauseMillis=value</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:GCTimeRatio=N</span> /<span class="regexp">/ GC 时间和用户时间比例 = 1 /</span> (N+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>G1 GC 这是一种兼顾吞吐量和停顿时间的 GC 实现，是 Oracle JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。 G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。 G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。</li></ul><h2 id="考点分析-26"><a href="#考点分析-26" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是考察你对 GC 的了解，GC 是 Java 程序员的面试常见题目，但是并不是每个人都有机会或者必要对 JVM、GC 进行深入了解，我前面的总结是为不熟悉这部分内容的同学提供一个整体的印象。</p><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。在今天的讲解中，我侧重介绍比较通用、基础性的部分：</p><ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul><p>另外，Java 一直处于非常迅速的发展之中，在最新的 JDK 实现中，还有多种新的 GC，我会在最后补充，除了前面提到的垃圾收集器，看看还有哪些值得关注的选择。</p><h2 id="知识扩展-26"><a href="#知识扩展-26" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>垃圾收集的原理和基础概念</strong></p><p>第一，自动垃圾收集的前提是清楚哪些内存可以被释放。这一点可以结合我前面对 Java 类加载和内存结构的分析，来思考一下。</p><p>主要就是两个方面，最主要部分就是对象实例，都是存储在堆上的；还有就是方法区中的元数据等信息，例如类型不再使用，卸载该 Java 类似乎是很合理的。</p><p>对于对象实例收集，主要是两种基本算法，<a href="https://zh.wikipedia.org/wiki/引用计数">引用计数</a>和可达性分析。</p><ul><li>引用计数算法，顾名思义，就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。这是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。 Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>另外就是 Java 选择的可达性分析，Java 的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，具体请参考<a href="http://time.geekbang.org/column/article/6970">专栏第 4 讲</a>，这种类型的垃圾收集通常叫作追踪性垃圾收集（<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">Tracing Garbage Collection</a>）。其原理简单来说，就是将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。JVM 会把虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量，作为 GC Roots。</li></ul><p>方法区无用元数据的回收比较复杂，我简单梳理一下。还记得我对类加载器的分类吧，一般来说初始化类加载器加载的类型是不会进行类卸载（unload）的；而普通的类型的卸载，往往是要求相应自定义类加载器本身被回收，所以大量使用动态类型的场合，需要防止元数据区（或者早期的永久代）不会 OOM。在 8u40 以后的 JDK 中，下面参数已经是默认的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+ClassUnloadingWithConcurrentMark</span></span><br></pre></td></tr></table></figure><p>第二，常见的垃圾收集算法，我认为总体上有个了解，理解相应的原理和优缺点，就已经足够了，其主要分为三类：</p><ul><li>复制（Copying）算法，我前面讲到的新生代 GC，基本都是基于复制算法，过程就如<a href="http://time.geekbang.org/column/article/10325">专栏上一讲</a>所介绍的，将活着的对象复制到 to 区域，拷贝过程中将对象顺序放置，就可以避免内存碎片化。 这么做的代价是，既然要进行复制，既要提前预留内存空间，有一定的浪费；另外，对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，这个开销也不小，不管是内存占用或者时间开销。</li><li>标记 - 清除（Mark-Sweep）算法，首先进行标记工作，标识出所有要回收的对象，然后进行清除。这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现 Full GC，暂停时间可能根本无法接受。</li><li>标记 - 整理（Mark-Compact），类似于标记 - 清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间。</li></ul><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p><p>如果对这方面的算法有兴趣，可以参考一本比较有意思的书《垃圾回收的算法与实现》，虽然其内容并不是围绕 Java 垃圾收集，但是对通用算法讲解比较形象。</p><p><strong>垃圾收集过程的理解</strong></p><p>我在<a href="http://time.geekbang.org/column/article/10325">专栏上一讲</a>对堆结构进行了比较详细的划分，在垃圾收集的过程，对应到 Eden、Survivor、Tenured 等区域会发生什么变化呢？</p><p>这实际上取决于具体的 GC 方式，先来熟悉一下通常的垃圾收集流程，我画了一系列示意图，希望能有助于你理解清楚这个过程。</p><p>第一，Java 应用不断创建对象，通常都是分配在 Eden 区域，当其空间占用达到一定阈值时，触发 minor GC。仍然被引用的对象（绿色方块）存活下来，被复制到 JVM 选择的 Survivor 区域，而没有被引用的对象（黄色方块）则被回收。注意，我给存活对象标记了“数字 1”，这是为了表明对象的存活时间。<img src="http://learn.lianglianglee.com/极客时间/assets/44d4a92e8e20f46e6646eae53442256d.png" alt="img"></p><p>第二， 经过一次 Minor GC，Eden 就会空闲下来，直到再次达到 Minor GC 触发条件，这时候，另外一个 Survivor 区域则会成为 to 区域，Eden 区域的存活对象和 From 区域对象，都会被复制到 to 区域，并且存活的年龄计数会被加 1。<img src="http://learn.lianglianglee.com/极客时间/assets/3be4ac4834e2790a8211252f2bebfd48.png" alt="img"></p><p>第三， 类似第二步的过程会发生很多次，直到有对象年龄计数达到阈值，这时候就会发生所谓的晋升（Promotion）过程，如下图所示，超过阈值的对象会被晋升到老年代。这个阈值是可以通过参数指定：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:MaxTenuringThreshold=&lt;N&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://learn.lianglianglee.com/极客时间/assets/dbcb15c99b368773145b358734e10e8d.png" alt="img"></p><p>后面就是老年代 GC，具体取决于选择的 GC 选项，对应不同的算法。下面是一个简单标记 - 整理算法过程示意图，老年代中的无用对象被清除后， GC 会将对象进行整理，以防止内存碎片化。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/399a0c23d1d57e08a2603fb76f328e25.png" alt="img"></p><p>通常我们把老年代 GC 叫作 Major GC，将对整个堆进行的清理叫作 Full GC，但是这个也没有那么绝对，因为不同的老年代 GC 算法其实表现差异很大，例如 CMS，“concurrent”就体现在清理工作是与工作线程一起并发运行的。</p><p><strong>GC 的新发展</strong></p><p>GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如， JDK 10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。</p><p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但是已经被标记为废弃，如果没有组织主动承担 CMS 的维护，很有可能会在未来版本移除。</p><p>如果你有关注目前尚处于开发中的 JDK 11，你会发现，JDK 又增加了两种全新的 GC 方式，分别是：</p><ul><li><a href="https://openjdk.java.net/jeps/318">Epsilon GC</a>，简单说就是个不做垃圾收集的 GC，似乎有点奇怪，有的情况下，例如在进行性能测试的时候，可能需要明确判断 GC 本身产生了多大的开销，这就是其典型应用场景。</li><li><a href="https://openjdk.java.net/jeps/333">ZGC</a>，这是 Oracle 开源出来的一个超级 GC 实现，具备令人惊讶的扩展能力，比如支持 T bytes 级别的堆大小，并且保证绝大部分情况下，延迟都不会超过 10 ms。虽然目前还处于实验阶段，仅支持 Linux 64 位的平台，但其已经表现出的能力和潜力都非常令人期待。</li></ul><p>当然，其他厂商也提供了各种独具一格的 GC 实现，例如比较有名的低延迟 GC，<a href="https://www.infoq.com/articles/azul_gc_in_detail">Zing</a>和<a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Shenandoah</a>等，有兴趣请参考我提供的链接。</p><p>今天，作为 GC 系列的第一讲，我从整体上梳理了目前的主流 GC 实现，包括基本原理和算法，并结合我前面介绍过的内存结构，对简要的垃圾收集过程进行了介绍，希望能够对你的相关实践有所帮助。</p><h2 id="一课一练-26"><a href="#一课一练-26" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天谈了一堆的理论，思考一个实践中的问题，你通常使用什么参数去打开 GC 日志呢？还会额外添加哪些选项？�(</p><h1 id="第28讲-谈谈你的GC调优思路"><a href="#第28讲-谈谈你的GC调优思路" class="headerlink" title="第28讲 谈谈你的GC调优思路"></a>第28讲 谈谈你的GC调优思路</h1><p>我发现，目前不少外部资料对 G1 的介绍大多还停留在 JDK 7 或更早期的实现，很多结论已经存在较大偏差，甚至一些过去的 GC 选项已经不再推荐使用。所以，今天我会选取新版 JDK 中的默认 G1 GC 作为重点进行详解，并且我会从调优实践的角度，分析典型场景和调优思路。下面我们一起来更新下这方面的知识。</p><p>今天我要问你的问题是，谈谈你的 GC 调优思路？</p><h2 id="典型回答-27"><a href="#典型回答-27" class="headerlink" title="典型回答"></a>典型回答</h2><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，内存占用（footprint）、延时（latency）和吞吐量（throughput），大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p><p>基本的调优思路可以总结为：</p><ul><li>理解应用需求和问题，确定调优目标。假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。</li><li>掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li><li>这里需要思考，选择的 GC 类型是否符合我们的应用特征，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。</li><li>通过分析确定具体调整的参数或者软硬件配置。</li><li>验证是否达到调优目标，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。</li></ul><h2 id="考点分析-27"><a href="#考点分析-27" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天考察的 GC 调优问题是 JVM 调优的一个基础方面，很多 JVM 调优需求，最终都会落实在 GC 调优上或者与其相关，我提供的是一个常见的思路。</p><p>真正快速定位和解决具体问题，还是需要对 JVM 和 GC 知识的掌握，以及实际调优经验的总结，有的时候甚至是源自经验积累的直觉判断。面试官可能会继续问项目中遇到的真实问题，如果你能清楚、简要地介绍其上下文，然后将诊断思路和调优实践过程表述出来，会是个很好的加分项。</p><p>专栏虽然无法提供具体的项目经验，但是可以帮助你掌握常见的调优思路和手段，这不管是面试还是在实际工作中都是很有帮助的。另外，我会还会从下面不同角度进行补充：</p><ul><li><a href="http://time.geekbang.org/column/article/10513">上一讲</a>中我已经谈到，涉及具体的 GC 类型，JVM 的实际表现要更加复杂。目前，G1 已经成为新版 JDK 的默认选择，所以值得你去深入理解。</li><li>因为 G1 GC 一直处在快速发展之中，我会侧重它的演进变化，尤其是行为和配置相关的变化。并且，同样是因为 JVM 的快速发展，即使是收集 GC 日志等方面也发生了较大改进，这也是为什么我在上一讲留给你的思考题是有关日志相关选项，看完讲解相信你会很惊讶。</li><li>从 GC 调优实践的角度，理解通用问题的调优思路和手段。</li></ul><h2 id="知识扩展-27"><a href="#知识扩展-27" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，先来整体了解一下 G1 GC 的内部结构和主要机制。</p><p>从内存区域的角度，G1 同样存在着年代的概念，但是与我前面介绍的内存结构很不一样，其内部是类似棋盘状的一个个 region 组成，请参考下面的示意图。<img src="http://learn.lianglianglee.com/极客时间/assets/a662fda0de8af087c37c40a86a9cf3f1.png" alt="img"></p><p>region 的大小是一致的，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region，这点可以从源码<a href="http://hg.openjdk.java.net/jdk/jdk/file/fa2f93f99dbc/src/hotspot/share/gc/g1/heapRegionBounds.hpp">heapRegionBounds.hpp</a>中看到。当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。</p><p>在 G1 实现中，年代是个逻辑概念，具体体现在，一部分 region 是作为 Eden，一部分作为 Survivor，除了意料之中的 Old region，G1 会将超过 region 50% 大小的对象（在应用中，通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中。逻辑上，Humongous region 算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代 GC 的复制算法。</p><p>你可以思考下 region 设计有什么副作用？</p><p>例如，region 大小和大对象很难保证一致，这会导致空间的浪费。不知道你有没有注意到，我的示意图中有的区域是 Humongous 颜色，但没有用名称标记，这是为了表示，特别大的对象是可能占用超过一个 region 的。并且，region 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况，请参考<a href="http://mail.openjdk.java.net/pipermail/hotspot-gc-use/2017-November/002726.html">OpenJDK 社区的讨论</a>。这本质也可以看作是 JVM 的 bug，尽管解决办法也非常简单，直接设置较大的 region 大小，参数如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:G1HeapRegionSize=&lt;N</span>, 例如 <span class="number">16</span>&gt;M</span><br></pre></td></tr></table></figure><p>从 GC 算法的角度，G1 选择的是复合算法，可以简化理解为：</p><ul><li>在新生代，G1 采用的仍然是并行的复制算法，所以同样会发生 Stop-The-World 的暂停。</li><li>在老年代，大部分情况下都是并发标记，而整理（Compact）则是和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行的。</li></ul><p>我在<a href="http://time.geekbang.org/column/article/10513">上一讲</a>曾经介绍过，习惯上人们喜欢把新生代 GC（Young GC）叫作 Minor GC，老年代 GC 叫作 Major GC，区别于整体性的 Full GC。但是现代 GC 中，这种概念已经不再准确，对于 G1 来说：</p><ul><li>Minor GC 仍然存在，虽然具体过程会有区别，会涉及 Remembered Set 等相关处理。</li><li>老年代回收，则是依靠 Mixed GC。并发标记结束后，JVM 就有足够的信息进行垃圾收集，Mixed GC 不仅同时会清理 Eden、Survivor 区域，而且还会清理部分 Old 区域。可以通过设置下面的参数，指定触发阈值，并且设定最多被包含在一次 Mixed GC 中的 region 比例。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">–XX:G1MixedGCLiveThresholdPercent</span></span><br><span class="line"><span class="section">–XX:G1OldCSetRegionThresholdPercent</span></span><br></pre></td></tr></table></figure><p>从 G1 内部运行的角度，下面的示意图描述了 G1 正常运行时的状态流转变化，当然，在发生逃逸失败等情况下，就会触发 Full GC。<img src="http://learn.lianglianglee.com/极客时间/assets/47dddbd91ad0e0adbd164632eb9facec.png" alt="img"></p><p>G1 相关概念非常多，有一个重点就是 Remembered Set，用于记录和维护 region 之间对象的引用关系。为什么需要这么做呢？试想，新生代 GC 是复制算法，也就是说，类似对象从 Eden 或者 Survivor 到 to 区域的“移动”，其实是“复制”，本质上是一个新的对象。在这个过程中，需要必须保证老年代到新生代的跨区引用仍然有效。下面的示意图说明了相关设计。<img src="http://learn.lianglianglee.com/极客时间/assets/eb50bb2b270478bc6f525aa615d4a3d3.png" alt="img"></p><p>G1 的很多开销都是源自 Remembered Set，例如，它通常约占用 Heap 大小的 20% 或更高，这可是非常可观的比例。并且，我们进行对象复制的时候，因为需要扫描和更改 Card Table 的信息，这个速度影响了复制的速度，进而影响暂停时间。</p><p>描述 G1 内部的资料很多，我就不重复了，如果你想了解更多内部结构和算法等，我建议参考一些具体的<a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All">介绍</a>，书籍方面我推荐 Charlie Hunt 等撰写的《Java Performance Companion》。</p><p>接下来，我介绍下大家可能还不了解的 G1 行为变化，它们在一定程度上解决了专栏其他讲中提到的部分困扰，如类型卸载不及时的问题。</p><ul><li>上面提到了 Humongous 对象的分配和回收，这是很多内存问题的来源，Humongous region 作为老年代的一部分，通常认为它会在并发标记结束后才进行回收，但是在新版 G1 中，Humongous 对象回收采取了更加激进的策略。 我们知道 G1 记录了老年代 region 间对象引用，Humongous 对象数量有限，所以能够快速的知道是否有老年代对象引用它。如果没有，能够阻止它被回收的唯一可能，就是新生代是否有对象引用了它，但这个信息是可以在 Young GC 时就知道的，所以完全可以在 Young GC 中就进行 Humongous 对象的回收，不用像其他老年代对象那样，等待并发标记结束。</li><li>我在<a href="http://time.geekbang.org/column/article/7349">专栏第 5 讲</a>，提到了在 8u20 以后字符串排重的特性，在垃圾收集过程中，G1 会把新创建的字符串对象放入队列中，然后在 Young GC 之后，并发地（不会 STW）将内部数据（char 数组，JDK 9 以后是 byte 数组）一致的字符串进行排重，也就是将其引用同一个数组。你可以使用下面参数激活：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseStringDeduplication</span></span><br></pre></td></tr></table></figure><p>注意，这种排重虽然可以节省不少内存空间，但这种并发操作会占用一些 CPU 资源，也会导致 Young GC 稍微变慢。</p><ul><li>类型卸载是个长期困扰一些 Java 应用的问题，在<a href="http://time.geekbang.org/column/article/10192">专栏第 25 讲</a>中，我介绍了一个类只有当加载它的自定义类加载器被回收后，才能被卸载。元数据区替换了永久代之后有所改善，但还是可能出现问题。</li></ul><p>G1 的类型卸载有什么改进吗？很多资料中都谈到，G1 只有在发生 Full GC 时才进行类型卸载，但这显然不是我们想要的。你可以加上下面的参数查看类型卸载：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+TraceClassUnloading</span></span><br></pre></td></tr></table></figure><p>幸好现代的 G1 已经不是如此了，8u40 以后，G1 增加并默认开启下面的选项：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+ClassUnloadingWithConcurrentMark</span></span><br></pre></td></tr></table></figure><p>也就是说，在并发标记阶段结束后，JVM 即进行类型卸载。</p><ul><li>我们知道老年代对象回收，基本要等待并发标记结束。这意味着，如果并发标记结束不及时，导致堆已满，但老年代空间还没完成回收，就会触发 Full GC，所以触发并发标记的时机很重要。早期的 G1 调优中，通常会设置下面参数，但是很难给出一个普适的数值，往往要根据实际运行结果调整</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:InitiatingHeapOccupancyPercent</span></span><br></pre></td></tr></table></figure><p>在 JDK 9 之后的 G1 实现中，这种调整需求会少很多，因为 JVM 只会将该参数作为初始值，会在运行时进行采样，获取统计数据，然后据此动态调整并发标记启动时机。对应的 JVM 参数如下，默认已经开启：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+G1UseAdaptiveIHOP</span></span><br></pre></td></tr></table></figure><ul><li>在现有的资料中，大多指出 G1 的 Full GC 是最差劲的单线程串行 GC。其实，如果采用的是最新的 JDK，你会发现 Full GC 也是并行进行的了，在通用场景中的表现还优于 Parallel GC 的 Full GC 实现。</li></ul><p>当然，还有很多其他的改变，比如更快的 Card Table 扫描等，这里不再展开介绍，因为它们并不带来行为的变化，基本不影响调优选择。</p><p>前面介绍了 G1 的内部机制，并且穿插了部分调优建议，下面从整体上给出一些调优的建议。</p><p>首先，<strong>建议尽量升级到较新的 JDK 版本</strong>，从上面介绍的改进就可以看到，很多人们常常讨论的问题，其实升级 JDK 就可以解决了。</p><p>第二，掌握 GC 调优信息收集途径。掌握尽量全面、详细、准确的信息，是各种调优的基础，不仅仅是 GC 调优。我们来看看打开 GC 日志，这似乎是很简单的事情，可是你确定真的掌握了吗？</p><p>除了常用的两个选项，</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDetails</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDateStamps</span></span><br></pre></td></tr></table></figure><p>还有一些非常有用的日志选项，很多特定问题的诊断都是要依赖这些选项：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintAdaptiveSizePolicy <span class="comment">// 打印 G1 Ergonomics 相关信息</span></span><br></pre></td></tr></table></figure><p>我们知道 GC 内部一些行为是适应性的触发的，利用 PrintAdaptiveSizePolicy，我们就可以知道为什么 JVM 做出了一些可能我们不希望发生的动作。例如，G1 调优的一个基本建议就是避免进行大量的 Humongous 对象分配，如果 Ergonomics 信息说明发生了这一点，那么就可以考虑要么增大堆的大小，要么直接将 region 大小提高。</p><p>如果是怀疑出现引用清理不及时的情况，则可以打开下面选项，掌握到底是哪里出现了堆积。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintReferenceGC</span></span><br></pre></td></tr></table></figure><p>另外，建议开启选项下面的选项进行并行引用处理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+ParallelRefProcEnabled</span></span><br></pre></td></tr></table></figure><p>需要注意的一点是，JDK 9 中 JVM 和 GC 日志机构进行了重构，其实我前面提到的<strong>PrintGCDetails 已经被标记为废弃</strong>，而<strong>PrintGCDateStamps 已经被移除</strong>，指定它会导致 JVM 无法启动。可以使用下面的命令查询新的配置参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xlog:<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>最后，来看一些通用实践，理解了我前面介绍的内部结构和机制，很多结论就一目了然了，例如：</p><ul><li>如果发现 Young GC 非常耗时，这很可能就是因为新生代太大了，我们可以考虑减小新生代的最小比例。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:G1NewSizePercent</span></span><br></pre></td></tr></table></figure><p>降低其最大值同样对降低 Young GC 延迟有帮助。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:G1MaxNewSizePercent</span></span><br></pre></td></tr></table></figure><p>如果我们直接为 G1 设置较小的延迟目标值，也会起到减小新生代的效果，虽然会影响吞吐量。</p><ul><li>如果是 Mixed GC 延迟较长，我们应该怎么做呢？</li></ul><p>还记得前面说的，部分 Old region 会被包含进 Mixed GC，减少一次处理的 region 个数，就是个直接的选择之一。 我在上面已经介绍了 G1OldCSetRegionThresholdPercent 控制其最大值，还可以利用下面参数提高 Mixed GC 的个数，当前默认值是 8，Mixed GC 数量增多，意味着每次被包含的 region 减少。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:G1MixedGCCountTarget</span></span><br></pre></td></tr></table></figure><p>今天的内容算是抛砖引玉，更多内容你可以参考<a href="https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector-tuning.htm#JSGCT-GUID-4914A8D4-DE41-4250-B68E-816B58D4E278">G1 调优指南</a>等，远不是几句话可以囊括的。需要注意的是，也要避免过度调优，G1 对大堆非常友好，其运行机制也需要浪费一定的空间，有时候稍微多给堆一些空间，比进行苛刻的调优更加实用。</p><p>今天我梳理了基本的 GC 调优思路，并对 G1 内部结构以及最新的行为变化进行了详解。总的来说，G1 的调优相对简单、直观，因为可以直接设定暂停时间等目标，并且其内部引入了各种智能的自适应机制，希望这一切的努力，能够让你在日常应用开发时更加高效。</p><h2 id="一课一练-27"><a href="#一课一练-27" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，定位 Full GC 发生的原因，有哪些方式？�=</p><h1 id="第29讲-Java内存模型中的happen-before是什么？"><a href="#第29讲-Java内存模型中的happen-before是什么？" class="headerlink" title="第29讲 Java内存模型中的happen-before是什么？"></a>第29讲 Java内存模型中的happen-before是什么？</h1><p>Java 语言在设计之初就引入了线程的概念，以充分利用现代处理器的计算能力，这既带来了强大、灵活的多线程机制，也带来了线程安全等令人混淆的问题，而 Java 内存模型（Java Memory Model，JMM）为我们提供了一个在纷乱之中达成一致的指导准则。</p><p>今天我要问你的问题是，Java 内存模型中的 happen-before 是什么？</p><h2 id="典型回答-28"><a href="#典型回答-28" class="headerlink" title="典型回答"></a>典型回答</h2><p>Happen-before 关系，是 Java 内存模型中保证多线程操作可见性的机制，也是对早期语言规范中含糊的可见性概念的一个精确定义。</p><p>它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面，例如：</p><ul><li>线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li><li>对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。</li><li>对于一个锁的解锁操作，保证 happen-before 加锁操作。</li><li>对象构建完成，保证 happen-before 于 finalizer 的开始动作。</li><li>甚至是类似线程内部操作的完成，保证 happen-before 其他 Thread.join() 的线程等。</li></ul><p>这些 happen-before 关系是存在着传递性的，如果满足 a happen-before b 和 b happen-before c，那么 a happen-before c 也成立。</p><p>前面我一直用 happen-before，而不是简单说前后，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。</p><h2 id="考点分析-28"><a href="#考点分析-28" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是一个常见的考察 Java 内存模型基本概念的问题，我前面给出的回答尽量选择了和日常开发相关的规则。</p><p>JMM 是面试的热点，可以看作是深入理解 Java 并发编程、编译器和 JVM 内部机制的必要条件，但这同时也是个容易让初学者无所适从的主题。对于学习 JMM，我有一些个人建议：</p><ul><li>明确目的，克制住技术的诱惑。除非你是编译器或者 JVM 工程师，否则我建议不要一头扎进各种 CPU 体系结构，纠结于不同的缓存、流水线、执行单元等。这些东西虽然很酷，但其复杂性是超乎想象的，很可能会无谓增加学习难度，也未必有实践价值。</li><li>克制住对“秘籍”的诱惑。有些时候，某些编程方式看起来能起到特定效果，但分不清是实现差异导致的“表现”，还是“规范”要求的行为，就不要依赖于这种“表现”去编程，尽量遵循语言规范进行，这样我们的应用行为才能更加可靠、可预计。</li></ul><p>在这一讲中，兼顾面试和编程实践，我会结合例子梳理下面两点：</p><ul><li>为什么需要 JMM，它试图解决什么问题？</li><li>JMM 是如何解决可见性等各种问题的？类似 volatile，体现在具体用例中有什么效果？</li></ul><p>注意，专栏中 Java 内存模型就是特指 JSR-133 中重新定义的 JMM 规范。在特定的上下文里，也许会与 JVM（Java）内存结构等混淆，并不存在绝对的对错，但一定要清楚面试官的本意，有的面试官也会特意考察是否清楚这两种概念的区别。</p><h2 id="知识扩展-28"><a href="#知识扩展-28" class="headerlink" title="知识扩展"></a>知识扩展</h2><p><strong>为什么需要 JMM，它试图解决什么问题？</strong></p><p>Java 是最早尝试提供内存模型的语言，这是简化多线程编程、保证程序可移植性的一个飞跃。早期类似 C、C++ 等语言，并不存在内存模型的概念（C++ 11 中也引入了标准内存模型），其行为依赖于处理器本身的<a href="https://en.wikipedia.org/wiki/Memory_ordering">内存一致性模型</a>，但不同的处理器可能差异很大，所以一段 C++ 程序在处理器 A 上运行正常，并不能保证其在处理器 B 上也是一致的。</p><p>即使如此，最初的 Java 语言规范仍然是存在着缺陷的，当时的目标是，希望 Java 程序可以充分利用现代硬件的计算能力，同时保持“书写一次，到处执行”的能力。</p><p>但是，显然问题的复杂度被低估了，随着 Java 被运行在越来越多的平台上，人们发现，过于泛泛的内存模型定义，存在很多模棱两可之处，对 synchronized 或 volatile 等，类似指令重排序时的行为，并没有提供清晰规范。这里说的指令重排序，既可以是<a href="https://en.wikipedia.org/wiki/Instruction_scheduling">编译器优化行为</a>，也可能是源自于现代处理器的<a href="https://en.wikipedia.org/wiki/Out-of-order_execution">乱序执行</a>等。</p><p>换句话说：</p><ul><li>既不能保证一些多线程程序的正确性，例如最著名的就是双检锁（Double-Checked Locking，DCL）的失效问题，具体可以参考我在<a href="http://time.geekbang.org/column/article/8624">第 14 讲</a>对单例模式的说明，双检锁可能导致未完整初始化的对象被访问，理论上这叫并发编程中的安全发布（Safe Publication）失败。</li><li>也不能保证同一段程序在不同的处理器架构上表现一致，例如有的处理器支持缓存一致性，有的不支持，各自都有自己的内存排序模型。</li></ul><p>所以，Java 迫切需要一个完善的 JMM，能够让普通 Java 开发者和编译器、JVM 工程师，能够<strong>清晰地</strong>达成共识。换句话说，可以相对简单并准确地判断出，多线程程序什么样的执行序列是符合规范的。</p><p>所以：</p><ul><li>对于编译器、JVM 开发者，关注点可能是如何使用类似<a href="https://en.wikipedia.org/wiki/Memory_barrier">内存屏障</a>（Memory-Barrier）之类技术，保证执行结果符合 JMM 的推断。</li><li>对于 Java 应用开发者，则可能更加关注 volatile、synchronized 等语义，如何利用类似 happen-before 的规则，写出可靠的多线程应用，而不是利用一些“秘籍”去糊弄编译器、JVM。</li></ul><p>我画了一个简单的角色层次图，不同工程师分工合作，其实所处的层面是有区别的。JMM 为 Java 工程师隔离了不同处理器内存排序的区别，这也是为什么我通常不建议过早深入处理器体系结构，某种意义上来说，这样本就违背了 JMM 的初衷。<img src="http://learn.lianglianglee.com/极客时间/assets/5d74ad650fa5d1cdf80df3b3062357e5.png" alt="img"></p><p><strong>JMM 是怎么解决可见性等问题的呢？</strong></p><p>在这里，我有必要简要介绍一下典型的问题场景。</p><p>我在<a href="http://time.geekbang.org/column/article/10192">第 25 讲</a>里介绍了 JVM 内部的运行时数据区，但是真正程序执行，实际是要跑在具体的处理器内核上。你可以简单理解为，把本地变量等数据从内存加载到缓存、寄存器，然后运算结束写回主内存。你可以从下面示意图，看这两种模型的对应。<img src="http://learn.lianglianglee.com/极客时间/assets/ff8afc2561e8891bc74a0112905fed61.png" alt="img"></p><p>看上去很美好，但是当多线程共享变量时，情况就复杂了。试想，如果处理器对某个共享变量进行了修改，可能只是体现在该内核的缓存里，这是个本地状态，而运行在其他内核上的线程，可能还是加载的旧状态，这很可能导致一致性的问题。从理论上来说，多线程共享引入了复杂的数据依赖性，不管编译器、处理器怎么做重排序，都必须尊重数据依赖性的要求，否则就打破了正确性！这就是 JMM 所要解决的问题。</p><p>JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种 happen-before 规则。与此同时，更多复杂度在于，需要尽量确保各种编译器、各种体系结构的处理器，都能够提供一致的行为。</p><p>我以 volatile 为例，看看如何利用内存屏障实现 JMM 定义的可见性？</p><p>对于一个 volatile 变量：</p><ul><li>对该变量的写操作<strong>之后</strong>，编译器会插入一个<strong>写屏障</strong>。</li><li>对该变量的读操作<strong>之前</strong>，编译器会插入一个<strong>读屏障</strong>。</li></ul><p>内存屏障能够在类似变量读、写操作之后，保证其他线程对 volatile 变量的修改对当前线程可见，或者本地修改对其他线程提供可见性。换句话说，线程写入，写屏障会通过类似强迫刷出处理器缓存的方式，让其他线程能够拿到最新数值。</p><p>如果你对更多内存屏障的细节感兴趣，或者想了解不同体系结构的处理器模型，建议参考 JSR-133<a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html">相关文档</a>，我个人认为这些都是和特定硬件相关的，内存屏障之类只是实现 JMM 规范的技术手段，并不是规范的要求。</p><p><strong>从应用开发者的角度，JMM 提供的可见性，体现在类似 volatile 上，具体行为是什么样呢？</strong></p><p>我这里循序渐进的举两个例子。</p><p>首先，前几天有同学问我一个问题，请看下面的代码片段，希望达到的效果是，当 condition 被赋值为 false 时，线程 A 能够从循环中退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread A</span></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line">condition = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这里就需要 condition 被定义为 volatile 变量，不然其数值变化，往往并不能被线程 A 感知，进而无法退出。当然，也可以在 while 中，添加能够直接或间接起到类似效果的代码。</p><p>第二，我想举 Brian Goetz 提供的一个经典用例，使用 volatile 作为守卫对象，实现某种程度上轻量级的同步，请看代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="type">char</span>[] configText;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="comment">// Thread A</span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>; </span><br><span class="line"><span class="comment">// Thread B</span></span><br><span class="line"><span class="keyword">while</span> (!initialized)</span><br><span class="line">  sleep();</span><br><span class="line"><span class="comment">// use configOptions</span></span><br></pre></td></tr></table></figure><p>JSR-133 重新定义的 JMM 模型，能够保证线程 B 获取的 configOptions 是更新后的数值。</p><p>也就是说 volatile 变量的可见性发生了增强，能够起到守护其上下文的作用。线程 A 对 volatile 变量的赋值，会强制将该变量自己和当时其他变量的状态都刷出缓存，为线程 B 提供可见性。当然，这也是以一定的性能开销作为代价的，但毕竟带来了更加简单的多线程行为。</p><p>我们经常会说 volatile 比 synchronized 之类更加轻量，但轻量也仅仅是相对的，volatile 的读、写仍然要比普通的读写要开销更大，所以如果你是在性能高度敏感的场景，除非你确定需要它的语义，不然慎用。</p><p>今天，我从 happen-before 关系开始，帮你理解了什么是 Java 内存模型。为了更方便理解，我作了简化，从不同工程师的角色划分等角度，阐述了问题的由来，以及 JMM 是如何通过类似内存屏障等技术实现的。最后，我以 volatile 为例，分析了可见性在多线程场景中的典型用例。</p><h2 id="一课一练-28"><a href="#一课一练-28" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天留给你的思考题是，给定一段代码，如何验证所有符合 JMM 执行可能？有什么工具可以辅助吗？�K</p><h1 id="第30讲-Java程序运行在Docker等容器环境有哪些新问题？"><a href="#第30讲-Java程序运行在Docker等容器环境有哪些新问题？" class="headerlink" title="第30讲 Java程序运行在Docker等容器环境有哪些新问题？"></a>第30讲 Java程序运行在Docker等容器环境有哪些新问题？</h1><p>如今，Docker 等容器早已不是新生事物，正在逐步成为日常开发、部署环境的一部分。Java 能否无缝地运行在容器环境，是否符合微服务、Serverless 等新的软件架构和场景，在一定程度上也会影响未来的技术栈选择。当然，Java 对 Docker 等容器环境的支持也在不断增强，自然地，Java 在容器场景的实践也逐渐在面试中被涉及。我希望通过专栏今天这一讲，能够帮你能做到胸有成竹。</p><p>今天我要问你的问题是，Java 程序运行在 Docker 等容器环境有哪些新问题？</p><h2 id="典型回答-29"><a href="#典型回答-29" class="headerlink" title="典型回答"></a>典型回答</h2><p>对于 Java 来说，Docker 毕竟是一个较新的环境，例如，其内存、CPU 等资源限制是通过 CGroup（Control Group）实现的，早期的 JDK 版本（8u131 之前）并不能识别这些限制，进而会导致一些基础问题：</p><ul><li>如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。</li><li>错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。</li></ul><p>从应用打包、发布等角度出发，JDK 自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。</p><p>如果考虑到微服务、Serverless 等新的架构和场景，Java 自身的大小、内存占用、启动速度，都存在一定局限性，因为 Java 早期的优化大多是针对长时间运行的大型服务器端应用。</p><h2 id="考点分析-29"><a href="#考点分析-29" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是个针对特定场景和知识点的问题，我给出的回答简单总结了目前业界实践中发现的一些问题。</p><p>如果我是面试官，针对这种问题，如果你确实没有太多 Java 在 Docker 环境的使用经验，直接说不知道，也算是可以接受的，毕竟没有人能够掌握所有知识点嘛。</p><p>但我们要清楚，有经验的面试官，一般不会以纯粹偏僻的知识点作为面试考察的目的，更多是考察思考问题的思路和解决问题的方法。所以，如果有基础的话，可以从操作系统、容器原理、JVM 内部机制、软件开发实践等角度，展示系统性分析新问题、新场景的能力。毕竟，变化才是世界永远的主题，能够在新变化中找出共性与关键，是优秀工程师的必备能力。</p><p>今天我会围绕下面几个方面展开：</p><ul><li>面试官可能会进一步问到，有没有想过为什么类似 Docker 这种容器环境，会有点“欺负”Java？从 JVM 内部机制来说，问题出现在哪里？</li><li>我注意到有种论调说“没人在容器环境用 Java”，不去争论这个观点正确与否，我会从工程实践出发，梳理问题原因和相关解决方案，并探讨下新场景下的最佳实践。</li></ul><h2 id="知识扩展-29"><a href="#知识扩展-29" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们先来搞清楚 Java 在容器环境的局限性来源，<strong>Docker 到底有什么特别</strong>？</p><p>虽然看起来 Docker 之类容器和虚拟机非常相似，例如，它也有自己的 shell，能独立安装软件包，运行时与其他容器互不干扰。但是，如果深入分析你会发现，Docker 并不是一种完全的<strong>虚拟化</strong>技术，而更是一种轻量级的<strong>隔离</strong>技术。<img src="http://learn.lianglianglee.com/极客时间/assets/a069a294d32d7778f3410192221358fb.png" alt="img"></p><p>上面的示意图，展示了 Docker 与虚拟机的区别。从技术角度，基于 namespace，Docker 为每个容器提供了单独的命名空间，对网络、PID、用户、IPC 通信、文件系统挂载点等实现了隔离。对于 CPU、内存、磁盘 IO 等计算资源，则是通过 CGroup 进行管理。如果你想了解更多 Docker 的细节，请参考相关<a href="https://medium.freecodecamp.org/a-beginner-friendly-introduction-to-containers-vms-and-docker-79a9e3e119b">技术文档</a>。</p><p>Docker 仅在类似 Linux 内核之上实现了有限的隔离和虚拟化，并不是像传统虚拟化软件那样，独立运行一个新的操作系统。如果是虚拟化的操作系统，不管是 Java 还是其他程序，只要调用的是同一个系统 API，都可以透明地获取所需的信息，基本不需要额外的兼容性改变。</p><p>容器虽然省略了虚拟操作系统的开销，实现了轻量级的目标，但也带来了额外复杂性，它限制对于应用不是透明的，需要用户理解 Docker 的新行为。所以，有专家曾经说过，“幸运的是 Docker 没有完全隐藏底层信息，但是不幸的也是 Docker 没有隐藏底层信息！”</p><p>对于 Java 平台来说，这些未隐藏的底层信息带来了很多意外的困难，主要体现在几个方面：</p><p>第一，容器环境对于计算资源的管理方式是全新的，CGroup 作为相对比较新的技术，历史版本的 Java 显然并不能自然地理解相应的资源限制。</p><p>第二，namespace 对于容器内的应用细节增加了一些微妙的差异，比如 jcmd、jstack 等工具会依赖于“/proc//”下面提供的部分信息，但是 Docker 的设计改变了这部分信息的原有结构，我们需要对原有工具进行<a href="https://bugs.openjdk.java.net/browse/JDK-8179498">修改</a>以适应这种变化。</p><p><strong>从 JVM 运行机制的角度，为什么这些“沟通障碍”会导致 OOM 等问题呢？</strong></p><p>你可以思考一下，这个问题实际是反映了 JVM 如何根据系统资源（内存、CPU 等）情况，在启动时设置默认参数。</p><p>这就是所谓的<a href="https://docs.oracle.com/javase/10/gctuning/ergonomics.htm#JSGCT-GUID-DB4CAE94-2041-4A16-90EC-6AE3D91EC1F1">Ergonomics</a>机制，例如：</p><ul><li>JVM 会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的 1/64；并将堆最大值，设置为系统内存的 1/4。</li><li>而 JVM 检测到系统的 CPU 核数，则直接影响到了 Parallel GC 的并行线程数目和 JIT complier 线程数目，甚至是我们应用中 ForkJoinPool 等机制的并行等级。</li></ul><p>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java 的判断很可能是基于错误信息而做出的。这就类似，我以为我住的是整栋别墅，实际上却只有一个房间是给我住的。</p><p>更加严重的是，JVM 的一些原有诊断或备用机制也会受到影响。为保证服务的可用性，一种常见的选择是依赖“-XX:OnOutOfMemoryError”功能，通过调用处理脚本的形式来做一些补救措施，比如自动重启服务等。但是，这种机制是基于 fork 实现的，当 Java 进程已经过度提交内存时，fork 新的进程往往已经不可能正常运行了。</p><p>根据前面的总结，似乎问题非常棘手，那我们在实践中，<strong>如何解决这些问题呢？</strong></p><p>首先，如果你能够<strong>升级到最新的 JDK 版本</strong>，这个问题就迎刃而解了。</p><ul><li>针对这种情况，JDK 9 中引入了一些实验性的参数，以方便 Docker 和 Java“沟通”，例如针对内存限制，可以使用下面的参数设置：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UnlockExperimentalVMOptions</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseCGroupMemoryLimitForHeap</span></span><br></pre></td></tr></table></figure><p>注意，这两个参数是顺序敏感的，并且只支持 Linux 环境。而对于 CPU 核心数限定，Java 已经被修正为可以正确理解“–cpuset-cpus”等设置，无需单独设置参数。</p><ul><li>如果你可以切换到 JDK 10 或者更新的版本，问题就更加简单了。Java 对容器（Docker）的支持已经比较完善，默认就会自适应各种资源限制和实现差异。前面提到的实验性参数“UseCGroupMemoryLimitForHeap”已经被标记为废弃。</li></ul><p>与此同时，新增了参数用以明确指定 CPU 核心的数目。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:ActiveProcessorCount=N</span></span><br></pre></td></tr></table></figure><p>如果实践中发现有问题，也可以使用“-XX:-UseContainerSupport”，关闭 Java 的容器支持特性，这可以作为一种防御性机制，避免新特性破坏原有基础功能。当然，也欢迎你向 OpenJDK 社区反馈问题。</p><ul><li>幸运的是，JDK 9 中的实验性改进已经被移植到 Oracle JDK 8u131 之中，你可以直接下载相应<a href="https://store.docker.com/images/oracle-serverjre-8">镜像</a>，并配置“UseCGroupMemoryLimitForHeap”，后续很有可能还会进一步将 JDK 10 中相关的增强，应用到 JDK 8 最新的更新中。</li></ul><p>但是，如果我暂时只能使用老版本的 JDK 怎么办？</p><p>我这里有几个建议：</p><ul><li>明确设置堆、元数据区等内存区域大小，保证 Java 进程的总大小可控。</li></ul><p>例如，我们可能在环境中，这样限制容器内存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it --<span class="built_in">rm</span> --name yourcontainer -p 8080:8080 -m 800M repo/your-java-container:openjdk</span></span><br></pre></td></tr></table></figure><p>那么，就可以额外配置下面的环境变量，直接指定 JVM 堆大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e JAVA_OPTIONS=<span class="string">&#x27;-Xmx300m&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>明确配置 GC 和 JIT 并行线程数目，以避免二者占用过多计算资源。</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:ParallelGCThreads</span></span><br><span class="line"><span class="deletion">-XX:CICompilerCount</span></span><br></pre></td></tr></table></figure><p>除了我前面介绍的 OOM 等问题，在很多场景中还发现 Java 在 Docker 环境中，似乎会意外使用 Swap。具体原因待查，但很有可能也是因为 Ergonomics 机制失效导致的，我建议配置下面参数，明确告知 JVM 系统内存限额。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxRAM=`<span class="built_in">cat</span> /sys/fs/cgroup/memory/memory.limit_in_bytes`</span><br></pre></td></tr></table></figure><p>也可以指定 Docker 运行参数，例如：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">--memory-swappiness</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这是受操作系统<a href="https://en.wikipedia.org/wiki/Swappiness">Swappiness</a>机制影响，当内存消耗达到一定门限，操作系统会试图将不活跃的进程换出（Swap out），上面的参数有显式关闭 Swap 的作用。所以可以看到，Java 在 Docker 中的使用，从操作系统、内核到 JVM 自身机制，需要综合运用我们所掌握的知识。</p><p>回顾我在专栏第 25 讲 JVM 内存区域的介绍，JVM 内存消耗远不止包括堆，很多时候仅仅设置 Xmx 是不够的，MaxRAM 也有助于 JVM 合理分配其他内存区域。如果应用需要设置更多 Java 启动参数，但又不确定什么数值合理，可以试试一些社区提供的<a href="https://github.com/cloudfoundry/java-buildpack-memory-calculator">工具</a>，但要注意通用工具的局限性。</p><p>更进一步来说，对于容器镜像大小的问题，如果你使用的是 JDK 9 以后的版本，完全可以使用 jlink 工具定制最小依赖的 Java 运行环境，将 JDK 裁剪为几十 M 的大小，这样运行起来并不困难。</p><p>今天我从 Docker 环境中 Java 可能出现的问题开始，分析了为什么容器环境对应用并不透明，以及这种偏差干扰了 JVM 的相关机制。最后，我从实践出发，介绍了主要问题的解决思路，希望对你在实际开发时有所帮助。</p><h2 id="一课一练-29"><a href="#一课一练-29" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，针对我提到的微服务和 Serverless 等场景 Java 表现出的不足，有哪些方法可以改善 Java 的表现？�?</p><h1 id="第31讲-你了解Java应用开发中的注入攻击吗？"><a href="#第31讲-你了解Java应用开发中的注入攻击吗？" class="headerlink" title="第31讲 你了解Java应用开发中的注入攻击吗？"></a>第31讲 你了解Java应用开发中的注入攻击吗？</h1><p>安全是软件开发领域永远的主题之一，随着新技术浪潮的兴起，安全的重要性愈发凸显出来，对于金融等行业，甚至可以说安全是企业的生命线。不论是移动设备、普通 PC、小型机，还是大规模分布式系统，以及各种主流操作系统，Java 作为软件开发的基础平台之一，可以说是无处不在，自然也就成为安全攻击的首要目标之一。</p><p>今天我要问你的问题是，你了解 Java 应用开发中的注入攻击吗？</p><h2 id="典型回答-30"><a href="#典型回答-30" class="headerlink" title="典型回答"></a>典型回答</h2><p>注入式（Inject）攻击是一类非常常见的攻击方式，其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，这就可能完全改变最初预计的执行过程，产生恶意效果。</p><p>下面是几种主要的注入式攻击途径，原则上提供动态执行能力的语言特性，都需要提防发生注入攻击的可能。</p><p>首先，就是最常见的 SQL 注入攻击。一个典型的场景就是 Web 系统的用户登录功能，根据用户输入的用户名和密码，我们需要去后端数据库核实信息。</p><p>假设应用逻辑是，后端程序利用界面输入动态生成类似下面的 SQL，然后让 JDBC 执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> use_info <span class="keyword">where</span> username <span class="operator">=</span> “input_usr_name” <span class="keyword">and</span> password <span class="operator">=</span> “input_pwd”</span><br></pre></td></tr></table></figure><p>但是，如果我输入的 input_pwd 是类似下面的文本，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“ or “”=”</span><br></pre></td></tr></table></figure><p>那么，拼接出的 SQL 字符串就变成了下面的条件，OR 的存在导致输入什么名字都是复合条件的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> use_info <span class="keyword">where</span> username <span class="operator">=</span> “input_usr_name” <span class="keyword">and</span> password <span class="operator">=</span> “” <span class="keyword">or</span> “” <span class="operator">=</span> “”</span><br></pre></td></tr></table></figure><p>这里只是举个简单的例子，它是利用了期望输入和可能输入之间的偏差。上面例子中，期望用户输入一个数值，但实际输入的则是 SQL 语句片段。类似场景可以利用注入的不同 SQL 语句，进行各种不同目的的攻击，甚至还可以加上“;delete xxx”之类语句，如果数据库权限控制不合理，攻击效果就可能是灾难性的。</p><p>第二，操作系统命令注入。Java 语言提供了类似 Runtime.exec(…) 的 API，可以用来执行特定命令，假设我们构建了一个应用，以输入文本作为参数，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> –la input_file_name</span><br></pre></td></tr></table></figure><p>但是如果用户输入是 “input_file_name;rm –rf /*”，这就有可能出现问题了。当然，这只是个举例，Java 标准类库本身进行了非常多的改进，所以类似这种编程错误，未必可以真的完成攻击，但其反映的一类场景是真实存在的。</p><p>第三，XML 注入攻击。Java 核心类库提供了全面的 XML 处理、转换等各种 API，而 XML 自身是可以包含动态内容的，例如 XPATH，如果使用不当，可能导致访问恶意内容。</p><p>还有类似 LDAP 等允许动态内容的协议，都是可能利用特定命令，构造注入式攻击的，包括 XSS（Cross-site Scripting）攻击，虽然并不和 Java 直接相关，但也可能在 JSP 等动态页面中发生。</p><h2 id="考点分析-30"><a href="#考点分析-30" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题是安全领域的入门题目，我简单介绍了最常见的几种注入场景作为示例。安全本身是个非常大的主题，在面试中，面试官可能会考察安全问题，但如果不是特定安全专家岗位，了解基础的安全实践就可以满足要求了。</p><p>Java 工程师未必都要成为安全专家，但了解基础的安全领域常识，有利于发现和规避日常开发中的风险。今天我会侧重和 Java 开发相关的安全内容，希望可以起到一个抛砖引玉的作用，让你对 Java 开发安全领域有个整体印象。</p><ul><li>谈到 Java 应用安全，主要涉及哪些安全机制？</li><li>到底什么是安全漏洞？对于前面提到的 SQL 注入等典型攻击，我们在开发中怎么避免？</li></ul><h2 id="知识扩展-30"><a href="#知识扩展-30" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，一起来看看哪些 Java API 和工具构成了 Java 安全基础。很多方面我在专栏前面的讲解中已经有所涉及，可以简单归为三个主要组成部分：</p><p>第一，运行时安全机制。可以简单认为，就是限制 Java 运行时的行为，不要做越权或者不靠谱的事情，具体来看：</p><ul><li>在类加载过程中，进行字节码验证，以防止不合规的代码影响 JVM 运行或者载入其他恶意代码。</li><li>类加载器本身也可以对代码之间进行隔离，例如，应用无法获取启动类加载器（Bootstrap Class-Loader）对象实例，不同的类加载器也可以起到容器的作用，隔离模块之间不必要的可见性等。目前，Java Applet、RMI 等特性已经或逐渐退出历史舞台，类加载等机制总体上反倒在不断简化。</li><li>利用 SecurityManger 机制和相关的组件，限制代码的运行时行为能力，其中，你可以定制 policy 文件和各种粒度的权限定义，限制代码的作用域和权限，例如对文件系统的操作权限，或者监听某个网络端口的权限等。我画了一个简单的示意图，对运行时安全的不同层次进行了整理。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/b48e754c6ebb11b6934f4697b7091854.png" alt="img"></p><p>可以看到，Java 的安全模型是以代码为中心的，贯穿了从类加载，如 URLClassLoader 加载网络上的 Java 类等，到应用程序运行时权限检查等全过程。</p><ul><li>另外，从原则上来说，Java 的 GC 等资源回收管理机制，都可以看作是运行时安全的一部分，如果相应机制失效，就会导致 JVM 出现 OOM 等错误，可看作是另类的拒绝服务。</li></ul><p>第二，Java 提供的安全框架 API，这是构建安全通信等应用的基础。例如：</p><ul><li>加密、解密 API。</li><li>授权、鉴权 API。</li><li>安全通信相关的类库，比如基本 HTTPS 通信协议相关标准实现，如<a href="https://openjdk.java.net/jeps/332">TLS 1.3</a>；或者附属的类似证书撤销状态判断（<a href="https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">OSCP</a>）等协议实现。</li></ul><p>注意，这一部分 API 内部实现是和厂商相关的，不同 JDK 厂商往往会定制自己的加密算法实现。</p><p>第三， 就是 JDK 集成的各种安全工具，例如：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html">keytool</a>，这是个强大的工具，可以管理安全场景中不可或缺的秘钥、证书等，并且可以管理 Java 程序使用的 keystore 文件。</li><li><a href="https://docs.oracle.com/javase/9/tools/jarsigner.htm#JSWOR-GUID-925E7A1B-B3F3-44D2-8B49-0B3FA2C54864">jarsigner</a>，用于对 jar 文件进行签名或者验证。</li></ul><p>在应用实践中，如果对安全要求非常高，建议打开 SecurityManager，</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Djava.security.manager</span></span><br></pre></td></tr></table></figure><p>请注意其开销，通常只要开启 SecurityManager，就会导致 10% ~ 15% 的性能下降，在 JDK 9 以后，这个开销有所改善。</p><p>理解了基础 Java 安全机制，接下来我们来一起探讨安全漏洞（<a href="https://en.wikipedia.org/wiki/Vulnerability_(computing">Vulnerability</a>)）。</p><p>按照传统的定义，任何可以用来<strong>绕过系统安全策略限制</strong>的程序瑕疵，都可以算作安全漏洞。具体原因可能非常多，设计或实现中的疏漏、配置错误等，任何不慎都有可能导致安全漏洞出现，例如恶意代码绕过了 Java 沙箱的限制，获取了特权等。如果你想了解更多安全漏洞的信息，可以从<a href="https://cve.mitre.org/">通用安全漏洞库</a>（CVE）等途径获取，了解安全漏洞<a href="https://www.first.org/cvss/calculator/3.0">评价</a>标准。</p><p>但是，要达到攻击的目的，未必都需要绕过权限限制。比如利用哈希碰撞发起拒绝服务攻击（DOS，Denial-Of-Service attack），常见的场景是，攻击者可以事先构造大量相同哈希值的数据，然后以 JSON 数据的形式发送给服务器端，服务器端在将其构建成为 Java 对象过程中，通常以 Hastable 或 HashMap 等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数量级（HashMap 后续进行了改进，我在<a href="http://time.geekbang.org/column/article/8053">专栏第 9 讲</a>介绍了树化机制），进而耗费大量 CPU 资源。</p><p>像这种攻击方式，无关于权限，可以看作是程序实现的瑕疵，给了攻击者以低成本进行进攻的机会。</p><p>我在开头提到的各种注入式攻击，可以有不同角度、不同层面的解决方法，例如针对 SQL 注入：</p><ul><li>在数据输入阶段，填补期望输入和可能输入之间的鸿沟。可以进行输入校验，限定什么类型的输入是合法的，例如，不允许输入标点符号等特殊字符，或者特定结构的输入。</li><li>在 Java 应用进行数据库访问时，如果不用完全动态的 SQL，而是利用 PreparedStatement，可以有效防范 SQL 注入。不管是 SQL 注入，还是 OS 命令注入，程序利用字符串拼接生成运行逻辑都是个可能的风险点！</li><li>在数据库层面，如果对查询、修改等权限进行了合理限制，就可以在一定程度上避免被注入删除等高破坏性的代码。</li></ul><p>在安全领域，有一句准则：安全倾向于 “明显没有漏洞”，而不是“没有明显漏洞”。所以，为了更加安全可靠的服务，我们最好是采取整体性的安全设计和综合性的防范手段，而不是头痛医头、脚痛医脚的修修补补，更不能心存侥幸。</p><p>一个比较普适的建议是，尽量使用较新版本的 JDK，并使用推荐的安全机制和标准。如果你有看过 JDK release notes，例如<a href="http://www.oracle.com/technetwork/java/javase/8u141-relnotes-3720385.html">8u141</a>，你会发现 JDK 更新会修复已知的安全漏洞，并且会对安全机制等进行增强。但现实情况是，相当一部分应用还在使用很古老的不安全版本 JDK 进行开发，并且很多信息处理的也很随意，或者通过明文传输、存储，这些都存在暴露安全隐患的可能。</p><p>今天我首先介绍了典型的注入攻击，然后整理了 Java 内部的安全机制，并探讨了到底什么是安全漏洞和典型的表现形式，以及如何防范 SQL 注入攻击等，希望对你有所帮助。</p><h2 id="一课一练-30"><a href="#一课一练-30" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，你知道 Man-In-The-Middle（MITM）攻击吗？有哪些常见的表现形式？如何防范呢？�0</p><h1 id="第32讲-如何写出安全的Java代码？"><a href="#第32讲-如何写出安全的Java代码？" class="headerlink" title="第32讲 如何写出安全的Java代码？"></a>第32讲 如何写出安全的Java代码？</h1><p>在上一讲中，我们已经初步接触了 Java 安全，今天我们将一起探讨更多 Java 开发中可能影响到安全的场合。很多安全问题，在特定的上下文，存在着不同的定义，尽管本质是相似或一致的，这是由于 Java 平台自身的特性所带来特有的问题。今天这一讲我将侧重于 Java 开发者的角度谈代码安全，而不是讲广义的安全风险。</p><p>今天我要问你的问题是，如何写出安全的 Java 代码？</p><h2 id="典型回答-31"><a href="#典型回答-31" class="headerlink" title="典型回答"></a>典型回答</h2><p>这个问题可能有点宽泛，我们可以用特定类型的安全风险为例，如拒绝服务（DoS）攻击，分析 Java 开发者需要重点考虑的点。</p><p>DoS 是一种常见的网络攻击，有人也称其为“洪水攻击”。最常见的表现是，利用大量机器发送请求，将目标网站的带宽或者其他资源耗尽，导致其无法响应正常用户的请求。</p><p>我认为，从 Java 语言的角度，更加需要重视的是程序级别的攻击，也就是利用 Java、JVM 或应用程序的瑕疵，进行低成本的 DoS 攻击，这也是想要写出安全的 Java 代码所必须考虑的。例如：</p><ul><li>如果使用的是早期的 JDK 和 Applet 等技术，攻击者构建合法但恶劣的程序就相对容易，例如，将其线程优先级设置为最高，做一些看起来无害但空耗资源的事情。幸运的是类似技术已经逐步退出历史舞台，在 JDK 9 以后，相关模块就已经被移除。</li><li>上一讲中提到的哈希碰撞攻击，就是个典型的例子，对方可以轻易消耗系统有限的 CPU 和线程资源。从这个角度思考，类似加密、解密、图形处理等计算密集型任务，都要防范被恶意滥用，以免攻击者通过直接调用或者间接触发方式，消耗系统资源。</li><li>利用 Java 构建类似上传文件或者其他接受输入的服务，需要对消耗系统内存或存储的上限有所控制，因为我们不能将系统安全依赖于用户的合理使用。其中特别注意的是涉及解压缩功能时，就需要防范<a href="https://en.wikipedia.org/wiki/Zip_bomb">Zip bomb</a>等特定攻击。</li><li>另外，Java 程序中需要明确释放的资源有很多种，比如文件描述符、数据库连接，甚至是再入锁，任何情况下都应该保证资源释放成功，否则即使平时能够正常运行，也可能被攻击者利用而耗尽某类资源，这也算是可能的 DoS 攻击来源。</li></ul><p>所以可以看出，实现安全的 Java 代码，需要从功能设计到实现细节，都充分考虑可能的安全影响。</p><h2 id="考点分析-31"><a href="#考点分析-31" class="headerlink" title="考点分析"></a>考点分析</h2><p>关于今天的问题，以典型的 DoS 攻击作为切入点，将问题聚焦在 Java 开发中，我介绍了 Java 应用设计、实现的注意事项，后面还会介绍更加全面的实践。</p><p>其实安全问题实际就是软件的缺陷，软件安全并不存在一劳永逸的秘籍，既离不开设计、架构中的风险分析，也离不开编码、测试等阶段的安全实践手段。对于面试官来说，考察安全问题，除了对特定安全领域知识的考察，更多是要看面试者的 Java 编程基本功和知识的积累。</p><p>所以，我会在后面会循序渐进探讨 Java 安全编程，这里面没有什么黑科技，只有规范的开发标准，很多安全问题其实是态度问题，取决于你是否真的认真对待它。</p><ul><li>我将以一些典型的代码片段为出发点，分析一些非常容易被忽略的安全风险，并介绍安全问题频发的热点场景，如 Java 序列化和反序列化。</li><li>从软件生命周期的角度，探讨设计、开发、测试、部署等不同阶段，有哪些常见的安全策略或工具。</li></ul><h2 id="知识扩展-31"><a href="#知识扩展-31" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们一起来看一段不起眼的条件判断代码，这里可能有什么问题吗？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c 都是 int 类型的数值</span><br><span class="line">if (<span class="selector-tag">a</span> + <span class="selector-tag">b</span> &lt; c) &#123;</span><br><span class="line">// …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会纳闷，这是再常见不过的一个条件判断了，能有什么安全隐患？</p><p>这里的隐患是数值类型需要防范溢出，否则这不仅仅可能会带来逻辑错误，在特定情况下可能导致严重的安全漏洞。</p><p>从语言特性来说，Java 和 JVM 提供了很多基础性的改进，相比于传统的 C、C++ 等语言，对于数组越界等处理要完善的多，原生的避免了<a href="https://en.wikipedia.org/wiki/Buffer_overflow">缓冲区溢出</a>等攻击方式，提高了软件的安全性。但这并不代表完全杜绝了问题，Java 程序可能调用本地代码，也就是 JNI 技术，错误的数值可能导致 C/C++ 层面的数据越界等问题，这是很危险的。</p><p>所以，上面的条件判断，需要判断其数值范围，例如，写成类似下面结构。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="selector-tag">a</span> &lt; c – <span class="selector-tag">b</span>)</span><br></pre></td></tr></table></figure><p>再来看一个例子，请看下面的一段异常处理代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(hostname + port + “ doesn’t response”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将敏感信息包含在异常消息中，试想，如果是一个 Web 应用，异常也没有良好的包装起来，很有可能就把内部信息暴露给终端客户。古人曾经告诫我们“言多必失”是很有道理的，虽然其本意不是指软件安全，但尽量少暴露信息，也是保证安全的基本原则之一。即使我们并不认为某个信息有安全风险，我的建议也是如果没有必要，不要暴露出来。</p><p>这种暴露还可能通过其他方式发生，比如某著名的编程技术网站，就被曝光过所有用户名和密码。这些信息都是明文存储，传输过程也未必进行加密，类似这种情况，暴露只是个时间早晚的问题。</p><p>对于安全标准特别高的系统，甚至可能要求敏感信息被使用后，要立即明确在内存中销毁，以免被探测；或者避免在发生 core dump 时，意外暴露。</p><p>第三，Java 提供了序列化等创新的特性，广泛使用在远程调用等方面，但也带来了复杂的安全问题。直到今天，序列化仍然是个安全问题频发的场景。</p><p>针对序列化，通常建议：</p><ul><li>敏感信息不要被序列化！在编码中，建议使用 transient 关键字将其保护起来。</li><li>反序列化中，建议在 readObject 中实现与对象构件过程相同的安全检查和数据检查。</li></ul><p>另外，在 JDK 9 中，Java 引入了过滤器机制，以保证反序列化过程中数据都要经过基本验证才可以使用。其原理是通过黑名单和白名单，限定安全或者不安全的类型，并且你可以进行定制，然后通过环境变量灵活进行配置， 更加具体的使用你可以参考 <a href="https://docs.oracle.com/javase/9/docs/api/java/io/ObjectInputFilter.html">ObjectInputFilter</a>。</p><p>通过前面的介绍，你可能注意到，很多安全问题都是源于非常基本的编程细节，类似 Immutable、封装等设计，都存在着安全性的考虑。从实践的角度，让每个人都了解和掌握这些原则，有必要但并不太现实，有没有什么工程实践手段，可以帮助我们排查安全隐患呢？</p><p><strong>开发和测试阶段</strong></p><p>在实际开发中，各种功能点五花八门，未必能考虑的全面。我建议没有必要所有都需要自己去从头实现，尽量使用广泛验证过的工具、类库，不管是来自于 JDK 自身，还是 Apache 等第三方组织，都在社区的反馈下持续地完善代码安全。</p><p>开发过程中应用代码规约标准，是避免安全问题的有效手段。我特别推荐来自孤尽的《阿里巴巴 Java 开发手册》，以及其配套工具，充分总结了业界在 Java 等领域的实践经验，将规约实践系统性地引入国内的软件开发，可以有效提高代码质量。</p><p>当然，凡事都是有代价的，规约会增加一定的开发成本，可能对迭代的节奏产生一定影响，所以对于不同阶段、不同需求的团队，可以根据自己的情况对规约进行适应性的调整。</p><p>落实到实际开发流程中，以 OpenJDK 团队为例，我们应用了几个不同角度的实践：</p><ul><li>在早期设计阶段，就由安全专家组对新特性进行风险评估。</li><li>开发过程中，尤其是 code review 阶段，应用 OpenJDK 自身定制的代码规范。</li><li>利用多种静态分析工具如<a href="http://findbugs.sourceforge.net/">FindBugs</a>、<a href="https://labs.oracle.com/pls/apex/f?p=labs:49:::::P49_PROJECT_ID:13">Parfait</a>等，帮助早期发现潜在安全风险，并对相应问题采取零容忍态度，强制要求解决。</li><li>甚至 OpenJDK 会默认将任何（编译等）警告，都当作错误对待，并体现在 CI 流程中。</li><li>在代码 check-in 等关键环节，利用 hook 机制去调用规则检查工具，以保证不合规代码不能进入 OpenJDK 代码库。</li></ul><p>关于静态分析工具的选择，我们选取的原则是“足够好”。没有什么工具能够发现所有问题，所以在保证功能的前提下，影响更大的是分析效率，换句话说是代码分析的噪音高低。不管分析有多么的完备，如果太多误报，就会导致有用信息被噪音覆盖，也不利于后续其他程序化的处理，反倒不利于排查问题。</p><p>以上这些是为了保证 JDK 作为基础平台的苛刻质量要求，在实际产品中，你需要斟酌具体什么程度的要求是合理的。</p><p><strong>部署阶段</strong></p><p>JDK 自身的也是个软件，难免会存在实现瑕疵，我们平时看到 JDK 更新的安全漏洞补丁，其实就是在修补这些漏洞。我最近还注意到，某大厂后台被曝出了使用的 JDK 版本存在序列化相关的漏洞。类似这种情况，大多数都是因为使用的 JDK 是较低版本，算是可以通过部署解决的问题。</p><p>如果是安全敏感型产品，建议关注 JDK 在加解密方面的<a href="https://java.com/en/jre-jdk-cryptoroadmap.html">路线图</a>，同样的标准也应用于其他语言和平台，很多早期认为非常安全的算法，已经被攻破，及时地升级基础软件是安全的必要条件。</p><p>攻击和防守是不对称的，只要有一个严重漏洞，对于攻击者就足够了，所以，不能对黑盒形式的部署心存侥幸，这并不能保证系统的安全，攻击者可以利用对软件设计的猜测，结合一系列手段，探测出漏洞。</p><p>今天我以 DoS 等典型攻击方式为例，分析了其在 Java 平台上的特定表现，并从更多安全编码的细节帮你体会安全问题的普遍性，最后我介绍了软件开发周期中的安全实践，希望能对你的工作有所帮助。</p><h2 id="一课一练-31"><a href="#一课一练-31" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？你在开发中遇到过 Java 特定的安全问题吗？是怎么解决的呢？�P</p><h1 id="第33讲-后台服务出现明显“变慢”，谈谈你的诊断思路？"><a href="#第33讲-后台服务出现明显“变慢”，谈谈你的诊断思路？" class="headerlink" title="第33讲 后台服务出现明显“变慢”，谈谈你的诊断思路？"></a>第33讲 后台服务出现明显“变慢”，谈谈你的诊断思路？</h1><p>在日常工作中，应用或者系统出现性能问题往往是不可避免的，除了在有一定规模的 IT 企业或者专注于特定性能领域的企业，可能大多数工程师并不会成为专职的性能工程师，但是掌握基本的性能知识和技能，往往是日常工作的需要，并且也是工程师进阶的必要条件之一，能否定位和解决性能问题也是对你知识、技能和能力的检验。</p><p>今天我要问你的问题是，后台服务出现明显“变慢”，谈谈你的诊断思路？</p><h2 id="典型回答-32"><a href="#典型回答-32" class="headerlink" title="典型回答"></a>典型回答</h2><p>首先，需要对这个问题进行更加清晰的定义:</p><ul><li>服务是突然变慢还是长时间运行后观察到变慢？类似问题是否重复出现？</li><li>“慢”的定义是什么，我能够理解是系统对其他方面的请求的反应延时变长吗?</li></ul><p>第二，理清问题的症状，这更便于定位具体的原因，有以下一些思路：</p><ul><li>问题可能来自于 Java 服务自身，也可能仅仅是受系统里其他服务的影响。初始判断可以先确认是否出现了意外的程序错误，例如检查应用本身的错误日志。 对于分布式系统，很多公司都会实现更加系统的日志、性能等监控系统。一些 Java 诊断工具也可以用于这个诊断，例如通过 JFR（<a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH173">Java Flight Recordera&gt;），监控应用是否大量出现了某种类型的异常。 如果有，那么异常可能就是个突破点。 如果没有，可以先检查系统级别的资源等情况，监控 CPU、内存等资源是否被其他进程大量占用，并且这种占用是否不符合系统正常运行状况。</a></li><li>监控 Java 服务自身，例如 GC 日志里面是否观察到 Full GC 等恶劣情况出现，或者是否 Minor GC 在变长等；利用 jstat 等工具，获取内存使用的统计信息也是个常用手段；利用 jstack 等工具检查是否出现死锁等。</li><li>如果还不能确定具体问题，对应用进行 Profiling 也是个办法，但因为它会对系统产生侵入性，如果不是非常必要，大多数情况下并不建议在生产系统进行。</li><li>定位了程序错误或者 JVM 配置的问题后，就可以采取相应的补救措施，然后验证是否解决，否则还需要重复上面部分过程。</li></ul><h2 id="考点分析-32"><a href="#考点分析-32" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天我选择的是一个常见的并且比较贴近实际应用的的性能相关问题，我提供的回答包括两部分。</p><ul><li>在正面回答之前，先探讨更加精确的问题定义是什么。有时候面试官并没有表达清楚，有必要确认自己的理解正确，然后再深入回答。</li><li>从系统、应用的不同角度、不同层次，逐步将问题域尽量缩小，隔离出真实原因。具体步骤未必千篇一律，在处理过较多这种问题之后，经验会令你的直觉分外敏感。</li></ul><p>大多数工程师也许并没有全面的性能问题诊断机会，如果被问到也不必过于紧张，你可以向面试官展示诊断问题的思考方式，展现自己的知识和综合运用的能力。接触到一个陌生的问题，通过沟通，能够条理清晰地将排查方案逐步确定下来，也是能力的体现。</p><p>面试官可能会针对某个角度的诊断深入询问，兼顾工作和面试的需求，我会针对下面一些方面进行介绍。目的是让你对性能分析有个整体的印象，在遇到特定领域问题时，即使不知道具体细节的工具和手段，至少也可以找到探索、查询的方向。</p><ul><li>我将介绍业界常见的性能分析方法论。</li><li>从系统分析到 JVM、应用性能分析，把握整体思路和主要工具。对于线程状态、JVM 内存使用等很多方面，我在专栏前面已经陆陆续续介绍了很多，今天这一讲也可以看作是聚焦性能角度的一个小结。</li></ul><p>如果你有兴趣进行系统性的学习，我建议参考 Charlie Hunt 编撰的《Java Performance》或者 Scott Oaks 的《Java Performance：The Definitive Guide》。另外，如果不希望出现理解偏差，最好是阅读英文版。</p><h2 id="知识扩展-32"><a href="#知识扩展-32" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们来了解一下业界最广泛的性能分析方法论。</p><p>根据系统架构不同，分布式系统和大型单体应用也存在着思路的区别，例如，分布式系统的性能瓶颈可能更加集中。传统意义上的性能调优大多是针对单体应用的调优，专栏的侧重点也是如此，Charlie Hunt 曾将其方法论总结为两类：</p><ul><li>自上而下。从应用的顶层，逐步深入到具体的不同模块，或者更近一步的技术细节单元，找到可能的问题和解决办法。这是最常见的性能分析思路，也是大多数工程师的选择。</li><li></li></ul><p><a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH173">自下而上。从类似 CPU 这种硬件底层，判断类似</a><a href="https://en.wikipedia.org/wiki/CPU_cache#Cache_miss">Cache-Miss</a>之类的问题和调优机会，出发点是指令级别优化。这往往是专业的性能工程师才能掌握的技能，并且需要专业工具配合，大多数是移植到新的平台上，或需要提供极致性能时才会进行。</p><p>例如，将大数据应用移植到 SPARC 体系结构的硬件上，需要对比和尽量释放性能潜力，但又希望尽量不改源代码。</p><p>我所给出的回答，首先是试图排除功能性错误，然后就是典型的自上而下分析思路。</p><p>第二，我们一起来看看自上而下分析中，各个阶段的常见工具和思路。需要注意的是，具体的工具在不同的操作系统上可能区别非常大。</p><p><strong>系统性能分析</strong>中，CPU、内存和 IO 是主要关注项。</p><p>对于 CPU，如果是常见的 Linux，可以先用 top 命令查看负载状况，下图是我截取的一个状态。<img src="http://learn.lianglianglee.com/极客时间/assets/3b927b63bec67f99e8dd72860a292601.png" alt="img"></p><p>可以看到，其平均负载（load average）的三个值（分别是 1 分钟、5 分钟、15 分钟）非常低，并且暂时看并没有升高迹象。如果这些数值非常高（例如，超过 50%、60%），并且短期平均值高于长期平均值，则表明负载很重；如果还有升高的趋势，那么就要非常警惕了。</p><p>进一步的排查有很多思路，例如，我在专栏第 18 讲曾经问过，怎么找到最耗费 CPU 的 Java 线程，简要介绍步骤：</p><ul><li>利用 top 命令获取相应 pid，“-H”代表 thread 模式，你可以配合 grep 命令更精准定位。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span> –H</span><br></pre></td></tr></table></figure><ul><li>然后转换成为 16 进制。</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">printf</span> <span class="string">&quot;%x&quot;</span> your_pid</span><br></pre></td></tr></table></figure><ul><li>最后利用 jstack 获取的线程栈，对比相应的 ID 即可。</li></ul><p>当然，还有更加通用的诊断方向，利用 vmstat 之类，查看上下文切换的数量，比如下面就是指定时间间隔为 1，收集 10 次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat -1 -10</span><br></pre></td></tr></table></figure><p>输出如下：<img src="http://learn.lianglianglee.com/极客时间/assets/abd28cb4a771365211e1a01d628213a0.png" alt="img"></p><p>如果每秒上下文（cs，<a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a>）切换很高，并且比系统中断高很多（in，system <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a>），就表明很有可能是因为不合理的多线程调度所导致。当然还需要利用<a href="https://linux.die.net/man/1/pidstat">pidstat</a>等手段，进行更加具体的定位，我就不再进一步展开了。</p><p>除了 CPU，内存和 IO 是重要的注意事项，比如：</p><ul><li>利用 free 之类查看内存使用。</li><li>或者，进一步判断 swap 使用情况，top 命令输出中 Virt 作为虚拟内存使用量，就是物理内存（Res）和 swap 求和，所以可以反推 swap 使用。显然，JVM 是不希望发生大量的 swap 使用的。</li><li>对于 IO 问题，既可能发生在磁盘 IO，也可能是网络 IO。例如，利用 iostat 等命令有助于判断磁盘的健康状况。我曾经帮助诊断过 Java 服务部署在国内的某云厂商机器上，其原因就是 IO 表现较差，拖累了整体性能，解决办法就是申请替换了机器。</li></ul><p>讲到这里，如果你对系统性能非常感兴趣，我建议参考<a href="http://www.brendangregg.com/linuxperf.html">Brendan Gregg</a>提供的完整图谱，我所介绍的只能算是九牛一毛。但我还是建议尽量结合实际需求，免得迷失在其中。<img src="http://learn.lianglianglee.com/极客时间/assets/93aa8c4516fd2266472ca4eab1b0cc40.png" alt="img"></p><p>对于<strong>JVM 层面的性能分析</strong>，我们已经介绍过非常多了：</p><ul><li>利用 JMC、JConsole 等工具进行运行时监控。</li><li>利用各种工具，在运行时进行堆转储分析，或者获取各种角度的统计数据（如<a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a> -gcutil 分析 GC、内存分带等）。</li><li>GC 日志等手段，诊断 Full GC、Minor GC，或者引用堆积等。</li></ul><p>这里并不存在放之四海而皆准的办法，具体问题可能非常不同，还要看你是否能否充分利用这些工具，从种种迹象之中，逐步判断出问题所在。</p><p>对于<strong>应用</strong><a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming"><strong>Profiling</strong></a>)，简单来说就是利用一些侵入性的手段，收集程序运行时的细节，以定位性能问题瓶颈。所谓的细节，就是例如内存的使用情况、最频繁调用的方法是什么，或者上下文切换的情况等。</p><p>我在前面给出的典型回答里提到，一般不建议生产系统进行 Profiling，大多数是在性能测试阶段进行。但是，当生产系统确实存在这种需求时，也不是没有选择。我建议使用 JFR 配合<a href="http://www.oracle.com/technetwork/java/javaseproducts/mission-control/java-mission-control-1998576.html">JMC</a>来做 Profiling，因为它是从 Hotspot JVM 内部收集底层信息，并经过了大量优化，性能开销非常低，通常是低于 <strong>2%</strong> 的；并且如此强大的工具，也已经被 Oracle 开源出来！</p><p>所以，JFR/JMC 完全具备了生产系统 Profiling 的能力，目前也确实在真正大规模部署的云产品上使用过相关技术，快速地定位了问题。</p><p>它的使用也非常方便，你不需要重新启动系统或者提前增加配置。例如，你可以在运行时启动 JFR 记录，并将这段时间的信息写入文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jcmd <span class="tag">&lt;<span class="name">pid</span>&gt;</span> JFR.start duration=120s filename=myrecording.jfr</span><br></pre></td></tr></table></figure><p>然后，使用 JMC 打开“.jfr 文件”就可以进行分析了，方法、异常、线程、IO 等应有尽有，其功能非常强大。如果你想了解更多细节，可以参考相关<a href="https://blog.takipi.com/oracle-java-mission-control-the-ultimate-guide/">指南</a>。</p><p>今天我从一个典型性能问题出发，从症状表现到具体的系统分析、JVM 分析，系统性地整理了常见性能分析的思路；并且在知识扩展部分，从方法论和实际操作的角度，让你将理论和实际结合，相信一定可以对你有所帮助。</p><h2 id="一课一练-32"><a href="#一课一练-32" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？ 今天的思考题是，Profiling 工具获取数据的主要方式有哪些？各有什么优缺点。�M</p><h1 id="第34讲-有人说“Lambda能让Java程序慢30倍”，你怎么看？"><a href="#第34讲-有人说“Lambda能让Java程序慢30倍”，你怎么看？" class="headerlink" title="第34讲 有人说“Lambda能让Java程序慢30倍”，你怎么看？"></a>第34讲 有人说“Lambda能让Java程序慢30倍”，你怎么看？</h1><p>在上一讲中，我介绍了 Java 性能问题分析的一些基本思路。但在实际工作中，我们不能仅仅等待性能出现问题再去试图解决，而是需要定量的、可对比的方法，去评估 Java 应用性能，来判断其是否能够符合业务支撑目标。今天这一讲，我会介绍从 Java 开发者角度，如何从代码级别判断应用的性能表现，重点理解最广泛使用的基准测试（Benchmark）。</p><p>今天我要问你的问题是，有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</p><p>为了让你清楚地了解这个背景，请参考下面的代码片段。在实际运行中，基于 Lambda/Stream 的版本（lambdaMaxInteger），比传统的 for-each 版本（forEachLoopMaxInteger）慢很多。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个大的 ArrayList，内部是随机的整形数据</span></span><br><span class="line"><span class="keyword">volatile</span> List&lt;Integer&gt; integers = … </span><br><span class="line"><span class="comment">// 基准测试 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">forEachLoopMaxInteger</span>()</span> &#123;</span><br><span class="line">   <span class="built_in">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">   <span class="keyword">for</span> (Integer n : integers) &#123;</span><br><span class="line">  max = Integer.max(max, n);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 基准测试 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">lambdaMaxInteger</span>()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> integers.stream().reduce(Integer.MIN_VALUE, (a, b) -&gt; Integer.max(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="典型回答-33"><a href="#典型回答-33" class="headerlink" title="典型回答"></a>典型回答</h2><p>我认为，“Lambda 能让 Java 程序慢 30 倍”这个争论实际反映了几个方面：</p><p>第一，基准测试是一个非常有效的通用手段，让我们以直观、量化的方式，判断程序在特定条件下的性能表现。</p><p>第二，基准测试必须明确定义自身的范围和目标，否则很有可能产生误导的结果。前面代码片段本身的逻辑就有瑕疵，更多的开销是源于自动装箱、拆箱（auto-boxing/unboxing），而不是源自 Lambda 和 Stream，所以得出的初始结论是没有说服力的。</p><p>第三，虽然 Lambda/Stream 为 Java 提供了强大的函数式编程能力，但是也需要正视其局限性：</p><ul><li>一般来说，我们可以认为 Lambda/Stream 提供了与传统方式接近对等的性能，但是如果对于性能非常敏感，就不能完全忽视它在特定场景的性能差异了，例如：<strong>初始化的开销</strong>。 Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html">CallSite</a>实例。这意味着，如果 Java 应用启动过程引入了很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。</li><li>增加了程序诊断等方面的复杂性，程序栈要复杂很多，Fluent 风格本身也不算是对于调试非常友好的结构，并且在可检查异常的处理方面也存在着局限性等。</li></ul><h2 id="考点分析-33"><a href="#考点分析-33" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的题目是源自于一篇有争议的<a href="https://blog.takipi.com/benchmark-how-java-8-lambdas-and-streams-can-make-your-code-5-times-slower/">文章</a>，原文后来更正为“如果 Stream 使用不当，会让你的代码慢 5 倍”。针对这个问题我给出的回答，并没有纠结于所谓的“快”与“慢”，而是从工程实践的角度指出了基准测试本身存在的问题，以及 Lambda 自身的局限性。</p><p>从知识点的角度，这个问题考察了我在<a href="http://time.geekbang.org/column/article/7514">专栏第 7 讲</a>中介绍过的自动装箱 / 拆箱机制对性能的影响，并且考察了 Java 8 中引入的 Lambda 特性的相关知识。除了这些知识点，面试官还可能更加深入探讨如何用基准测试之类的方法，将含糊的观点变成可验证的结论。</p><p>对于 Java 语言的很多特性，经常有很多似是而非的 “秘籍”，我们有必要去伪存真，以定量、定性的方式探究真相，探讨更加易于推广的实践。找到结论的能力，比结论本身更重要，因此在今天这一讲中，我们来探讨一下：</p><ul><li>基准测试的基础要素，以及如何利用主流框架构建简单的基准测试。</li><li>进一步分析，针对保证基准测试的有效性，如何避免偏离测试目的，如何保证基准测试的正确性。</li></ul><h2 id="知识扩展-33"><a href="#知识扩展-33" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们先来整体了解一下基准测试的主要目的和特征，专栏里我就不重复那些<a href="https://baike.baidu.com/item/基准测试">书面的定义</a>了。</p><p>性能往往是特定情景下的评价，泛泛地说性能“好”或者“快”，往往是具有误导性的。通过引入基准测试，我们可以定义性能对比的明确条件、具体的指标，进而保证得到<strong>定量的、可重复的</strong>对比数据，这是工程中的实际需要。</p><p>不同的基准测试其具体内容和范围也存在很大的不同。如果是专业的性能工程师，更加熟悉的可能是类似<a href="https://www.spec.org/">SPEC</a>提供的工业标准的系统级测试；而对于大多数 Java 开发者，更熟悉的则是范围相对较小、关注点更加细节的微基准测试（Micro-Benchmark）。我在文章开头提的问题，就是典型的微基准测试，也是我今天的侧重点。</p><p><strong>什么时候需要开发微基准测试呢？</strong></p><p>我认为，当需要对一个大型软件的某小部分的性能进行评估时，就可以考虑微基准测试。换句话说，微基准测试大多是 API 级别的验证，或者与其他简单用例场景的对比，例如：</p><ul><li>你在开发共享类库，为其他模块提供某种服务的 API 等。</li><li>你的 API 对于性能，如延迟、吞吐量有着严格的要求，例如，实现了定制的 HTTP 客户端 API，需要明确它对 HTTP 服务器进行大量 GET 请求时的吞吐能力，或者需要对比其他 API，保证至少对等甚至更高的性能标准。</li></ul><p>所以微基准测试更是偏基础、底层平台开发者的需求，当然，也是那些追求极致性能的前沿工程师的最爱。</p><p><strong>如何构建自己的微基准测试，选择什么样的框架比较好？</strong></p><p>目前应用最为广泛的框架之一就是<a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH</a>，OpenJDK 自身也大量地使用 JMH 进行性能对比，如果你是做 Java API 级别的性能对比，JMH 往往是你的首选。</p><p>JMH 是由 Hotspot JVM 团队专家开发的，除了支持完整的基准测试过程，包括预热、运行、统计和报告等，还支持 Java 和其他 JVM 语言。更重要的是，它针对 Hotspot JVM 提供了各种特性，以保证基准测试的正确性，整体准确性大大优于其他框架，并且，JMH 还提供了用近乎白盒的方式进行 Profiling 等工作的能力。</p><p>使用 JMH 也非常简单，你可以直接将其依赖加入 Maven 工程，如下图：<img src="http://learn.lianglianglee.com/极客时间/assets/0dd290f8842959cb02d6c3a434a58e68.png" alt="img"></p><p>也可以，利用类似下面的命令，直接生成一个 Maven 项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mvn archetype:generate \</span></span><br><span class="line"><span class="language-bash">      -DinteractiveMode=<span class="literal">false</span> \</span></span><br><span class="line"><span class="language-bash">      -DarchetypeGroupId=org.openjdk.jmh \</span></span><br><span class="line"><span class="language-bash">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \</span></span><br><span class="line"><span class="language-bash">      -DgroupId=org.sample \</span></span><br><span class="line"><span class="language-bash">      -DartifactId=<span class="built_in">test</span> \</span></span><br><span class="line"><span class="language-bash">      -Dversion=1.0</span></span><br></pre></td></tr></table></figure><p>JMH 利用注解（Annotation），定义具体的测试方法，以及基准测试的详细配置。例如，至少要加上“@Benchmark”以标识它是个基准测试方法，而 BenchmarkMode 则指定了基准测试模式，例如下面例子指定了吞吐量（Throughput）模式，还可以根据需要指定平均时间（AverageTime）等其他模式。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Benchmark</span></span><br><span class="line"><span class="variable">@BenchmarkMode</span>(Mode.Throughput)</span><br><span class="line">public void <span class="built_in">testMethod</span>() &#123;</span><br><span class="line">   <span class="comment">// Put your benchmark code here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们实现了具体的测试后，就可以利用下面的 Maven 命令构建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>运行基准测试则与运行不同的 Java 应用没有明显区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar target/benchmarks.jar</span><br></pre></td></tr></table></figure><p>更加具体的上手步骤，请参考相关<a href="http://www.baeldung.com/java-microbenchmark-harness">指南</a>。JMH 处处透着浓浓的工程师味道，并没有纠结于完善的文档，而是提供了非常棒的<a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-samples/src/main/java/org/openjdk/jmh/samples">样例代码</a>，所以你需要习惯于直接从代码中学习。</p><p><strong>如何保证微基准测试的正确性，有哪些坑需要规避？</strong></p><p>首先，构建微基准测试，需要从白盒层面理解代码，尤其是具体的性能开销，不管是 CPU 还是内存分配。这有两个方面的考虑，第一，需要保证我们写出的基准测试符合测试目的，确实验证的是我们要覆盖的功能点，这一讲的问题就是个典型例子；第二，通常对于微基准测试，我们通常希望代码片段确实是有限的，例如，执行时间如果需要很多毫秒（ms），甚至是秒级，那么这个有效性就要存疑了，也不便于诊断问题所在。</p><p>更加重要的是，由于微基准测试基本上都是体量较小的 API 层面测试，最大的威胁来自于过度“聪明”的 JVM！Brain Goetz 曾经很早就指出了微基准测试中的<a href="https://www.ibm.com/developerworks/java/library/j-jtp02225/">典型问题</a>。</p><p>由于我们执行的是非常有限的代码片段，必须要保证 JVM 优化过程不影响原始测试目的，下面几个方面需要重点关注：</p><ul><li>保证代码经过了足够并且合适的预热。我在<a href="http://time.geekbang.org/column/article/6845">专栏第 1 讲</a>中提到过，默认情况，在 server 模式下，JIT 会在一段代码执行 10000 次后，将其编译为本地代码，client 模式则是 1500 次以后。我们需要排除代码执行初期的噪音，保证真正采样到的统计数据符合其稳定运行状态。 通常建议使用下面的参数来判断预热工作到底是经过了多久。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintCompilation</span></span><br></pre></td></tr></table></figure><p>我这里建议考虑另外加上一个参数，否则 JVM 将默认开启后台编译，也就是在其他线程进行，可能导致输出的信息有些混淆。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-Xbatch</span></span><br></pre></td></tr></table></figure><p>与此同时，也要保证预热阶段的代码路径和采集阶段的代码路径是一致的，并且可以观察 PrintCompilation 输出是否在后期运行中仍然有零星的编译语句出现。</p><ul><li>防止 JVM 进行无效代码消除（Dead Code Elimination），例如下面的代码片段中，由于我们并没有使用计算结果 mul，那么 JVM 就可能直接判断无效代码，根本就不执行它。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span>()</span> &#123;</span><br><span class="line">   <span class="built_in">int</span> left = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">int</span> right = <span class="number">100</span>;</span><br><span class="line">   <span class="built_in">int</span> mul = left * right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你发现代码统计数据发生了数量级程度上的提高，需要警惕是否出现了无效代码消除的问题。</p><p>解决办法也很直接，尽量保证方法有返回值，而不是 void 方法，或者使用 JMH 提供的<a href="http://hg.openjdk.java.net/code-tools/jmh/file/3769055ad883/jmh-core/src/main/java/org/openjdk/jmh/infra/Blackhole.java">BlackHole</a>设施，在方法中添加下面语句。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">testMethod</span>(<span class="params">Blackhole blackhole</span>) &#123;</span><br><span class="line">   <span class="comment">// …</span></span><br><span class="line">   blackhole.<span class="title function_">consume</span>(mul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>防止发生常量折叠（Constant Folding）。JVM 如果发现计算过程是依赖于常量或者事实上的常量，就可能会直接计算其结果，所以基准测试并不能真实反映代码执行的性能。JMH 提供了 State 机制来解决这个问题，将本地变量修改为 State 对象信息，请参考下面示例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyState</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(MyState state, Blackhole blackhole)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> state.left;</span><br><span class="line">   <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> state.right;</span><br><span class="line">   <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> left * right;</span><br><span class="line">   blackhole.consume(mul);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另外 JMH 还会对 State 对象进行额外的处理，以尽量消除伪共享（<a href="https://blogs.oracle.com/dave/java-contended-annotation-to-help-reduce-false-sharing">False Sharing</a>）的影响，标记 @State，JMH 会自动进行补齐。</li><li>如果你希望确定方法内联（Inlining）对性能的影响，可以考虑打开下面的选项。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintInlining</span></span><br></pre></td></tr></table></figure><p>从上面的总结，可以看出来微基准测试是一个需要高度了解 Java、JVM 底层机制的技术，是个非常好的深入理解程序背后效果的工具，但是也反映了我们需要审慎对待微基准测试，不被可能的假象蒙蔽。</p><p>我今天介绍的内容是相对常见并易于把握的，对于微基准测试，GC 等基层机制同样会影响其统计数据。我在前面提到，微基准测试通常希望执行时间和内存分配速率都控制在有限范围内，而在这个过程中发生 GC，很可能导致数据出现偏差，所以 Serial GC 是个值得考虑的选项。另外，JDK 11 引入了<a href="https://openjdk.java.net/jeps/318">Epsilon GC</a>，可以考虑使用这种什么也不做的 GC 方式，从最大可能性去排除相关影响。</p><p>今天我从一个争议性的程序开始，探讨了如何从开发者角度而不是性能工程师角度，利用（微）基准测试验证你在性能上的判断，并且介绍了其基础构建方式和需要重点规避的风险点。</p><h2 id="一课一练-33"><a href="#一课一练-33" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？我们在项目中需要评估系统的容量，以计划和保证其业务支撑能力，谈谈你的思路是怎么样的？常用手段有哪些？�6</p><h1 id="第35讲-JVM优化Java代码时都做了什么？"><a href="#第35讲-JVM优化Java代码时都做了什么？" class="headerlink" title="第35讲 JVM优化Java代码时都做了什么？"></a>第35讲 JVM优化Java代码时都做了什么？</h1><p>我在专栏上一讲介绍了微基准测试和相关的注意事项，其核心就是避免 JVM 运行中对 Java 代码的优化导致失真。所以，系统地理解 Java 代码运行过程，有利于在实践中进行更进一步的调优。</p><p>今天我要问你的问题是，JVM 优化 Java 代码时都做了什么？</p><p>与以往我来给出典型回答的方式不同，今天我邀请了隔壁专栏<a href="http://time.geekbang.org/column/intro/108?utm_source=app&amp;utm_medium=article&amp;utm_campaign=108-presell&amp;utm_content=java">《深入拆解 Java 虚拟机》</a>的作者，同样是来自 Oracle 的郑雨迪博士，让他以 JVM 专家的身份去思考并回答这个问题。</p><h2 id="来自-JVM-专栏作者郑雨迪博士的回答"><a href="#来自-JVM-专栏作者郑雨迪博士的回答" class="headerlink" title="来自 JVM 专栏作者郑雨迪博士的回答"></a>来自 JVM 专栏作者郑雨迪博士的回答</h2><p>JVM 在对代码执行的优化可分为运行时（runtime）优化和即时编译器（JIT）优化。运行时优化主要是解释执行和动态编译通用的一些机制，比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。</p><p>JVM 的即时编译器优化是指将热点代码以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化（speculative/optimistic optimization）。这个怎么理解呢？比如我有一条 instanceof 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回 instanceof 的结果。如果出现了其他类，那么就抛弃这段编译后的机器码，并且切换回解释执行。</p><p>当然，JVM 的优化方式仅仅作用在运行应用代码的时候。如果应用代码本身阻塞了，比如说并发时等待另一线程的结果，这就不在 JVM 的优化范畴啦。</p><h2 id="考点分析-34"><a href="#考点分析-34" class="headerlink" title="考点分析"></a>考点分析</h2><p>感谢郑雨迪博士从 JVM 的角度给出的回答。今天这道面试题在专栏里有不少同学问我，也是会在面试时被面试官刨根问底的一个知识点，郑博士的回答已经非常全面和深入啦。</p><p>大多数 Java 工程师并不是 JVM 工程师，知识点总归是要落地的，面试官很有可能会从实践的角度探讨，例如，如何在生产实践中，与 JIT 等 JVM 模块进行交互，落实到如何真正进行实际调优。</p><p>在今天这一讲，我会从 Java 工程师日常的角度出发，侧重于：</p><ul><li>从整体去了解 Java 代码编译、执行的过程，目的是对基本机制和流程有个直观的认识，以保证能够理解调优选择背后的逻辑。</li><li>从生产系统调优的角度，谈谈将 JIT 的知识落实到实际工作中的可能思路。这里包括两部分：如何收集 JIT 相关的信息，以及具体的调优手段。</li></ul><h2 id="知识扩展-34"><a href="#知识扩展-34" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们从整体的角度来看看 Java 代码的整个生命周期，你可以参考我提供的示意图。<img src="http://learn.lianglianglee.com/极客时间/assets/12526a857a7685af0d7c2ee389c0ca9d.png" alt="img"></p><p>我在<a href="http://time.geekbang.org/column/article/6845">专栏第 1 讲</a>就已经提到过，Java 通过引入字节码这种中间表达方式，屏蔽了不同硬件的差异，由 JVM 负责完成从字节码到机器码的转化。</p><p>通常所说的编译期，是指 javac 等编译器或者相关 API 等将源码转换成为字节码的过程，这个阶段也会进行少量类似常量折叠之类的优化，只要利用反编译工具，就可以直接查看细节。</p><p>javac 优化与 JVM 内部优化也存在关联，毕竟它负责了字节码的生成。例如，Java 9 中的字符串拼接，会被 javac 替换成对 StringConcatFactory 的调用，进而为 JVM 进行字符串拼接优化提供了统一的入口。在实际场景中，还可以通过不同的<a href="https://openjdk.java.net/jeps/280">策略</a>选项来干预这个过程。</p><p>今天我要讲的重点是<strong>JVM 运行时的优化</strong>，在通常情况下，编译器和解释器是共同起作用的，具体流程可以参考下面的示意图。<img src="http://learn.lianglianglee.com/极客时间/assets/5c095075dcda0f39f0e7395ab9636378.png" alt="img"></p><p>JVM 会根据统计信息，动态决定什么方法被编译，什么方法解释执行，即使是已经编译过的代码，也可能在不同的运行阶段不再是热点，JVM 有必要将这种代码从 Code Cache 中移除出去，毕竟其大小是有限的。</p><p>就如郑博士所回答的，解释器和编译器也会进行一些通用优化，例如：</p><ul><li>锁优化，你可以参考我在<a href="http://time.geekbang.org/column/article/9042">专栏第 16 讲</a>提供的解释器运行时的源码分析。</li><li>Intrinsic 机制，或者叫作内建方法，就是针对特别重要的基础方法，JDK 团队直接提供定制的实现，利用汇编或者编译器的中间表达方式编写，然后 JVM 会直接在运行时进行替换。</li></ul><p>这么做的理由有很多，例如，不同体系结构的 CPU 在指令等层面存在着差异，定制才能充分发挥出硬件的能力。我们日常使用的典型字符串操作、数组拷贝等基础方法，Hotspot 都提供了内建实现。</p><p>而<strong>即时编译器（JIT）</strong>，则是更多优化工作的承担者。JIT 对 Java 编译的基本单元是整个方法，通过对方法调用的计数统计，甄别出热点方法，编译为本地代码。另外一个优化场景，则是最针对所谓热点循环代码，利用通常说的栈上替换技术（OSR，On-Stack Replacement，更加细节请参考<a href="https://github.com/AdoptOpenJDK/jitwatch/wiki/Understanding-the-On-Stack-Replacement-(OSR">R 大的文章</a>-optimisation-in-the-HotSpot-C1-compiler)），如果方法本身的调用频度还不够编译标准，但是内部有大的循环之类，则还是会有进一步优化的价值。</p><p>从理论上来看，JIT 可以看作就是基于两个计数器实现，方法计数器和回边计数器提供给 JVM 统计数据，以定位到热点代码。实际中的 JIT 机制要复杂得多，郑博士提到了<a href="https://en.wikipedia.org/wiki/Escape_analysis">逃逸分析</a>、<a href="https://en.wikipedia.org/wiki/Loop_unrolling">循环展开</a>、方法内联等，包括前面提到的 Intrinsic 等通用机制同样会在 JIT 阶段发生。</p><p>第二，有哪些手段可以探查这些优化的具体发生情况呢？</p><p>专栏中已经陆陆续续介绍了一些，我来简单总结一下并补充部分细节。</p><ul><li>打印编译发生的细节。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintCompilation</span></span><br></pre></td></tr></table></figure><ul><li>输出更多编译的细节。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:UnlockDiagnosticVMOptions</span> -<span class="variable constant_">XX</span><span class="symbol">:+LogCompilation</span> -<span class="variable constant_">XX</span><span class="symbol">:LogFile=&lt;your_file_path&gt;</span></span><br></pre></td></tr></table></figure><p>JVM 会生成一个 xml 形式的文件，另外， LogFile 选项是可选的，不指定则会输出到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hotspot_pid&lt;pid&gt;.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>具体格式可以参考 Ben Evans 提供的<a href="https://github.com/AdoptOpenJDK/jitwatch/">JitWatch</a>工具和<a href="http://www.oracle.com/technetwork/articles/java/architect-evans-pt1-2266278.html">分析指南</a>。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/07b00499b0ca857fc3ccd51f7046d946.png" alt="img"></p><ul><li>打印内联的发生，可利用下面的诊断选项，也需要明确解锁。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintInlining</span></span><br></pre></td></tr></table></figure><ul><li>如何知晓 Code Cache 的使用状态呢？</li></ul><p>很多工具都已经提供了具体的统计信息，比如，JMC、JConsole 之类，我也介绍过使用 NMT 监控其使用。</p><p>第三，我们作为应用开发者，有哪些可以触手可及的调优角度和手段呢？</p><ul><li>调整热点代码门限值</li></ul><p>我曾经介绍过 JIT 的默认门限，server 模式默认 10000 次，client 是 1500 次。门限大小也存在着调优的可能，可以使用下面的参数调整；与此同时，该参数还可以变相起到降低预热时间的作用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:CompileThreshold=N</span></span><br></pre></td></tr></table></figure><p>很多人可能会产生疑问，既然是热点，不是早晚会达到门限次数吗？这个还真未必，因为 JVM 会周期性的对计数的数值进行衰减操作，导致调用计数器永远不能达到门限值，除了可以利用 CompileThreshold 适当调整大小，还有一个办法就是关闭计数器衰减。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:-UseCounterDecay</span></span><br></pre></td></tr></table></figure><p>如果你是利用 debug 版本的 JDK，还可以利用下面的参数进行试验，但是生产版本是不支持这个选项的。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-XX:CounterHalfLifeTime</span></span><br></pre></td></tr></table></figure><ul><li>调整 Code Cache 大小</li></ul><p>我们知道 JIT 编译的代码是存储在 Code Cache 中的，需要注意的是 Code Cache 是存在大小限制的，而且不会动态调整。这意味着，如果 Code Cache 太小，可能只有一小部分代码可以被 JIT 编译，其他的代码则没有选择，只能解释执行。所以，一个潜在的调优点就是调整其大小限制。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:ReservedCodeCacheSize=&lt;SIZE&gt;</span></span><br></pre></td></tr></table></figure><p>当然，也可以调整其初始大小。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:InitialCodeCacheSize=&lt;SIZE&gt;</span></span><br></pre></td></tr></table></figure><p>注意，在相对较新版本的 Java 中，由于分层编译（Tiered-Compilation）的存在，Code Cache 的空间需求大大增加，其本身默认大小也被提高了。</p><ul><li>调整编译器线程数，或者选择适当的编译器模式</li></ul><p>JVM 的编译器线程数目与我们选择的模式有关，选择 client 模式默认只有一个编译线程，而 server 模式则默认是两个，如果是当前最普遍的分层编译模式，则会根据 CPU 内核数目计算 C1 和 C2 的数值，你可以通过下面的参数指定的编译线程数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:CICompilerCount=N</span></span><br></pre></td></tr></table></figure><p>在强劲的多处理器环境中，增大编译线程数，可能更加充分的利用 CPU 资源，让预热等过程更加快速；但是，反之也可能导致编译线程争抢过多资源，尤其是当系统非常繁忙时。例如，系统部署了多个 Java 应用实例的时候，那么减小编译线程数目，则是可以考虑的。</p><p>生产实践中，也有人推荐在服务器上关闭分层编译，直接使用 server 编译器，虽然会导致稍慢的预热速度，但是可能在特定工作负载上会有微小的吞吐量提高。</p><ul><li>其他一些相对边界比较混淆的所谓“优化”</li></ul><p>比如，减少进入安全点。严格说，它远远不只是发生在动态编译的时候，GC 阶段发生的更加频繁，你可以利用下面选项诊断安全点的影响。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintSafepointStatistics</span> ‑<span class="variable constant_">XX</span><span class="symbol">:+PrintGCApplicationStoppedTime</span></span><br></pre></td></tr></table></figure><p>注意，在 JDK 9 之后，PrintGCApplicationStoppedTime 已经被移除了，你需要使用“-Xlog:safepoint”之类方式来指定。</p><p>很多优化阶段都可能和安全点相关，例如：</p><ul><li>在 JIT 过程中，逆优化等场景会需要插入安全点。</li><li>常规的锁优化阶段也可能发生，比如，偏斜锁的设计目的是为了避免无竞争时的同步开销，但是当真的发生竞争时，撤销偏斜锁会触发安全点，是很重的操作。所以，在并发场景中偏斜锁的价值其实是被质疑的，经常会明确建议关闭偏斜锁。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:-UseBiasedLocking</span></span><br></pre></td></tr></table></figure><p>主要的优化手段就介绍到这里，这些方法都是普通 Java 开发者就可以利用的。如果你想对 JVM 优化手段有更深入的了解，建议你订阅 JVM 专家郑雨迪博士的专栏。</p><h2 id="一课一练-34"><a href="#一课一练-34" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？ 请思考一个问题，如何程序化验证 final 关键字是否会影响性能？�m</p><h1 id="第36讲-谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"><a href="#第36讲-谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？" class="headerlink" title="第36讲 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"></a>第36讲 谈谈MySQL支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</h1><p>在日常开发中，尤其是业务开发，少不了利用 Java 对数据库进行基本的增删改查等数据操作，这也是 Java 工程师的必备技能之一。做好数据操作，不仅仅需要对 Java 语言相关框架的掌握，更需要对各种数据库自身体系结构的理解。今天这一讲，作为补充 Java 面试考察知识点的完整性，关于数据库的应用和细节还需要在实践中深入学习。</p><p>今天我要问你的问题是，谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</p><h2 id="典型回答-34"><a href="#典型回答-34" class="headerlink" title="典型回答"></a>典型回答</h2><p>所谓隔离级别（<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems">Isolation Level</a>#Isolation_levels)），就是在数据库事务中，为保证并发数据读写的正确性而提出的定义，它并不是 MySQL 专有的概念，而是源于<a href="https://en.wikipedia.org/wiki/American_National_Standards_Institute">ANSI</a>/<a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">ISO</a>制定的<a href="https://en.wikipedia.org/wiki/SQL-92">SQL-92</a>标准。</p><p>每种关系型数据库都提供了各自特色的隔离级别实现，虽然在通常的<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems">定义</a>#Isolation_levels)中是以锁为实现单元，但实际的实现千差万别。以最常见的 MySQL InnoDB 引擎为例，它是基于 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">MVCC</a>（Multi-Versioning Concurrency Control）和锁的复合实现，按照隔离程度从低到高，MySQL 事务隔离级别分为四个不同层次：</p><ul><li>读未提交（Read uncommitted），就是一个事务能够看到其他事务尚未提交的修改，这是最低的隔离水平，允许<a href="https://en.wikipedia.org/wiki/Isolation_(database_systems">脏读</a>#Dirty_reads)出现。</li><li>读已提交（Read committed），事务能够看到的数据都是其他事务已经提交的修改，也就是保证不会看到任何中间性状态，当然脏读也不会出现。读已提交仍然是比较低级别的隔离，并不保证再次读取时能够获取同样的数据，也就是允许其他事务并发修改数据，允许不可重复读和幻象读（Phantom Read）出现。</li><li>可重复读（Repeatable reads），保证同一个事务中多次读取的数据是一致的，这是 MySQL InnoDB 引擎的默认隔离级别，但是和一些其他数据库实现不同的是，可以简单认为 MySQL 在可重复读级别不会出现幻象读。</li><li>串行化（Serializable），并发事务之间是串行化的，通常意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还会获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用），这是最高的隔离级别。</li></ul><p>至于悲观锁和乐观锁，也并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。主要区别在于，操作共享数据时，“悲观锁”即认为数据出现冲突的可能性更大，而“乐观锁”则是认为大部分情况不会出现冲突，进而决定是否采取排他性措施。</p><p>反映到 MySQL 数据库应用开发中，悲观锁一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。乐观锁则与 Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p><p>我认为前面提到的 MVCC，其本质就可以看作是种乐观锁机制，而排他性的读写锁、双阶段锁等则是悲观锁的实现。</p><p>有关它们的应用场景，你可以构建一下简化的火车余票查询和购票系统。同时查询的人可能很多，虽然具体座位票只能是卖给一个人，但余票可能很多，而且也并不能预测哪个查询者会购票，这个时候就更适合用乐观锁。</p><h2 id="考点分析-35"><a href="#考点分析-35" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题来源于实际面试，这两部分问题反映了面试官试图考察面试者在日常应用开发中，是否学习或者思考过数据库内部的机制，是否了解并发相关的基础概念和实践。</p><p>我从普通数据库应用开发者的角度，提供了一个相对简化的答案，面试官很有可能进一步从实例的角度展开，例如设计一个典型场景重现脏读、幻象读，或者从数据库设计的角度，可以用哪些手段避免类似情况。我建议你在准备面试时，可以在典型的数据库上试验一下，验证自己的观点。</p><p>其他可以考察的点也有很多，在准备这个问题时你也可以对比 Java 语言的并发机制，进行深入理解，例如，随着隔离级别从低到高，竞争性（Contention）逐渐增强，随之而来的代价同样是性能和扩展性的下降。</p><p>数据库衍生出很多不同的职责方向：</p><ul><li>数据库管理员（DBA），这是一个单独的专业领域。</li><li>数据库应用工程师，很多业务开发者就是这种定位，综合利用数据库和其他编程语言等技能，开发业务应用。</li><li>数据库工程师，更加侧重于开发数据库、数据库中间件等基础软件。</li></ul><p>后面两者与 Java 开发更加相关，但是需要的知识和技能是不同的，所以面试的考察角度也有区别，今天我会分析下对相关知识学习和准备面试的看法。</p><p>另外，在数据库相关领域，Java 工程师最常接触到的就是 O/R Mapping 框架或者类似的数据库交互类库，我会选取最广泛使用的框架进行对比和分析。</p><h2 id="知识扩展-35"><a href="#知识扩展-35" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我来谈谈对数据库相关领域学习的看法，从最广泛的应用开发者角度，至少需要掌握：</p><ul><li>数据库设计基础，包括数据库设计中的几个基本范式，各种数据库的基础概念，例如表、视图、索引、外键、序列号生成器等，清楚如何将现实中业务实体和其依赖关系映射到数据库结构中，掌握典型实体数据应该使用什么样的数据库数据类型等。</li><li>每种数据库的设计和实现多少会存在差异，所以至少要精通你使用过的数据库的设计要点。我今天开篇谈到的 MySQL 事务隔离级别，就区别于其他数据库，进一步了解 MVCC、Locking 等机制对于处理进阶问题非常有帮助；还需要了解，不同索引类型的使用，甚至是底层数据结构和算法等。</li><li>常见的 SQL 语句，掌握基础的 SQL 调优技巧，至少要了解基本思路是怎样的，例如 SQL 怎样写才能更好利用索引、知道如何分析<a href="https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html">SQL 执行计划</a>等。</li><li>更进一步，至少需要了解针对高并发等特定场景中的解决方案，例如读写分离、分库分表，或者如何利用缓存机制等，目前的数据存储也远不止传统的关系型数据库了。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/ae0959aafa30d1530ad4bdf7b1a8a19d.png" alt="img"></p><p>上面的示意图简单总结了我对数据库领域的理解，希望可以给你进行准备时提供个借鉴。当然在准备面试时并不是一味找一堆书闷头苦读，我还是建议从实际工作中使用的数据库出发，侧重于结合实践，完善和深化自己的知识体系。</p><p>接下来我们还是回到 Java 本身，目前最为通用的 Java 和数据库交互技术就是 JDBC，最常见的开源框架基本都是构建在 JDBC 之上，包括我们熟悉的<a href="https://www.tutorialspoint.com/jpa/jpa_introduction.htm">JPA</a>/<a href="https://en.wikipedia.org/wiki/Hibernate_(framework">Hibernate</a>)、<a href="http://www.mybatis.org/mybatis-3/">MyBatis</a>、Spring JDBC Template 等，各自都有独特的设计特点。</p><p>Hibernate 是最负盛名的 O/R Mapping 框架之一，它也是一个 JPA Provider。顾名思义，它是以对象为中心的，其强项更体现在数据库到 Java 对象的映射，可以很方便地在 Java 对象层面体现外键约束等相对复杂的关系，提供了强大的持久化功能。内部大量使用了<a href="https://en.wikipedia.org/wiki/Lazy_loading">Lazy-load</a>等技术提高效率。并且，为了屏蔽数据库的差异，降低维护开销，Hibernate 提供了类 SQL 的 HQL，可以自动生成某种数据库特定的 SQL 语句。</p><p>Hibernate 应用非常广泛，但是过度强调持久化和隔离数据库底层细节，也导致了很多弊端，例如 HQL 需要额外的学习，未必比深入学习 SQL 语言更高效；减弱程序员对 SQL 的直接控制，还可能导致其他代价，本来一句 SQL 的事情，可能被 Hibernate 生成几条，隐藏的内部细节也阻碍了进一步的优化。</p><p>而 MyBatis 虽然仍然提供了一些映射的功能，但更加以 SQL 为中心，开发者可以侧重于 SQL 和存储过程，非常简单、直接。如果我们的应用需要大量高性能的或者复杂的 SELECT 语句等，“半自动”的 MyBatis 就会比 Hibernate 更加实用。</p><p>而 Spring JDBC Template 也是更加接近于 SQL 层面，Spring 本身也可以集成 Hibernate 等 O/R Mapping 框架。</p><p>关于这些具体开源框架的学习，我的建议是：</p><ul><li>从整体上把握主流框架的架构和设计理念，掌握主要流程，例如 SQL 解析生成、SQL 执行到结果映射等处理过程到底发生了什么。</li><li>掌握映射等部分的细节定义和原理，根据我在准备专栏时整理的面试题目，发现很多题目都是偏向于映射定义的细节。</li><li>另外，对比不同框架的设计和实现，既有利于你加深理解，也是面试考察的热点方向之一。</li></ul><p>今天我从数据库应用开发者的角度，分析了 MySQL 数据库的部分内部机制，并且补充了我对数据库相关面试准备和知识学习的建议，最后对主流 O/R Mapping 等框架进行了简单的对比。</p><h2 id="一课一练-35"><a href="#一课一练-35" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？ 今天的思考题是，从架构设计的角度，可以将 MyBatis 分为哪几层？每层都有哪些主要模块？�=</p><h1 id="第37讲-谈谈Spring-Bean的生命周期和作用域？"><a href="#第37讲-谈谈Spring-Bean的生命周期和作用域？" class="headerlink" title="第37讲 谈谈Spring Bean的生命周期和作用域？"></a>第37讲 谈谈Spring Bean的生命周期和作用域？</h1><p>在企业应用软件开发中，Java 是毫无争议的主流语言，开放的 Java EE 规范和强大的开源框架功不可没，其中 Spring 毫无疑问已经成为企业软件开发的事实标准之一。今天这一讲，我将补充 Spring 相关的典型面试问题，并谈谈其部分设计细节。</p><p>今天我要问你的问题是，谈谈 Spring Bean 的生命周期和作用域？</p><h2 id="典型回答-35"><a href="#典型回答-35" class="headerlink" title="典型回答"></a>典型回答</h2><p>Spring Bean 生命周期比较复杂，可以分为创建和销毁两个过程。</p><p>首先，创建 Bean 会经过一系列的步骤，主要包括：</p><ul><li>实例化 Bean 对象。</li><li>设置 Bean 属性。</li><li>如果我们通过各种 Aware 接口声明了依赖关系，则会注入 Bean 对容器基础设施层面的依赖。具体包括 BeanNameAware、BeanFactoryAware 和 ApplicationContextAware，分别会注入 Bean ID、Bean Factory 或者 ApplicationContext。</li><li>调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization。</li><li>如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法。</li><li>调用 Bean 自身定义的 init 方法。</li><li>调用 BeanPostProcessor 的后置初始化方法 postProcessAfterInitialization。</li><li>创建过程完毕。</li></ul><p>你可以参考下面示意图理解这个具体过程和先后顺序。<img src="http://learn.lianglianglee.com/极客时间/assets/3a51f06f56b905b8fbf1661359e1727e.png" alt="img"></p><p>第二，Spring Bean 的销毁过程会依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法。</p><p>Spring Bean 有五个作用域，其中最基础的有下面两种：</p><ul><li>Singleton，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例。</li><li>Prototype，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例。</li></ul><p>从 Bean 的特点来看，Prototype 适合有状态的 Bean，而 Singleton 则更适合无状态的情况。另外，使用 Prototype 作用域需要经过仔细思考，毕竟频繁创建和销毁 Bean 是有明显开销的。</p><p>如果是 Web 容器，则支持另外三种作用域：</p><ul><li>Request，为每个 HTTP 请求创建单独的 Bean 实例。</li><li>Session，很显然 Bean 实例的作用域是 Session 范围。</li><li>GlobalSession，用于 Portlet 容器，因为每个 Portlet 有单独的 Session，GlobalSession 提供一个全局性的 HTTP Session。</li></ul><h2 id="考点分析-36"><a href="#考点分析-36" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天我选取的是一个入门性质的高频 Spring 面试题目，我认为相比于记忆题目典型回答里的细节步骤，理解和思考 Bean 生命周期所体现出来的 Spring 设计和机制更有意义。</p><p>你能看到，Bean 的生命周期是完全被容器所管理的，从属性设置到各种依赖关系，都是容器负责注入，并进行各个阶段其他事宜的处理，Spring 容器为应用开发者定义了清晰的生命周期沟通界面。</p><p>如果从具体 API 设计和使用技巧来看，还记得我在<a href="http://time.geekbang.org/column/article/8471">专栏第 13 讲</a>提到过的 Marker Interface 吗，Aware 接口就是个典型应用例子，Bean 可以实现各种不同 Aware 的子接口，为容器以 Callback 形式注入依赖对象提供了统一入口。</p><p>言归正传，还是回到 Spring 的学习和面试。关于 Spring，也许一整本书都无法完整涵盖其内容，专栏里我会有限地补充：</p><ul><li>Spring 的基础机制。</li><li>Spring 框架的涵盖范围。</li><li>Spring AOP 自身设计的一些细节，前面<a href="http://time.geekbang.org/column/article/10076">第 24 讲</a>偏重于底层实现原理，这样还不够全面，毕竟不管是动态代理还是字节码操纵，都还只是基础，更需要 Spring 层面对切面编程的支持。</li></ul><h2 id="知识扩展-36"><a href="#知识扩展-36" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们先来看看 Spring 的基础机制，至少你需要理解下面两个基本方面。</p><ul><li>控制反转（Inversion of Control），或者也叫依赖注入（Dependency Injection），广泛应用于 Spring 框架之中，可以有效地改善了模块之间的紧耦合问题。</li></ul><p>从 Bean 创建过程可以看到，它的依赖关系都是由容器负责注入，具体实现方式包括带参数的构造函数、setter 方法或者<a href="https://docs.spring.io/spring-framework/docs/5.0.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">AutoWired</a>方式实现。</p><ul><li>AOP，我们已经在前面接触过这种切面编程机制，Spring 框架中的事务、安全、日志等功能都依赖于 AOP 技术，下面我会进一步介绍。</li></ul><p>第二，Spring 到底是指什么？</p><p>我前面谈到的 Spring，其实是狭义的<a href="https://github.com/spring-projects/spring-framework/blob/67ea4b3a050af3db5545f58ff85a0d132ee91c2a/spring-aop/src/main/java/org/aopalliance/aop/Advice.java">Spring Framework</a>，其内部包含了依赖注入、事件机制等核心模块，也包括事务、O/R Mapping 等功能组成的数据访问模块，以及 Spring MVC 等 Web 框架和其他基础组件。</p><p>广义上的 Spring 已经成为了一个庞大的生态系统，例如：</p><ul><li>Spring Boot，通过整合通用实践，更加自动、智能的依赖管理等，Spring Boot 提供了各种典型应用领域的快速开发基础，所以它是以应用为中心的一个框架集合。</li><li>Spring Cloud，可以看作是在 Spring Boot 基础上发展出的更加高层次的框架，它提供了构建分布式系统的通用模式，包含服务发现和服务注册、分布式配置管理、负载均衡、分布式诊断等各种子系统，可以简化微服务系统的构建。</li><li>当然，还有针对特定领域的 Spring Security、Spring Data 等。</li></ul><p>上面的介绍比较笼统，针对这么多内容，如果将目标定得太过宽泛，可能就迷失在 Spring 生态之中，我建议还是深入你当前使用的模块，如 Spring MVC。并且，从整体上把握主要前沿框架（如 Spring Cloud）的应用范围和内部设计，至少要了解主要组件和具体用途，毕竟如何构建微服务等，已经逐渐成为 Java 应用开发面试的热点之一。</p><p>第三，我们来探讨一下更多有关 Spring AOP 自身设计和实现的细节。</p><p>先问一下自己，我们为什么需要切面编程呢？</p><p>切面编程落实到软件工程其实是为了更好地模块化，而不仅仅是为了减少重复代码。通过 AOP 等机制，我们可以把横跨多个不同模块的代码抽离出来，让模块本身变得更加内聚，进而业务开发者可以更加专注于业务逻辑本身。从迭代能力上来看，我们可以通过切面的方式进行修改或者新增功能，这种能力不管是在问题诊断还是产品能力扩展中，都非常有用。</p><p>在之前的分析中，我们已经分析了 AOP Proxy 的实现原理，简单回顾一下，它底层是基于 JDK 动态代理或者 cglib 字节码操纵等技术，运行时动态生成被调用类型的子类等，并实例化代理对象，实际的方法调用会被代理给相应的代理对象。但是，这并没有解释具体在 AOP 设计层面，什么是切面，如何定义切入点和切面行为呢？</p><p>Spring AOP 引入了其他几个关键概念：</p><ul><li>Aspect，通常叫作方面，它是跨不同 Java 类层面的横切性逻辑。在实现形式上，既可以是 XML 文件中配置的普通类，也可以在类代码中用“@Aspect”注解去声明。在运行时，Spring 框架会创建类似<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-aop/src/main/java/org/springframework/aop/Advisor.java">Advisor</a>来指代它，其内部会包括切入的时机（Pointcut）和切入的动作（Advice）。</li><li>Join Point，它是 Aspect 可以切入的特定点，在 Spring 里面只有方法可以作为 Join Point。</li><li><a href="https://github.com/spring-projects/spring-framework/blob/67ea4b3a050af3db5545f58ff85a0d132ee91c2a/spring-aop/src/main/java/org/aopalliance/aop/Advice.java">Advice</a>，它定义了切面中能够采取的动作。如果你去看 Spring 源码，就会发现 Advice、Join Point 并没有定义在 Spring 自己的命名空间里，这是因为他们是源自<a href="http://aopalliance.sourceforge.net/">AOP 联盟</a>，可以看作是 Java 工程师在 AOP 层面沟通的通用规范。</li></ul><p>Java 核心类库中同样存在类似代码，例如 Java 9 中引入的 Flow API 就是 Reactive Stream 规范的最小子集，通过这种方式，可以保证不同产品直接的无缝沟通，促进了良好实践的推广。</p><p>具体的 Spring Advice 结构请参考下面的示意图。<img src="http://learn.lianglianglee.com/极客时间/assets/5b6955b4757c1a5fd0ecacdaf835e3ba.png" alt="img"></p><p>其中，BeforeAdvice 和 AfterAdvice 包括它们的子接口是最简单的实现。而 Interceptor 则是所谓的拦截器，用于拦截住方法（也包括构造器）调用事件，进而采取相应动作，所以 Interceptor 是覆盖住整个方法调用过程的 Advice。通常将拦截器类型的 Advice 叫作 Around，在代码中可以使用“@Around”来标记，或者在配置中使用“<a href="aop:around">aop:around</a>”。</p><p>如果从时序上来看，则可以参考下图，理解具体发生的时机。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/85205c0c0ddcdafd2fad4ff5a53af0cb.png" alt="img"></p><ul><li>Pointcut，它负责具体定义 Aspect 被应用在哪些 Join Point，可以通过指定具体的类名和方法名来实现，或者也可以使用正则表达式来定义条件。</li></ul><p>你可以参看下面的示意图，来进一步理解上面这些抽象在逻辑上的意义。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/dee96c33619d76d33281332bb3d2494a.png" alt="img"></p><ul><li>Join Point 仅仅是可利用的机会。</li><li>Pointcut 是解决了切面编程中的 Where 问题，让程序可以知道哪些机会点可以应用某个切面动作。</li><li>而 Advice 则是明确了切面编程中的 What，也就是做什么；同时通过指定 Before、After 或者 Around，定义了 When，也就是什么时候做。</li></ul><p>在准备面试时，如果在实践中使用过 AOP 是最好的，否则你可以选择一个典型的 AOP 实例，理解具体的实现语法细节，因为在面试考察中也许会问到这些技术细节。</p><p>如果你有兴趣深入内部，最好可以结合 Bean 生命周期，理解 Spring 如何解析 AOP 相关的注解或者配置项，何时何地使用到动态代理等机制。为了避免被庞杂的源码弄晕，我建议你可以从比较精简的测试用例作为一个切入点，如<a href="https://github.com/spring-projects/spring-framework/blob/da80502ea6ed4860f5bf7b668300644cdfe3bb5a/spring-context/src/test/java/org/springframework/aop/framework/CglibProxyTests.java">CglibProxyTests</a>。</p><p>另外，Spring 框架本身功能点非常多，AOP 并不是它所支持的唯一切面技术，它只能利用动态代理进行运行时编织，而不能进行编译期的静态编织或者类加载期编织。例如，在 Java 平台上，我们可以使用 Java Agent 技术，在类加载过程中对字节码进行操纵，比如修改或者替换方法实现等。在 Spring 体系中，如何做到类似功能呢？你可以使用 AspectJ，它具有更加全面的能力，当然使用也更加复杂。</p><p>今天我从一个常见的 Spring 面试题开始，浅谈了 Spring 的基础机制，探讨了 Spring 生态范围，并且补充分析了部分 AOP 的设计细节，希望对你有所帮助。</p><h2 id="一课一练-36"><a href="#一课一练-36" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，请介绍一下 Spring 声明式事务的实现机制，可以考虑将具体过程画图。�\</p><h1 id="第38讲-对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？"><a href="#第38讲-对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？" class="headerlink" title="第38讲 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？"></a>第38讲 对比Java标准NIO类库，你知道Netty是如何实现更高性能的吗？</h1><p>今天我会对 NIO 进行一些补充，在<a href="http://time.geekbang.org/column/article/8369">专栏第 11 讲</a>中，我们初步接触了 Java 提供的几种 IO 机制，作为语言基础类库，Java 自身的 NIO 设计更偏底层，这本无可厚非，但是对于一线的应用开发者，其复杂性、扩展性等方面，就存在一定的局限了。在基础 NIO 之上，Netty 构建了更加易用、高性能的网络框架，广泛应用于互联网、游戏、电信等各种领域。</p><p>今天我要问你的问题是，对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</p><h2 id="典型回答-36"><a href="#典型回答-36" class="headerlink" title="典型回答"></a>典型回答</h2><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p><ul><li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li><li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li><li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li><li>在通信协议、序列化等其他角度的优化。</li></ul><p>总的来说，Netty 并没有 Java 核心类库那些强烈的通用性、跨平台等各种负担，针对性能等特定目标以及 Linux 等特定环境，采取了一些极致的优化手段。</p><h2 id="考点分析-37"><a href="#考点分析-37" class="headerlink" title="考点分析"></a>考点分析</h2><p>这是一个比较开放的问题，我给出的回答是个概要性的举例说明。面试官很可能利用这种开放问题作为引子，针对你回答的一个或者多个点，深入探讨你在不同层次上的理解程度。</p><p>在面试准备中，兼顾整体性的同时，不要忘记选定个别重点进行深入理解掌握，最好是进行源码层面的深入阅读和实验。如果你希望了解更多从性能角度 Netty 在编码层面的手段，可以参考 Norman 在 Devoxx 上的<a href="https://speakerdeck.com/normanmaurer/writing-highly-performant-network-frameworks-on-the-jvm-a-love-hate-relationship">分享</a>，其中的很多技巧对于实现极致性能的 API 有一定借鉴意义，但在一般的业务开发中要谨慎采用。</p><p>虽然提到 Netty，人们会自然地想到高性能，但是 Netty 本身的优势不仅仅只有这一个方面，</p><p>下面我会侧重两个方面：</p><ul><li>对 Netty 进行整体介绍，帮你了解其基本组成。</li><li>从一个简单的例子开始，对比在<a href="http://time.geekbang.org/column/article/8369">第 11 讲</a>中基于 IO、NIO 等标准 API 的实例，分析它的技术要点，给你提供一个进一步深入学习的思路。</li></ul><h2 id="知识扩展-37"><a href="#知识扩展-37" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>首先，我们从整体了解一下 Netty。按照官方定义，它是一个异步的、基于事件 Client/Server 的网络框架，目标是提供一种简单、快速构建网络应用的方式，同时保证高吞吐量、低延时、高可靠性。</p><p>从设计思路和目的上，Netty 与 Java 自身的 NIO 框架相比有哪些不同呢？</p><p>我们知道 Java 的标准类库，由于其基础性、通用性的定位，往往过于关注技术模型上的抽象，而不是从一线应用开发者的角度去思考。我曾提到过，引入并发包的一个重要原因就是，应用开发者使用 Thread API 比较痛苦，需要操心的不仅仅是业务逻辑，而且还要自己负责将其映射到 Thread 模型上。Java NIO 的设计也有类似的特点，开发者需要深入掌握线程、IO、网络等相关概念，学习路径很长，很容易导致代码复杂、晦涩，即使是有经验的工程师，也难以快速地写出高可靠性的实现。</p><p>Netty 的设计强调了 “<strong>Separation Of Concerns</strong>”，通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。</p><p>另外，<strong>Netty &gt; java.nio + java. net！</strong></p><p>从 API 能力范围来看，Netty 完全是 Java NIO 框架的一个大大的超集，你可以参考 Netty 官方的模块划分。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/f5de2483afd924b90ea09b656f4fced8.png" alt="img"></p><p>除了核心的事件机制等，Netty 还额外提供了很多功能，例如：</p><ul><li>从网络协议的角度，Netty 除了支持传输层的 UDP、TCP、<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol">SCTP</a>协议，也支持 HTTP(s)、WebSocket 等多种应用层协议，它并不是单一协议的 API。</li><li>在应用中，需要将数据从 Java 对象转换成为各种应用协议的数据格式，或者进行反向的转换，Netty 为此提供了一系列扩展的编解码框架，与应用开发场景无缝衔接，并且性能良好。</li><li>它扩展了 Java NIO Buffer，提供了自己的 ByteBuf 实现，并且深度支持 Direct Buffer 等技术，甚至 hack 了 Java 内部对 Direct Buffer 的分配和销毁等。同时，Netty 也提供了更加完善的 Scatter/Gather 机制实现。</li></ul><p>可以看到，Netty 的能力范围大大超过了 Java 核心类库中的 NIO 等 API，可以说它是一个从应用视角出发的产物。</p><p>当然，对于基础 API 设计，Netty 也有自己独到的见解，未来 Java NIO API 也可能据此进行一定的改进，如果你有兴趣可以参考<a href="https://bugs.openjdk.java.net/browse/JDK-8187540">JDK-8187540</a>。</p><p>接下来，我们一起来看一个入门的代码实例，看看 Netty 应用到底是什么样子。</p><p>与<a href="http://time.geekbang.org/column/article/8369">第 11 讲</a>类似，同样是以简化的 Echo Server 为例，下图是 Netty 官方提供的 Server 部分，完整用例请点击<a href="http://netty.io/4.1/xref/io/netty/example/echo/package-summary.html">链接</a>。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/97f1f65e7277681a9e6da818832c8342.png" alt="img"></p><p>上面的例子，虽然代码很短，但已经足够体现出 Netty 的几个核心概念，请注意我用红框标记出的部分：</p><ul><li><a href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java">ServerBootstrap</a>，服务器端程序的入口，这是 Netty 为简化网络程序配置和关闭等生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以<strong>Fluent</strong> API 等形式完成，相对简化了 API 使用。与之相对应， <a href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a>则是 Client 端的通常入口。</li><li><a href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/Channel.java">Channel</a>，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li><a href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a>，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li><a href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/ChannelFuture.java">ChannelFuture</a>，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有<a href="https://github.com/netty/netty/blob/eb7f751ba519cbcab47d640cd18757f09d077b55/common/src/main/java/io/netty/util/concurrent/Future.java">Future</a>定义。</li><li>ChannelHandler，这是应用开发者<strong>放置业务逻辑的主要地方</strong>，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li><a href="https://github.com/netty/netty/blob/2c13f71c733c5778cd359c9148f50e63d1878f7f/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a>，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ul><p>你可以参考下面的简化示意图，忽略 Inbound/OutBound Handler 的细节，理解这几个基本单元之间的操作流程和对应关系。</p><p><img src="http://learn.lianglianglee.com/极客时间/assets/77452800d6567dbf202583a9308421fa.png" alt="img"></p><p>对比 Java 标准 NIO 的代码，Netty 提供的相对高层次的封装，减少了对 Selector 等细节的操纵，而 EventLoop、Pipeline 等机制则简化了编程模型，开发者不用担心并发等问题，在一定程度上简化了应用代码的开发。最难能可贵的是，这一切并没有以可靠性、可扩展性为代价，反而将其大幅度提高。</p><p>我在<a href="http://time.geekbang.org/column/article/12188">专栏周末福利</a>中已经推荐了 Norman Maurer 等编写的《Netty 实战》（Netty In Action），如果你想系统学习 Netty，它会是个很好的入门参考。针对 Netty 的一些实现原理，很可能成为面试中的考点，例如：</p><ul><li>Reactor 模式和 Netty 线程模型。</li><li>Pipelining、EventLoop 等部分的设计实现细节。</li><li>Netty 的内存管理机制、<a href="http://netty.io/wiki/reference-counted-objects.html">引用计数</a>等特别手段。</li><li>有的时候面试官也喜欢对比 Java 标准 NIO API，例如，你是否知道 Java NIO 早期版本中的 Epoll<a href="http://www.10tiao.com/html/308/201602/401718035/1.html">空转问题</a>，以及 Netty 的解决方式等。</li></ul><p>对于这些知识点，公开的深入解读已经有很多了，在学习时希望你不要一开始就被复杂的细节弄晕，可以结合实例，逐步、有针对性的进行学习。我的一个建议是，可以试着画出相应的示意图，非常有助于理解并能清晰阐述自己的看法。</p><p>今天，从 Netty 性能的问题开始，我概要地介绍了 Netty 框架，并且以 Echo Server 为例，对比了 Netty 和 Java NIO 在设计上的不同。但这些都仅仅是冰山的一角，全面掌握还需要下非常多的功夫。</p><h2 id="一课一练-37"><a href="#一课一练-37" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，Netty 的线程模型是什么样的？�d</p><h1 id="第39讲-谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？"><a href="#第39讲-谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？" class="headerlink" title="第39讲 谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？"></a>第39讲 谈谈常用的分布式ID的设计方案？Snowflake是否受冬令时切换影响？</h1><p>专栏的绝大部分主题都侧重于 Java 语言和虚拟机，基本都是单机模式下的问题，今天我会补充一个分布式相关的问题。严格来说，分布式并不算是 Java 领域，而是一个单独的大主题，但确实也会在 Java 技术岗位面试中被涉及。在准备面试时，如果有丰富的分布式系统经验当然好；如果没有，你可以选择典型问题和基础技术进行适当准备。关于分布式，我自身的实战经验也非常有限，专栏里就谈谈从理论出发的一些思考。</p><p>今天我要问你的问题是，谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</p><h2 id="典型回答-37"><a href="#典型回答-37" class="headerlink" title="典型回答"></a>典型回答</h2><p>首先，我们需要明确通常的分布式 ID 定义，基本的要求包括：</p><ul><li>全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。</li><li>有序性，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。</li></ul><p>目前业界的方案很多，典型方案包括：</p><ul><li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。</li><li>基于 Twitter 早期开源的<a href="https://github.com/twitter/snowflake">Snowflake</a>的实现，以及相关改动方案。这是目前应用相对比较广泛的一种方式，其结构定义你可以参考下面的示意图。</li></ul><p><img src="http://learn.lianglianglee.com/极客时间/assets/ffd41494a39ef737b3c1151929c3c4ad.png" alt="img"></p><p>整体长度通常是 64 （1 + 41 + 10+ 12 = 64）位，适合使用 Java 语言中的 long 类型来存储。</p><p>头部是 1 位的正负标识位。</p><p>紧跟着的高位部分包含 41 位时间戳，通常使用 System.currentTimeMillis()。</p><p>后面是 10 位的 WorkerID，标准定义是 5 位数据中心 + 5 位机器 ID，组成了机器编号，以区分不同的集群节点。</p><p>最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。</p><p>Snowflake 的<a href="https://github.com/twitter/snowflake">官方版本</a>是基于 Scala 语言，Java 等其他语言的<a href="https://github.com/relops/snowflake">参考实现</a>有很多，是一种非常简单实用的方式，具体位数的定义是可以根据分布式系统的真实场景进行修改的，并不一定要严格按照示意图中的设计。</p><ul><li>Redis、Zookeeper、MongoDB 等中间件，也都有各种唯一 ID 解决方案。其中一些设计也可以算作是 Snowflake 方案的变种。例如，MongoDB 的<a href="https://mongodb.github.io/node-mongodb-native/2.0/tutorials/objectid/">ObjectId</a>提供了一个 12 byte（96 位）的 ID 定义，其中 32 位用于记录以秒为单位的时间，机器 ID 则为 24 位，16 位用作进程 ID，24 位随机起始的计数序列。</li><li>国内的一些大厂开源了其自身的部分分布式 ID 实现，InfoQ 就曾经介绍过微信的<a href="http://www.infoq.com/cn/articles/wechat-serial-number-generator-architecture">seqsvr</a>，它采取了相对复杂的两层架构，并根据社交应用的数据特点进行了针对性设计，具体请参考相关<a href="https://github.com/nebula-im/seqsvr">代码实现</a>。另外，<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">百度</a>、美团等也都有开源或者分享了不同的分布式 ID 实现，都可以进行参考。</li></ul><p>关于第二个问题，<strong>Snowflake 是否受冬令时切换影响？</strong></p><p>我认为没有影响，你可以从 Snowflake 的具体算法实现寻找答案。我们知道 Snowflake 算法的 Java 实现，大都是依赖于 System.currentTimeMillis()，这个数值代表什么呢？从 Javadoc 可以看出，它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个数值与夏 / 冬令时并没有关系，所以并不受其影响。</p><h2 id="考点分析-38"><a href="#考点分析-38" class="headerlink" title="考点分析"></a>考点分析</h2><p>今天的问题不仅源自面试的热门考点，并且也存在着广泛的应用场景，我前面给出的回答只是一个比较精简的典型方案介绍。我建议你针对特定的方案进行深入分析，以保证在面试官可能会深入追问时能有充分准备；如果恰好在现有系统使用分布式 ID，理解其设计细节是很有必要的。</p><p>涉及分布式，很多单机模式下的简单问题突然就变得复杂了，这是分布式天然的复杂性，需要从不同角度去理解适用场景、架构和细节算法，我会从下面的角度进行适当解读：</p><ul><li>我们的业务到底需要什么样的分布式 ID，除了唯一和有序，还有哪些必须要考虑的要素？</li><li>在实际场景中，针对典型的方案，有哪些可能的局限性或者问题，可以采取什么办法解决呢？</li></ul><h2 id="知识扩展-38"><a href="#知识扩展-38" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>如果试图深入回答这个问题，首先需要明确业务场景的需求要点，我们到底需要一个什么样的分布式 ID？</p><p>除了唯一和有序，考虑到分布式系统的功能需要，通常还会额外希望分布式 ID 保证：</p><ul><li>有意义，或者说包含更多信息，例如时间、业务等信息。这一点和有序性要求存在一定关联，如果 ID 中包含时间，本身就能保证一定程度的有序，虽然并不能绝对保证。ID 中包含额外信息，在分布式数据存储等场合中，有助于进一步优化数据访问的效率。</li><li>高可用性，这是分布式系统的必然要求。前面谈到的方案中，有的是真正意义上的分布式，有得还是传统主从的思路，这一点没有绝对的对错，取决于我们业务对扩展性、性能等方面的要求。</li><li>紧凑性，ID 的大小可能受到实际应用的制约，例如数据库存储往往对长 ID 不友好，太长的 ID 会降低 MySQL 等数据库索引的性能；编程语言在处理时也可能受数据类型长度限制。</li></ul><p>在具体的生产环境中，还有可能提出对 QPS 等方面的具体要求，尤其是在国内一线互联网公司的业务规模下，更是需要考虑峰值业务场景的数量级层次需求。</p><p>第二，<strong>主流方案的优缺点分析</strong>。</p><p>对于数据库自增方案，除了实现简单，它生成的 ID 还能够保证固定步长的递增，使用很方便。</p><p>但是，因为每获取一个 ID 就会触发数据库的写请求，是一个代价高昂的操作，构建高扩展性、高性能解决方案比较复杂，性能上限明显，更不要谈扩容等场景的难度了。与此同时，保证数据库方案的高可用性也存在挑战，数据库可能发生宕机，即使采取主从热备等各种措施，也可能出现 ID 重复等问题。</p><p>实际大厂商往往是构建了多层的复合架构，例如美团公开的数据库方案<a href="https://tech.meituan.com/MT_Leaf.html">Leaf-Segment</a>，引入了起到缓存等作用的 Leaf 层，对数据库操作则是通过数据库中间件提供的批量操作，这样既能保证性能、扩展性，也能保证高可用。但是，这种方案对基础架构层面的要求很多，未必适合普通业务规模的需求。</p><p>与其相比，Snowflake 方案的好处是算法简单，依赖也非常少，生成的序列可预测，性能也非常好，比如 Twitter 的峰值超过 10 万 /s。</p><p>但是，它也存在一定的不足，例如：</p><ul><li>时钟偏斜问题（Clock Skew）。我们知道普通的计算机系统时钟并不能保证长久的一致性，可能发生时钟回拨等问题，这就会导致时间戳不准确，进而产生重复 ID。</li></ul><p>针对这一点，Twitter 曾经在文档中建议开启<a href="http://doc.ntp.org/4.1.0/ntpd.htm">NTP</a>，毕竟 Snowflake 对时间存在依赖，但是也有人提议关闭 NTP。我个人认为还是应该开启 NTP，只是可以考虑将 stepback 设置为 0，以禁止回调。</p><p>从设计和具体编码的角度，还有一个很有效的措施就是缓存历史时间戳，然后在序列生成之前进行检验，如果出现当前时间落后于历史时间的不合理情况，可以采取相应的动作，要么重试、等待时钟重新一致，或者就直接提示服务不可用。</p><ul><li>另外，序列号的可预测性是把双刃剑，虽然简化了一些工程问题，但很多业务场景并不适合可预测的 ID。如果你用它作为安全令牌之类，则是非常危险的，很容易被黑客猜测并利用。</li><li>ID 设计阶段需要谨慎考虑暴露出的信息。例如，<a href="https://github.com/boundary/flake">Erlang 版本</a>的 flake 实现基于 MAC 地址计算 WorkerID，在安全敏感的领域往往是不可以这样使用的。</li><li>从理论上来说，类似 Snowflake 的方案由于时间数据位数的限制，存在与<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038 年问题</a>相似的理论极限。虽然目前的系统设计考虑数十年后的问题还太早，但是理解这些可能的极限是有必要的，也许会成为面试的过程中的考察点。</li></ul><p>如果更加深入到时钟和分布式系统时序的问题，还有与分布式 ID 相关但又有所区别的问题，比如在分布式系统中，不同机器的时间很可能是不一致的，如何保证事件的有序性？Lamport 在 1978 年的论文（<a href="https://amturing.acm.org/p558-lamport.pdf">Time, Clocks, and the Ording of Events in a Distributed System</a>）中就有很深入的阐述，有兴趣的同学可以去查找相应的翻译和解读。</p><p>最后，我再补充一些当前分布式领域的面试热点，例如：</p><ul><li>分布式事务，包括其产生原因、业务背景、主流的解决方案等。</li><li>理解<a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP</a>、<a href="https://en.wikipedia.org/wiki/Eventual_consistency">BASE</a>等理论，懂得从最终一致性等角度来思考问题，理解<a href="https://en.wikipedia.org/wiki/Paxos_(computer_science">Paxos</a>)、<a href="https://raft.github.io/">Raft</a>等一致性算法。</li><li>理解典型的分布式锁实现，例如最常见的<a href="https://redis.io/topics/distlock">Redis 分布式锁</a>。</li><li>负载均衡等分布式领域的典型算法，至少要了解主要方案的原理。</li></ul><p>这些方面目前都已经有相对比较深入的分析，尤其是来自于一线大厂的实践经验。另外，在<a href="http://time.geekbang.org/column/48">左耳听风专栏的“程序员练级攻略”</a>里，提供了非常全面的分布式学习资料，感兴趣的同学可以参考。</p><p>今天我简要梳理了当前典型的分布式 ID 生成方案，并探讨了 ID 设计的一些考量，尤其是应用相对广泛的 Snowflake 的不足之处，希望对你有所帮助。</p><h2 id="一课一练-38"><a href="#一课一练-38" class="headerlink" title="一课一练"></a>一课一练</h2><p>关于今天我们讨论的题目你做到心中有数了吗？今天的思考题是，从理论上来看，Snowflake 这种基于时间的算法，从形式上天然地限制了 ID 的并发生成数量，如果在极端情况下，短时间需要更多 ID，有什么办法解决呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础36讲&quot;&gt;&lt;a href=&quot;#Java基础36讲&quot; class=&quot;headerlink&quot; title=&quot;Java基础36讲&quot;&gt;&lt;/a&gt;Java基础36讲&lt;/h1&gt;&lt;h1 id=&quot;开篇词-以面试题为切入点，有效提升你的Java内功&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>10万字208道Java经典面试题总结</title>
    <link href="https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/10%E4%B8%87%E5%AD%97208%E9%81%93Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://manamn.space/2022/12/13/%E9%9D%A2%E8%AF%95%E9%A2%98/10%E4%B8%87%E5%AD%97208%E9%81%93Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-13T13:12:53.000Z</published>
    <updated>2022-12-13T13:43:30.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10万字208道Java经典面试题总结"><a href="#10万字208道Java经典面试题总结" class="headerlink" title="10万字208道Java经典面试题总结"></a>10万字208道Java经典面试题总结</h1><hr><h2 id="1、JDK-和-JRE-有什么区别？"><a href="#1、JDK-和-JRE-有什么区别？" class="headerlink" title="1、JDK 和 JRE 有什么区别？"></a>1、JDK 和 JRE 有什么区别？</h2><p>JDK（Java Development Kit），Java开发工具包</p><p>JRE（Java Runtime <a href="https://so.csdn.net/so/search?q=Environment&amp;spm=1001.2101.3001.7020">Environment</a>），Java运行环境</p><p>JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是<a href="https://so.csdn.net/so/search?q=JVM&amp;spm=1001.2101.3001.7020">JVM</a>，lib就是JVM工作所需要的类库。</p><h2 id="2、-和-equals-的区别是什么？"><a href="#2、-和-equals-的区别是什么？" class="headerlink" title="2、== 和 equals 的区别是什么？"></a>2、== 和 equals 的区别是什么？</h2><ol><li>对于基本类型，==比较的是值；</li><li>对于引用类型，==比较的是地址；</li><li>equals不能用于基本类型的比较；</li><li>如果没有重写equals，equals就相当于==；</li><li>如果重写了equals方法，equals比较的是对象的内容；</li></ol><h2 id="3、final-在-java-中有什么作用？"><a href="#3、final-在-java-中有什么作用？" class="headerlink" title="3、final 在 java 中有什么作用？"></a>3、final 在 java 中有什么作用？</h2><p>（1）用来修饰一个引用</p><ol><li>如果引用为基本数据类型，则该引用为常量，该值无法修改；</li><li>如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。</li><li>如果引用时类的成员变量，则必须当场赋值，否则编译会报错。</li></ol><p>（2）用来修饰一个方法</p><p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类<a href="https://so.csdn.net/so/search?q=重写&amp;spm=1001.2101.3001.7020">重写</a>。但是，该方法仍然可以被继承。</p><p>（3）用来修饰类</p><p>当用final修改类时，该类成为最终类，无法被继承。</p><p> 比如常用的String类就是最终类。</p><h2 id="4、java-中的-Math-round-1-5-等于多少？"><a href="#4、java-中的-Math-round-1-5-等于多少？" class="headerlink" title="4、java 中的 Math.round(-1.5) 等于多少？"></a>4、java 中的 Math.round(-1.5) 等于多少？</h2><p>Math提供了三个与取整有关的方法：ceil、floor、round</p><p>（1）ceil：向上取整；</p><p>Math.ceil(11.3) = 12;</p><p>Math.ceil(-11.3) = 11;</p><p>（2）floor：向下取整；</p><p>Math.floor(11.3) = 11;</p><p>Math.floor(-11.3) = -12;</p><p>（3）round：四舍五入；</p><p>加0.5然后向下取整。</p><p>Math.round(11.3) = 11;</p><p>Math.round(11.8) = 12;</p><p>Math.round(-11.3) = -11;</p><p>Math.round(-11.8) = -12;</p><h2 id="5、String-属于基础的数据类型吗？"><a href="#5、String-属于基础的数据类型吗？" class="headerlink" title="5、String 属于基础的数据类型吗？"></a>5、String 属于基础的数据类型吗？</h2><p>不属于。</p><p>八种基本数据类型：byte、short、char、int、long、double、float、boolean。</p><h2 id="6、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#6、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="6、String str=”i”与 String str=new String(“i”)一样吗？"></a>6、String str=”i”与 String str=new String(“i”)一样吗？</h2><p>String str=”i”会将起分配到常量池中，常量池中没有重复的元素，如果常量池中存中i，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p><p>String str=new String(“i”)会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p><h2 id="7、如何将字符串反转？"><a href="#7、如何将字符串反转？" class="headerlink" title="7、如何将字符串反转？"></a>7、如何将字符串反转？</h2><p>将对象封装到stringBuilder中，调用reverse方法反转。</p><p><img src="https://img-blog.csdnimg.cn/20210801160716840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="8、String-类的常用方法都有那些？"><a href="#8、String-类的常用方法都有那些？" class="headerlink" title="8、String 类的常用方法都有那些？"></a>8、String 类的常用方法都有那些？</h2><p>（1）常见String类的获取功能</p><blockquote><p>length：获取字符串长度；<br>charAt(int index)：获取指定索引位置的字符；<br>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引；<br>substring(int start)：从指定位置开始截取字符串,默认到末尾；<br>substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</p></blockquote><p>（2）常见String类的判断功能</p><blockquote><p>equals(Object obj)： 比较字符串的内容是否相同,区分大小写；<br>contains(String str): 判断字符串中是否包含传递进来的字符串；<br>startsWith(String str): 判断字符串是否以传递进来的字符串开头；<br>endsWith(String str): 判断字符串是否以传递进来的字符串结尾；<br>isEmpty(): 判断字符串的内容是否为空串””；</p></blockquote><p>（3）常见String类的转换功能</p><blockquote><p>byte[] getBytes(): 把字符串转换为字节数组；<br>char[] toCharArray(): 把字符串转换为字符数组；<br>String valueOf(char[] chs): 把字符数组转成字符串。valueOf可以将任意类型转为字符串；<br>toLowerCase(): 把字符串转成小写；<br>toUpperCase(): 把字符串转成大写；<br>concat(String str): 把字符串拼接；</p></blockquote><p>（4）常见String类的其他常用功能</p><blockquote><p>replace(char old,char new) 将指定字符进行互换<br>replace(String old,String new) 将指定字符串进行互换<br>trim() 去除两端空格<br>int compareTo(String str) 会对照ASCII 码表 从第一个字母进行减法运算 返回的就是这个减法的结果，如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果，如果连个字符串一摸一样 返回的就是0。</p></blockquote><h2 id="9、new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#9、new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="9、new String(“a”) + new String(“b”) 会创建几个对象？"></a>9、new String(“a”) + new String(“b”) 会创建几个对象？</h2><blockquote><p>对象1：new StringBuilder()</p><p>对象2：new String(“a”)</p><p>对象3：常量池中的”a”</p><p>对象4：new String(“b”)</p><p>对象5：常量池中的”b”</p><p>深入剖析：StringBuilder中的toString()：</p><p>对象6：new String(“ab”)</p><p>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p></blockquote><p>附加题</p><blockquote><p>String s1 = new String(“1”) + new String(“1”);//s1变量记录的地址为：new String  s1.intern();<br>//在字符串常量池中生成”11”。如何理解：jdk6：创建了一个新的对象”11”，也就有新的地址；jdk7：此时常量池中并没有创建”11”，而是创建了一个指向堆空间中new String(“11”)的地址；<br>String s2 = “11”;<br>System.out.println(s1 == s2);//jdk6:false;jdk7:true</p></blockquote><h2 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h2><p>添加到StringBuilder中，然后调用reverse()。</p><h2 id="11、String-类的常用方法都有那些？"><a href="#11、String-类的常用方法都有那些？" class="headerlink" title="11、String 类的常用方法都有那些？"></a>11、String 类的常用方法都有那些？</h2><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等等。</p><h2 id="12、普通类和抽象类有哪些区别？"><a href="#12、普通类和抽象类有哪些区别？" class="headerlink" title="12、普通类和抽象类有哪些区别？"></a>12、普通类和抽象类有哪些区别？</h2><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p><h2 id="13、接口和抽象类有什么区别？"><a href="#13、接口和抽象类有什么区别？" class="headerlink" title="13、接口和抽象类有什么区别？"></a>13、接口和抽象类有什么区别？</h2><p>（1）接口</p><p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p><p>①java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p><p>（2）抽象类</p><p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</p><h2 id="14、java-中-IO-流分为几种？"><a href="#14、java-中-IO-流分为几种？" class="headerlink" title="14、java 中 IO 流分为几种？"></a>14、java 中 IO 流分为几种？</h2><p>（1）按流划分，可以分为输入流和输出流；</p><p>（2）按单位划分，可以分为字节流和字符流；</p><p>字节流：inputStream、outputStream；</p><p>字符流：reader、writer；</p><h2 id="15、BIO、NIO、AIO-有什么区别？"><a href="#15、BIO、NIO、AIO-有什么区别？" class="headerlink" title="15、BIO、NIO、AIO 有什么区别？"></a>15、BIO、NIO、AIO 有什么区别？</h2><p>（1）同步阻塞BIO</p><p>一个连接一个线程。</p><p>JDK1.4之前，建立网络连接的时候采用BIO模式，先在启动服务端socket，然后启动客户端socket，对服务端通信，客户端发送请求后，先判断服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话会等待请求结束后才继续执行。</p><p>（2）同步非阻塞NIO</p><p>NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</p><p>JDK1.4开始支持NIO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中。</p><p>一个请求一个线程。</p><p>（3）异步非阻塞AIO</p><p>一个有效请求一个线程。</p><p>JDK1.7开始支持AIO，适用于连接数目多且连接比较长的结构，比如相册服务器，充分调用OS参与并发操作。</p><h2 id="16、Files的常用方法都有哪些？"><a href="#16、Files的常用方法都有哪些？" class="headerlink" title="16、Files的常用方法都有哪些？"></a>16、Files的常用方法都有哪些？</h2><p>exist<br>createFile<br>createDirectory<br>write<br>read<br>copy<br>size<br>delete<br>move</p><h2 id="17、什么是反射？"><a href="#17、什么是反射？" class="headerlink" title="17、什么是反射？"></a>17、什么是反射？</h2><p>所谓反射，是java在运行时进行自我观察的能力，通过class、constructor、field、method四个方法获取一个类的各个组成部分。</p><p>在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于反射机制。</p><h2 id="18、什么是-java-序列化？什么情况下需要序列化？"><a href="#18、什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="18、什么是 java 序列化？什么情况下需要序列化？"></a>18、什么是 java 序列化？什么情况下需要序列化？</h2><p>序列化就是一种用来处理对象流的机制。将对象的内容流化，将流化后的对象传输于网络之间。</p><p>序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</p><p>序列化是将对象转换为容易传输的格式的过程。</p><p>例如，可以序列化一个对象，然后通过HTTP通过Internet在客户端和服务器之间传输该对象。在另一端，反序列化将从流中心构造成对象。</p><p>一般程序在运行时，产生对象，这些对象随着程序的停止而消失，但我们想将某些对象保存下来，这时，我们就可以通过序列化将对象保存在磁盘，需要使用的时候通过反序列化获取到。</p><p>对象序列化的最主要目的就是传递和保存对象，保存对象的完整性和可传递性。</p><p>譬如通过网络传输或者把一个对象保存成本地一个文件的时候，需要使用序列化。</p><h2 id="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"><a href="#19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？" class="headerlink" title="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"></a>19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</h2><p>（1）什么要使用克隆？</p><p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，这个时候就需要克隆了。</p><p>（2）如何实现对象克隆？</p><p>实现Cloneable接口，重写clone方法；<br>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。<br>BeanUtils，apache和Spring都提供了bean工具，只是这都是浅克隆。</p><p>（3）深拷贝和浅拷贝区别是什么？</p><p>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；<br>深克隆：既克隆基本类型变量，又克隆引用类型变量；</p><p>（4）代码实例</p><p><img src="https://img-blog.csdnimg.cn/20210801160905498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210801160958218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="20、throw-和-throws-的区别？"><a href="#20、throw-和-throws-的区别？" class="headerlink" title="20、throw 和 throws 的区别？"></a>20、throw 和 throws 的区别？</h2><p>（1）throw</p><p>作用在方法内，表示抛出具体异常，由方法体内的语句处理；<br>一定抛出了异常；</p><p>（2）throws</p><p>作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；<br>可能出现异常，不一定会发生异常；</p><h2 id="21、final、finally、finalize-有什么区别？"><a href="#21、final、finally、finalize-有什么区别？" class="headerlink" title="21、final、finally、finalize 有什么区别？"></a>21、final、finally、finalize 有什么区别？</h2><p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p><p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p><p>finalize方法用于垃圾回收。</p><p>一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。</p><p>但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p><h2 id="22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p><img src="https://img-blog.csdnimg.cn/20210801161038947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="23、常见的异常类有哪些？"><a href="#23、常见的异常类有哪些？" class="headerlink" title="23、常见的异常类有哪些？"></a>23、常见的异常类有哪些？</h2><ol><li>NullPointerException：空指针异常；</li><li>SQLException：数据库相关的异常；</li><li>IndexOutOfBoundsException：数组下角标越界异常；</li><li>FileNotFoundException：打开文件失败时抛出；</li><li>IOException：当发生某种IO异常时抛出；</li><li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；</li><li>NoSuchMethodException：无法找到某一方法时，抛出；</li><li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；</li><li>NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；</li><li>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li><li>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 </li></ol><h2 id="24、hashcode是什么？有什么作用？"><a href="#24、hashcode是什么？有什么作用？" class="headerlink" title="24、hashcode是什么？有什么作用？"></a>24、hashcode是什么？有什么作用？</h2><p>Java中Object有一个方法：</p><p>public native int hashcode();</p><p>（1）hashcode()方法的作用</p><p>hashcode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。</p><p>当集合需要添加新的对象时，先调用这个对象的hashcode()方法，得到对应的hashcode值，实际上hashmap中会有一个table保存已经存进去的对象的hashcode值，如果table中没有改hashcode值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。</p><p>（2）equals和hashcode的关系</p><p>如果equals为true，hashcode一定相等； </p><p>如果equals为false，hashcode不一定不相等；</p><p>如果hashcode值相等，equals不一定相等；</p><p>如果hashcode值不等，equals一定不等；</p><p>（3）重写equals方法时，一定要重写hashcode方法</p><p>（4）百度百科</p><blockquote><p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 </p><p>hashCode 的常规协定是：<br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。<br>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） </p><p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p></blockquote><p>（5）小白解释</p><blockquote><p>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0  1  2  3  4  5  6  7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p><p>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊。</p></blockquote><h2 id="25、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#25、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="25、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>25、java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>（1）String</p><p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p><p>（2）StringBuilder</p><p>线程不安全，效率高，多用于单线程。</p><p>（3）StringBuffer</p><p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p><p>不频繁的字符串操作使用String，操作频繁的情况不建议使用String。</p><p>StringBuilder &gt; StringBuffer &gt; String。</p><h2 id="26、java-中都有哪些引用类型？"><a href="#26、java-中都有哪些引用类型？" class="headerlink" title="26、java 中都有哪些引用类型？"></a>26、java 中都有哪些引用类型？</h2><p>（1）强引用</p><p>Java中默认声明的就是强引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象。如果想被回收，可以将对象置为null； </p><p>（2）软引用（SoftReference）</p><p>在内存足够的时候，软引用不会被回收，只有在内存不足时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会跑出内存溢出异常。</p><p>byte[] buff = new byte[1024 * 1024];<br>SoftReference<byte[]> sr = new SoftReference&lt;&gt;(buff);</p><p>（3）弱引用（WeakReference）</p><p>进行垃圾回收时，弱引用就会被回收。</p><p>（4）虚引用（PhantomReference）</p><p>（5）引用队列（ReferenceQueue）</p><p>引用队列可以与软引用、弱引用、虚引用一起配合使用。</p><p>当垃圾回收器准备回收一个对象时，如果发现它还有引用，就会在回收对象之前，把这个引用加入到引用队列中。</p><p>程序可以通过判断引用队列中是否加入了引用，来判断被引用的对象是否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施。</p><h2 id="27、在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#27、在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="27、在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>27、在 Java 中，为什么不允许从静态方法中访问非静态变量？</h2><ol><li>静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；</li><li>非静态变量属于类的对象，只有在类的对象产生时，才会分配内存，通过类的实例去访问；</li><li>静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法调用。</li></ol><h2 id="28、说说Java-Bean的命名规范"><a href="#28、说说Java-Bean的命名规范" class="headerlink" title="28、说说Java Bean的命名规范"></a>28、说说Java Bean的命名规范</h2><ol><li>JavaBean 类必须是一个公共类，并将其访问属性设置为 public</li><li>JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器，此构造器也应该通过调用各个特性的设置方法来设置特性的缺省值。</li><li>一个javaBean类不应有公共实例变量，类变量都为private</li><li>持有值应该通过一组存取方法（getXxx 和 setXxx）来访问：对于每个特性，应该有一个带匹配公用 getter 和 setter 方法的专用实例变量。</li></ol><p>属性为布尔类型，可以使用 isXxx() 方法代替 getXxx() 方法。</p><p>通常属性名是要和 包名、类名、方法名、字段名、常量名作出区别的:</p><p>首先:必须用英文，不要用汉语拼音</p><p>（1）包(package)</p><p>用于将完成不同功能的类分门别类，放在不同的目录(包)下，包的命名规则：将公司域名反转作为包名。比如www.sohu.com 对于包名：每个字母都需要小写。比如：com.sohu.test;该包下的Test类的全名是：com.sohu.Test.Java 。</p><p>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(default package)。</p><p>（2）类</p><p>首字母大写，如果一个类由多个单词构成，那么每个单词的首字母都大写，而且中间不使用任何的连接符。尽量使用英文。如ConnectionFactory</p><p>（3）方法</p><p>首单词全部小写，如果一个方法由多个单词构成，那么从第二个单词开始首字母大写，不使用连接符。addPerson</p><p>（4）字段</p><p>与方法相同。如ageOfPerson</p><p>（5）常量</p><p>所有单词的字母都是大写，如果有多个单词，那么使用下划线链接即可。</p><p>如：public static final int AGE_OF_PERSON = 20; //通常加上static</p><h2 id="29、Java-Bean-属性命名规范问题分析"><a href="#29、Java-Bean-属性命名规范问题分析" class="headerlink" title="29、Java Bean 属性命名规范问题分析"></a>29、Java Bean 属性命名规范问题分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String busName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String pCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Boolean isRunning;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的命名方式，驼峰式的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getBusName</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> busName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusName</span><span class="params">(String busName)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.busName = busName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是什么？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getpCount</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setpCount</span><span class="params">(String pCount)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.pCount = pCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个也是不允许的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">getIsRunning</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isRunning;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsRunning</span><span class="params">(Boolean isRunning)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.isRunning = isRunning;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>javabean属性命名尽量使用常规的驼峰式命名规则</li><li>属性名第一个单词尽量避免使用一个字母：如eBook， eMail。</li><li>boolean属性名避免使用 “is” 开头的名称</li><li>随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。</li></ol><h2 id="30、什么是-Java-的内存模型"><a href="#30、什么是-Java-的内存模型" class="headerlink" title="30、什么是 Java 的内存模型?"></a>30、什么是 Java 的内存模型?</h2><p>在了解什么是 Java 内存模型之前，先了解一下为什么要提出 Java 内存模型。</p><p>之前提到过并发编程有三大问题</p><p>CPU 缓存，在多核 CPU 的情况下，带来了可见性问题<br>操作系统对当前执行线程的切换，带来了原子性问题<br>译器指令重排优化，带来了有序性问题<br>为了解决并发编程的三大问题，提出了 JSR-133，新的 Java 内存模型，JDK 5 开始使用。</p><p>简单总结下</p><p>Java 内存模型是 JVM 的一种规范<br>定义了共享内存在多线程程序中读写操作行为的规范<br>屏蔽了各种硬件和操作系统的访问差异，保证了 Java 程序在各种平台下对内存的访问效果一致<br>解决并发问题采用的方式：限制处理器优化和使用内存屏障<br>增强了三个同步原语（synchronized、volatile、final）的内存语义<br>定义了 happens-before 规则</p><h2 id="31、在-Java-中，什么时候用重载，什么时候用重写？"><a href="#31、在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="31、在 Java 中，什么时候用重载，什么时候用重写？"></a>31、在 Java 中，什么时候用重载，什么时候用重写？</h2><p>（1）重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p><p>（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p><p>（3）简单总结：</p><p>重载是多样性，重写是增强剂；<br>目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；<br>目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</p><p>生活例子：</p><blockquote><p>你想吃一碗面，我给你提供了拉面，炒面，刀削面，担担面供你选择，这是重载；<br>你想吃一碗面，我不但给你端来了面，还给你加了青菜，加了鸡蛋，这个是重写；</p></blockquote><p>设计模式：</p><blockquote><p>cglib实现动态代理，核心原理用的就是方法的重写；</p></blockquote><p>详细解答：</p><blockquote><p>Java的重载(overload) 最重要的应用场景就是构造器的重载，构造器重载后，提供多种形参形式的构造器，可以应对不同的业务需求，加强程序的健壮性和可扩展性，比如我们最近学习的Spring源码中的ClassPathXmlApplicationContext，它的构造函数使用重载一共提供了10个构造函数，这样就为业务的选择提供了多选择性。在应用到方法中时，主要是为了增强方法的健壮性和可扩展性，比如我们在开发中常用的各种工具类，比如我目前工作中的短信工具类SMSUtil, 发短信的方法就会使用重载，针对不同业务场景下的不同形参，提供短信发送方法，这样提高了工具类的扩展性和健壮性。<br>总结：重载必须要修改方法(构造器)的形参列表，可以修改方法的返回值类型，也可以修改方法的异常信息即访问权限；使用范围是在同一个类中，目的是对方法(构造器)进行功能扩展，以应对多业务场景的不同使用需求。提高程序的健壮性和扩展性。<br>java的重写(override) 只要用于子类对父类方法的扩展或修改，但是在我们开发中，为了避免程序混乱，重写一般都是为了方法的扩展，比如在cglib方式实现的动态代理中，代理类就是继承了目标类，对目标类的方法进行重写，同时在方法前后进行切面织入。</p></blockquote><p>总结：方法重写时，参数列表，返回值得类型是一定不能修改的，异常可以减少或者删除，但是不能抛出新的异常或者更广的异常，方法的访问权限可以降低限制，但是不能做更严格的限制。</p><p>（4）在里氏替换原则中，子类对父类的方法尽量不要重写和重载。（我们可以采用final的手段强制来遵循）</p><h2 id="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#32、举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>32、举例说明什么情况下会更倾向于使用抽象类而不是接口？</h2><p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p><p>接口通常被用来表示附属描述或行为如： Runnable 、 Clonable 、 Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable( 注：这里的意思是指如果把 Runnable 等实现为抽象类的情况 ) ，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p><p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p><h2 id="33、实例化对象有哪几种方式"><a href="#33、实例化对象有哪几种方式" class="headerlink" title="33、实例化对象有哪几种方式"></a>33、实例化对象有哪几种方式</h2><ul><li>new</li><li>clone()</li><li>通过反射机制创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用 Class.forName方法获取类，在调用类的newinstance（）方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;com.dao.User&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)cls.newInstance();</span><br></pre></td></tr></table></figure><ul><li>序列化反序列化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象（远程通信的场景下使用）</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span> (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="comment">//序列化对象</span></span><br><span class="line">out.writeObject(user1); </span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;反序列化user：&quot;</span> + user2);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><h2 id="34、byte类型127-1等于多少"><a href="#34、byte类型127-1等于多少" class="headerlink" title="34、byte类型127+1等于多少"></a>34、byte类型127+1等于多少</h2><p>byte的范围是-128~127。</p><p>字节长度为8位，最左边的是符号位，而127的二进制为01111111，所以执行+1操作时，01111111变为10000000。</p><p>大家知道，计算机中存储负数，存的是补码的兴衰。左边第一位为符号位。</p><p>那么负数的补码转换成十进制如下：</p><p>一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。</p><p>已知一个负数的补码，将其转换为十进制数，步骤如下：</p><ol><li>先对各位取反；</li><li>将其转换为十进制数；</li><li>加上负号，再减去1；</li></ol><p>例如10000000，最高位是1，是负数，①对各位取反得01111111，转换为十进制就是127，加上负号得-127，再减去1得-128；</p><hr><h2 id="35、Java-容器都有哪些？"><a href="#35、Java-容器都有哪些？" class="headerlink" title="35、Java 容器都有哪些？"></a>35、Java 容器都有哪些？</h2><p>（1）Collection</p><p>① set</p><p>HashSet、TreeSet</p><p>② list</p><p>ArrayList、LinkedList、Vector</p><p>（2）Map</p><p>HashMap、HashTable、TreeMap</p><h2 id="36、Collection-和-Collections-有什么区别？"><a href="#36、Collection-和-Collections-有什么区别？" class="headerlink" title="36、Collection 和 Collections 有什么区别？"></a>36、Collection 和 Collections 有什么区别？</h2><p>（1）Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式。</p><p>（2）Collections是一个包装类，它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）。</p><p>此类不能实例化，就像一个工具类，服务于Collection框架。</p><h2 id="37、list与Set区别"><a href="#37、list与Set区别" class="headerlink" title="37、list与Set区别"></a>37、list与Set区别</h2><p>（1）List简介</p><p>实际上有两种List：一种是基本的ArrayList,其优点在于随机访问元素，另一种是LinkedList,它并不是为快速随机访问设计的，而是快速的插入或删除。<br>ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。<br>LinkedList ：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。<br>还具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</p><p>（2）Set简介</p><p>Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection,只是行为不同。这是继承与多态思想的典型应用：表现不同的行为。Set不保存重复的元素(至于如何判断元素相同则较为负责) </p><p>Set : 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br>HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。<br>TreeSet： 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。 </p><p>（3）list与Set区别</p><p>① List,Set都是继承自Collection接口</p><p>② List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） </p><p>③ Set和List对比： </p><p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p><h2 id="38、HashMap-和-Hashtable-有什么区别？"><a href="#38、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="38、HashMap 和 Hashtable 有什么区别？"></a>38、HashMap 和 Hashtable 有什么区别？</h2><ol><li>HashMap是线程不安全的，HashTable是线程安全的；</li><li>HashMap中允许键和值为null，HashTable不允许；</li><li>HashMap的默认容器是16，为2倍扩容，HashTable默认是11，为2倍+1扩容；</li></ol><h2 id="39、说一下-HashMap-的实现原理？"><a href="#39、说一下-HashMap-的实现原理？" class="headerlink" title="39、说一下 HashMap 的实现原理？"></a>39、说一下 HashMap 的实现原理？</h2><p>（1）简介</p><p>HashMap基于map接口，元素以键值对方式存储，允许有null值，HashMap是线程不安全的。</p><p>（2）基本属性</p><p>初始化大小，默认16，2倍扩容；<br>负载因子0.75；<br>初始化的默认数组；<br>size<br>threshold。判断是否需要调整hashmap容量</p><p>（3）HashMap的存储结构</p><p>JDK1.7中采用数组+链表的存储形式。</p><p>HashMap采取Entry数组来存储key-value，每一个键值对组成了一个Entry实体，Entry类时机上是一个单向的链表结构，它具有next指针，指向下一个Entry实体，以此来解决Hash冲突的问题。</p><p>HashMap实现一个内部类Entry，重要的属性有hash、key、value、next。</p><p><img src="https://img-blog.csdnimg.cn/20210801163033687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>JDK1.8中采用数据+链表+红黑树的存储形式。当链表长度超过阈值（8）时，将链表转换为红黑树。在性能上进一步得到提升。</p><p><img src="https://img-blog.csdnimg.cn/2021080116310757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="40、set有哪些实现类？"><a href="#40、set有哪些实现类？" class="headerlink" title="40、set有哪些实现类？"></a>40、set有哪些实现类？</h2><p>（1）HashSet</p><p>HashSet是set接口的实现类，set下面最主要的实现类就是HashSet（也就是用的最多的），此外还有LinkedHashSet和TreeSet。<br>HashSet是无序的、不可重复的。通过对象的hashCode和equals方法保证对象的唯一性。<br>HashSet内部的存储结构是哈希表，是线程不安全的。</p><p>（2）TreeSet</p><p>TreeSet对元素进行排序的方式：</p><p>元素自身具备比较功能，需要实现Comparable接口，并覆盖compareTo方法。<br>元素自身不具备比较功能，需要实现Comparator接口，并覆盖compare方法。</p><p>（3）LinkedHashSet</p><p>LinkedHashSet是一种有序的Set集合，即其元素的存入和输出的顺序是相同的。</p><h2 id="41、说一下-HashSet-的实现原理？"><a href="#41、说一下-HashSet-的实现原理？" class="headerlink" title="41、说一下 HashSet 的实现原理？"></a>41、说一下 HashSet 的实现原理？</h2><p>HashSet实际上是一个HashMap实例，数据存储结构都是数组+链表。</p><p>HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value都是一个统一的对象PRESENT。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>HashSet中add方法调用的是底层HashMap中的put方法，put方法要判断插入值是否存在，而HashSet的add方法，首先判断元素是否存在，如果存在则插入，如果不存在则不插入，这样就保证了HashSet中不存在重复值。</p><p> 通过对象的hashCode和equals方法保证对象的唯一性。</p><h2 id="42、ArrayList-和-LinkedList-的区别是什么？"><a href="#42、ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="42、ArrayList 和 LinkedList 的区别是什么？"></a>42、ArrayList 和 LinkedList 的区别是什么？</h2><p>ArrayList是动态数组的数据结构实现，查找和遍历的效率较高；</p><p>LinkedList 是双向链表的数据结构，增加和删除的效率较高；</p><h2 id="43、如何实现数组和-List-之间的转换？"><a href="#43、如何实现数组和-List-之间的转换？" class="headerlink" title="43、如何实现数组和 List 之间的转换？"></a>43、如何实现数组和 List 之间的转换？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;zs&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ww&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr)</span><br><span class="line">System.out.println(list);</span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">String[] arr1 = list1.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list1.size()]);</span><br><span class="line">System.out.println(arr1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    System.out.println(arr1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44、在-Queue-中-poll-和-remove-有什么区别？"><a href="#44、在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="44、在 Queue 中 poll()和 remove()有什么区别？"></a>44、在 Queue 中 poll()和 remove()有什么区别？</h2><p>（1）offer()和add()区别：</p><p>增加新项时，如果队列满了，add会抛出异常，offer返回false。</p><p>（2）poll()和remove()区别：</p><p>poll()和remove()都是从队列中删除第一个元素，remove抛出异常，poll返回null。</p><p>（3）peek()和element（）区别：</p><p>peek()和element（）用于查询队列头部元素，为空时element抛出异常，peek返回null。</p><h2 id="45、哪些集合类是线程安全的"><a href="#45、哪些集合类是线程安全的" class="headerlink" title="45、哪些集合类是线程安全的"></a>45、哪些集合类是线程安全的</h2><p>Vector：就比Arraylist多了个同步化机制（线程安全）。<br>Stack：栈，也是线程安全的，继承于Vector。<br>Hashtable：就比Hashmap多了个线程安全。<br>ConcurrentHashMap:是一种高效但是线程安全的集合。</p><h2 id="46、迭代器-Iterator-是什么？"><a href="#46、迭代器-Iterator-是什么？" class="headerlink" title="46、迭代器 Iterator 是什么？"></a>46、迭代器 Iterator 是什么？</h2><p>为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator)。</p><h2 id="47、Iterator-怎么使用？有什么特点？"><a href="#47、Iterator-怎么使用？有什么特点？" class="headerlink" title="47、Iterator 怎么使用？有什么特点？"></a>47、Iterator 怎么使用？有什么特点？</h2><p>Iterator 接口源码中的方法：</p><ol><li>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</li><li>next() 方法获得集合中的下一个元素</li><li>hasNext() 检查集合中是否还有元素</li><li>remove() 方法将迭代器新返回的元素删除</li></ol><h2 id="48、Iterator-和-ListIterator-有什么区别？"><a href="#48、Iterator-和-ListIterator-有什么区别？" class="headerlink" title="48、Iterator 和 ListIterator 有什么区别？"></a>48、Iterator 和 ListIterator 有什么区别？</h2><p>（1）ListIterator 继承 Iterator</p><p>（2）ListIterator 比 Iterator多方法</p><ol><li>add(E e)  将指定的元素插入列表，插入位置为迭代器当前位置之前</li><li>set(E e)  迭代器返回的最后一个元素替换参数e</li><li>hasPrevious()  迭代器当前位置，反向遍历集合是否含有元素</li><li>previous()  迭代器当前位置，反向遍历集合，下一个元素</li><li>previousIndex()  迭代器当前位置，反向遍历集合，返回下一个元素的下标</li><li>nextIndex()  迭代器当前位置，返回下一个元素的下标</li></ol><p>（3）使用范围不同，Iterator可以迭代所有集合；ListIterator 只能用于List及其子类</p><ol><li>ListIterator 有 add 方法，可以向 List 中添加对象；Iterator 不能</li><li>ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向遍历；Iterator不可以</li><li>ListIterator 有 nextIndex() 和previousIndex() 方法，可定位当前索引的位置；Iterator不可以</li><li>ListIterator 有 set()方法，可以实现对 List 的修改；Iterator 仅能遍历，不能修改。</li></ol><h2 id="49、怎么确保一个集合不能被修改？"><a href="#49、怎么确保一个集合不能被修改？" class="headerlink" title="49、怎么确保一个集合不能被修改？"></a>49、怎么确保一个集合不能被修改？</h2><p>我们很容易想到用final关键字进行修饰，我们都知道</p><p>final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。</p><p>那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。</p><p>我们可以做一个实验：</p><p>可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。</p><p>那我们应该怎么做才能确保集合不被修改呢？<br>我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。</p><p>同理：Collections包也提供了对list和set集合的方法。</p><p>Collections.unmodifiableList(List)<br>Collections.unmodifiableSet(Set)</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221213204400879.png" alt="image-20221213204400879"></p><h2 id="50、队列和栈是什么？有什么区别？"><a href="#50、队列和栈是什么？有什么区别？" class="headerlink" title="50、队列和栈是什么？有什么区别？"></a>50、队列和栈是什么？有什么区别？</h2><p>（1）队列先进先出，栈先进后出。</p><p>（2）遍历数据速度不同。</p><p>栈只能从头部取数据 也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性；</p><p>队列则不同，他基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多。</p><h2 id="51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？"><a href="#51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？" class="headerlink" title="51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？"></a>51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？</h2><p>ConcurrentHashMap的原理是引用了内部的 Segment ( ReentrantLock )  分段锁，保证在操作不同段 map 的时候， 可以并发执行， 操作同段 map 的时候，进行锁的竞争和等待。从而达到线程安全， 且效率大于 synchronized。</p><p>但是在 Java 8 之后， JDK 却弃用了这个策略，重新使用了 synchronized+CAS。</p><p>弃用原因</p><p>通过  JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p><p>加入多个分段锁浪费内存空间。<br>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。<br>为了提高 GC 的效率<br>新的同步方案</p><p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？（源码保留了segment 代码， 但并没有使用）。</p><h2 id="52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"><a href="#52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？" class="headerlink" title="52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"></a>52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</h2><p>我想从下面几个角度讨论这个问题：</p><p>（1）锁的粒度</p><p>首先锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍。</p><p>（2）Hash冲突</p><p>JDK1.7中，ConcurrentHashMap从过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。<br>JDK1.8中，在ConcurrentHashmap进行扩容时，其他线程可以通过检测数组中的节点决定是否对这条链表（红黑树）进行扩容，减小了扩容的粒度，提高了扩容的效率。</p><p>下面是我对面试中的那个问题的一下看法。</p><p>为什么是synchronized，而不是ReentranLock</p><p>（1）减少内存开销</p><p>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p><p>（2）获得JVM的支持</p><p>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</p><h2 id="53、concurrentHashMap和HashTable有什么区别"><a href="#53、concurrentHashMap和HashTable有什么区别" class="headerlink" title="53、concurrentHashMap和HashTable有什么区别"></a>53、concurrentHashMap和HashTable有什么区别</h2><p>concurrentHashMap融合了hashmap和hashtable的优势，hashmap是不同步的，但是单线程情况下效率高，hashtable是同步的同步情况下保证程序执行的正确性。</p><p>但hashtable每次同步执行的时候都要锁住整个结构，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210801163535297.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>concurrentHashMap锁的方式是细粒度的。concurrentHashMap将hash分为16个桶（默认值），诸如get、put、remove等常用操作只锁住当前需要用到的桶。</p><p>concurrentHashMap的读取并发，因为读取的大多数时候都没有锁定，所以读取操作几乎是完全的并发操作，只是在求size时才需要锁定整个hash。</p><p>而且在迭代时，concurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，弱一致迭代器。在这种方式中，当iterator被创建后集合再发生改变就不会抛出ConcurrentModificationException，取而代之的是在改变时new新的数据而不是影响原来的数据，iterator完成后再讲头指针替代为新的数据，这样iterator时使用的是原来的数据。</p><h2 id="54、HasmMap和HashSet的区别"><a href="#54、HasmMap和HashSet的区别" class="headerlink" title="54、HasmMap和HashSet的区别"></a>54、HasmMap和HashSet的区别</h2><p>（1）先了解一下HashCode</p><p>Java中的集合有两类，一类是List，一类是Set。</p><p>List：元素有序，可以重复；</p><p>Set：元素无序，不可重复；</p><p>要想保证元素的不重复，拿什么来判断呢？这就是Object.equals方法了。如果元素有很多，增加一个元素，就要判断n次吗？</p><p>显然不现实，于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一根地址上，初学者可以简单的理解为，HashCode方法返回的就是对象存储的物理位置（实际上并不是）。</p><p>这样一来，当集合添加新的元素时，先调用这个元素的hashcode()方法，就一下子能定位到他应该放置的物理位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上，不用再进行任何比较了。如果这个位置上有元素，就调用它的equals方法与新元素进行比较，想同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际上调用equals方法的次数就大大降低了，几乎只需要一两次。</p><p>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率。</p><p>Java对象的equals方法和hashCode方法时这样规定的：</p><p>相等的对象就必须具有相等的hashcode。</p><ol><li>如果两个对象的hashcode相同，他们并不一定相同。</li><li>如果两个对象的hashcode相同，他们并不一定相同。</li></ol><p>如果两个Java对象A和B，A和B不相等，但是A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同，这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用规则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法避免哈希冲突。</p><p>equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p><p>（2）HashMap和HashSet的区别</p><p><img src="https://img-blog.csdnimg.cn/20210801163631659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210801163653626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="55、请谈谈-ReadWriteLock-和-StampedLock"><a href="#55、请谈谈-ReadWriteLock-和-StampedLock" class="headerlink" title="55、请谈谈 ReadWriteLock 和 StampedLock"></a>55、请谈谈 ReadWriteLock 和 StampedLock</h2><p>ReadWriteLock包括两种子锁</p><p>（1）ReadWriteLock</p><p>ReadWriteLock 可以实现多个读锁同时进行，但是读与写和写于写互斥，只能有一个写锁线程在进行。</p><p>（2）StampedLock</p><p>StampedLock是Jdk在1.8提供的一种读写锁，相比较ReentrantReadWriteLock性能更好，因为ReentrantReadWriteLock在读写之间是互斥的，使用的是一种悲观策略，在读线程特别多的情况下，会造成写线程处于饥饿状态，虽然可以在初始化的时候设置为true指定为公平，但是吞吐量又下去了，而StampedLock是提供了一种乐观策略，更好的实现读写分离，并且吞吐量不会下降。</p><p>StampedLock包括三种锁：</p><p>（1）写锁writeLock：</p><p>writeLock是一个独占锁写锁，当一个线程获得该锁后，其他请求读锁或者写锁的线程阻塞， 获取成功后，会返回一个stamp（凭据）变量来表示该锁的版本，在释放锁时调用unlockWrite方法传递stamp参数。提供了非阻塞式获取锁tryWriteLock。</p><p>（2）悲观读锁readLock：</p><p>readLock是一个共享读锁，在没有线程获取写锁情况下，多个线程可以获取该锁。如果有写锁获取，那么其他线程请求读锁会被阻塞。悲观读锁会认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据进行加锁，这是在读少写多的情况下考虑的。请求该锁成功后会返回一个stamp值，在释放锁时调用unlockRead方法传递stamp参数。提供了非阻塞式获取锁方法tryWriteLock。</p><p>（3）乐观读锁tryOptimisticRead：</p><p>tryOptimisticRead相对比悲观读锁，在操作数据前并没有通过CAS设置锁的状态，如果没有线程获取写锁，则返回一个非0的stamp变量，获取该stamp后在操作数据前还需要调用validate方法来判断期间是否有线程获取了写锁，如果是返回值为0则有线程获取写锁，如果不是0则可以使用stamp变量的锁来操作数据。由于tryOptimisticRead并没有修改锁状态，所以不需要释放锁。这是读多写少的情况下考虑的，不涉及CAS操作，所以效率较高，在保证数据一致性上需要复制一份要操作的变量到方法栈中，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性得到了保证。</p><hr><h2 id="56、线程的run-和start-有什么区别？"><a href="#56、线程的run-和start-有什么区别？" class="headerlink" title="56、线程的run()和start()有什么区别？"></a>56、线程的run()和start()有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p><h2 id="57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p><p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h2 id="58、Synchronized-用过吗，其原理是什么？"><a href="#58、Synchronized-用过吗，其原理是什么？" class="headerlink" title="58、Synchronized 用过吗，其原理是什么？"></a>58、Synchronized 用过吗，其原理是什么？</h2><p>（1）可重入性</p><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；</p><ol><li>可重入的好处：</li><li>可以避免死锁；</li><li>可以让我们更好的封装代码；</li></ol><p>synchronized是可重入锁，每部锁对象会有一个计数器记录线程获取几次锁，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p><p>（2）不可中断性</p><ol><li>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断；</li><li>synchronized 属于不可被中断；</li><li>Lock lock方法是不可中断的；</li><li>Lock tryLock方法是可中断的；</li></ol><h2 id="59、JVM-对-Java-的原生锁做了哪些优化？"><a href="#59、JVM-对-Java-的原生锁做了哪些优化？" class="headerlink" title="59、JVM 对 Java 的原生锁做了哪些优化？"></a>59、JVM 对 Java 的原生锁做了哪些优化？</h2><p>（1）自旋锁</p><p>在线程进行阻塞的时候，先让线程自旋等待一段时间，可能这段时间其它线程已经解锁，这时就无需让线程再进行阻塞操作了。</p><p>自旋默认次数是10次。</p><p>（2）自适应自旋锁</p><p>自旋锁的升级，自旋的次数不再固定，由前一次自旋次数和锁的拥有者的状态决定。</p><p>（3）锁消除</p><p>在动态编译同步代码块的时候，JIT编译器借助逃逸分析技术来判断锁对象是否只被一个线程访问，而没有其他线程，这时就可以取消锁了。</p><p>4、锁粗化</p><p>当JIT编译器发现一系列的操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环中，此时会将加锁同步的范围粗化到整个操作系列的外部。</p><p>锁粒度：不要锁住一些无关的代码。</p><p>锁粗化：可以一次性执行完的不要多次加锁执行。</p><h2 id="60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p><p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p><p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p><p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p><h2 id="61、Java-如何实现多线程之间的通讯和协作？"><a href="#61、Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="61、Java 如何实现多线程之间的通讯和协作？"></a>61、Java 如何实现多线程之间的通讯和协作？</h2><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p><p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p><p>Java中线程通信协作的最常见的两种方式：</p><p>1、syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()</p><p>2、ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()</p><p>线程间直接的数据交换：</p><p>通过管道进行线程间通信：1）字节流；2）字符流</p><h2 id="62、Thread-类中的-yield-方法有什么作用？"><a href="#62、Thread-类中的-yield-方法有什么作用？" class="headerlink" title="62、Thread 类中的 yield 方法有什么作用？"></a>62、Thread 类中的 yield 方法有什么作用？</h2><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p>结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p><h2 id="63、为什么说-Synchronized-是非公平锁？"><a href="#63、为什么说-Synchronized-是非公平锁？" class="headerlink" title="63、为什么说 Synchronized 是非公平锁？"></a>63、为什么说 Synchronized 是非公平锁？</h2><p>当锁被释放后，任何一个线程都有机会竞争得到锁，这样做的目的是提高效率，但缺点是可能产生线程饥饿现象。</p><h2 id="64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？"><a href="#64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？" class="headerlink" title="64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？"></a>64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？</h2><p>volatile只能作用于变量，保证了操作可见性和有序性，不保证原子性。</p><p>在Java的内存模型中分为主内存和工作内存，Java内存模型规定所有的变量存储在主内存中，每条线程都有自己的工作内存。</p><p>主内存和工作内存之间的交互分为8个原子操作：</p><ol><li>lock</li><li>unlock</li><li>read</li><li>load</li><li>assign</li><li>use</li><li>store</li><li>write</li></ol><p>volatile修饰的变量，只有对volatile进行assign操作，才可以load，只有load才可以use，，这样就保证了在工作内存操作volatile变量，都会同步到主内存中。</p><h2 id="65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a>65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</h2><p>Synchronized的并发策略是悲观的，不管是否产生竞争，任何数据的操作都必须加锁。</p><p>乐观锁的核心是CAS，CAS包括内存值、预期值、新值，只有当内存值等于预期值时，才会将内存值修改为新值。</p><h2 id="66、乐观锁一定就是好的吗？"><a href="#66、乐观锁一定就是好的吗？" class="headerlink" title="66、乐观锁一定就是好的吗？"></a>66、乐观锁一定就是好的吗？</h2><p>乐观锁认为对一个对象的操作不会引发冲突，所以每次操作都不进行加锁，只是在最后提交更改时验证是否发生冲突，如果冲突则再试一遍，直至成功为止，这个尝试的过程称为自旋。</p><p>乐观锁没有加锁，但乐观锁引入了ABA问题，此时一般采用版本号进行控制；<br>也可能产生自旋次数过多问题，此时并不能提高效率，反而不如直接加锁的效率高；<br>只能保证一个对象的原子性，可以封装成对象，再进行CAS操作；</p><h2 id="67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。"><a href="#67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。" class="headerlink" title="67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。"></a>67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</h2><p>（1）相似点</p><p>它们都是阻塞式的同步，也就是说一个线程获得了对象锁，进入代码块，其它访问该同步块的线程都必须阻塞在同步代码块外面等待，而进行线程阻塞和唤醒的代码是比较高的。</p><p>（2）功能区别</p><p>Synchronized是java语言的关键字，是原生语法层面的互斥，需要JVM实现；ReentrantLock 是JDK1.5之后提供的API层面的互斥锁，需要lock和unlock()方法配合try/finally代码块来完成。<br>Synchronized使用较ReentrantLock 便利一些；<br>锁的细粒度和灵活性：ReentrantLock强于Synchronized；</p><p>（3）性能区别</p><p>Synchronized引入偏向锁，自旋锁之后，两者的性能差不多，在这种情况下，官方建议使用Synchronized。</p><p>① Synchronized</p><p>Synchronized会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。</p><p>在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计数器+1，相应的执行monitorexit时，计数器-1，当计数器为0时，锁就会被释放。如果获取锁失败，当前线程就要阻塞，知道对象锁被另一个线程释放为止。</p><p>② ReentrantLock</p><p>ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有如下三项：</p><p>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized避免出现死锁的情况。通过lock.lockInterruptibly()来实现这一机制；<br>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁是非公平锁；ReentrantLock默认也是非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好；<br>锁绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象。ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像Synchronized要么随机唤醒一个线程，要么唤醒全部线程。</p><h2 id="68、ReentrantLock-是如何实现可重入性的？"><a href="#68、ReentrantLock-是如何实现可重入性的？" class="headerlink" title="68、ReentrantLock 是如何实现可重入性的？"></a>68、ReentrantLock 是如何实现可重入性的？</h2><p>（1）什么是可重入性</p><p>一个线程持有锁时，当其他线程尝试获取该锁时，会被阻塞；而这个线程尝试获取自己持有锁时，如果成功说明该锁是可重入的，反之则不可重入。</p><p>（2）synchronized是如何实现可重入性</p><p>synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。每个锁对象内部维护一个计数器，该计数器初始值为0，表示任何线程都可以获取该锁并执行相应的方法。根据虚拟机规范要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了对象的锁，把锁的计数器+1，相应的在执行monitorexit指令后锁计数器-1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p><p>（3）ReentrantLock如何实现可重入性</p><p>ReentrantLock使用内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个private volatile int state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p><p>（4）ReentrantLock代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync继承于AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过向构造方法中传true来实现公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前想要获取锁的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前锁的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不存在并发问题</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（5）代码分析</p><p>当一个线程在获取锁过程中，先判断state的值是否为0，如果是表示没有线程持有锁，就可以尝试获取锁。<br>当state的值不为0时，表示锁已经被一个线程占用了，这时会做一个判断current==getExclusiveOwnerThread()，这个方法返回的是当前持有锁的线程，这个判断是看当前持有锁的线程是不是自己，如果是自己，那么将state的值+1，表示重入返回即可。</p><h2 id="69、什么是锁消除和锁粗化？"><a href="#69、什么是锁消除和锁粗化？" class="headerlink" title="69、什么是锁消除和锁粗化？"></a>69、什么是锁消除和锁粗化？</h2><p>（1）锁消除</p><p>所消除就是虚拟机根据一个对象是否真正存在同步情况，若不存在同步情况，则对该对象的访问无需经过加锁解锁的操作。</p><p>比如StringBuffer的append方法，因为append方法需要判断对象是否被占用，而如果代码不存在锁竞争，那么这部分的性能消耗是无意义的。于是虚拟机在即时编译的时候就会将上面的代码进行优化，也就是锁消除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，append方法用了 synchronized关键字，它是线程安全的。但我们可能仅在线程内部把StringBuffer当做局部变量使用；StringBuffer仅在方法内作用域有效，不存在线程安全的问题，这时我们可以通过编译器将其优化，将锁消除，前提是Java必须运行在server模式，同时必须开启逃逸分析；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br><span class="line">其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sBuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sBuf.append(str1);<span class="comment">// append方法是同步操作</span></span><br><span class="line">    sBuf.append(str2);</span><br><span class="line">    <span class="keyword">return</span> sBuf.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。 </p><p>（2）锁粗化</p><p>锁的请求、同步、释放都会消耗一定的系统资源，如果高频的锁请求反而不利于系统性能的优化，锁粗化就是把多次的锁请求合并成一个请求，扩大锁的范围，降低锁请求、同步、释放带来的性能损耗。</p><h2 id="70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？"><a href="#70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？" class="headerlink" title="70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？"></a>70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？</h2><p>（1）都是可重入锁；</p><p>（2）ReentrantLock内部是实现了Sync，Sync继承于AQS抽象类。Sync有两个实现，一个是公平锁，一个是非公平锁，通过构造函数定义。AQS中维护了一个state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p><p>（3）ReentrantLock只能定义代码块，而Synchronized可以定义方法和代码块；</p><p>4、Synchronized是JVM的一个内部关键字，ReentrantLock是JDK1.5之后引入的一个API层面的互斥锁；</p><p>5、Synchronized实现自动的加锁、释放锁，ReentrantLock需要手动加锁和释放锁，中间可以暂停；</p><p>6、Synchronized由于引进了偏向锁和自旋锁，所以性能上和ReentrantLock差不多，但操作上方便很多，所以优先使用Synchronized。</p><h2 id="71、那么请谈谈-AQS-框架是怎么回事儿？"><a href="#71、那么请谈谈-AQS-框架是怎么回事儿？" class="headerlink" title="71、那么请谈谈 AQS 框架是怎么回事儿？"></a>71、那么请谈谈 AQS 框架是怎么回事儿？</h2><p>（1）AQS是AbstractQueuedSynchronizer的缩写，它提供了一个FIFO队列，可以看成是一个实现同步锁的核心组件。</p><p>AQS是一个抽象类，主要通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取和释放的方法来提供自定义的同步组件。</p><p>（2）AQS的两种功能：独占锁和共享锁</p><p>（3）AQS的内部实现</p><p>AQS的实现依赖内部的同步队列，也就是FIFO的双向队列，如果当前线程竞争失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。</p><p><img src="https://img-blog.csdnimg.cn/20210801171611775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。所以双向链表可以从任意一个节点开始很方便的范文前驱和后继节点。每个Node其实是由线程封装，当线程争抢锁失败后会封装成Node加入到AQS队列中。</p><h2 id="72、AQS-对资源的共享方式？"><a href="#72、AQS-对资源的共享方式？" class="headerlink" title="72、AQS 对资源的共享方式？"></a>72、AQS 对资源的共享方式？</h2><p>AQS定义两种资源共享方式</p><p>（1）Exclusive（独占）</p><p>只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul><p>（2）Share（共享）</p><p>多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><h2 id="73、如何让-Java-的线程彼此同步？"><a href="#73、如何让-Java-的线程彼此同步？" class="headerlink" title="73、如何让 Java 的线程彼此同步？"></a>73、如何让 Java 的线程彼此同步？</h2><ol><li>synchronized</li><li>volatile</li><li>ReenreantLock</li><li>使用局部变量实现线程同步</li></ol><h2 id="74、你了解过哪些同步器？请分别介绍下。"><a href="#74、你了解过哪些同步器？请分别介绍下。" class="headerlink" title="74、你了解过哪些同步器？请分别介绍下。"></a>74、你了解过哪些同步器？请分别介绍下。</h2><p>（1）Semaphore同步器</p><p>特征：</p><p>经典的信号量，通过计数器控制对共享资源的访问<br>Semaphore(int count):创建拥有count个许可证的信号量<br>acquire()/acquire(int num) : 获取1/num个许可证<br>release/release(int num) : 释放1/num个许可证</p><p>（2）CountDownLatch同步器</p><p>特征：</p><p>必须发生指定数量的事件后才可以继续运行(比如赛跑比赛，裁判喊出3,2,1之后大家才同时跑)<br>CountDownLatch(int count):必须发生count个数量才可以打开锁存器<br>await:等待锁存器<br>countDown:触发事件</p><p>（3）CyclicBarrier同步器</p><p>特征：</p><p>适用于只有多个线程都到达预定点时才可以继续执行(比如斗地主，需要等齐三个人才开始)<br>CyclicBarrier(int num) :等待线程的数量<br>CyclicBarrier(int num, Runnable action) :等待线程的数量以及所有线程到达后的操作<br>await() : 到达临界点后暂停线程</p><p>（4）交换器(Exchanger)同步器</p><p>（5）Phaser同步器</p><h2 id="75、Java-中的线程池是如何实现的"><a href="#75、Java-中的线程池是如何实现的" class="headerlink" title="75、Java 中的线程池是如何实现的"></a>75、Java 中的线程池是如何实现的</h2><p>创建一个阻塞队列来容纳任务，在第一次执行任务时创建足够多的线程，并处理任务，之后每个工作线程自动从任务队列中获取线程，直到任务队列中任务为0为止，此时线程处于等待状态，一旦有工作任务加入任务队列中，即刻唤醒工作线程进行处理，实现线程的可复用性。</p><p>线程池一般包括四个基本组成部分：</p><p>（1）线程池管理器</p><p>用于创建线程池，销毁线程池，添加新任务。</p><p>（2）工作线程</p><p>线程池中线程，可循环执行任务，在没有任务时处于等待状态。</p><p>（3）任务队列</p><p>用于存放没有处理的任务，一种缓存机制。</p><p>（4）任务接口</p><p>每个任务必须实现的接口，供工作线程调度任务的执行，主要规定了任务的开始和收尾工作，和任务的状态。</p><h2 id="76、创建线程池的几个核心构造参数"><a href="#76、创建线程池的几个核心构造参数" class="headerlink" title="76、创建线程池的几个核心构造参数"></a>76、创建线程池的几个核心构造参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java线程池的完整构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize, // 线程池长期维持的最小线程数，即使线程处于Idle状态，也不会回收。</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize, // 线程数的上限</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime, // 线程最大生命周期。</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  TimeUnit unit, //时间单位                                 </span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, //任务队列。当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory, // 线程工厂。定义如何启动一个线程，可以设置线程名称，并且可以确认是否是后台线程等。</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler // 拒绝任务处理器。由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><h2 id="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"><a href="#77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？" class="headerlink" title="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"></a>77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？</h2><p>线程池中的线程是在第一次提交任务submit时创建的</p><p>创建线程的方式有继承Thread和实现Runnable，重写run方法，start开始执行，wait等待，sleep休眠，shutdown停止。</p><p>（1）newSingleThreadExecutor：单线程池。</p><p>顾名思义就是一个池中只有一个线程在运行，该线程永不超时，而且由于是一个线程，当有多个任务需要处理时，会将它们放置到一个无界阻塞队列中逐个处理，它的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的使用方法也很简单，下面是简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建单线程执行器</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">// 执行一个任务</span></span><br><span class="line">    Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 获得任务执行后的返回值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回值：&quot;</span> + future.get());</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）newCachedThreadPool：缓冲功能的线程。</p><p>建立了一个线程池，而且线程数量是没有限制的(当然，不能超过Integer的最大值)，新增一个任务即有一个线程处理，或者复用之前空闲的线程，或者重亲启动一个线程，但是一旦一个线程在60秒内一直处于等待状态时（也就是一分钟无事可做），则会被终止，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要说明的是，任务队列使用了同步阻塞队列，这意味着向队列中加入一个元素，即可唤醒一个线程(新创建的线程或复用空闲线程来处理)，这种队列已经没有队列深度的概念了。</p><p>（3）newFixedThreadPool：固定线程数量的线程池。</p><p>在初始化时已经决定了线程的最大数量，若任务添加的能力超出了线程的处理能力，则建立阻塞队列容纳多余的任务，其源码如下：　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面返回的是一个ThreadPoolExecutor，它的corePoolSize和maximumPoolSize是相等的，也就是说，最大线程数量为nThreads。如果任务增长的速度非常快，超过了LinkedBlockingQuene的最大容量(Integer的最大值)，那此时会如何处理呢？会按照ThreadPoolExecutor默认的拒绝策略(默认是DiscardPolicy，直接丢弃)来处理。</p><p>以上三种线程池执行器都是ThreadPoolExecutor的简化版，目的是帮助开发人员屏蔽过得线程细节，简化多线程开发。当需要运行异步任务时，可以直接通过Executors获得一个线程池，然后运行任务，不需要关注ThreadPoolExecutor的一系列参数时什么含义。当然，有时候这三个线程不能满足要求，此时则可以直接操作ThreadPoolExecutor来实现复杂的多线程计算。</p><p>newSingleThreadExecutor、newCachedThreadPool、newFixedThreadPool是线程池的简化版，而ThreadPoolExecutor则是旗舰版<em>_</em>简化版容易操作，需要了解的知识相对少些，方便使用，而旗舰版功能齐全，适用面广，难以驾驭。</p><h2 id="78、volatile-关键字的作用"><a href="#78、volatile-关键字的作用" class="headerlink" title="78、volatile 关键字的作用"></a>78、volatile 关键字的作用</h2><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</p><p>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p><h2 id="79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？"><a href="#79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？" class="headerlink" title="79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？"></a>79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？</h2><p>volatile修饰的变量在各个线程的工作内存中不存在一致性的问题（在各个线程工作的内存中，volatile修饰的变量也会存在不一致的情况，但是由于每次使用之前都会先刷新主存中的数据到工作内存，执行引擎看不到不一致的情况，因此可以认为不存在不一致的问题），但是java的运算并非原子性的操作，导致volatile在并发下并非是线程安全的。</p><h2 id="80、ThreadLocal-是什么？有哪些使用场景？"><a href="#80、ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="80、ThreadLocal 是什么？有哪些使用场景？"></a>80、ThreadLocal 是什么？有哪些使用场景？</h2><p>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p><p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</p><h2 id="81、请谈谈-ThreadLocal-是怎么解决并发安全的？"><a href="#81、请谈谈-ThreadLocal-是怎么解决并发安全的？" class="headerlink" title="81、请谈谈 ThreadLocal 是怎么解决并发安全的？"></a>81、请谈谈 ThreadLocal 是怎么解决并发安全的？</h2><p>在java程序中，常用的有两种机制来解决多线程并发问题，一种是sychronized方式，通过锁机制，一个线程执行时，让另一个线程等待，是以时间换空间的方式来让多线程串行执行。而另外一种方式就是ThreadLocal方式，通过创建线程局部变量，以空间换时间的方式来让多线程并行执行。两种方式各有优劣，适用于不同的场景，要根据不同的业务场景来进行选择。</p><p>在spring的源码中，就使用了ThreadLocal来管理连接，在很多开源项目中，都经常使用ThreadLocal来控制多线程并发问题，因为它足够的简单，我们不需要关心是否有线程安全问题，因为变量是每个线程所特有的。</p><h2 id="82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？"><a href="#82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？" class="headerlink" title="82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？"></a>82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？</h2><p>ThreadLocal 变量解决了多线程环境下单个线程中变量的共享问题，使用名为ThreadLocalMap的哈希表进行维护（key为ThreadLocal变量名，value为ThreadLocal变量的值）；</p><p>使用时需要注意以下几点：</p><ul><li>线程之间的threadLocal变量是互不影响的，</li><li>使用private final static进行修饰，防止多实例时内存的泄露问题</li><li>线程池环境下使用后将threadLocal变量remove掉或设置成一个初始值</li></ul><h2 id="83、为什么代码会重排序？"><a href="#83、为什么代码会重排序？" class="headerlink" title="83、为什么代码会重排序？"></a>83、为什么代码会重排序？</h2><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ul><li>在单线程环境下不能改变程序运行的结果；</li><li>存在数据依赖关系的不允许重排序</li></ul><p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p><h2 id="84、什么是自旋"><a href="#84、什么是自旋" class="headerlink" title="84、什么是自旋"></a>84、什么是自旋</h2><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><h2 id="85、多线程中-synchronized-锁升级的原理是什么？"><a href="#85、多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="85、多线程中 synchronized 锁升级的原理是什么？"></a>85、多线程中 synchronized 锁升级的原理是什么？</h2><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="86、synchronized-和-ReentrantLock-区别是什么？"><a href="#86、synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="86、synchronized 和 ReentrantLock 区别是什么？"></a>86、synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>相同点：两者都是可重入锁</p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li></ul><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul><h2 id="87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h2><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p><p>它的优势有：</p><p>（1）可以使锁更公平</p><p>（2）可以使线程在等待锁的时候响应中断</p><p>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p><p>（4）可以在不同的范围，以不同的顺序获取和释放锁</p><p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><hr><h2 id="88、jsp-和-servlet-有什么区别？"><a href="#88、jsp-和-servlet-有什么区别？" class="headerlink" title="88、jsp 和 servlet 有什么区别？"></a>88、jsp 和 servlet 有什么区别？</h2><p>（1）servlet是服务器端的Java程序，它担当客户端和服务端的中间层。</p><p>（2）jsp全名为Java server pages，中文名叫Java服务器页面，其本质是一个简化的servlet设计。JSP是一种动态页面设计，它的主要目的是将表示逻辑从servlet中分离出来。</p><p>（3）JVM只能识别Java代码，不能识别JSP，JSP编译后变成了servlet，web容器将JSP的代码编译成JVM能够识别的Java类（servlet）。</p><p>（4）JSP有内置对象、servlet没有内置对象。</p><h2 id="89、jsp-有哪些内置对象？作用分别是什么？"><a href="#89、jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="89、jsp 有哪些内置对象？作用分别是什么？"></a>89、jsp 有哪些内置对象？作用分别是什么？</h2><p>JSP九大内置对象：</p><ol><li>pageContext，页面上下文对象，相当于页面中所有功能的集合，通过它可以获取JSP页面的out、request、response、session、application对象。</li><li>request</li><li>response</li><li>session</li><li>application，应用程序对象，application实现了用户间数据的共享，可存放全局变量，它开始于服务器启动，知道服务器关闭。</li><li>page，就是JSP本身。</li><li>exception</li><li>out，out用于在web浏览器内输出信息，并且管理应用服务器上的输出缓冲区，作用域page。</li><li>config，取得服务器的配置信息。</li></ol><h2 id="90、forward-和-redirect-的区别？"><a href="#90、forward-和-redirect-的区别？" class="headerlink" title="90、forward 和 redirect 的区别？"></a>90、forward 和 redirect 的区别？</h2><ol><li>forward是直接请求转发；redirect是间接请求转发，又叫重定向。</li><li>forward，客户端和浏览器执行一次请求；redirect，客户端和浏览器执行两次请求。</li><li>forward，经典的MVC模式就是forward；redirect，用于避免用户的非正常访问。（例如用户非正常访问，servlet就可以将HTTP请求重定向到登录页面）。</li><li>forward，地址不变；redirect，地址改变。</li><li>forward常用方法：RequestDispatcher类的forward()方法；redirect常用方法：HttpServletRequest类的sendRedirect()方法。</li></ol><h2 id="91、说一下-jsp-的-4-种作用域？"><a href="#91、说一下-jsp-的-4-种作用域？" class="headerlink" title="91、说一下 jsp 的 4 种作用域？"></a>91、说一下 jsp 的 4 种作用域？</h2><p>application、session、request、page</p><h2 id="92、session-和-cookie-有什么区别？"><a href="#92、session-和-cookie-有什么区别？" class="headerlink" title="92、session 和 cookie 有什么区别？"></a>92、session 和 cookie 有什么区别？</h2><p>（1）存储位置不同</p><ul><li>cookie在客户端浏览器；</li><li>session在服务器；</li></ul><p>（2）存储容量不同</p><ul><li>cookie&lt;=4K，一个站点最多保留20个cookie；</li><li>session没有上线，出于对服务器的保护，session内不可存过多东西，并且要设置session删除机制；</li></ul><p>（3）存储方式不同</p><ul><li>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；</li><li>session中能存储任何类型的数据，包括并不局限于String、integer、list、map等；</li></ul><p>（4）隐私策略不同</p><ul><li>cookie对客户端是可见的，不安全；</li><li>session存储在服务器上，安全；</li></ul><p>（5）有效期不同</p><ul><li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果；</li><li>session依赖于名为JESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session达不到长期有效的效果；</li></ul><p>（6）跨域支持上不同</p><ul><li>cookie支持跨域；</li><li>session不支持跨域；</li></ul><h2 id="93、如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#93、如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="93、如果客户端禁止 cookie 能实现 session 还能用吗？"></a>93、如果客户端禁止 cookie 能实现 session 还能用吗？</h2><p>一般默认情况下，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。</p><p>如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，session失效。</p><p>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session。</p><ol><li>通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。</li><li>服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。</li><li>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。</li></ol><h2 id="94、什么是上下文切换？"><a href="#94、什么是上下文切换？" class="headerlink" title="94、什么是上下文切换？"></a>94、什么是上下文切换？</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><h2 id="95、cookie、session、token"><a href="#95、cookie、session、token" class="headerlink" title="95、cookie、session、token"></a>95、cookie、session、token</h2><p>1、session机制</p><p><img src="https://img-blog.csdnimg.cn/20210801175715748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>session是服务端存储的一个对象，主要用来存储所有访问过该服务端的客户端的用户信息（也可以存储其他信息），从而实现保持用户会话状态。但是服务器重启时，内存会被销毁，存储的用户信息也就消失了。</p><p>不同的用户访问服务端的时候会在session对象中存储键值对，“键”用来存储开启这个用户信息的“钥匙”，在登录成功后，“钥匙”通过cookie返回给客户端，客户端存储为sessionId记录在cookie中。当客户端再次访问时，会默认携带cookie中的sessionId来实现会话机制。</p><p>（1）session是基于cookie的。</p><ul><li>cookie的数据4k左右；</li><li>cookie存储数据的格式：字符串key=value</li><li>cookie存储有效期：可以自行通过expires进行具体的日期设置，如果没设置，默认是关闭浏览器时失效。</li><li>cookie有效范围：当前域名下有效。所以session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上（前后端项目协议、域名、端口号都一致，即在一个项目下）</li></ul><p>（2）session持久化</p><p>用于解决重启服务器后session消失的问题。在数据库中存储session，而不是存储在内存中。通过包：express-mysql-session。</p><p>当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，不会造成无效数据占用存储空间的问题。</p><p>2、token机制</p><p><img src="https://img-blog.csdnimg.cn/20210801175804261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>适用于前后端分离的项目（前后端代码运行在不同的服务器下）</p><p>请求登录时，token和sessionid原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，会在响应主体中将{token：“字符串”}返回给客户端。</p><p>客户端通过cookie都可以进行存储。再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器就可以通过token信息查找用户登录状态。</p><h2 id="96、说一下-session-的工作原理？"><a href="#96、说一下-session-的工作原理？" class="headerlink" title="96、说一下 session 的工作原理？"></a>96、说一下 session 的工作原理？</h2><p>当客户端登录完成后，会在服务端产生一个session，此时服务端会将sessionid返回给客户端浏览器。客户端将sessionid储存在浏览器的cookie中，当用户再次登录时，会获得对应的sessionid，然后将sessionid发送到服务端请求登录，服务端在内存中找到对应的sessionid，完成登录，如果找不到，返回登录页面。</p><hr><h2 id="97、http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#97、http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="97、http 响应码 301 和 302 代表的是什么？有什么区别？"></a>97、http 响应码 301 和 302 代表的是什么？有什么区别？</h2><ol><li>301和302状态码都表示重定向，当浏览器拿到服务器返回的这个状态码后悔自动跳转到一个新的URL地址。</li><li>301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求。</li><li>302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求。</li><li>303代表暂时性重定向，重定向到新地址时，必须使用GET方法请求新地址。</li><li>307代表暂时性重定向，与302的区别在于307不允许从POST改为GET。</li><li>307代表永久性重定向，与301的区别在于308不允许从POST改为GET。</li></ol><h2 id="98、简述-tcp-和-udp的区别？"><a href="#98、简述-tcp-和-udp的区别？" class="headerlink" title="98、简述 tcp 和 udp的区别？"></a>98、简述 tcp 和 udp的区别？</h2><ol><li>TCP是传输控制协议，UDP是用户数据表协议；</li><li>TCP长连接，UDP无连接；</li><li>UDP程序结构较简单，只需发送，无须接收；</li><li>TCP可靠，保证数据正确性、顺序性；UDP不可靠，可能丢数据；</li><li>TCP适用于少量数据，UDP适用于大量数据传输；</li><li>TCP速度慢，UDP速度快；</li></ol><h2 id="99、tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#99、tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="99、tcp 为什么要三次握手，两次不行吗？为什么？"></a>99、tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>因为客户端和服务端都要确认连接，①客户端请求连接服务端；②针对客户端的请求确认应答，并请求建立连接；③针对服务端的请求确认应答，建立连接；</p><p>两次无法确保A能收到B的数据；</p><h2 id="100、OSI-的七层模型都有哪些？"><a href="#100、OSI-的七层模型都有哪些？" class="headerlink" title="100、OSI 的七层模型都有哪些？"></a>100、OSI 的七层模型都有哪些？</h2><p><img src="https://img-blog.csdnimg.cn/20210801175909518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="101、get-和-post-请求有哪些区别？"><a href="#101、get-和-post-请求有哪些区别？" class="headerlink" title="101、get 和 post 请求有哪些区别？"></a>101、get 和 post 请求有哪些区别？</h2><ol><li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的；</li><li>get请求因为浏览器对url长度有限制，所以参数个数有限制，而post请求参数个数没有限制；</li><li>因为get请求参数暴露在url上,所以安全方面post比get更加安全；</li><li>get请求只能进行url编码,而post请求可以支持多种编码方式；</li><li>get请求参数会保存在浏览器历史记录内,post请求并不会；</li><li>get请求浏览器会主动cache,post并不会,除非主动设置；</li><li>get请求产生1个tcp数据包,post请求产生2个tcp数据包；</li><li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次；</li><li>浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK；</li></ol><h2 id="102、什么是-XSS-攻击，如何避免？"><a href="#102、什么是-XSS-攻击，如何避免？" class="headerlink" title="102、什么是 XSS 攻击，如何避免？"></a>102、什么是 XSS 攻击，如何避免？</h2><p>xss(Cross Site Scripting)，即跨站脚本攻击，是一种常见于web应用程序中的计算机安全漏洞。指的是在用户浏览器上，在渲染DOM树的时候，执行了不可预期的JS脚本，从而发生了安全问题。</p><p>XSS就是通过在用户端注入恶意的可运行脚本，若服务端对用户的输入不进行处理，直接将用户的输入输出到浏览器，然后浏览器将会执行用户注入的脚本。 所以XSS攻击的核心就是浏览器渲染DOM的时候将文本信息解析成JS脚本从而引发JS脚本注入，那么XSS攻击的防御手段就是基于浏览器渲染这一步去做防御。只要我们使用HTML编码将浏览器需要渲染的信息编码后，浏览器在渲染DOM元素的时候，会自动解码需要渲染的信息，将上述信息解析成字符串而不是JS脚本，这就是我们防御XSS攻击的核心想法。</p><p>预防：</p><p>1、获取用户的输入，不用innerHtml,用innerText.<br>2、对用户的输入进行过滤，如对&amp; &lt; &gt; “ ‘ /等进行转义；</p><h2 id="103、什么是-CSRF-攻击，如何避免？"><a href="#103、什么是-CSRF-攻击，如何避免？" class="headerlink" title="103、什么是 CSRF 攻击，如何避免？"></a>103、什么是 CSRF 攻击，如何避免？</h2><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>1、攻击细节</p><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><p>例子</p><p>假如一家银行用以运行转账操作的URL地址如下：<a href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a></p><p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成信息的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</p><p>2、防御措施</p><p>检查Referer字段</p><p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p><p>3、添加校验token</p><p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p><h2 id="104、如何实现跨域？说一下-JSONP-实现原理？"><a href="#104、如何实现跨域？说一下-JSONP-实现原理？" class="headerlink" title="104、如何实现跨域？说一下 JSONP 实现原理？"></a>104、如何实现跨域？说一下 JSONP 实现原理？</h2><p>1、<a href="https://blog.csdn.net/guorui_java/article/details/107345499">jsonp原理详解——终于搞清楚jsonp是啥了</a></p><p>2、最流行的跨域方案cors</p><p>cors是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p><p>3、最方便的跨域方案Nginx</p><p>nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p><p>现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p><p>反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。</p><h2 id="105、websocket应用的是哪个协议"><a href="#105、websocket应用的是哪个协议" class="headerlink" title="105、websocket应用的是哪个协议"></a>105、websocket应用的是哪个协议</h2><p>WebSocket是一个允许Web应用程序(通常指浏览器)与服务器进行双向通信的协议。HTML5的WebSocket API主要是为浏览器端提供了一个基于TCP协议实现全双工通信的方法。</p><p>WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小。</p><h2 id="106、说一下-tcp-粘包是怎么产生的？"><a href="#106、说一下-tcp-粘包是怎么产生的？" class="headerlink" title="106、说一下 tcp 粘包是怎么产生的？"></a>106、说一下 tcp 粘包是怎么产生的？</h2><p>发送方需要等缓冲区满才能发送出去，造成粘包；<br>接收方不及时接收缓冲区的包，造成粘包；</p><hr><h2 id="107、请列举出在-JDK-中几个常用的设计模式？"><a href="#107、请列举出在-JDK-中几个常用的设计模式？" class="headerlink" title="107、请列举出在 JDK 中几个常用的设计模式？"></a>107、请列举出在 JDK 中几个常用的设计模式？</h2><p>1、单例模式</p><p>作用：保证类只有一个实例。</p><p>JDK中体现：Runtime类。</p><p>2、静态工厂模式</p><p>作用：代替构造函数创建对象，方法名比构造函数清晰。</p><p>JDK中体现：Integer.valueOf、Class.forName</p><p>3、抽象工厂</p><p>作用：创建某一种类的对象。</p><p>JDK中体现：Java.sql包。</p><p>4、原型模式</p><p>clone()；</p><p>原型模式的本质是拷贝原型来创建新的对象，拷贝是比new更快的创建对象的方法，当需要大批量创建新对象而且都是同一个类的对象的时候考虑使用原型模式。</p><p>一般的克隆只是浅拷贝（对象的hash值不一样，但是对象里面的成员变量的hash值是一样的）。</p><p>有些场景需要深拷贝，这时我们就要重写clone方法，以ArrayList为例：</p><p>5、适配器模式</p><p>作用：使不兼容的接口相容。</p><p>JDK中体现：InputStream、OutputStream。</p><p>6、装饰器模式</p><p>作用：为类添加新的功能，防止类继承带来的类爆炸。</p><p>JDK中体现：io类、Collections、List。</p><p>7、外观模式</p><p>作用：封装一组交互类，一直对外提供接口。</p><p>JDK中体现：logging包。</p><p>8、享元模式</p><p>作用：共享对象、节省内存。</p><p>JDK中体现：Integer.valueOf、String常量池。</p><p>9、代理模式</p><p>作用：</p><p>（1）透明调用被代理对象，无须知道复杂实现细节；</p><p>（2）增加被代理类的功能；</p><p>JDK中体现：动态代理。</p><p>10、迭代器模式</p><p>作用：将集合的迭代和集合本身分离。</p><p>JDK中体现：Iterator</p><p>11、命令模式</p><p>作用：封装操作，使接口一致。</p><p>JDK中体现：Runable、Callable、ThreadPoolExecutor。</p><h2 id="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"><a href="#108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"></a>108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？</h2><p>1、什么是设计模式？</p><p>设计模式是解决软件开发某些特定问题而提出的一些解决方案，也可以理解为解决问题的一些固定思路。</p><p>通过设计模式可以帮助我们增强代码的可复用性、可扩展性、灵活性。</p><p>我们使用设计模式的最终目的是实现代码的高内聚、低耦合。</p><p>2、设计模式的七大原则</p><ol><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里式替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ol><p>3、你是否在你的代码里面使用过任何设计模式？</p><p>（1）单例模式</p><p>JDK种的runtime，Spring种的singeton。</p><p>（2）简单工厂模式</p><p>Spring的BeanFactory，根据传入一个唯一标识来获得bean对象。</p><p>（3）原型模式</p><p>clone()</p><p>（4）代理模式</p><p>Spring的AOP中，Spring实现AOP功能的原理就是代理模式，①JDK动态代理。②CGLIB动态代理，使用Advice（通知）对类进行方法级别的切面增强。</p><p>（5）装饰器模式</p><p>为类添加新的功能，防止类爆炸；</p><p>IO流、数据源包装，Spring中用到的装饰器模式表现在Wrapper。</p><h2 id="109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式"><a href="#109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式" class="headerlink" title="109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h2><ol><li>保证程序只有一个对象的实例，叫做单例模式；</li><li>内部类的方式实现单例模式，是线程安全的；</li><li>双重验证方式实现单例模式也是线程安全的；</li></ol><h2 id="110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？"><a href="#110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？" class="headerlink" title="110、在 Java 中，什么叫观察者设计模式（observer design pattern）？"></a>110、在 Java 中，什么叫观察者设计模式（observer design pattern）？</h2><p>1、观察者模式是一种一对多的依赖关系，让多个观察者同时监听某一主题对象。当这个主题对象发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><p>2、JAVA提供的对观察者模式的支持</p><p>在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。</p><p>（1）Observer接口</p><p>这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）Observable类</p><p>被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p><h2 id="111、使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#111、使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="111、使用工厂模式最主要的好处是什么？在哪里使用？"></a>111、使用工厂模式最主要的好处是什么？在哪里使用？</h2><p>1、工厂模式好处</p><ul><li>良好的封装性、代码结构清晰；</li><li>扩展性好，如果想增加一个产品，只需扩展一个工厂类即可；</li><li>典型的解耦框架；</li></ul><p>2、在哪里使用？</p><ul><li>需要生成对象的地方；</li><li>不同数据库的访问；</li></ul><h2 id="112、请解释自动装配模式的区别？"><a href="#112、请解释自动装配模式的区别？" class="headerlink" title="112、请解释自动装配模式的区别？"></a>112、请解释自动装配模式的区别？</h2><p>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p><p>1、no</p><p>默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。第 402 页 共 485 页</p><p>2、byName</p><p>通过参数名 自动装配，Spring 容器在配置文件中发现 bean</p><p>的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属</p><p>性具有相同名字的 bean。</p><p>3、byType:</p><p>通过参数类型自动装配，Spring 容器在配置文件中发现 bean</p><p>的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属</p><p>性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</p><p>4、constructor</p><p>这个方式类似于 byType， 但是要提供给构造器参数，如</p><p>果没有确定的带参数的构造器参数类型，将会抛出异常。</p><p>5、autodetect</p><p>首先尝试使用 constructor 来自动装配，如果无法工作，</p><p>则使用 byType 方式。</p><h2 id="113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h2><p>在Java IO中运用了装饰器模式，inputStream作为抽象类，其下有几个实现类，表示从不同的数据源输入：</p><ol><li>byteArrayInputStream</li><li>fileInputStream</li><li>StringBufferInputStream</li><li>PipedInputStream，从管道产生输入；</li><li>SequenceInputStream，可将其他流收集合并到一个流内；</li></ol><p>FilterInputStream作为装饰器在JDK中是一个普通类，其下面有多个具体装饰器比如BufferedInputStream、DataInputStream等。</p><p>FilterInputStream内部封装了基础构件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br></pre></td></tr></table></figure><p>而BufferedInputStream在调用其read()读取数据时会委托基础构件来进行更底层的操作，而它自己所起的装饰作用就是缓冲，在源码中可以很清楚的看到这一切。</p><hr><h2 id="114、什么是-Spring-框架？Spring-框架有哪些主要模块？"><a href="#114、什么是-Spring-框架？Spring-框架有哪些主要模块？" class="headerlink" title="114、什么是 Spring 框架？Spring 框架有哪些主要模块？"></a>114、什么是 Spring 框架？Spring 框架有哪些主要模块？</h2><p>Spring是一个控制反转和面向切面的容器框架。</p><p>Spring有七大功能模块：</p><p>1、Core</p><p>Core模块是Spring的核心类库，Core实现了IOC功能。</p><p>2、AOP</p><p>Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。</p><p>3、orm</p><p>提供对常用ORM框架的管理和支持，hibernate、mybatis等。</p><p>4、Dao</p><p>Spring提供对JDBC的支持，对JDBC进行封装。</p><p>5、Web</p><p>对Struts2的支持。</p><p>6、Context</p><p>Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。</p><p>7、MVC</p><p>MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。</p><h2 id="115、使用-Spring-框架能带来哪些好处？"><a href="#115、使用-Spring-框架能带来哪些好处？" class="headerlink" title="115、使用 Spring 框架能带来哪些好处？"></a>115、使用 Spring 框架能带来哪些好处？</h2><p>1、轻量级框架、容器</p><p>Spring是一个容器，管理对象的生命周期和配置。基于一个可配置原型prototype，你的bean可以使单利的，也可以每次需要时都生成一个新的实例。</p><p>2、控制反转IOC</p><p>Spring通过控制反转实现松耦合。</p><p>3、支持AOP</p><p>Spring提供对AOP的支持，它允许将一些通用任务，如安全、事务、日志等进行集中式处理，从而提高了程序的复用性。</p><p>4、轻量级框架</p><p>5、方便测试</p><p>Spring提供Junit4的支持，可以通过注解方便测试spring程序。</p><p>6、对Java中很多API进行了封装</p><p>7、方便集成各种优秀框架</p><p>如Struts、hibernate、mybstis。</p><p>8、支持声明式事务处理</p><p>只需通过配置就可以完成对事务的管理，而无须手动编程。</p><h2 id="116、Spring-IOC、AOP举例说明"><a href="#116、Spring-IOC、AOP举例说明" class="headerlink" title="116、Spring IOC、AOP举例说明"></a>116、Spring IOC、AOP举例说明</h2><p>1、IOC理论的背景</p><p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p><p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。<br>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p><p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。</p><p>2、什么是控制反转</p><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。<br>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20210801180652362.jpg" alt="img"></p><p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。<br>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统（拿掉IoC容器后的系统）：</p><p><img src="https://img-blog.csdnimg.cn/20210801180714819.jpg" alt="img"></p><p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！<br>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：<br>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p><p>3、IOC的别名：依赖注入（DI）</p><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。<br>我们举一个生活中的例子，来帮助理解依赖注入的过程。大家对USB接口和USB设备应该都很熟悉吧，USB为我们使用电脑提供了很大的方便，现在有很多的外部设备都支持USB接口。</p><p><img src="https://img-blog.csdnimg.cn/20210801180744625.jpg" alt="img"></p><p>现在，我们利用电脑主机和USB接口来实现一个任务：从外部USB设备读取一个文件。<br>电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。<br>通过这个例子,依赖注入的思路已经非常清楚：当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。<br>我们把依赖注入应用到软件系统中，再来描述一下这个过程：<br>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。<br>在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。</p><p>4、IOC为我们带来了什么好处</p><p>我们还是从USB的例子说起，使用USB外部设备比使用内置硬盘，到底带来什么好处？<br>第一、USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。所以，无论两者中的任何一方出现什么的问题，都不会影响另一方的运行。这种特性体现在软件工程中，就是可维护性比较好，非常便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。<br>第二、USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。这种特性体现在软件开发过程中，好处可是太大了。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。所以，在一个大中型项目中，团队成员分工明确、责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将得到大幅度的提高。<br>第三、同一个USB外部设备可以插接到任何支持USB的设备，可以插接到电脑主机，也可以插接到DV机，USB外部设备可以被反复利用。在软件工程中，这种特性就是可复用性好，我们可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。显然，IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现，都可以插接到支持此标准的模块中。<br>第四、同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。<br>以上几点好处，难道还不足以打动我们，让我们在项目开发过程中使用IOC框架吗？</p><p>5、IOC容器的技术剖析</p><p>IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。<br>反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。<br>我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p><p>6、IOC容器的一些产品</p><p>Sun ONE技术体系下的IOC容器有：轻量级的有Spring、Guice、Pico Container、Avalon、HiveMind；重量级的有EJB；不轻不重的有JBoss，Jdon等等。Spring框架作为Java开发中SSH(Struts、Spring、Hibernate)三剑客之一，大中小项目中都有使用，非常成熟，应用广泛，EJB在关键性的工业级项目中也被使用，比如某些电信业务。<br>.Net技术体系下的IOC容器有：Spring.Net、Castle等等。Spring.Net是从Java的Spring移植过来的IOC容器，Castle的IOC容器就是Windsor部分。它们均是轻量级的框架，比较成熟，其中Spring.Net已经被逐渐应用于各种项目中。</p><p>7、使用IOC框架应该注意什么</p><p>使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p><p>（1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p><p>（2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p><p>（3）、具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p><p>（4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。<br>我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，象WEB2.0网站就是这种情况。</p><h2 id="117、什么是控制反转-IOC-？什么是依赖注入？"><a href="#117、什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="117、什么是控制反转(IOC)？什么是依赖注入？"></a>117、什么是控制反转(IOC)？什么是依赖注入？</h2><p>借助Spring实现具有依赖关系的对象之间的解耦。</p><p>对象A运行需要对象B，由主动创建变为IOC容器注入，这便是控制反转。</p><p>获得依赖对象的过程被反转了，获取依赖对象的过程由自身创建变为由IOC容器注入，这便是依赖注入。</p><h2 id="118、BeanFactory-和-ApplicationContext-有什么区别？"><a href="#118、BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="118、BeanFactory 和 ApplicationContext 有什么区别？"></a>118、BeanFactory 和 ApplicationContext 有什么区别？</h2><p>1、BeanFactory是Spring的最底层接口，包含bean的定义，管理bean的加载，实例化，控制bean的生命周期，特点是每次获取对象时才会创建对象。</p><p>ApplicationContext是BeanFactory的子接口，拥有BeanFactory的全部功能，并且扩展了很多高级特性，每次容器启动时就会创建所有的对象。</p><ol><li>ApplicationContext的额外功能：</li><li>继承MessageSource，支持国际化；</li><li>统一的资源文件访问方式；</li><li>提供在监听器中注册bean；</li><li>同时加载过个配置文件；</li><li>载入多个（有继承关系）上下文，使得每个上下文都专注于一个特定的层次，比如应用的web层；</li></ol><p>2、BeanFactory通常以编程的方式被创建，ApplicationContext可以以声明的方式创建，如使用ContextLoader。</p><p>3、BeanFactory 和 ApplicationContext都支持BeanPostProcessor，BeanFactoryPostProcessor，但BeanFactory需要手动注册，ApplicationContext则是自动注册。</p><h2 id="119、什么是-JavaConfig？"><a href="#119、什么是-JavaConfig？" class="headerlink" title="119、什么是 JavaConfig？"></a>119、什么是 JavaConfig？</h2><p>JavaConfig是Spring3.0新增的概念，就是以注解的形式取代Spring中繁琐的xml文件。</p><p>JavaConfig结合了xml的解耦和java编译时检查的优点。</p><ol><li>@Configuration，表示这个类是配置类；</li><li>@ComponentScan，相当于xml的<context:componentScan basepackage=>；</li><li>@Bean，相当于xml的<bean id="student" class="com.guor.entity">；</li><li>@EnableWebMvc，相当于xml的<mvc:annotation-driven>；</li><li>@ImportResource，相当于xml的<import resource="application-context-cache.xml">；</li><li>@PropertySource，用于读取properties配置文件；</li><li>@Profile，一般用于多环境配置，激活时可用@ActiveProfile(“dev”)注解；</li></ol><h2 id="120、什么是-ORM-框架？"><a href="#120、什么是-ORM-框架？" class="headerlink" title="120、什么是 ORM 框架？"></a>120、什么是 ORM 框架？</h2><p>ORM（Object-relational mapping），对象关系映射。</p><p>是为了解决面向对象与关系型数据库存在的不匹配问题。</p><p>ORM框架的优点：</p><ol><li>开发效率更高</li><li>数据访问更抽象、轻便</li><li>支持面向对象封装</li></ol><h2 id="121、Spring-有几种配置方式？"><a href="#121、Spring-有几种配置方式？" class="headerlink" title="121、Spring 有几种配置方式？"></a>121、Spring 有几种配置方式？</h2><p>1、xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jackma&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tyq.dto.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jackma&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jm&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tyq.dto.Dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;breed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;金毛&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、基于注解的方式</p><p>项目越来越大，基于xml配置太麻烦，Spring 2.x时代提供了声明bean的注解。</p><p>（1）Bean的定义</p><p>@Component、@Controller、@Service、@Repository。</p><p>（2）Bean的注入</p><p>@Autowire</p><p>3、基于Java的方式</p><p>Spring 3.x以后，可以通过Java代码装配Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">zs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//两个狗</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">haqi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component(&quot;zs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">  <span class="comment">//get，set方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 原来就是配置类啊，通过@Bean、@Component、getBean方式进行Bean的注册和发现。</p><h2 id="122、请解释-Spring-Bean-的生命周期？"><a href="#122、请解释-Spring-Bean-的生命周期？" class="headerlink" title="122、请解释 Spring Bean 的生命周期？"></a>122、请解释 Spring Bean 的生命周期？</h2><ol><li>通过构造器或工厂方法创建bean实例；</li><li>为bean的属性赋值；</li><li>调用bean的初始化方法；</li><li>使用bean；</li><li>当容器关闭时，调用bean的销毁方法；</li></ol><h2 id="123、Spring-Bean-的作用域之间有什么区别？-Spring容器中的bean可以分为5个范围："><a href="#123、Spring-Bean-的作用域之间有什么区别？-Spring容器中的bean可以分为5个范围：" class="headerlink" title="123、Spring Bean 的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围："></a>123、Spring Bean 的作用域之间有什么区别？ Spring容器中的bean可以分为5个范围：</h2><ol><li>singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只哟一个bean的实例，单例模式；</li><li>prototype：为每一个bean提供一个实例；</li><li>request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；</li><li>session：为每个session创建一个实例，session过期后，bean会随之消失；</li><li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。</li></ol><h2 id="124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="124、如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>124、如何在 Spring Boot 中禁用 Actuator 端点安全性？</h2><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有Actuator角色的用户才能访问它们。安全性是使用标准的HTTPServletRequest.isUserInRole方法实施的。我们可以使用management.security.enable = false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h2 id="125、什么是-Spring-inner-beans？"><a href="#125、什么是-Spring-inner-beans？" class="headerlink" title="125、什么是 Spring inner beans？"></a>125、什么是 Spring inner beans？</h2><p>在Spring框架中，无论何时bean被使用时，当仅被调用一个属性。可以将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们要做的是创建一个Person实例，然后再Customer内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">&quot;CustomerBean&quot;</span> class=<span class="string">&quot;com.Customer&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;person&quot;</span>&gt;</span><br><span class="line">&lt;bean class=<span class="string">&quot;com.person&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="number">1</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;素小暖&quot;</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;age&quot;</span> value=<span class="number">18</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="126、Spring-框架中的单例-Beans-是线程安全的么？"><a href="#126、Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="126、Spring 框架中的单例 Beans 是线程安全的么？"></a>126、Spring 框架中的单例 Beans 是线程安全的么？</h2><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态，所以在某种程度上说Spring的单例bean时线程安全的。如果你的bean有多种状态的话，比如view model，就需要自行保证线程安全啦。</p><p>最浅显的解决办法就是将多态bean的作用域由singleton变更为prototype。</p><h2 id="127、请解释-Spring-Bean-的自动装配？"><a href="#127、请解释-Spring-Bean-的自动装配？" class="headerlink" title="127、请解释 Spring Bean 的自动装配？"></a>127、请解释 Spring Bean 的自动装配？</h2><p>Spring支持IOC，自动装配不用类实例化，直接从bean容器中取。</p><p>1、配置在xml中</p><p><bean id="employeeDAO" class="com.guor.EmployeeDAOImpl" autowire="byName" /><br>2、@Autowired自动装配</p><h2 id="128、如何开启基于注解的自动装配？"><a href="#128、如何开启基于注解的自动装配？" class="headerlink" title="128、如何开启基于注解的自动装配？"></a>128、如何开启基于注解的自动装配？</h2><p>要使用 <code>@Autowired</code>，需要注册 <code>AutowiredAnnotationBeanPostProcessor</code>，可以有以下两种方式来实现：</p><p>引入配置文件中的<code>&lt;bean&gt;</code>下引入 <code>&lt;context:annotation-config&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在bean配置文件中直接引入<code>AutowiredAnnotationBeanPostProcessor</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="129、什么是-Spring-Batch？"><a href="#129、什么是-Spring-Batch？" class="headerlink" title="129、什么是 Spring Batch？"></a>129、什么是 Spring Batch？</h2><p>1、什么是spring batch?</p><p>spring batch是一个轻量级的、完善的批处理框架，它主要的目的在于帮助企业建立健壮、高效的批处理应用。</p><p>spring batch是Spring的一个子项目，它使用java语言并基于spring框架作为基础开发，使得已经使用Spring框架的开发者或者是企业可以更加容易访问和利用企业服务。</p><p>spring batch提供了大量可重用的组件,包括了日志、追踪、事务、任务作业统计、任务重启、跳过、重复、资源管理。</p><p>对大数据量和高性能的批处理任务，spring batch同样提供了高级功能和特性来支持。</p><p>例如：分区功能、远程功能。</p><p>总的来说，spring batch可以支持简单的、复杂的和大数据量的批处理作业。</p><p>2、spring batch业务场景</p><p>周期性的提交批处理</p><p>把一个任务并行处理</p><p>消息驱动应用分级处理</p><p>大规模并行批处理</p><p>手工或调度使任务失败之后重新启动</p><p>有依赖步骤的顺序执行(使用工作流驱动扩展)</p><p>处理时跳过部分记录</p><p>成批事务：为小批量的或有的存储过程/脚本的场景使用</p><h2 id="130、spring-mvc-和-struts-的区别是什么？"><a href="#130、spring-mvc-和-struts-的区别是什么？" class="headerlink" title="130、spring mvc 和 struts 的区别是什么？"></a>130、spring mvc 和 struts 的区别是什么？</h2><p>1、拦截机制的不同</p><p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p><p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p><p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p><p>2、底层框架的不同</p><p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p><p>3、性能方面</p><p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p><p>4、配置方面</p><p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p><h2 id="131、请举例解释-Required-注解？"><a href="#131、请举例解释-Required-注解？" class="headerlink" title="131、请举例解释@Required 注解？"></a>131、请举例解释@Required 注解？</h2><p>@Required注解应用于bean属性的setter方法，它表明影响的bean属性在配置时必须放在XML配置文件中。</p><p>十九、请举例说明@Qualifier 注解？<br>如果在xml中定义了一种类型的多个bean，同时在java注解中又想把其中一个bean对象作为属性，那么此时可以使用@Qualifier加@Autowired来达到这一目的，若不加@Qualifier这个注解，在运行时会出现“ No qualifying bean of type [com.tutorialspoint.Student] is defined: expected single matching bean but found 2: student1,student2”这个异常。</p><h2 id="132、Spring常用注解"><a href="#132、Spring常用注解" class="headerlink" title="132、Spring常用注解"></a>132、Spring常用注解</h2><p><a href="https://blog.csdn.net/guorui_java/article/details/107347754">Spring常用注解（绝对经典）</a></p><h2 id="133、项目中是如何实现权限验证的，权限验证需要几张表"><a href="#133、项目中是如何实现权限验证的，权限验证需要几张表" class="headerlink" title="133、项目中是如何实现权限验证的，权限验证需要几张表"></a>133、项目中是如何实现权限验证的，权限验证需要几张表</h2><p>通过了解，现在最普遍的权限管理模型就是RBAC（Role-Based Access Control）。</p><p>1、权限控制分类</p><p>菜单功能<br>url控制（控制访问不同的控制器）<br>2、RBAC的优缺点</p><p>（1）优点</p><p>简化了用户和权限的关系<br>易扩展、易维护</p><p>（2）缺点</p><p>RBAC模型没有提供操作顺序的控制机制，这一缺陷使得RBAC模型很难适应哪些对操作次序有严格要求的系统。</p><p>3、RBAC支持的安全原则</p><p>（1）最小权限原则</p><p>RBAC可以将角色配置成其完成任务所需的最小权限集合。</p><p>（2）责任分离原则</p><p>可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个记账员和财务管理员共同参与统一过账操作。</p><p>（3）数据抽象原则</p><p>可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读写权限。</p><p>4、远古时代的权限控制</p><p>当时还没有RBAC，也没有这个概念，就是一堆程序员在那鼓捣，觉得登录这块该做点什么。</p><p><img src="https://img-blog.csdnimg.cn/20210801181255483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>1、新建一个用户，对这个用户进行赋予权限。</p><p>2、但是一旦用户多了，权限复杂了，这工作量也是蛮大的。</p></blockquote><p>5、RBAC</p><p>RBAC 1.0</p><p><img src="https://img-blog.csdnimg.cn/20210801181330199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20210801181401168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>直接上图，一目了然，当程序不是很复杂的时候，RBAC就是这样设计的，我们公司的权限验证模块就是这样设计的。</p><p>简简单单，五张表，解</p><p>RBAC 2.0</p><p>基于RBAC 1.0模型的基础上，进行了角色的访问控制</p><p><img src="https://img-blog.csdnimg.cn/20210801181428450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>RBAC2中的一个基本限制是互斥角色的限制，互斥角色是指各自权限可以互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。</p><p>该模型有以下几种约束</p><ul><li>互斥角色 ：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。</li><li>基数约束 ：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。</li><li>先决条件角色 ：可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。</li><li>运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。</li></ul><p>6、rbac的实现理论分析</p><p>进入登录页面；<br>拿到通过post传过来的用户名和密码；<br>使用orm进行过滤查找；<br>如果能找到值，则说明登录成功：登录成功后调用rbac初始化函数，初始化函数的主要功能是获取用户的权限和菜单保存到session中，并跳转客户列表页面；如果失败，页面进行友好提示；</p><p>7、url权限控制关键代码</p><p><img src="https://img-blog.csdnimg.cn/20210801181510714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="134、谈谈controller，接口调用的路径问题"><a href="#134、谈谈controller，接口调用的路径问题" class="headerlink" title="134、谈谈controller，接口调用的路径问题"></a>134、谈谈controller，接口调用的路径问题</h2><p>1、Spring MVC如何匹配请求路径</p><p>@RequestMapping是用来映射请求的，比如get请求、post请求、或者REST风格与非REST风格的。该注解可以用在类上或方法上，如果用在类上，表示是该类中所有方法的父路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/springmvc&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCTest</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestMapping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类上还添加了一个@Controller注解，该注解在SpringMVC中负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个model，然后再把该model返回给对应的view进行展示。</p><p>我们可以通过“springmvc/testRequestMapping”这个路径来定位到testRequestMapping这个方法，然后执行方法内的方法体。</p><p>RequestMapping可以实现模糊匹配路径，比如：</p><ol><li>？表示一个字符；</li><li>*表示任意字符；</li><li>**匹配多层路径；</li></ol><p>/springmvc/**/testRequestMapping 就可以匹配/springmvc/stu/getStudentInfo/testRequestMapping 这样的路径了。</p><p>2、SpringMVC如何获取请求的参数</p><p>（1）@PathVariable</p><p>该注解用来映射请求URL中绑定的占位符。通过@PathVariable可以将URL中占位符的参数绑定到controller处理方法的入参中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testPathVariable:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.jsp中我们添加一条连接，用来触发一个请求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/testPathVariable/1&quot;</span>&gt;</span>testPathVariable<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2） @RequestParam</p><p>该注解也是用来获取请求参数的，那么该注解和@PathVariable有什么不同呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRequestParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(value=&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(value=&quot;age&quot;, required=false, defaultValue=&quot;0&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testRequestParam&quot;</span> + <span class="string">&quot; username:&quot;</span> + username + <span class="string">&quot; age:&quot;</span> +age);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在index.jsp添加超链接标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/testRequestParam?username=jackie&amp;age=12&quot;</span>&gt;</span>testRequestParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、REST风格的请求</p><p>在SpringMVC中业务最多的应该是CRUD了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestPut</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test put:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestDelete</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test delete:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test post&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test get:&quot;</span> + id)</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="135、如何防止表单重复提交"><a href="#135、如何防止表单重复提交" class="headerlink" title="135、如何防止表单重复提交"></a>135、如何防止表单重复提交</h2><p>1、通过JavaScript屏蔽提交按钮（不推荐）</p><p>2、给数据库增加唯一键约束（简单粗暴）</p><p>3、利用Session防止表单重复提交（推荐）</p><p>4、使用AOP自定义切入实现</p><h2 id="136、Spring中都应用了哪些设计模式"><a href="#136、Spring中都应用了哪些设计模式" class="headerlink" title="136、Spring中都应用了哪些设计模式"></a>136、Spring中都应用了哪些设计模式</h2><p>1、简单工厂模式</p><p>简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。</p><p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。</p><p>2、工厂方法模式</p><p>应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。</p><p>定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。</p><p>3、单例模式</p><p>Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、代理模式</p><p>Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。</p><p>5、装饰器模式</p><p>装饰器模式：动态的给一个对象添加一些额外的功能。</p><p>Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。</p><p>在Spring中有两种表现：</p><p>一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><p>6、观察者模式</p><p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p><p>Spring中观察者模式一般用在listener的实现。</p><p>7、策略模式</p><p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p><p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p><p>8、模板方法模式</p><p>Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。</p><h2 id="137、请举例说明如何在-Spring-中注入一个-Java-Collection？"><a href="#137、请举例说明如何在-Spring-中注入一个-Java-Collection？" class="headerlink" title="137、请举例说明如何在 Spring 中注入一个 Java Collection？"></a>137、请举例说明如何在 Spring 中注入一个 Java Collection？</h2><p>Spring注入有四种方式，</p><ol><li>set注入；</li><li>构造器注入；</li><li>基于注解的注入；</li><li>xml配置文件注入；</li></ol><p>想要注入java collection，就是注入集合类：</p><ol><li>list</li><li>set</li><li>map</li><li>props：该标签支持注入键和值都是字符串类型的键值对。</li></ol><p>list和set都使用value标签；map使用entry标签；props使用prop标签；</p><hr><h2 id="138、mybatis-中-和-的区别是什么？"><a href="#138、mybatis-中-和-的区别是什么？" class="headerlink" title="138、mybatis 中 #{}和 ${}的区别是什么？"></a>138、mybatis 中 #{}和 ${}的区别是什么？</h2><ol><li>#{}带引号，${}不带引号；</li><li>#{}可以防止SQL注入；</li><li>${}常用于数据库表名、order by子句；</li><li>一般能用#{}就不要使用${}；</li></ol><h2 id="139、mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#139、mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="139、mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>139、mybatis 是否支持延迟加载？延迟加载的原理是什么？</h2><p>1、mybatis 是否支持延迟加载？</p><p>延迟加载其实就是讲数据加载时机推迟，比如推迟嵌套查询的时机。</p><p>延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。</p><p>mybatis仅支持关联对象association和关联集合对象collection的延迟加载，association是一对一，collection是一对多查询，在mybatis配置文件中可以配置lazyloadingEnable=true/false。</p><p>2、延迟加载的原理是什么？</p><p>使用CGLIB为目标对象建立代理对象，当调用目标对象的方法时进入拦截器方法。</p><p>比如调用a.getB().getName()，拦截器方法invoke()发现a.getB()为null，会单独发送事先准备好的查询关联B对象的sql语句，把B查询出来然后调用a.setB(b)，也是a的对象的属性b就有值了，然后调用getName()，这就是延迟加载的原理。</p><h2 id="140、说一下-mybatis-的一级缓存和二级缓存？"><a href="#140、说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="140、说一下 mybatis 的一级缓存和二级缓存？"></a>140、说一下 mybatis 的一级缓存和二级缓存？</h2><p>一级缓存是session级别的缓存，默认开启，当查询一次数据库时，对查询结果进行缓存，如果之后的查询在一级缓存中存在，则无需再访问数据库；</p><p>二级缓存是sessionFactory级别的缓存，需要配置才会开启。当进行sql语句查询时，先查看一级缓存，如果不存在，访问二级缓存，降低数据库访问压力。</p><h2 id="141、mybatis-有哪些执行器（Executor）？"><a href="#141、mybatis-有哪些执行器（Executor）？" class="headerlink" title="141、mybatis 有哪些执行器（Executor）？"></a>141、mybatis 有哪些执行器（Executor）？</h2><p>1、mybatis有三种基本的Executor执行器：</p><p>（1）、SimpleExecutor</p><p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p>（2）、PauseExecutor</p><p>执行update或select，以sql做为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而且放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</p><p>（3）、BatchExecutor</p><p>执行update，将所有sql通过addBatch()都添加到批处理中，等待统一执行executeBatch()，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>2、作用范围：</p><p>Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><p>3、Mybatis中如何指定使用哪一种Executor执行器？</p><p>在mybatis的配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p><h2 id="142、mybatis-和-hibernate-的区别有哪些？"><a href="#142、mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="142、mybatis 和 hibernate 的区别有哪些？"></a>142、mybatis 和 hibernate 的区别有哪些？</h2><p>1、两者最大的区别</p><p>针对简单逻辑，都有对应的代码生成工具，可以生成简单基本的dao层方法；</p><p>针对高级查询，mybatis要手动编写sql语句和resultMap，而hibernate有良好的映射机制；</p><p>2、开发难度对比</p><p>hibernate &gt; mybatis </p><p>3、日志统计</p><p>hibernate有自己的日志统计功能，而mybatis需要借助log4j来记录日志。</p><p>4、数据库扩展比较</p><p>hibernate &gt; mybatis </p><p>5、缓存机制比较</p><p>因为hibernate对查询对象有良好的管理机制，用户无需关心sql，所以使用二级缓存如果出现脏数据，系统会报错。</p><p>而mybatis，如果不能获取最新数据，应该避免缓存的使用，脏数据的出现会给系统的正常运行带来很大的隐患。</p><p>6、如何选择</p><ol><li>mybatis需要编写sql和映射规则，工作量大于hibernate；</li><li>mybatis支持的工具也有限，不能像hibernate那样有许多插件可以帮助生成映射代码和关联关系；</li><li>对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐hibernate；</li><li>对于性能要求高、响应快、灵活的系统，比如电商系统，推荐使用mybatis；</li></ol><h2 id="143、myBatis查询多个id、myBatis常用属性"><a href="#143、myBatis查询多个id、myBatis常用属性" class="headerlink" title="143、myBatis查询多个id、myBatis常用属性"></a>143、myBatis查询多个id、myBatis常用属性</h2><p>myBatis查询多个id（我居然回答用对象来传递…）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Page<span class="tag">&lt;<span class="name">UserPoJo</span>&gt;</span>  getUserListByIds(@Param(&quot;ids&quot;) List<span class="tag">&lt;<span class="name">Integer</span>&gt;</span> ids);</span><br><span class="line"><span class="comment">&lt;!--根据id列表批量查询user--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserListByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.guor.UserPoJo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    select * from student</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    where id in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;userid&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #&#123;userid&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="144、mybatis一级缓存、二级缓存"><a href="#144、mybatis一级缓存、二级缓存" class="headerlink" title="144、mybatis一级缓存、二级缓存"></a>144、mybatis一级缓存、二级缓存</h2><p>1、一级缓存：指的是mybatis中sqlSession对象的缓存，当我们执行查询以后，查询的结果会同时存入sqlSession中，再次查询的时候，先去sqlSession中查询，有的话直接拿出，当sqlSession消失时，mybatis的一级缓存也就消失了，当调用sqlSession的修改、添加、删除、commit()、close()等方法时，会清空一级缓存。</p><p>2、二级缓存：指的是mybatis中的sqlSessionFactory对象的缓存，由同一个sqlSessionFactory对象创建的sqlSession共享其缓存，但是其中缓存的是数据而不是对象。当命中二级缓存时，通过存储的数据构造成对象返回。查询数据的时候，查询的流程是二级缓存 &gt; 一级缓存 &gt; 数据库。</p><p>3、如果开启了二级缓存，sqlSession进行close()后，才会把sqlSession一级缓存中的数据添加到二级缓存中，为了将缓存数据取出执行反序列化，还需要将要缓存的pojo实现Serializable接口，因为二级缓存数据存储介质多种多样，不一定只存在内存中，也可能存在硬盘中。</p><p>4、mybatis框架主要是围绕sqlSessionFactory进行的，具体的步骤：</p><ol><li>定义一个configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings。</li><li>通过配置对象，则可以创建一个sqlSessionFactoryBuilder对象。</li><li>通过sqlSessionFactoryBuilder获得sqlSessionFactory实例。</li><li>通过sqlSessionFactory实例创建qlSession实例，通过sqlSession对数据库进行操作。</li></ol><p>5、代码实例</p><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载类路径下的属性文件 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置类型别名 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;cn.itcast.javaee.mybatis.app04.Student&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;student&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置一个默认的连接环境信息 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_developer&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_developer&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;oracle_developer&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.driver&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.url&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.password&#125;&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载映射文件--&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/itcast/javaee/mybatis/app14/StudentMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">public class MyBatisTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //读取mybatis-config.xml文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            InputStream resourceAsStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //初始化mybatis,创建SqlSessionFactory类的实例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            SqlSessionFactory sqlSessionFactory =  new SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //创建session实例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             * 接下来在这里做很多事情,到目前为止,目的已经达到得到了SqlSession对象.通过调用SqlSession里面的方法,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             * 可以测试MyBatis和Dao层接口方法之间的正确性,当然也可以做别的很多事情,在这里就不列举了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //插入数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            User user = new User();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            user.setC_password(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            user.setC_username(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            user.setC_salt(&quot;123&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //第一个参数为方法的完全限定名:位置信息+映射文件当中的id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            session.insert(&quot;com.cn.dao.UserMapping.insertUserInformation&quot;, user);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //提交事务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            session.commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            session.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="145、mybatis如何防止sql注入"><a href="#145、mybatis如何防止sql注入" class="headerlink" title="145、mybatis如何防止sql注入"></a>145、mybatis如何防止sql注入</h2><p>注意：但凡是sql注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成sql语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的【外部数据不可信任】的原则，纵观web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到，就是变量的检测、过滤、验证下手，确保变量是开发者所预想的。</p><p>1、检查变量数据类型和格式</p><p>数据类型检查，sql执行前，要进行数据类型检查，如果是邮箱，参数就必须是邮箱的格式，如果是日期，就必须是日期格式；</p><p>只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。</p><p>如果上述例子中id是int型的，效果会怎样呢？无法注入，因为输入注入参数会失败。比如上述中的name字段，我们应该在用户注册的时候，就确定一个用户名规则，比如5-20个字符，只能由大小写字母、数字以及汉字组成，不包含特殊字符。此时我们应该有一个函数来完成统一的用户名检查。不过，仍然有很多场景并不能用到这个方法，比如写博客，评论系统，弹幕系统，必须允许用户可以提交任意形式的字符才行，否则用户体验感太差了。</p><p>2、过滤特殊符号</p><p>3、绑定变量，使用预编译语句</p><p>146、为什么要使用 hibernate？</p><ol><li>hibernate对jdbc进行了封装，简化了JDBC的重复性代码；</li><li>hibernate对dao有一个封装类hibernateTemplate，可以继承它，实现简单的CRUD接口。</li><li>hibernate使用注解和配置文件，可以对实体类和映射文件进行映射；</li><li>hibernate有事务管理机制，保证了数据的安全性；</li><li>hibernate有一级缓存和二级缓存；</li></ol><hr><h2 id="146、hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#146、hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="146、hibernate 中如何在控制台查看打印的 sql 语句？"></a>146、hibernate 中如何在控制台查看打印的 sql 语句？</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.show_sql=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.jpa.properties.hibernate.format_sql=true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.jpa.properties.hibernate.use_sql_comments=true</span><br></pre></td></tr></table></figure><h2 id="147、hibernate-有几种查询方式？"><a href="#147、hibernate-有几种查询方式？" class="headerlink" title="147、hibernate 有几种查询方式？"></a>147、hibernate 有几种查询方式？</h2><p>1、导航对象图查询：根据已加载的对象，导航到其他对象。</p><p>例如，对于已经加载的Customer对象，调用它的getOrders().iterator()方法就可以导航到所有关联的Order对象，假如在关联级别使用了延迟加载检索策略，那么首次执行此方法时，hibernate会从数据库中加载关联的Order对象，否则就从缓存中获得Order对象。</p><p>2、OID方式：按照对象的OID来检索对象</p><p>Session的get()和load()方法提供了这种功能，如果在应用程序中先知道了OID，就可以使用这种方式检索对象。</p><p>get()和load()的用法完全一样，都需要两个参数，一个是持久化对象类名class，一个是行号OID，返回固定的某一行的数据，但是需要注意的是，当输入的OID不存在时，get()会返回一个空对象，load()则直接报错。</p><p>3、HQL检索方式：（hibernate query language）</p><p>使用面向对象的HQL查询语言，session的find()方法用于执行HQL查询语句。此外，hibernate还提供了query接口，它是hibernate提供的专门的HQL查询接口，能够执行各种复杂的HQL查询语句。</p><p>它具备以下功能：</p><ol><li>在查询语句中设定各种查询条件；</li><li>支持投影查询，即仅检索出对象的部分属性；</li><li>支持分页查询；</li><li>支持连接查询；</li><li>支持分组查询；</li><li>提供内置函数；</li><li>能够调用用户自定义的SQL函数；</li><li>支持子查询；</li><li>支持动态绑定参数；</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(“from UserPo”）；</span><br></pre></td></tr></table></figure><p>获得一个query对象，注意参数字符串中不是一个SQL语句，from后面的是持久化对象名称；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br></pre></td></tr></table></figure><p>就可以获取数据库中对应表的数据集合。</p><p>4、QBC检索方式：Query By Criteria的API来检索对象</p><p>这种API封装了基于字符串形式的查询语句，提供了更加面向对象的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：<span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> session.createCriteria(UserPo.class);</span><br></pre></td></tr></table></figure><p>创建一个Criteria对象，参数是所关联的持久化对象，criteria.add(Restrictions.ge(“id”,2));将查询条件加入对象中，后面的操作就和Query对象一样了。</p><p>5、本地SQL</p><p>使用本地数据库的SQL查询语句，hibernate会负责把检索到的JDBC ResultSet结果映射为持久化对象图。</p><h2 id="148、hibernate-实体类可以被定义为-final-吗？"><a href="#148、hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="148、hibernate 实体类可以被定义为 final 吗？"></a>148、hibernate 实体类可以被定义为 final 吗？</h2><p>可以将hibernate的实体类定义为final，但这种做法不好。</p><p>因为hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为Java不允许对final类进行扩展，所以hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。</p><p>不过，如果你的持久化类实现了一个接口，而且在该接口中声明了所有定义于实体类中的所有public的方法的话，就能避免出现前面所说的不利后果。</p><h2 id="149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><p>hibernate是面向对象的ORM，所以一般定义成封装类型，要看数据库中的定义，如果数据库中有对应字段存在null值，就要定义Integer。也可以定义基本类型，在配置文件中写清楚即可。</p><h2 id="150、什么是-Spring-Boot？Spring-Boot-有哪些优点？"><a href="#150、什么是-Spring-Boot？Spring-Boot-有哪些优点？" class="headerlink" title="150、什么是 Spring Boot？Spring Boot 有哪些优点？"></a>150、什么是 Spring Boot？Spring Boot 有哪些优点？</h2><p>1、Spring Boot简介</p><p>基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突、引用的不稳定性得到了解决。</p><p>2、Spring Boot 有哪些优点？</p><ol><li>快速构建项目，可以选一些必要的组件；</li><li>对主流框架的无配置集成；</li><li>内嵌Tomcat容器，项目可独立运行；</li><li>删除了繁琐的xml配置文件；</li><li>极大地提高了开发和部署效率；</li><li>提供starter，简化maven配置；</li></ol><p>3、SpringBoot有哪些缺点？</p><ol><li>版本迭代速度快，一些模块改动很大；</li><li>由于无须配置，报错时很难定位；</li></ol><h2 id="151、Spring-Boot-中的监视器是什么？"><a href="#151、Spring-Boot-中的监视器是什么？" class="headerlink" title="151、Spring Boot 中的监视器是什么？"></a>151、Spring Boot 中的监视器是什么？</h2><p>监听器也叫listener，是servlet的监听器，可以用于监听web应用程序中某些对象的创建、销毁、增加、修改、删除等动作的发生，然后做出相应的响应处理。当范围对象的状态发生变化时，服务器自动调用监听器对象中的方法，常用于系统加载时进行信息初始化，统计在线人数和在线用户，统计网站的访问量。</p><p>配置监听器的方法：</p><p>通过@Component把监听器加入Spring容器中管理；<br>在application.properties中添加context.listener.classes配置；<br>在方法上加@EventListener注解；</p><h2 id="152、什么是-YAML？"><a href="#152、什么是-YAML？" class="headerlink" title="152、什么是 YAML？"></a>152、什么是 YAML？</h2><p>YAML是JSON的一个超集，可以非常方便地将外部配置以层次结构形式存储起来。YAML可以作为properties配置文件的替代。</p><p>YAML使用的注意事项：</p><ol><li>在properties文件中是以”.”进行分割的，在yml中是用”.”进行分割的；</li><li>yml的数据格式和json的格式很像，都是K-V格式，并且通过”:”进行赋值；</li><li>每个冒号后面一定要加一个空格；</li></ol><h2 id="153、如何使用-Spring-Boot-实现分页和排序？"><a href="#153、如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="153、如何使用 Spring Boot 实现分页和排序？"></a>153、如何使用 Spring Boot 实现分页和排序？</h2><p>使用Spring Data Jpa可以实现将可分页的传递给存储库方法。</p><h2 id="154、如何使用-Spring-Boot-实现异常处理？"><a href="#154、如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="154、如何使用 Spring Boot 实现异常处理？"></a>154、如何使用 Spring Boot 实现异常处理？</h2><p>1、使用 @ExceptionHandler 注解处理局部异常(只能处理当前controller中的ArithmeticException和NullPointerException异常，缺点就是只能处理单个controller的异常)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/excep&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exceptionMethod</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String a=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(a.charAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;没有抛出异常&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(value = &#123;ArithmeticException.class,NullPointerException.class&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arithmeticExceptionHandle</span><span class="params">(Model model, Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;@ExceptionHandler&quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用 @ControllerAdvice + @ExceptionHandler 注解处理全局异常(value后面可以填写数组)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerAdviceException</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(value = &#123;NullPointerException.class&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">NullPointerExceptionHandler</span><span class="params">(Model model, Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;@ControllerAdvice + @ExceptionHandler :&quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、配置 SimpleMappingExceptionResolver 类处理异常（配置类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMappingException</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">getSimpleMappingExceptionResolver</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">SimpleMappingExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数为异常全限定名，第二个为跳转视图名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mappings.put(<span class="string">&quot;java.lang.NullPointerException&quot;</span>, <span class="string">&quot;index&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mappings.put(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;index&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置异常与视图映射信息的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resolver.setExceptionMappings(mappings);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resolver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、实现 HandlerExceptionResolver 接口处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerException</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modelAndView.addObject(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;实现HandlerExceptionResolver接口&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断不同异常类型，做不同视图跳转</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ArithmeticException)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="155、单点登录"><a href="#155、单点登录" class="headerlink" title="155、单点登录"></a>155、单点登录</h2><p>1、概念</p><p>单点登录SSO，说的是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。</p><p>2、单点登录的要点</p><p>存储信任；<br>验证信任；</p><p>3、实现单点登录的三种方式</p><p>（1）以cookie作为凭证</p><p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。</p><p>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie进行校验，校验通过则登录当前用户。</p><p>缺点：</p><p>cookie不安全</p><p>通过加密可以保证安全性，但如果对方掌握了解密算法就完蛋了。</p><p>不能跨域实现免登</p><p>（2）通过JSONP实现</p><p>对于跨域问题，可以使用JSONP实现。用户在父应用中登录后，跟session匹配的cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p><p>缺点：</p><p>这种方法虽然能解决跨域问题，但是治标不治本，没有解决cookie安全性的问题。</p><p>（3）通过页面重定向的方式</p><p>最后一种介绍的方式，是通过父应用和子应用来回重定向进行通信，实现信息的安全传递。</p><p>父应用提供一个GET方式的登录接口A（此时的父应用接口固定，攻击者无法去伪造），用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个登录页面，用户输入账号密码进行登录，如果用户已经登录了，则生成加密的token，并且重定向到子应用提供的验证token的接口B（此时的子应用接口固定，攻击者无法去伪造），通过解密和校验之后，子应用登录当前用户。</p><p>缺点：</p><p>这种方式较前面的两种方式，是解决了安全性和跨域的问题，但是并没有前面两种方式简单，安全与方便，本来就是矛盾的。</p><p>4、使用独立登录系统</p><p>一般来说，大型应用会把授权的逻辑和用户信息的相关逻辑独立成一个应用，称为用户中心。用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕后返回凭证，第三方应用验证凭证，通过后就登录用户。</p><p>5、sso（单点登录）与OAuth2.0（授权）的区别？</p><p>（1）sso（单点登录）</p><p>通常处理的是一个公司的不同应用间的访问登录问题，如企业应用有很多子系统，只需登录一个系统，就可以实现不同子系统间的跳转，而避免了登录操作；<br>通过cookie、jsonp、重定向来实现；</p><p>（2）OAuth2.0（授权）</p><p>解决的是服务提供方（如微信）给第三方应用授权的问题，简称微信登录；<br>是一种具体的协议，只是为用户资源的授权提供了一个安全的、开放的而又简易的标准，OAuth2.0（授权）为客户开发者开发web应用，桌面应用程序，移动应用及客厅设备提供特定的授权流程。</p><h2 id="156、Spring-Boot比Spring多哪些注解"><a href="#156、Spring-Boot比Spring多哪些注解" class="headerlink" title="156、Spring Boot比Spring多哪些注解"></a>156、Spring Boot比Spring多哪些注解</h2><p><a href="https://blog.csdn.net/guorui_java/article/details/107379648">Spring Boot常用注解（绝对经典）</a></p><h2 id="157、打包和部署"><a href="#157、打包和部署" class="headerlink" title="157、打包和部署"></a>157、打包和部署</h2><p>Spring和Spring Boot都支持maven和Gradle通用打包管理技术。</p><p>Spring Boot相对Spring的一些优点：</p><ul><li>提供嵌入式容器支持；</li><li>使用命令java -jar独立运行jar；</li><li>部署时可以灵活指定配置文件；</li></ul><p>最近项目是分布式的项目，都是通过分项目打包部署，然后部署在docker中运行。</p><h2 id="158、Spring-Boot如何访问不同的数据库"><a href="#158、Spring-Boot如何访问不同的数据库" class="headerlink" title="158、Spring Boot如何访问不同的数据库"></a>158、Spring Boot如何访问不同的数据库</h2><p>可以使用druidDataSource创建DataSource，然后通过jdbcTemplate执行sql。</p><h2 id="159、查询网站在线人数"><a href="#159、查询网站在线人数" class="headerlink" title="159、查询网站在线人数"></a>159、查询网站在线人数</h2><p>通过监听session对象的方式来实现在线人数的统计和在线人信息展示，并且让超时的自动销毁。</p><blockquote><p>对session对象实现监听，首先必须继承HttpSessionListener类，该程序的基本原理就是当浏览器访问页面的时候必定会产生一个session对象，当关闭该页面的时候必然会删除session对象。所以每当产生一个新的session对象就让在线人数+1，当删除一个session对象就让在线人数-1。</p><p>还要继承一个HttpSessionAttributeListener，来实现对其属性的监听。分别实现attributeAdded方法，attributeReplace方法以及attributeRemove方法。</p><p>sessionCreated//新建一个会话的时候触发，也可以说是客户端第一次喝服务器交互时触发。</p><p>sessionDestroyed//销毁会话的时候，一般来说只有某个按钮触发进行销毁，或者配置定时销毁。</p><p>HttpSessionAttributeListener有三个方法需要实现</p><p>attributeAdded//在session中添加对象时触发此操作 笼统的说就是调用setAttribute这个方法时候会触发的<br>attributeRemoved//修改、删除session中添加对象时触发此操作  笼统的说就是调用 removeAttribute这个方法时候会触发的<br>attributeReplaced//在Session属性被重新设置时。</p></blockquote><h2 id="160、easyExcel如何实现"><a href="#160、easyExcel如何实现" class="headerlink" title="160、easyExcel如何实现"></a>160、easyExcel如何实现</h2><p>异步读取<br>新建一个 ExcelModelListener 监听类出来，并且 继承 AnalysisEventListener 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zh.oukele.listener;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zh.oukele.model.ExcelMode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *  监听器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelModelListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;ExcelMode&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;ExcelMode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExcelMode&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelMode data, AnalysisContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;解析到一条数据:&#123; &quot;</span>+ data.toString() +<span class="string">&quot; &#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        list.add(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        count ++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            saveData( count );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            list.clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        saveData( count );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; count ：&quot;</span> + count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&#123; &quot;</span>+ count +<span class="string">&quot; &#125;条数据，开始存储数据库！&quot;</span> + list.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="161、什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#161、什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="161、什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>161、什么是 Swagger？你用 Spring Boot 实现了它吗？</h2><p>Swagger是用于生成RestFul Web服务的可视化表示工具，它使文档和服务器可视化更新；</p><p>当定义好Swagger后，可以调用服务端接口，来查看接口的返回值，验证返回数据的正确性；</p><hr><h2 id="162、数据库的三范式是什么？"><a href="#162、数据库的三范式是什么？" class="headerlink" title="162、数据库的三范式是什么？"></a>162、数据库的三范式是什么？</h2><p>1、列不可再分；</p><p>2、每一行数据只做一件事，只与一列相关，主键；</p><p>3、每个属性都与主键有直接关系，而不是间接关系；</p><p>三大范式只是设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情结，当然要特殊对待，数据库设计最重要的是看需求和性能，需求&gt;性能&gt;表结构。</p><p>所以不能一味的追求三范式建立数据库。</p><h2 id="163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？"><a href="#163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？"></a>163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</h2><p>一般情况下，我们创建的表类型是InnoDB。</p><p>不重启MySQL，如果新增一条记录，id是8；<br>重启，ID是6；因为InnoDB表只把自增主键的最大ID记录在内存中，如果重启，已删除的最大ID会丢失。<br>如果表类型是MyISAM，重启之后，最大ID也不会丢失，ID是8；</p><p>InnoDB必须有主键（建议使用自增主键，不用UUID，自增主键索引查询效率高）、支持外键、支持事务、支持行级锁。</p><p>系统崩溃后，MyISAM很难恢复；</p><p>综合考虑，优先选择InnoDB，MySQL默认也是InnoDB。</p><h2 id="164、如何获取当前数据库版本？"><a href="#164、如何获取当前数据库版本？" class="headerlink" title="164、如何获取当前数据库版本？"></a>164、如何获取当前数据库版本？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>MySQL,,mysql <span class="operator">-</span>v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Oracle </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$version;</span><br></pre></td></tr></table></figure><h2 id="165、说一下-ACID-是什么？"><a href="#165、说一下-ACID-是什么？" class="headerlink" title="165、说一下 ACID 是什么？"></a>165、说一下 ACID 是什么？</h2><p>ACID是数据库事务执行的四大基本要素，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><p>1、原子性</p><p>整个事务中的所有操作，要么全部完成，要不全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被roolback回滚到事务开始前的状态，就像这个事务从未执行过一样。</p><p>2、一致性</p><p>事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</p><p>3、隔离性</p><p>隔离状态执行事务，使他们好像是系统在给定时间内执行的唯一操作。</p><p>如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性确保每一个事务在系统中认为只有自己在使用系统。这种属性称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p><p>4、持久性</p><p>一个成功的事务将永久的改变系统的状态。</p><h2 id="166、char-和-varchar-的区别是什么？"><a href="#166、char-和-varchar-的区别是什么？" class="headerlink" title="166、char 和 varchar 的区别是什么？"></a>166、char 和 varchar 的区别是什么？</h2><ol><li>char的长度是固定的，varchar的长度的可变的；</li><li>char的效率比varchar的效率高；</li><li>char占用空间比varchar大，char在查询时需要使用trim；</li></ol><h2 id="167、float-和-double-的区别是什么？"><a href="#167、float-和-double-的区别是什么？" class="headerlink" title="167、float 和 double 的区别是什么？"></a>167、float 和 double 的区别是什么？</h2><p>1、float 和 double 的区别是什么？</p><p>（1）内存中占有的字节数不同</p><p>单精度浮点数在内存中占有4个字节；</p><p>双精度浮点数在内存中占有8个字节；</p><p>（2）有效数字位数不同</p><p>单精度浮点数有效数字8位；</p><p>双精度浮点数有效数字16位；</p><p>（3）数值取值范围不同</p><p>单精度浮点数的表示范围：-3.40E+38~3.40E+38</p><p>双精度浮点数的表示范围：-1.79E+308~-1.79E+308</p><p>（4）在程序中处理速度不同</p><p>一般来说，CPU处理单精度浮点数的速度比双精度浮点数的速度快</p><p>如果不声明，默认小数是double类型，如果想用float，要进行强转；</p><p>2、例如</p><p>float f = 1.3；会编译报错，正确的写法是float f = (float)1.3;或者float a = 1.3f;（f或F都可以不区分大小写）</p><p>3、注意</p><p>float是八位有效数字，第七位会四舍五入；</p><p>4、面试题</p><p>（1）java中3*0.1==0.3将会返回什么？true还是false？</p><p>答：返回false，因为浮点数不能完全精确的表示出来，一般会损失精度；</p><p>（2）java中float f = 3.4;是否正确？</p><p>答：不正确。因为3.4是双精度浮点数，将双精度赋给单精度属于向下转型，会造成精度损失，因此需要强制类型转换float=（float）3.4;或者写成float f = 3.4f;</p><h2 id="168、Oracle分页sql"><a href="#168、Oracle分页sql" class="headerlink" title="168、Oracle分页sql"></a>168、Oracle分页sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#不带排序的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ROWNUM <span class="keyword">AS</span> rowno, t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">where</span> ROWNUM <span class="operator">&lt;=</span><span class="number">20</span>) table_alias </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno <span class="operator">&gt;</span> <span class="number">10</span>;</span><br><span class="line">#带排序的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> tt.<span class="operator">*</span>, ROWNUM <span class="keyword">AS</span> rowno <span class="keyword">FROM</span> (  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">ORDER</span> <span class="keyword">BY</span> wkid <span class="keyword">aSC</span>) tt <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">20</span>) table_alias </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="169、数据库如何保证主键唯一性"><a href="#169、数据库如何保证主键唯一性" class="headerlink" title="169、数据库如何保证主键唯一性"></a>169、数据库如何保证主键唯一性</h2><p>1、主键约束</p><p>主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）；</p><p>2、唯一性约束</p><p>保证一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一性约束允许为null，但是只能有一行；</p><p>3、唯一性索引</p><p>不允许具有索引值相同的行，从而禁止重复的索引和键值；</p><p>4、三者的区别</p><ul><li>约束是用来检查数据的正确性；</li><li>索引是用来优化查询的；</li><li>创建唯一性约束会创建一个约束和一个唯一性索引；</li><li>创建唯一性索引只会创建一个唯一性索引；</li><li>主键约束和唯一性约束都会创建一个唯一性索引。</li></ul><h2 id="170、如何设计数据库"><a href="#170、如何设计数据库" class="headerlink" title="170、如何设计数据库"></a>170、如何设计数据库</h2><p>1、数据库设计最起码要占用这个项目开发的40%以上的时间</p><p>2、数据库设计不仅仅停留在页面demo的表面</p><p>页面内容所需字段，在数据库设计中只是一部分，还有系统运转、模块交互、中转数据、表之间的联系等等所需要的字段，因此数据库设计绝对不是简单的基本数据存储，还有逻辑数据存储。</p><p>3、数据库设计完成后，项目80%的设计开发都要存在你的脑海中</p><p>每个字段的设计都要有他存在的意义，要清楚的知道程序中如何去运用这些字段，多张表的联系在程序中是如何体现的。</p><p>4、数据库设计时就要考虑效率和优化问题</p><p>数据量大的表示粗粒度的，会冗余一些必要字段，达到用最少的表，最弱的表关系去存储海量的数据。大数据的表要建立索引，方便查询。对于含有计算、数据交互、统计这类需求时，还有考虑是否有必要采用存储过程。</p><p>5、添加必要的冗余字段</p><p>像创建时间、修改时间、操作用户IP、备注这些字段，在每张表中最好都有，一些冗余的字段便于日后维护、分析、拓展而添加。</p><p>6、设计合理的表关联 </p><p>若两张表之间的关系复杂，建议采用第三张映射表来关联维护两张表之间的关系，以降低表之间的直接耦合度。</p><p>7、设计表时不加主外键等约束关联，系统编码阶段完成后再添加约束性关联</p><p>8、选择合适的主键生成策略</p><p>数据库的设计难度其实比单纯的技术实现难很多，他充分体现了一个人的全局设计能力和掌控能力，最后说一句，数据库设计，很重要，很复杂。</p><h2 id="171、性别是否适合做索引"><a href="#171、性别是否适合做索引" class="headerlink" title="171、性别是否适合做索引"></a>171、性别是否适合做索引</h2><p>区分度不高的字段不适合做索引，因为索引页是需要有开销的，需要存储的，不过这类字段可以做联合索引的一部分。</p><h2 id="172、如何查询重复的数据"><a href="#172、如何查询重复的数据" class="headerlink" title="172、如何查询重复的数据"></a>172、如何查询重复的数据</h2><p>1、查询重复的单个字段（group by）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>2、查询重复的多个字段（group by）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, 重复字段B, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A, 重复字段B <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="173、数据库一般会采取什么样的优化方法？"><a href="#173、数据库一般会采取什么样的优化方法？" class="headerlink" title="173、数据库一般会采取什么样的优化方法？"></a>173、数据库一般会采取什么样的优化方法？</h2><p>1、选取适合的字段属性</p><ul><li>为了获取更好的性能，可以将表中的字段宽度设得尽可能小。</li><li>尽量把字段设置成not null</li><li>执行查询的时候，数据库不用去比较null值。</li><li>对某些省份或者性别字段，将他们定义为enum类型，enum类型被当做数值型数据来处理，而数值型数据被处理起来的速度要比文本类型块很多。</li></ul><p>2、使用join连接代替子查询</p><p>3、使用联合union来代替手动创建的临时表</p><p>注意：union用法中，两个select语句的字段类型要匹配，而且字段个数要相同。</p><p>4、事务</p><p>要么都成功，要么都失败。</p><p>可以保证数据库中数据的一致性和完整性。事务以begin开始，commit关键字结束。</p><p>如果出错，rollback命令可以将数据库恢复到begin开始之前的状态。</p><p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方式为用户提供一种安全的访问方式，这样就可以保证用户的操作不被其他的用户干扰。</p><p>5、锁定表</p><p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在大应用中。</p><p>由于在事务执行的过程中，数据库会被锁定，因此其它用户只能暂时等待直到事务结束。</p><p>有的时候可以用锁定表的方法来获得更好的性能，</p><p>共享锁：其它用户只能看，不能修改</p><p>lock table person in share mode；</p><p>对于通过lock table 命令主动添加的锁来说，如果要释放它们，只需发出rollback命令即可。</p><p>6、使用外键</p><p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性，这个时候可以使用外键。</p><p>7、使用索引</p><p>索引是提高数据库查询速度的常用方法，尤其是查询语句中包含max()、min()、order by这些命令的时候，性能提高更为显著。</p><p>一般来说索引应该建在常用于join、where、order by的字段上。尽量不要对数据库中含有大量重复的值得字段建立索引。</p><p>8、优化的查询语句</p><p>在索引的字段上尽量不要使用函数进行操作。</p><p>尽量不要使用like关键字和通配符，这样做法很简单，但却是以牺牲性能为代价的。</p><p>避免在查询中进行自动类型转换，因为类型转换也会使索引失效。</p><h2 id="174、索引怎么定义，分哪几种"><a href="#174、索引怎么定义，分哪几种" class="headerlink" title="174、索引怎么定义，分哪几种"></a>174、索引怎么定义，分哪几种</h2><ol><li>b-tree索引，如果不建立索引的情况下，oracle就自动给每一列都加一个B 树索引;</li><li>normal：普通索引</li><li>unique：唯一索引</li><li>bitmap：位图索引，位图索引特定于只有几个枚举值的情况，比如性别字段；</li><li>基于函数的索引</li></ol><h2 id="175、mysql-的内连接、左连接、右连接有什么区别？"><a href="#175、mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="175、mysql 的内连接、左连接、右连接有什么区别？"></a>175、mysql 的内连接、左连接、右连接有什么区别？</h2><ol><li>内连接,显示两个表中有联系的所有数据;</li><li>左链接,以左表为参照,显示所有数据,右表中没有则以null显示</li><li>右链接,以右表为参照显示数据，,左表中没有则以null显示</li></ol><hr><h2 id="176、RabbitMQ的使用场景有哪些？"><a href="#176、RabbitMQ的使用场景有哪些？" class="headerlink" title="176、RabbitMQ的使用场景有哪些？"></a>176、RabbitMQ的使用场景有哪些？</h2><p>1、解决异步问题</p><p>例如用户注册，发送邮件和短信反馈注册成功，可以使用RabbitMQ消息队列，用户无需等待反馈。</p><p>2、服务间解耦</p><p>订单系统和库存系统，中间加入RabbitMQ消息队列，当库存系统出现问题时，订单系统依旧能正常使用，降低服务间耦合度。</p><p>3、秒杀系统</p><p>利用RabbitMQ的最大值，实现秒杀系统。</p><h2 id="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"><a href="#177、RabbitMQ有哪些重要的角色？有哪些重要的组件？" class="headerlink" title="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"></a>177、RabbitMQ有哪些重要的角色？有哪些重要的组件？</h2><p>1、RabbitMQ有哪些重要的角色？</p><p>客户端、RabbitMQ、服务端。</p><p>2、有哪些重要的组件？</p><p>（1）connectionFactory（连接管理器）</p><p>应用程序与RabbitMQ之间建立连接的管理器。</p><p>（2）Channel（信道）</p><p>消息推送使用的信道。</p><p>（3）RoutingKey（路由键）</p><p>用于把生产者的数据分配到交换机上。</p><p>（4）Exchange（交换机）</p><p>用于接受和分配消息。</p><p>（5）BindKey（绑定键）</p><p>用于把交换机的消息绑定到队列上</p><p>（6）Queue（队列）</p><p>用于存储生产者消息。</p><h2 id="178、RabbitMQ中-vhost-的作用是什么？"><a href="#178、RabbitMQ中-vhost-的作用是什么？" class="headerlink" title="178、RabbitMQ中 vhost 的作用是什么？"></a>178、RabbitMQ中 vhost 的作用是什么？</h2><p>vhost可以理解为mini版的RabbitMQ，其内部均含有独立的交换机、绑定、队列，最重要的是拥有独立的权限系统，可以做到vhost范围内的用户控制。从RabbitMQ全局考虑，不同的应用可以跑在不同的vhost上，作为不同权限隔离的手段。</p><hr><h2 id="179、说一下-jvm-的主要组成部分？及其作用？"><a href="#179、说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="179、说一下 jvm 的主要组成部分？及其作用？"></a>179、说一下 jvm 的主要组成部分？及其作用？</h2><p>JVM包括类加载子系统、堆、方法区、栈、本地方法栈、程序计数器、直接内存、垃圾回收器、执行引擎。</p><p>1、类加载子系统</p><p>类加载子系统负责加载class信息，加载的类信息存放于方法区中。</p><p>2、直接内存</p><p>直接内存是在Java堆外的、直接向系统申请的内存空间。访问直接内存的速度会由于Java堆。出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。</p><p>3、垃圾回收器</p><p>垃圾回收器可以对堆、方法区、直接内存进行回收。</p><p>4、执行引擎</p><p>执行引擎负责执行虚拟机的字节码，虚拟机会使用即时编译技术将方法编译成机器码后再执行。</p><h2 id="180、说一下-jvm-运行时数据区？"><a href="#180、说一下-jvm-运行时数据区？" class="headerlink" title="180、说一下 jvm 运行时数据区？"></a>180、说一下 jvm 运行时数据区？</h2><p>运行时数据区包括堆、方法区、栈、本地方法栈、程序计数器。</p><p>1、堆</p><p>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</p><p>2、方法区</p><p>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</p><p>3、栈</p><p>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>（1）栈帧</p><p>每个方法从调用到执行的过程就是一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>（2）局部变量表</p><p>用于保存函数的参数和局部变量。</p><p>（3）操作数栈</p><p>操作数栈又称操作栈，大多数指令都是从这里弹出数据，执行运算，然后把结果压回操作数栈。</p><p>4、本地方法栈</p><p>与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</p><p>5、程序计数器（PC寄存器）</p><p>程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p><h2 id="181、什么是类加载器，类加载器有哪些？"><a href="#181、什么是类加载器，类加载器有哪些？" class="headerlink" title="181、什么是类加载器，类加载器有哪些？"></a>181、什么是类加载器，类加载器有哪些？</h2><p><img src="https://img-blog.csdnimg.cn/20210801183934528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3J1aV9qYXZh,size_16,color_FFFFFF,t_70" alt="img"></p><p>1、什么是类加载器？</p><p>类加载器负责加载所有的类，其为所有被载入内存的类生成一个java.lang.Class实例对象。</p><p>2、类加载器有哪些？</p><p>JVM有三种类加载器：</p><p>（1）启动类加载器</p><p>该类没有父加载器，用来加载Java的核心类，启动类加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并不继承自java.lang.classLoader。</p><p>（2）扩展类加载器</p><p>它的父类为启动类加载器，扩展类加载器是纯java类，是ClassLoader类的子类，负责加载JRE的扩展目录。</p><p>（3）应用程序类加载器</p><p>它的父类为扩展类加载器，它从环境变量classpath或者系统属性java.lang.path所指定的目录中加载类，它是自定义的类加载器的父加载器。</p><h2 id="182、说一下类加载的执行过程？"><a href="#182、说一下类加载的执行过程？" class="headerlink" title="182、说一下类加载的执行过程？"></a>182、说一下类加载的执行过程？</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接、初始化3个步骤对该类进行类加载。</p><p>1、加载</p><p>加载指的是将类的class文件读入到内存中，并为之创建一个java.lang.Class对象。</p><p>类的加载由类加载器完成，类加载器由JVM提供，开发者也可以通过继承ClassLoader基类来创建自己的类加载器。</p><p>通过使用不同的类加载器可以从不同来源加载类的二进制数据，通常有如下几种来源：</p><ol><li>从本地文件系统加载</li><li>从jar包加载</li><li>通过网络加载</li><li>把一个Java源文件动态编译，并执行加载</li></ol><p>2、连接</p><p>当类被加载之后，系统为之生成一个对应的Class对象，接着进入连接阶段，连接阶段负责将类的二进制数据合并到JRE中。</p><p>类连接又可分为三个阶段：</p><p>（1）验证</p><p>文件格式验证<br>元数据验证<br>字节码验证<br>符号引用验证</p><p>（2）准备</p><p>为类的静态变量分配内存，并设置默认初始值。</p><p>（3）解析</p><p>将类的二进制数据中的符号引用替换成直接引用。</p><p>3、初始化</p><p>为类的静态变量赋予初始值。</p><h2 id="183、JVM的类加载机制是什么？"><a href="#183、JVM的类加载机制是什么？" class="headerlink" title="183、JVM的类加载机制是什么？"></a>183、JVM的类加载机制是什么？</h2><p>JVM类加载机制主要有三种：</p><p>1、全盘负责</p><p>类加载器加载某个class时，该class所依赖的和引用其它的class也由该类加载器载入。</p><p>2、双亲委派</p><p>先让父加载器加载该class，父加载器无法加载时才考虑自己加载。</p><p>3、缓存机制</p><p>缓存机制保证所有加载过的class都会被缓存，当程序中需要某个class时，先从缓存区中搜索，如果不存在，才会读取该类对应的二进制数据，并将其转换成class对象，存入缓存区中。</p><p>这就是为什么修改了class后，必须重启JVM，程序所做的修改才会生效的原因。</p><h2 id="184、什么是双亲委派模型？"><a href="#184、什么是双亲委派模型？" class="headerlink" title="184、什么是双亲委派模型？"></a>184、什么是双亲委派模型？</h2><p>如果一个类收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器执行，如果父加载器还存在其父加载器，则进一步向上委托，依次递归，请求将最终到达顶层的启动类加载器，如果父类加载器可以完成父加载任务，就成功返回，如果父加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型。</p><p>双亲委派模式的优势：</p><ol><li>避免重复加载；</li><li>考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模式传递到启动加载器，而启动加载器在核心Java API中发现同名的类，发现该类已经被加载，就不会重新加载网络传递的Integer类，而直接返回已加载过的Integer.class，这样可以防止核心API库被随意篡改。</li></ol><h2 id="185、怎么判断对象是否可以被回收？"><a href="#185、怎么判断对象是否可以被回收？" class="headerlink" title="185、怎么判断对象是否可以被回收？"></a>185、怎么判断对象是否可以被回收？</h2><p>1、引用计数算法</p><p>（1）判断对象的引用数量</p><p>通过判断对象的引用数量来决定对象是否可以被回收；<br>每个对象实例都有一个引用计数器，被引用+1，完成引用-1；<br>任何引用计数为0的对象实例可以被当做垃圾回收；</p><p>（2）优缺点</p><p>优点：执行效率高，程序受影响较小；<br>缺点：无法检测出循环引用的情况，导致内存泄漏；</p><p>2、可达性分析算法</p><p>通过判断对象的引用链是否可达来决定对象是否可以被回收。</p><p>如果程序无法再引用该对象，那么这个对象肯定可以被回收，这个状态称为不可达。</p><p>那么不可达状态如何判断呢？</p><p>答案是GC roots，也就是根对象，如果一个对象无法到达根对象的路径，或者说从根对象无法引用到该对象，该对象就是不可达的。</p><p>以下三种对象在JVM中被称为GC roots，来判断一个对象是否可以被回收。</p><p>（1）虚拟机栈的栈帧</p><p>每个方法在执行的时候，JVM都会创建一个相应的栈帧（操作数栈、局部变量表、运行时常量池的引用），当方法执行完，该栈帧就从栈中弹出，这样一来，方法中临时创建的独享就不存在了，或者说没有任何GC roots指向这些临时对象，这些对象在下一次GC的时候便会被回收。</p><p>（2）方法区中的静态属性</p><p>静态属性数据类属性，不属于任何实例，因此该属性自然会作为GC roots。这要这个class在，该引用指向的对象就一直存在，class也由被回收的时候。</p><p>class何时会被回收？</p><ol><li>堆中不存在该类的任何实例</li><li>加载该类的classLoader已经被回收</li><li>该类的java.lang.class对象没有在任何地方被引用，也就是说无法通过反射访问该类的信息</li></ol><p>（3）本地方法栈引用的对象</p><h2 id="186、说一下-jvm-有哪些垃圾回收算法？"><a href="#186、说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="186、说一下 jvm 有哪些垃圾回收算法？"></a>186、说一下 jvm 有哪些垃圾回收算法？</h2><p>1、对象是否已死算法</p><ul><li>引用计数器算法</li><li>可达性分析算法</li></ul><p>2、GC算法</p><p>（1）标记清除算法</p><p>如果对象被标记后进行清除，会带来一个新的问题—内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p><p>（2）复制算法（Java堆中新生代的垃圾回收算法）</p><ol><li>先标记待回收内存和不用回收内存；</li><li>将不用回收的内存复制到新的内存区域；</li><li>就的内存区域就可以被全部回收了，而新的内存区域也是连续的；</li></ol><p>缺点是损失部分系统内存，因为腾出部分内存进行复制。</p><p>（3）标记压缩算法（Java堆中老年代的垃圾回收算法）</p><p>对于新生代，大部分对象都不会存活，所以复制算法较高效，但对于老年代，大部分对象可能要继续存活，如果此时使用复制算法，效率会降低。</p><p>标记压缩算法首先还是标记，将不用回收的内存对象压缩到内存一端，此时即可清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p><p>老年代的垃圾回收算法称为“Major GC”。</p><h2 id="187、说一下-jvm-有哪些垃圾回收器？"><a href="#187、说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="187、说一下 jvm 有哪些垃圾回收器？"></a>187、说一下 jvm 有哪些垃圾回收器？</h2><p><a href="https://blog.csdn.net/guorui_java/article/details/108405844">说一下 jvm 有哪些垃圾回收器？</a></p><h2 id="188、JVM栈堆概念，何时销毁对象"><a href="#188、JVM栈堆概念，何时销毁对象" class="headerlink" title="188、JVM栈堆概念，何时销毁对象"></a>188、JVM栈堆概念，何时销毁对象</h2><ol><li>类在程序运行的时候就会被加载，方法是在执行的时候才会被加载，如果没有任何引用了，Java自动垃圾回收，也可以用System.gc()开启回收器，但是回收器不一定会马上回收。</li><li>静态变量在类装载的时候进行创建，在整个程序结束时按序销毁；</li><li>实例变量在类实例化对象时创建，在对象销毁的时候销毁；</li><li>局部变量在局部范围内使用时创建，跳出局部范围时销毁；</li></ol><h2 id="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p><p>老年代回收器：Serial Old、Parallel Old、CMS</p><p>新生代回收器一般采用的是复制算法，复制算法效率较高，但是浪费内存；</p><p>老生代回收器一般采用标记清楚算法，比如最常用的CMS；</p><h2 id="190、详细介绍一下-CMS-垃圾回收器？"><a href="#190、详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="190、详细介绍一下 CMS 垃圾回收器？"></a>190、详细介绍一下 CMS 垃圾回收器？</h2><p>CMS 垃圾回收器是Concurrent Mark Sweep，是一种同步的标记-清除，CMS分为四个阶段：</p><p>初始标记，标记一下GC Root能直接关联到的对象，会触发“Stop The World”；<br>并发标记，通过GC Roots Tracing判断对象是否在使用中；<br>重新标记，标记期间产生对象的再次判断，执行时间较短，会触发“Stop The World”；<br>并发清除，清除对象，可以和用户线程并发进行；</p><h2 id="191、简述分代垃圾回收器是怎么工作的？"><a href="#191、简述分代垃圾回收器是怎么工作的？" class="headerlink" title="191、简述分代垃圾回收器是怎么工作的？"></a>191、简述分代垃圾回收器是怎么工作的？</h2><p>分代回收器分为新生代和老年代，新生代大概占1/3，老年代大概占2/3；</p><p>新生代包括Eden、From Survivor、To Survivor；</p><p>Eden区和两个survivor区的 的空间比例 为8：1：1 ；</p><p>垃圾回收器的执行流程：</p><ol><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden + From Survivor 分区，From Survivor 和 To Survivor 分区交换；</li><li>每次交换后存活的对象年龄+1，到达15，升级为老年代，大对象会直接进入老年代；</li><li>老年代中当空间到达一定占比，会触发全局回收，老年代一般采取标记-清除算法；</li></ol><hr><h2 id="192、Redis是什么？"><a href="#192、Redis是什么？" class="headerlink" title="192、Redis是什么？"></a>192、Redis是什么？</h2><p>Redis是一个key-value存储系统，它支持存储的value类型相对更多，包括string、list、set、zset（sorted set —有序集合）和hash。这些数据结构都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中，Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p><h2 id="193、Redis都有哪些使用场景？"><a href="#193、Redis都有哪些使用场景？" class="headerlink" title="193、Redis都有哪些使用场景？"></a>193、Redis都有哪些使用场景？</h2><ol><li>Redis是基于内存的nosql数据库，可以通过新建线程的形式进行持久化，不影响Redis单线程的读写操作</li><li>通过list取最新的N条数据</li><li>模拟类似于token这种需要设置过期时间的场景</li><li>发布订阅消息系统</li><li>定时器、计数器</li></ol><h2 id="194、Redis有哪些功能？"><a href="#194、Redis有哪些功能？" class="headerlink" title="194、Redis有哪些功能？"></a>194、Redis有哪些功能？</h2><p>1、基于本机内存的缓存</p><p>当调用api访问数据库时，假如此过程需要2秒，如果每次请求都要访问数据库，那将对服务器造成巨大的压力，如果将此sql的查询结果存到Redis中，再次请求时，直接从Redis中取得，而不是访问数据库，效率将得到巨大的提升，Redis可以定时去更新数据（比如1分钟）。</p><p>2、如果电脑重启，写入内存的数据是不是就失效了呢，这时Redis还提供了持久化的功能。</p><p>3、哨兵（Sentinel）和复制</p><p>Sentinel可以管理多个Redis服务器，它提供了监控、提醒以及自动的故障转移功能；</p><p>复制则是让Redis服务器可以配备备份的服务器；</p><p>Redis也是通过这两个功能保证Redis的高可用；</p><p>4、集群（Cluster）</p><p>单台服务器资源总是有上限的，CPU和IO资源可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，但是内存资源怎么办，主从模式只是数据的备份，并不能扩充内存；</p><p>现在我们可以横向扩展，让每台服务器只负责一部分任务，然后将这些服务器构成一个整体，对外界来说，这一组服务器就像是集群一样。</p><h2 id="195、Redis支持的数据类型有哪些？"><a href="#195、Redis支持的数据类型有哪些？" class="headerlink" title="195、Redis支持的数据类型有哪些？"></a>195、Redis支持的数据类型有哪些？</h2><ol><li>字符串</li><li>hash</li><li>list</li><li>set</li><li>zset</li></ol><h2 id="196、Redis取值存值问题"><a href="#196、Redis取值存值问题" class="headerlink" title="196、Redis取值存值问题"></a>196、Redis取值存值问题</h2><p>1、先把Redis的连接池拿出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>(),<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br></pre></td></tr></table></figure><p>2、存取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">jedis.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">jedis.del(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//给一个key叠加value</span></span><br><span class="line">jedis.append(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value2&quot;</span>);<span class="comment">//此时key的值就是value + value2;</span></span><br><span class="line"><span class="comment">//同时给多个key进行赋值：</span></span><br><span class="line"></span><br><span class="line">jedis.mset(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br></pre></td></tr></table></figure><p>3、对map进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">user.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line"><span class="comment">//存入</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"><span class="comment">//取出user中key1 </span></span><br><span class="line">List&lt;String&gt; nameMap = jedis.hmget(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="comment">//删除其中一个键值</span></span><br><span class="line">jedis.hdel(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;key2&quot;</span>);</span><br><span class="line"><span class="comment">//是否存在一个键</span></span><br><span class="line">jedis.exists(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">//取出所有的Map中的值：</span></span><br><span class="line">Iterator&lt;String&gt; iter = jedis.hkeys(<span class="string">&quot;user&quot;</span>).iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.next())&#123;</span><br><span class="line">    jedis.hmget(<span class="string">&quot;user&quot;</span>,iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="197、Redis为什么是单线程的？"><a href="#197、Redis为什么是单线程的？" class="headerlink" title="197、Redis为什么是单线程的？"></a>197、Redis为什么是单线程的？</h2><ol><li>代码更清晰，处理逻辑更简单；</li><li>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能问题；</li><li>不存在多线程切换而消耗CPU；</li><li>无法发挥多核CPU的优势，但可以采用多开几个Redis实例来完善；</li></ol><h2 id="198、Redis真的是单线程的吗？"><a href="#198、Redis真的是单线程的吗？" class="headerlink" title="198、Redis真的是单线程的吗？"></a>198、Redis真的是单线程的吗？</h2><p>Redis6.0之前是单线程的，Redis6.0之后开始支持多线程；<br>redis内部使用了基于epoll的多路服用，也可以多部署几个redis服务器解决单线程的问题；<br>redis主要的性能瓶颈是内存和网络；<br>内存好说，加内存条就行了，而网络才是大麻烦，所以redis6内存好说，加内存条就行了；<br>而网络才是大麻烦，所以redis6.0引入了多线程的概念，<br>redis6.0在网络IO处理方面引入了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</p><h2 id="199、Redis持久化有几种方式？"><a href="#199、Redis持久化有几种方式？" class="headerlink" title="199、Redis持久化有几种方式？"></a>199、Redis持久化有几种方式？</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p><p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p><p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p><p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p><p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p><h2 id="200、Redis和-memecache-有什么区别？"><a href="#200、Redis和-memecache-有什么区别？" class="headerlink" title="200、Redis和 memecache 有什么区别？"></a>200、Redis和 memecache 有什么区别？</h2><p>1、Redis相比memecache，拥有更多的数据结构和支持更丰富的数据操作。</p><p>（1）Redis支持key-value，常用的数据类型主要有String、Hash、List、Set、Sorted Set。</p><p>（2）memecache只支持key-value。</p><p>2、内存使用率对比，Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memecache。</p><p>3、性能对比：Redis只使用单核，memecache使用多核。</p><p>4、Redis支持磁盘持久化，memecache不支持。</p><p>Redis可以将一些很久没用到的value通过swap方法交换到磁盘。</p><p>5、Redis支持分布式集群，memecache不支持。</p><h2 id="201、Redis支持的-java-客户端都有哪些？"><a href="#201、Redis支持的-java-客户端都有哪些？" class="headerlink" title="201、Redis支持的 java 客户端都有哪些？"></a>201、Redis支持的 java 客户端都有哪些？</h2><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p><h2 id="202、jedis-和-redisson-有哪些区别？"><a href="#202、jedis-和-redisson-有哪些区别？" class="headerlink" title="202、jedis 和 redisson 有哪些区别？"></a>202、jedis 和 redisson 有哪些区别？</h2><p>Jedis 和 Redisson 都是Java中对Redis操作的封装。Jedis 只是简单的封装了 Redis 的API库，可以看作是Redis客户端，它的方法和Redis 的命令很类似。Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 更加大。但Jedis相比于Redisson 更原生一些，更灵活。</p><h2 id="203、什么是缓存穿透？怎么解决？"><a href="#203、什么是缓存穿透？怎么解决？" class="headerlink" title="203、什么是缓存穿透？怎么解决？"></a>203、什么是缓存穿透？怎么解决？</h2><p>1、缓存穿透</p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>2、怎么解决？</p><p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p><p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</p><p>3、缓存雪崩</p><p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。</p><p>4、如何解决？</p><ol><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其它线程等待；</li><li>做二级缓存；</li><li>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀；</li></ol><h2 id="204、怎么保证缓存和数据库数据的一致性？"><a href="#204、怎么保证缓存和数据库数据的一致性？" class="headerlink" title="204、怎么保证缓存和数据库数据的一致性？"></a>204、怎么保证缓存和数据库数据的一致性？</h2><p>1、淘汰缓存</p><p>数据如果为较为复杂的数据时，进行缓存的更新操作就会变得异常复杂，因此一般推荐选择淘汰缓存，而不是更新缓存。</p><p>2、选择先淘汰缓存，再更新数据库</p><p>假如先更新数据库，再淘汰缓存，如果淘汰缓存失败，那么后面的请求都会得到脏数据，直至缓存过期。</p><p>假如先淘汰缓存再更新数据库，如果更新数据库失败，只会产生一次缓存穿透，相比较而言，后者对业务则没有本质上的影响。</p><p>3、延时双删策略</p><p>如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。</p><ol><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li></ol><p>次数便出现了数据不一致问题。采用延时双删策略得以解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">    db.update(data);</span><br><span class="line">    Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。</p><p>4、数据库读写分离的场景</p><p>两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p><ol><li>请求A进行写操作，删除缓存</li><li>请求A将数据写入数据库了，</li><li>请求B查询缓存发现，缓存没有值</li><li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li><li>请求B将旧值写入缓存</li><li>数据库完成主从同步，从库变为新值</li></ol><p>依旧采用延时双删策略解决此问题。</p><h2 id="205、Redis，什么是缓存穿透？怎么解决？"><a href="#205、Redis，什么是缓存穿透？怎么解决？" class="headerlink" title="205、Redis，什么是缓存穿透？怎么解决？"></a>205、Redis，什么是缓存穿透？怎么解决？</h2><p>1、缓存穿透</p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p>2、怎么解决？</p><p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p><p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</p><p>3、缓存雪崩</p><p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。</p><p>4、如何解决？</p><ol><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其它线程等待；</li><li>做二级缓存；</li><li>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀；</li></ol><h2 id="206、Redis怎么实现分布式锁？"><a href="#206、Redis怎么实现分布式锁？" class="headerlink" title="206、Redis怎么实现分布式锁？"></a>206、Redis怎么实现分布式锁？</h2><p>使用Redis实现分布式锁</p><p>redis命令：set users 10 nx ex 12  原子性命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用uuid，解决锁释放的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b_lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(b_lock)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lockUUID</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(uuid.equals(lockUUID.toString()))&#123;</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        testLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：可以通过lua脚本，保证分布式锁的原子性。</p><h2 id="207、Redis分布式锁有什么缺陷？"><a href="#207、Redis分布式锁有什么缺陷？" class="headerlink" title="207、Redis分布式锁有什么缺陷？"></a>207、Redis分布式锁有什么缺陷？</h2><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><p>Redis容易产生的几个问题：</p><ol><li>锁未被释放</li><li>B锁被A锁释放了</li><li>数据库事务超时</li><li>锁过期了，业务还没执行完</li><li>Redis主从复制的问题</li></ol><h2 id="208、Redis如何做内存优化？"><a href="#208、Redis如何做内存优化？" class="headerlink" title="208、Redis如何做内存优化？"></a>208、Redis如何做内存优化？</h2><p>1、缩短键值的长度</p><ol><li>缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；</li><li>首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；</li><li>其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；</li><li>以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等</li></ol><p>2、共享对象池</p><p>对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。</p><p>3、字符串优化</p><p>4、编码优化</p><p>5、控制key的数量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;10万字208道Java经典面试题总结&quot;&gt;&lt;a href=&quot;#10万字208道Java经典面试题总结&quot; class=&quot;headerlink&quot; title=&quot;10万字208道Java经典面试题总结&quot;&gt;&lt;/a&gt;10万字208道Java经典面试题总结&lt;/h1&gt;&lt;hr&gt;
</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL面试题</title>
    <link href="https://manamn.space/2022/11/30/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://manamn.space/2022/11/30/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-11-30T09:39:25.000Z</published>
    <updated>2022-11-30T09:42:21.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><h3 id="1、MySQL有哪些数据库类型？"><a href="#1、MySQL有哪些数据库类型？" class="headerlink" title="1、MySQL有哪些数据库类型？"></a>1、MySQL有哪些数据库类型？</h3><ul><li><strong>数值类型</strong></li></ul><p>有包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3 字节、4 字节、8 字节的<strong>整数类型</strong>。</p><p>1）任何整数类型都可以加上 UNSIGNED 属性，表示无符号整数。</p><p>2）任何整数类型都可以指定长度，但它不会限制数据的合法长度，仅仅限制了显示长度。</p><p>还有包括 FLOAT、DOUBLE、DECIMAL 在内的<strong>小数类型</strong>。</p><ul><li><strong>字符串类型</strong></li></ul><p>包括 VARCHAR、CHAR、TEXT、BLOB。</p><p><strong>注意：VARCHAR(n) 和 CHAR(n) 中的 n 并不代表字节个数，而是代表字符的个数。</strong></p><ul><li><strong>日期和时间类型</strong></li></ul><p>常用于表示日期和时间类型为 DATETIME、DATE 和 TIMESTAMP。</p><p>尽量使用 TIMESTAMP，空间效率高于 DATETIME。</p><p> <em>ref MySQL 数据类型</em> </p><h3 id="2、CHAR-和-VARCHAR-区别？"><a href="#2、CHAR-和-VARCHAR-区别？" class="headerlink" title="2、CHAR 和 VARCHAR 区别？"></a>2、CHAR 和 VARCHAR 区别？</h3><p>1）首先可以明确的是 CHAR 是定长的，而 VARCHAR 是可以变长。</p><p>CHAR 会根据声明的字符串长度分配空间，并会使用空格对字符串右边进行尾部填充。所以在检索 CHAR 类型数据时尾部空格会被删除，如保存的是字符串 ‘char ‘，但最后查询到的是 ‘char’。又因为长度固定，所以存储效率高于 VARCHAR 类型。</p><p>VARCHAR 在 MySQL 5.0 之后长度支持到 65535 字节，<strong>但会在数据开头使用额外 1~2 个字节存储字符串长度（列长度小于 255 字节时使用 1 字节表示，否则 2 字节），在结尾使用 1 字节表示字符串结束。</strong></p><p>2）再者，在存储方式上，CHAR 对英文字符（ASCII）占用 1 字节，对一个汉字使用用 2 字节。而 VARCHAR 对每个字符均使用 2 字节。</p><p><strong>虽然 VARCHAR 是根据字符串长度分配存储空间的，但在内存中依旧使用声明长度进行排序等作业，故在使用时仍需综合考量字段长度。</strong></p><h3 id="3、CHAR-和-VARCHAR-如何选择？"><a href="#3、CHAR-和-VARCHAR-如何选择？" class="headerlink" title="3、CHAR 和 VARCHAR 如何选择？"></a>3、CHAR 和 VARCHAR 如何选择？</h3><p>1）对于经常变更的数据来说，CHAR 比 VARCHAR更好，因为 CHAR 不容易产生碎片。</p><p>2）对于非常短的列或固定长度的数据（如 MD5），CHAR 比 VARCHAR 在存储空间上更有效率。</p><p>4）使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p><p>4）尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。</p><h3 id="4、CHAR，VARCHAR-和-Text-的区别？"><a href="#4、CHAR，VARCHAR-和-Text-的区别？" class="headerlink" title="4、CHAR，VARCHAR 和 Text 的区别？"></a>4、CHAR，VARCHAR 和 Text 的区别？</h3><p>1）<strong>长度区别</strong></p><ul><li>Char 范围是 0～255。  </li><li>Varchar 最长是 64k（注意这里的 64k 是整个 row 的长度，要考虑到其它的 column，还有如果存在 not null 的时候也会占用一位，对不同的字符集，有效长度还不一样，比如 utf-8 的，最多 21845，还要除去别的column），但 Varchar 在一般情况下存储都够用了。  </li><li>如果遇到了大文本，考虑使用 Text，最大能到 4G（其中 TEXT 长度 65,535 bytes，约 64kb；MEDIUMTEXT 长度 16,777,215 bytes，约 16 Mb；而 LONGTEXT 长度 4,294,967,295 bytes，约 4Gb）。 </li></ul><p>2）<strong>效率区别</strong></p><p>效率来说基本是 Char &gt; Varchar &gt; Text，但是如果使用的是 Innodb 引擎的话，推荐使用 Varchar 代替 Char。</p><p>3）<strong>默认值区别</strong></p><p>Char 和 Varchar 支持设置默认值，而 Text 不能指定默认值。</p><h2 id="1-2-数据库设计"><a href="#1-2-数据库设计" class="headerlink" title="1.2 数据库设计"></a>1.2 数据库设计</h2><h3 id="1、什么是三大范式？"><a href="#1、什么是三大范式？" class="headerlink" title="1、什么是三大范式？"></a>1、什么是三大范式？</h3><ul><li>第一范式（1NF）：字段（或属性）是不可分割的最小单元，即不会有重复的列，体现原子性  </li><li>第二范式（2NF）：满足 1NF 前提下，存在一个候选码，非主属性全部依赖该候选码，即存在主键，体现唯一性，专业术语则是消除部分函数依赖  </li><li><p>第三范式（3NF）：满足 2NF 前提下，非主属性必须互不依赖，消除传递依赖 </p><p><em>ref：如何理解关系型数据库的常见设计范式？</em> </p></li></ul><p>除了三大范式外，还有<strong>BC范式</strong>和<strong>第四范式</strong>，但其规范过于严苛，在生产中往往使用不到。</p><h3 id="2、什么是范式和反范式，以及各自优缺点？"><a href="#2、什么是范式和反范式，以及各自优缺点？" class="headerlink" title="2、什么是范式和反范式，以及各自优缺点？"></a>2、什么是范式和反范式，以及各自优缺点？</h3><p><strong>范式</strong>是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。</p><p>所以在平时工作中，我们通常是将范式和反范式相互结合使用。</p><p>首先了解一下什么是索引，<strong>索引</strong>是对数据库表中一列或多列的值进行排序的数据结构，用于快速访问数据库表中的特定信息。</p><h3 id="1、索引的几种类型或分类？"><a href="#1、索引的几种类型或分类？" class="headerlink" title="1、索引的几种类型或分类？"></a>1、索引的几种类型或分类？</h3><p>1）从<strong>物理结构</strong>上可以分为聚集索引和非聚集索引两类：</p><ul><li>聚簇索引指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的主键索引；  </li><li>非聚簇索引的逻辑顺序则与数据行的物理顺序不一致。 </li></ul><p>2）从<strong>应用</strong>上可以划分为一下几类：</p><ul><li>普通索引：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 ALTER TABLE table_name ADD INDEX index_name (column) 创建；  </li><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。通过 ALTER TABLE table_name ADD UNIQUE index_name (column) 创建；  </li><li>主键索引：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；  </li><li>组合索引：组合表中多个字段创建的索引，遵守最左前缀匹配规则；  </li><li>全文索引：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。 </li></ul><h3 id="2、索引的优缺点？"><a href="#2、索引的优缺点？" class="headerlink" title="2、索引的优缺点？"></a>2、索引的优缺点？</h3><p>先来说说<strong>优点</strong>：创建索引可以大大提高系统的性能。</p><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  </li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。  </li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。  </li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。  </li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 </li></ul><p>既然增加索引有如此多的优点，为什么不对表中的每一个列都创建一个索引呢？这是因为索引也是有<strong>缺点</strong>的：</p><ul><li>创建和维护索引需要耗费时间，这种时间随着数据量的增加而增加，这样就降低了数据的维护速度。  </li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。 </li></ul><h3 id="3、索引设计原则？"><a href="#3、索引设计原则？" class="headerlink" title="3、索引设计原则？"></a>3、索引设计原则？</h3><ul><li><strong>选择唯一性索引</strong>；</li></ul><p>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</p><ul><li><strong>为常作为查询条件的字段建立索引</strong>；</li></ul><p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p><ul><li><strong>为经常需要排序、分组和联合操作的字段建立索引</strong>；</li></ul><p>经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p><ul><li><strong>限制索引的数目</strong>；</li></ul><p>每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。</p><ul><li><strong>小表不建议索引（如数量级在百万以内）</strong>；</li></ul><p>由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p><ul><li><strong>尽量使用数据量少的索引</strong>；</li></ul><p>如果索引的值很长，那么查询的速度会受到影响。此时<strong>尽量使用前缀索引</strong>。</p><ul><li><strong>删除不再使用或者很少使用的索引</strong>。</li></ul><h3 id="4、索引的数据结构？"><a href="#4、索引的数据结构？" class="headerlink" title="4、索引的数据结构？"></a>4、索引的数据结构？</h3><p>索引的数据结构和具体存储引擎的实现有关，MySQL 中常用的是 <strong>Hash</strong> 和 <strong>B+ 树</strong>索引。</p><ul><li>Hash 索引底层就是 Hash 表，进行查询时调用 Hash 函数获取到相应的键值（对应地址），然后回表查询获得实际数据.  </li><li>B+ 树索引底层实现原理是多路平衡查找树，对于每一次的查询都是从根节点出发，查询到叶子节点方可以获得所查键值，最后查询判断是否需要回表查询. </li></ul><h3 id="5、Hash-和-B-树索引的区别？"><a href="#5、Hash-和-B-树索引的区别？" class="headerlink" title="5、Hash 和 B+ 树索引的区别？"></a>5、Hash 和 B+ 树索引的区别？</h3><p><strong>Hash</strong> 1）Hash 进行等值查询更快，但无法进行范围查询。因为经过 Hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，故不能支持范围查询。同理，也不支持使用索引进行排序。</p><p>2）Hash 不支持模糊查询以及多列索引的最左前缀匹配,因为 Hash 函数的值不可预测，如 AA 和 AB 的算出的值没有相关性。</p><p>3）Hash 任何时候都避免不了回表查询数据.</p><p>4）虽然在等值上查询效率高，但性能不稳定，因为当某个键值存在大量重复时，产生 Hash 碰撞，此时查询效率反而可能降低。</p><p><strong>B+ Tree</strong></p><p>1）B+ 树本质是一棵查找树，自然支持范围查询和排序。</p><p>2）在符合某些条件（聚簇索引、覆盖索引等）时候可以只通过索引完成查询，不需要回表。</p><p>3）查询效率比较稳定，因为每次查询都是从根节点到叶子节点，且为树的高度。</p><h3 id="6、为何使用-B-树而非二叉查找树做索引？"><a href="#6、为何使用-B-树而非二叉查找树做索引？" class="headerlink" title="6、为何使用 B+ 树而非二叉查找树做索引？"></a>6、为何使用 B+ 树而非二叉查找树做索引？</h3><p>我们知道二叉树的查找效率为 O(logn)，当树过高时，查找效率会下降。另外由于我们的索引文件并不小，所以是存储在磁盘上的。</p><p>文件系统需要从磁盘读取数据时，一般以页为单位进行读取，假设一个页内的数据过少，那么操作系统就需要读取更多的页，涉及磁盘随机 I/O 访问的次数就更多。将数据从磁盘读入内存涉及随机 I/O 的访问，是数据库里面成本最高的操作之一。</p><p>因而这种树高会随数据量增多急剧增加，每次更新数据又需要通过左旋和右旋维护平衡的二叉树，不太适合用于存储在磁盘上的索引文件。</p><h3 id="7、为何使用-B-树而非-B-树做索引？"><a href="#7、为何使用-B-树而非-B-树做索引？" class="headerlink" title="7、为何使用 B+ 树而非 B 树做索引？"></a>7、为何使用 B+ 树而非 B 树做索引？</h3><p>在此之前，先来了解一下 B+ 树和 B 树的区别：</p><ul><li>B 树非叶子结点和叶子结点都存储数据，因此查询数据时，时间复杂度最好为 O(1)，最坏为 O(log n)。而 B+ 树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。  </li><li>B+ 树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B 树只能通过中序遍历。 </li></ul><p><strong>为什么 B+ 树比 B 树更适合应用于数据库索引？</strong></p><ul><li><strong>B+ 树减少了 IO 次数</strong>。</li></ul><p>由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I/O 读取次数相对就减少了。</p><ul><li><strong>B+ 树查询效率更稳定</strong></li></ul><p>由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)，所以 B+ 树的查询效率相比B树更加稳定。</p><ul><li><strong>B+ 树更加适合范围查找</strong></li></ul><p>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</p><p> <em>ref 为什么 B+ 树比 B 树更适合应用于数据库索引？</em> </p><h3 id="8、什么是最左匹配原则？"><a href="#8、什么是最左匹配原则？" class="headerlink" title="8、什么是最左匹配原则？"></a>8、什么是最左匹配原则？</h3><p>顾名思义，最左优先，以最左边为起点任何连续的索引都能匹配上。同时遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。</p><p>如建立 (a,b,c,d) 索引，查询条件 b = 2 是匹配不到索引的，但是如果查询条件是 a = 1 and b = 2 或 a=1 又或 b = 2 and a = 1 就可以，因为优化器会自动调整 a,b 的顺序。</p><p>再比如 a = 1 and b = 2 and c &gt; 3 and d = 4，其中 d 是用不到索引的，因为 c 是一个范围查询，它之后的字段会停止匹配。</p><p><strong>最左匹配的原理</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNzUyOTcxLzIwMTkxMC83NTI5NzEtMjAxOTEwMTcyMTEzMDc3NzctMTA0NzgzNTQ1OS5wbmc" alt="img"></p><p>上图可以看出 a 是有顺序的（1、1、2、2、3、3），而 b 的值是没有顺序的（1、2、1、4、1、2）。所以 b = 2 这种查询条件无法利用索引。</p><p>同时我们还可以发现在 a 值相等的情况下（a = 1），b 又是顺序排列的，所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。</p><p> <em>ref 最左匹配原则</em> </p><h3 id="9、什么是覆盖索引？"><a href="#9、什么是覆盖索引？" class="headerlink" title="9、什么是覆盖索引？"></a>9、什么是覆盖索引？</h3><p>在 B+ 树的索引中，叶子节点可能存储了当前的键值，也可能存储了当前的键值以及整行的数据，这就是聚簇索引和非聚簇索引。 在 InnoDB 中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p><p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><h3 id="10、什么是索引下推？"><a href="#10、什么是索引下推？" class="headerlink" title="10、什么是索引下推？"></a>10、什么是索引下推？</h3><p><strong>索引下推（Index condition pushdown）</strong> 简称 ICP，在 Mysql 5.6 版本上推出的一项用于优化查询的技术。</p><p>在不使用索引下推的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器判断数据是否符合条件。</p><p>而有了索引下推之后，如果存在某些被索引列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</p><p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</strong></p><p> <em>ref Mysql性能优化：什么是索引下推？</em> </p><h2 id="3-1-存储引擎"><a href="#3-1-存储引擎" class="headerlink" title="3.1 存储引擎"></a>3.1 存储引擎</h2><h3 id="1、有哪些常见的存储引擎？"><a href="#1、有哪些常见的存储引擎？" class="headerlink" title="1、有哪些常见的存储引擎？"></a>1、有哪些常见的存储引擎？</h3><p> <em>ref 几种MySQL数据库引擎优缺点对比</em> </p><h3 id="2、MyISAM-和-InnoDB-的区别？"><a href="#2、MyISAM-和-InnoDB-的区别？" class="headerlink" title="2、MyISAM 和 InnoDB 的区别？"></a>2、MyISAM 和 InnoDB 的区别？</h3><p>1）InnoDB 支持事务，而 MyISAM 不支持。</p><p>2）InnoDB 支持外键，而 MyISAM 不支持。因此将一个含有外键的 InnoDB 表 转为 MyISAM 表会失败。</p><p>3）InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但 InnoDB 是聚集索引，而 MyISAM 是非聚集索引。</p><p>4）InnoDB 不保存表中数据行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）。</p><p><strong>那为什么 InnoDB 没有使用这样的变量呢</strong>？因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的。</p><p>5）InnoDB 支持表、行（默认）级锁，而 MyISAM 支持表级锁。</p><p>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。</p><p>6）InnoDB 必须有唯一索引（如主键），如果没有指定，就会自动寻找或生产一个隐藏列 Row_id 来充当默认主键，而 Myisam 可以没有主键。</p><p> <em>ref MyISAM与InnoDB 的区别（9个不同点）</em> </p><h3 id="3、InnoDB-的四大特性"><a href="#3、InnoDB-的四大特性" class="headerlink" title="3、InnoDB 的四大特性?"></a>3、InnoDB 的四大特性?</h3><ul><li>插入缓冲insert buffer) </li><li>二次写(double write) </li><li>自适应哈希索引(ahi) </li><li>预读(read ahead)</li></ul><h3 id="4、InnoDB-为何推荐使用自增主键？"><a href="#4、InnoDB-为何推荐使用自增主键？" class="headerlink" title="4、InnoDB 为何推荐使用自增主键？"></a>4、InnoDB 为何推荐使用自增主键？</h3><p>自增 ID 可以保证每次插入时 B+ 树索引是从右边扩展的，因此相比自定义 ID （如 UUID）可以避免 B+ 树的频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><h3 id="5、如何选择存储引擎？"><a href="#5、如何选择存储引擎？" class="headerlink" title="5、如何选择存储引擎？"></a>5、如何选择存储引擎？</h3><p>默认使用 InnoDB，MyISAM 适用以插入为主的程序，比如博客系统、新闻门户。</p><h2 id="3-2-存储结构"><a href="#3-2-存储结构" class="headerlink" title="3.2 存储结构"></a>3.2 存储结构</h2><h3 id="1、什么是-InnoDB-的页、区、段？"><a href="#1、什么是-InnoDB-的页、区、段？" class="headerlink" title="1、什么是 InnoDB 的页、区、段？"></a>1、什么是 InnoDB 的页、区、段？</h3><ul><li><strong>页（Page）</strong></li></ul><p>首先，InnoDB 将物理磁盘划分为<strong>页（page）</strong>，每页的大小默认为 16 KB，<strong>页是最小的存储单位</strong>。页根据上层应用的需要，如索引、日志等，分为很多的格式。我们主要说<strong>数据页</strong>，也就是存储实际数据的页。</p><ul><li><strong>区（Extent）</strong></li></ul><p>如果只有页这一个层次的话，页的个数是非常多的，存储空间的分配和回收都会很麻烦，因为要维护这么多的页的状态是非常麻烦的。</p><p>所以，InnoDB 又引入了<strong>区（Extent)</strong> 的概念。一个区默认是 64 个连续的页组成的，也就是 1MB。通过 Extent 对存储空间的分配和回收就比较容易了。</p><ul><li><strong>段（Segment）</strong></li></ul><p>为什么要引入段呢，这要从索引说起。我们都知道索引的目的是为了加快查找速度，是一种典型的用空间换时间的方法。</p><p>B+ 树的叶子节点存放的是我们的具体数据，非叶子结点是索引页。所以 B+ 树将数据分为了两部分，叶子节点部分和非叶子节点部分，也就我们要介绍的段 Segment，也就是说 InnoBD 中每一个索引都会创建两个 Segment 来存放对应的两部分数据。</p><p>Segment 是一种逻辑上的组织，其层次结构从上到下一次为 Segment、Extent、Page。</p><h3 id="2、页由哪些数据组成？"><a href="#2、页由哪些数据组成？" class="headerlink" title="2、页由哪些数据组成？"></a>2、页由哪些数据组成？</h3><p>首先看数据页的基本格式，如下图： <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/02b9ce6996a4948be0ff22ab1000b8e8.png" alt="img"></p><ul><li><strong>File Header</strong></li></ul><p>用于描述数据页的外部信息，比如属于哪一个表空间、前后页的页号等。</p><ul><li><strong>Page Header</strong></li></ul><p>用来描述数据页中的具体信息，比如存在多少条纪录，第一条纪录的位置等。</p><ul><li><strong>infimum 和 supremum 纪录</strong></li></ul><p>infimum 和 supremum 是系统生成的纪录，分别为最小和最大纪录值，infimum 的下一条是用户纪录中键值最小的纪录，supremum 的上一条是用户纪录中键值最大的纪录，通过 next_record 字段来相连。</p><ul><li><strong>User Records</strong></li></ul><p>用户纪录，也就是数据库表中对应的数据，这里我们说常用的 Compact 格式。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/026d07b681d6f178e3f23b944b855541.png" alt="img"></p><p>InnoDB 除了我们插入的数据外，还有一些隐藏列，transaction_id（事务ID）、roll_pointer（回滚指针）是一定添加的。</p><p>row_id 则不一定，根据以下策略生成：优先使用用户建表时指定的主键，若用户没有指定主键，则使用unique键。若unique键都没有，则系统自动生成row_id，为隐藏列。</p><ul><li><strong>Free Space</strong></li></ul><p>页中目前空闲的存储，可以插入纪录。</p><ul><li><strong>Page Dictionary</strong></li></ul><p>类似于字典的目录结构，根据主键大小，每隔 4-8 个纪录设置一个槽，用来纪录其位置，当根据主键查找数据时，首先一步到位找到数据所在的槽，然后在槽中线性搜素。这种方法比从前到后遍历页的链表的效率更快。</p><ul><li><strong>Page Tailer</strong></li></ul><p>File Header存储刷盘前内存的校验和，Page Tailer储存刷盘后的校验和。当刷盘的时候，出现异常，Page Tailer和File Header中的校验和不一致，则说明出现刷盘错误。</p><h3 id="3、页中插入记录的过程？"><a href="#3、页中插入记录的过程？" class="headerlink" title="3、页中插入记录的过程？"></a>3、页中插入记录的过程？</h3><p>1）如果 Free Space 的空间足够的话，直接分配空间来添加纪录，并将插入前最后一条纪录的 next_record 指向当前插入的纪录，将当前插入纪录的 next_record 指向 supremum 纪录。</p><p>2）如果 Free Space的 空间不够的话，则首先将之前删除造成的碎片重新整理之后，按照上述步骤插入纪录。</p><p>3）如果当前页空间整理碎片之后仍然不足的话，则重新申请一个页，将页初始化之后，按照上述步骤插入纪录</p><p> <em>ref MySQL之InnoDB物理存储结构</em> </p><h3 id="4、什么是-Buffer-Pool？"><a href="#4、什么是-Buffer-Pool？" class="headerlink" title="4、什么是 Buffer Pool？"></a>4、什么是 Buffer Pool？</h3><p>Buffer Pool 是 InnoDB 存储引擎层的缓冲池，不属于 MySQL 的 Server 层，注意跟 8.0 删掉的“查询缓存”功能区分。</p><p>内存中以页（page）为单位缓存磁盘数据，减少磁盘IO，提升访问速度。缓冲池大小默认 128M，独立的 MySQL 服务器推荐设置缓冲池大小为总内存的 80%。主要存储数据页、索引页更新缓冲（change buffer）等。</p><ul><li><strong>预读机制</strong></li></ul><p>Buffer Pool 有一项特技叫<strong>预读</strong>，存储引擎的接口在被 Server 层调用时，会在响应的同时进行预判，将下次可能用到的数据和索引加载到 Buffer Pool。</p><p>预读策略有两种，为线性预读（linear read-ahead）和随机预读（random read-ahead），其中 InnoDB 默认使用线性预读，随机预读已经基本废弃。</p><p>线性预读认为如果前面的请求顺序访问当前区（extent）的页，那么接下来的若干请求也会顺序访问下一个区的页，并将下一个区加载到 Buffer Pool。在 5.4 版本以后默认开启，默认值为 56，最大不能超过 64，表示顺序访问 N 个页后触发预读（一个页16K，一个区1M，一个区最多64个页，所以最大值64）。</p><ul><li><strong>换页算法</strong></li></ul><p>与传统的 LRU 算法不同，因为面临两个问题：</p><p>1）<strong>预读失效</strong>：由于提前把页放入了缓冲池，但最终 MySQL 并没有从页中读取数据。</p><p>要优化预读失效，则让预读失败的页停留在缓冲池里的时间尽可能短，预读成功的页停留时间尽可能长。具体将 LRU 链分代实现，即新生代和老年代（old subList），预读的页加入缓冲池时只加入到老年代头部，只有真正被预读成功，则再加入新生代。</p><p>2）<strong>缓冲池污染</strong>：当批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL 性能急剧下降。</p><p>InnoDB 缓冲池加入了一个<strong>老生代停留时间窗口</strong>的机制，只有满足预读成功并且在老生代停留时间大于该窗口才会被放入新生代头部。</p><p><a href="https://blog.csdn.net/wuhenyouyuyouyu/article/details/93377605">https://blog.csdn.net/wuhenyouyuyouyu/article/details/93377605</a></p><h3 id="5、什么是-Change-Buffer？"><a href="#5、什么是-Change-Buffer？" class="headerlink" title="5、什么是 Change Buffer？"></a>5、什么是 Change Buffer？</h3><p>如果每次写操作，数据库都直接更新磁盘中的数据，会很占磁盘IO。为了减少磁盘IO，InnoDB在Buffer Pool中开辟了一块内存，用来存储变更记录，为了防止异常宕机丢失缓存，当事务提交时会将变更记录持久化到磁盘（redo log），等待时机更新磁盘的数据文件（刷脏），用来缓存写操作的内存，就是Change Buffer</p><p>Change Buffer默认占Buffer Pool的25%，最大设置占用50%。</p><p><a href="https://www.modb.pro/db/112469">https://www.modb.pro/db/112469</a></p><h2 id="3-3-InnoDB"><a href="#3-3-InnoDB" class="headerlink" title="3.3 InnoDB"></a>3.3 InnoDB</h2><h3 id="1、InnoDB-架构设计？"><a href="#1、InnoDB-架构设计？" class="headerlink" title="1、InnoDB 架构设计？"></a>1、InnoDB 架构设计？</h3><p>以下主要从内存和线程的角度分析 InnoDB 的架构。 <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221127141110456.png" alt="image-20221127141110456"></p><p>内存中的数据区域划分： <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221127141139040.png" alt="image-20221127141139040"></p><p> <em>ref深入理解InnoDB – 架构篇</em> </p><h3 id="2、InnoDB-有哪些线程？"><a href="#2、InnoDB-有哪些线程？" class="headerlink" title="2、InnoDB 有哪些线程？"></a>2、InnoDB 有哪些线程？</h3><p><strong>线程的作用</strong>：</p><p>1）负责刷新内存池中的数据，保证缓冲池的内存缓冲的是最近的数据</p><p>2）已修改的数据文件刷新到磁盘文件</p><p>3）保证数据库发生异常的情况下InnoDB能恢复到正常状态。</p><p><strong>线程分类</strong>：</p><p>1）Master Thread</p><p>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等。</p><p>2）IO Thread</p><p>负责 AIO 请求的回调处理。</p><p>3）Purge Thread</p><p>事务提交后，undo log 可能不再需要，由 Purge Thread 负责回收并重新分配的这些已经使用的 undo 页。</p><p>4）Page Cleaner Thread</p><p>将Master Threader中刷新脏页的工作移至该线程，如上面说的FLUSH LRU LIST Checkpoint以及Async/Sync Flush Checkpoint。</p><h3 id="3、什么是-doublewrite？"><a href="#3、什么是-doublewrite？" class="headerlink" title="3、什么是 doublewrite？"></a>3、什么是 doublewrite？</h3><h3 id="4、什么是自适应哈希？"><a href="#4、什么是自适应哈希？" class="headerlink" title="4、什么是自适应哈希？"></a>4、什么是自适应哈希？</h3><p>InnoDB 会监控对表上各索引页的查询执行情况，如发现建立哈希索引可以提升速度，则建立哈希索引，这是过程不需要用户干预。（默认开启）</p><h3 id="1、什么是数据库的事务？"><a href="#1、什么是数据库的事务？" class="headerlink" title="1、什么是数据库的事务？"></a>1、什么是数据库的事务？</h3><p>数据库的<strong>事务</strong>是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务的典型应用场景，如转账。</p><h3 id="2、什么是事务的四大特性（ACID）？"><a href="#2、什么是事务的四大特性（ACID）？" class="headerlink" title="2、什么是事务的四大特性（ACID）？"></a>2、什么是事务的四大特性（ACID）？</h3><ul><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用 </li><li><strong>一致性：</strong> 事务执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的 </li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的 </li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h3 id="4、事务的并发问题？"><a href="#4、事务的并发问题？" class="headerlink" title="4、事务的并发问题？"></a>4、事务的并发问题？</h3><p>脏读、幻读和不可重复读。</p><p> <em>ref 并发事务带来的问题</em> </p><h3 id="5、什么是脏读、幻读和不可重复度？"><a href="#5、什么是脏读、幻读和不可重复度？" class="headerlink" title="5、什么是脏读、幻读和不可重复度？"></a>5、什么是脏读、幻读和不可重复度？</h3><ul><li>脏读：一个事务读取到另一个事务尚未提交的数据。 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。  </li><li>不可重复读：一个事务中两次读取的数据的内容不一致。 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。  </li><li>幻读：一个事务中两次读取的数据量不一致。 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 </li></ul><p><strong>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。</strong> 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><p> <em>ref MySQL的四种事务隔离级别</em> </p><h3 id="6、事务的隔离级别有哪些？"><a href="#6、事务的隔离级别有哪些？" class="headerlink" title="6、事务的隔离级别有哪些？"></a>6、事务的隔离级别有哪些？</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/2019052019551758.png" alt="img"></p><p>串行化的隔离级别最高，读未提交的级别最低，级别越高，则执行效率就越低，所以在选择隔离级别时应该结合实际情况。</p><p>MySQL 支持以上四种隔离级别，默认为 Repeatable read (可重复读)；而 Oracle 只支持 Serializeble(串行化) 级别和 Read committed(读已提交) 两种，其中默认为读已提交。</p><p> <em>ref 事务的隔离级别</em> </p><h3 id="7、ACID-特性是如何实现的？"><a href="#7、ACID-特性是如何实现的？" class="headerlink" title="7、ACID 特性是如何实现的？"></a>7、ACID 特性是如何实现的？</h3><p>分四个维度去理解，如原子性是 undo 日志，持久性是 redo 日志。（PS 日志具体原理在后续章节讲述。）</p><p> <em>ref ACID特性的实现原理</em> </p><h3 id="1、数据库锁的作用以及有哪些锁？"><a href="#1、数据库锁的作用以及有哪些锁？" class="headerlink" title="1、数据库锁的作用以及有哪些锁？"></a>1、数据库锁的作用以及有哪些锁？</h3><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。即锁的作用是解决并发问题。</p><p><strong>从锁的粒度划分</strong>，可以将锁分为表锁、行锁以及页锁。</p><ul><li><strong>行级锁</strong>：是锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。</li></ul><p>行级锁开销大，加锁慢，且会出现死锁。但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><ul><li>表级锁：是粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。  </li><li>页级锁：是粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。 </li></ul><p>开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p><p><strong>从使用性质划分</strong>，可以分为共享锁、排它锁以及更新锁。</p><ul><li><strong>共享锁（Share Lock）</strong>：S 锁，又称<strong>读锁</strong>，用于所有的只读数据操作。</li></ul><p>S 锁并非独占，允许多个并发事务对同一资源加锁，但加 S 锁的同时不允许加 X 锁，即资源不能被修改。S 锁通常读取结束后立即释放，无需等待事务结束。</p><ul><li><strong>排他锁（Exclusive Lock）</strong>：X 锁，又称<strong>写锁</strong>，表示对数据进行写操作。</li></ul><p>X 锁仅允许一个事务对同一资源加锁，且直到事务结束才释放，其他任何事务必须等到 X 锁被释放才能对该页进行访问。</p><p>使用 select * from table_name for update; 语句产生 X 锁。</p><ul><li><strong>更新锁</strong>：U 锁，用来预定要对资源施加 X 锁，允许其他事务读，但不允许再施加 U 锁或 X 锁。</li></ul><p>当被读取的页将要被更新时，则升级为 X 锁，U 锁一直到事务结束时才能被释放。故 U 锁用来避免使用共享锁造成的<strong>死锁</strong>现象。</p><p> <em>ref 数据库锁分类和总结</em> </p><p><strong>从主观上划分</strong>，又可以分为乐观锁和悲观锁。</p><ul><li><strong>乐观锁（Optimistic Lock）</strong>：顾名思义，从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改。</li></ul><p>乐观锁适用于多读的应用类型，可以系统提高吞吐量。</p><ul><li><strong>悲观锁（Pessimistic Lock）</strong>：正如其名，具有强烈的独占和排它特性，每次读取数据时都会认为会被其它事务修改，所以每次操作都需要加上锁。</li></ul><h3 id="2、隔离级别和锁的关系？"><a href="#2、隔离级别和锁的关系？" class="headerlink" title="2、隔离级别和锁的关系？"></a>2、隔离级别和锁的关系？</h3><p>1）在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；</p><p>2）在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>3）在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</p><p>4）在 SERIALIZABLE 级别下，限制性最强，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p><h3 id="3、InnoDB-中的锁算法？"><a href="#3、InnoDB-中的锁算法？" class="headerlink" title="3、InnoDB 中的锁算法？"></a>3、InnoDB 中的锁算法？</h3><ul><li><strong>Record lock</strong>：单个行记录上的锁 </li><li><strong>Gap lock</strong>：间隙锁，锁定一个范围，不包括记录本身 </li><li><p><strong>Next-key lock</strong>：record + gap 锁定一个范围，包含记录本身</p><p><em>ref 锁机制与InnoDB锁算法</em> </p></li></ul><h3 id="4、什么是快照读和当前读？"><a href="#4、什么是快照读和当前读？" class="headerlink" title="4、什么是快照读和当前读？"></a>4、什么是快照读和当前读？</h3><p><strong>快照读</strong>就是读取的是快照数据，不加锁的简单 Select 都属于快照读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player WHERE ...</span><br></pre></td></tr></table></figure><p><strong>当前读</strong>就是读的是最新数据，而不是历史的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM player LOCK IN SHARE MODE;</span><br><span class="line">SELECT FROM player FOR UPDATE;</span><br><span class="line">INSERT INTO player values ...</span><br><span class="line">DELETE FROM player WHERE ...</span><br><span class="line">UPDATE player SET ...</span><br></pre></td></tr></table></figure><h3 id="5、什么是-MVCC-以及实现？"><a href="#5、什么是-MVCC-以及实现？" class="headerlink" title="5、什么是 MVCC 以及实现？"></a>5、什么是 MVCC 以及实现？</h3><p>MVCC 的英文全称是 Multiversion Concurrency Control，中文意思是<strong>多版本并发控制</strong>，可以做到读写互相不阻塞，主要用于解决不可重复读和幻读问题时提高并发效率。</p><p>其原理是通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p><p> <em>ref MVCC 原理</em>   <em>ref MVCC详解</em> </p><h2 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h2><h2 id="6-2-存储过程"><a href="#6-2-存储过程" class="headerlink" title="6.2 存储过程"></a>6.2 存储过程</h2><h3 id="1、什么是存储过程？"><a href="#1、什么是存储过程？" class="headerlink" title="1、什么是存储过程？"></a>1、什么是存储过程？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><h3 id="2、存储过程和函数的区别？"><a href="#2、存储过程和函数的区别？" class="headerlink" title="2、存储过程和函数的区别？"></a>2、存储过程和函数的区别？</h3><p>1）<strong>返回值的区别</strong>：函数有1个返回值，而存储过程是通过参数返回的，可以有多个或者没有。</p><p>2）<strong>调用的区别</strong>：，函数可以在查询语句中直接调用，而存储过程必须单独调用。</p><p> <em>ref 存储过程（procedure）和函数（Function）的区别</em> </p><h2 id="6-3-触发器"><a href="#6-3-触发器" class="headerlink" title="6.3 触发器"></a>6.3 触发器</h2><h2 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h2><h3 id="1、MySQL-中有哪些常见日志？"><a href="#1、MySQL-中有哪些常见日志？" class="headerlink" title="1、MySQL 中有哪些常见日志？"></a>1、MySQL 中有哪些常见日志？</h3><ul><li><strong>重做日志（redo log）</strong>：物理日志</li></ul><p><strong>作用是确保事务的持久性。</strong> redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已提交事务数据。</p><ul><li><strong>回滚日志（undo log）</strong>：逻辑日志</li></ul><p><strong>作用是保证数据的原子性。</strong> 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p><ul><li><strong>二进制日志（binlog）</strong>：逻辑日志</li></ul><p>常用于主从同步或数据同步中，也可用于数据库基于时间点的还原。</p><ul><li><strong>错误日志（errorlog）</strong></li></ul><p>记录着 MySQL 启动和停止，以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</p><ul><li><strong>普通查询日志（general query log）</strong></li></ul><p>记录了服务器接收到的每一个命令，无论命令语句是否正确，因此会带来不小开销，所以也是默认关闭的。</p><ul><li><strong>慢查询日志（slow query log）</strong></li></ul><p>记录执行时间过长和没有使用索引的查询语句（<strong>默认 10s</strong>），同时只会记录执行成功的语句。</p><ul><li><strong>中继日志（relay log）</strong></li></ul><p>在从节点中存储接收到的 binlog 日志内容，用于主从同步。</p><p> <em>ref MySQL中的几种日志了解</em> </p><h2 id="7-2-主从复制"><a href="#7-2-主从复制" class="headerlink" title="7.2 主从复制"></a>7.2 主从复制</h2><h3 id="1、什么是主从复制？"><a href="#1、什么是主从复制？" class="headerlink" title="1、什么是主从复制？"></a>1、什么是主从复制？</h3><p><strong>主从复制</strong>是用来建立一个与主数据库完全一样的数据库环境，即从数据库。主数据库一般是准实时的业务数据库。</p><h3 id="2、主从复制的作用？"><a href="#2、主从复制的作用？" class="headerlink" title="2、主从复制的作用？"></a>2、主从复制的作用？</h3><ul><li>读写分离，使数据库能支撑更大的并发。 </li><li>高可用，做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</li></ul><h3 id="3、主从复制的架构？"><a href="#3、主从复制的架构？" class="headerlink" title="3、主从复制的架构？"></a>3、主从复制的架构？</h3><ul><li><strong>一主一从或一主多从</strong></li></ul><p>在主库的请求压力非常大时，可通过配置一主多从复制架构实现读写分离，把大量对实时性要求不是很高的请求通过负载均衡分发到多个从库上去读取数据，降低主库的读取压力。而且在主库出现宕机时，可将一个从库切换为主库继续提供服务。</p><ul><li><strong>主主复制</strong></li></ul><p><strong>双主复制架构适用于需要进行主从切换的场景。</strong> 两个数据库互为主从，当主库宕机恢复后，由于它还是原来从库（现在主库）的从机，所以它还是会复制新的主库上的数据。那么无论主库的角色怎么切换，原来的主库都不会脱离复制环境。</p><ul><li><strong>多主一从</strong>（5.7 开始支持） </li><li><strong>联级复制</strong></li></ul><p>因为每个从库在主库上都会有一个独立的 Binlog Dump 线程来推送 binlog 日志，所以随着从库数量的增加，主库的 IO 压力和网络压力也会随之增加，这时，联级复制架构应运而生。</p><p>联级复制架构只是在一主多从的基础上，再主库和各个从库之间增加了一个二级主库 Master2，这个二级主库仅仅用来将一级主库推送给它的 Binlog 日志再推送给各个从库，以此来减轻一级主库的推送压力。</p><p> <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221127141157851.png" alt="image-20221127141157851"></p><h3 id="4、主从复制的实现原理？"><a href="#4、主从复制的实现原理？" class="headerlink" title="4、主从复制的实现原理？"></a>4、主从复制的实现原理？</h3><p>数据库有个 binlog 二进制文件，记录了数据可执行的所有 SQL 语句。主从同步的目标就是把主数据库的 binlog 文件中的 SQL 语句复制到从数据库，让其在从数据的 relaylog 文件中再执行一次这些 SQL 语句即可。</p><p><strong>具体实现需要三个线程：</strong></p><ul><li><strong>binlog 输出线程</strong>：每当有从库连接到主库的时候，主库都会创建一个线程然后发送 binlog内 容到从库。</li></ul><p>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p><ul><li>从库 IO 线程：当 START SLAVE 语句在从库开始执行之后，从库创建一个 IO 线程，该线程连接到主库并请求主库发送 binlog 里面的更新记录到从库上。从库 IO 线程读取主库的 binlog 输出线程发送的更新并拷贝这些更新到本地文件，其中包括 relaylog 文件。  </li><li>从库 SQL 线程：从库创建一个 SQL 线程，这个线程读取从库 IO 线程写到 relaylog 的更新事件并执行。 </li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221127141211573.png" alt="image-20221127141211573"></p><p> <em>ref MySQL主从复制面试之和原理</em> </p><h3 id="5、什么是异步复制和半同步？"><a href="#5、什么是异步复制和半同步？" class="headerlink" title="5、什么是异步复制和半同步？"></a>5、什么是异步复制和半同步？</h3><p>MySQL 的主从复制有两种复制方式，分别是<strong>异步复制</strong>和<strong>半同步复制</strong>：</p><ul><li><strong>异步复制</strong></li></ul><p>MySQL 默认的主从复制方式就是<strong>异步复制</strong>，因为 Master 根本不考虑数据是否达到了 Slave，或 Slave 是否成功执行。</p><p>如过需要实现<strong>完全同步</strong>方式，即 Master 需要等待一个或所有 Slave 执行成功后才响应成功，那集群效率可想而知。故 MySQL 5.6 之后出现了一种折中的方式——<strong>半同步</strong>。</p><ul><li><strong>半同步复制</strong></li></ul><p>一主一从，一主多从情况下，Master 节点只要确认至少有一个 Slave 接受到了事务，即可向发起请求的客户端返回执行成功的操作。同时 Master 是不需要等待 Slave 成功执行完这个事务，<strong>Slave 节点接受到这个事务，并成功写入到本地 relay 日志中就算成功</strong>。</p><p>另外，在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），如果这个时间过后还无法推送到从库，<strong>那 MySQL 会自动从半同步复制切换为异步复制，当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。</strong></p><p>半同步复制的“半”体现在，虽然主从库的Binlog是同步的，但主库不会等待从库执行完Relay-log后才返回，而是确认从库接收到Binlog，达到主从Binlog同步的目的后就返回了，所以从库的数据对于主库来说还是有延时的，这个延时就是从库执行Relay-log的时间。所以只能称为半同步。</p><p> <em>refMySQL主从复制（异步复制与半同步复制）</em> </p><h3 id="6、主从中常见问题以及解决？"><a href="#6、主从中常见问题以及解决？" class="headerlink" title="6、主从中常见问题以及解决？"></a>6、主从中常见问题以及解决？</h3><p><strong>问题</strong> 1）主库宕机后，数据可能丢失。</p><p>2）从库只有一个sql Thread，主库写压力大，复制很可能延时。</p><p><strong>解决</strong> 1）<strong>半同步复制</strong>：确保事务提交后 binlog 至少传输到一个从库 ，解决数据丢失的问题。</p><p>2）<strong>并行复制</strong>：从库多线程apply binlog，解决从库复制延迟的问题。</p><h2 id="8-1-语法"><a href="#8-1-语法" class="headerlink" title="8.1 语法"></a>8.1 语法</h2><p>SQL 是一门 ANSI 标准计算机语言，用来访问和操作数据库系统。通常 SQL 语句可以分为两类：</p><ul><li><strong>数据操作语言（DML）</strong>：SELECT、DELETE、INSERT INTO、UPDATE </li><li><strong>数据定义语言（DDL）</strong>：CREATE、DROP、ALTER</li></ul><p>实践中，还有一种</p><ul><li><strong>数据控制语言（Data Control Language）</strong>：GRANT，REVOKE，COMMIT，ROLLBACK</li></ul><h3 id="1、常见的聚合查询？"><a href="#1、常见的聚合查询？" class="headerlink" title="1、常见的聚合查询？"></a>1、常见的聚合查询？</h3><p>使用聚合函数的查询就是聚合查询。所有的聚合函数（UDAF）都应该支持分组查询，内置的聚合函数有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum(列名) 求和  　　　　</span><br><span class="line">max(列名) 最大值 　　　　</span><br><span class="line">min(列名) 最小值 　　　　</span><br><span class="line">avg(列名) 平均值 　　　　</span><br><span class="line">first(列名)   第一条记录   </span><br><span class="line">last(列名)    最后一条记录  </span><br><span class="line">count(列名)   统计记录数   注意和count(*)的区别</span><br></pre></td></tr></table></figure><p> <em>ref SQL 聚合查询</em> </p><h3 id="2、几种关联查询？"><a href="#2、几种关联查询？" class="headerlink" title="2、几种关联查询？"></a>2、几种关联查询？</h3><p>1） <strong>内连接（自然连接）</strong>：只返回匹配的行，如 Inner Join、Union Join。</p><p>2）<strong>外连接</strong>：返回一个表的全集，如 Left、Right、Full 和 Cross。</p><p> <em>ref SQL多表查询</em> </p><h3 id="3、Where-和-Having-的区别？"><a href="#3、Where-和-Having-的区别？" class="headerlink" title="3、Where 和 Having 的区别？"></a>3、Where 和 Having 的区别？</h3><p>where 子句的作用是在对查询结果进行分组前，将不符合条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。</p><p>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。</p><p>总结一下条件的过滤顺序：on-&gt;join-&gt;where-&gt;group by-&gt;having。</p><h3 id="4、SQL-关键字的执行顺序？"><a href="#4、SQL-关键字的执行顺序？" class="headerlink" title="4、SQL 关键字的执行顺序？"></a>4、SQL 关键字的执行顺序？</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221127141223470.png" alt="image-20221127141223470"></p><p> <em>ref SQL的执行顺序</em> </p><h3 id="5、In-和-Exists-的区别？"><a href="#5、In-和-Exists-的区别？" class="headerlink" title="5、In 和 Exists 的区别？"></a>5、In 和 Exists 的区别？</h3><p>in 适合内表比外表数据小的情况，exists 适合内表比外表数据大的情况。如果查询的内外表大小相当，则二者效率差别不大。</p><p> <em>ref SQL语句中exists和in的区别</em> </p><h3 id="6、Union-和-Union-All-的区别？"><a href="#6、Union-和-Union-All-的区别？" class="headerlink" title="6、Union 和 Union All 的区别？"></a>6、Union 和 Union All 的区别？</h3><ul><li>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序  </li><li>Union All：对两个结果集进行并集操作，包括重复行，不进行排序 </li></ul><p>Union 因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All。</p><p> <em>ref union和union all的区别</em> </p><h3 id="7、Drop、Delete-和-Truncate-的区别？"><a href="#7、Drop、Delete-和-Truncate-的区别？" class="headerlink" title="7、Drop、Delete 和 Truncate 的区别？"></a>7、Drop、Delete 和 Truncate 的区别？</h3><p>虽然通过 delete、truncate、drop 这三个关键字都可以用来删除数据，但场景不同。</p><p>从执行速度上讲：drop &gt; truncate &gt;&gt; DELETE。</p><p> <em>ref delete、truncate、drop的区别有哪些，该如何选择</em> </p><h2 id="8-2-优化"><a href="#8-2-优化" class="headerlink" title="8.2 优化"></a>8.2 优化</h2><h3 id="1、一条-SQL-是如何执行的？"><a href="#1、一条-SQL-是如何执行的？" class="headerlink" title="1、一条 SQL 是如何执行的？"></a>1、一条 SQL 是如何执行的？</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221127141231928.png" alt="image-20221127141231928"></p><p> <em>ref sql执行过程</em> </p><h3 id="2、如何判断-SQL-是否走了索引？"><a href="#2、如何判断-SQL-是否走了索引？" class="headerlink" title="2、如何判断 SQL 是否走了索引？"></a>2、如何判断 SQL 是否走了索引？</h3><p>EXPLAIN 命令是查看查询优化器如何决定执行查询的主要方法，使用 EXPLAIN 只需在查询语句开头增加 EXPLAIN 这个关键字即。</p><p><img src="https://img-blog.csdn.net/20180521161430126" alt="img"></p><p><strong>其结果中的几个重要参数：</strong></p><ul><li><strong>id</strong></li></ul><p>ID 代表执行 select 子句或操作表的顺序，如果包含子查询，则会出现多个 ID。值越大，优先级越高，越先被执行。值相同的按照由上至下的顺序执行。</p><ul><li><strong>select_type（查询类型）</strong></li></ul><p>查询类型主要用于区别普通查询、联合查询以及子查询等复杂查询。</p><ul><li>table  </li><li>type </li></ul><p>查询扫描情况，最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All，一般情况下至少保证达到 range 级别，最好能达到 ref。</p><ul><li><strong>possible_keys</strong></li></ul><p>显示可能应用在这张表中的索引，一个或多个。查询到的索引不一定是真正被使用。</p><ul><li><strong>key</strong></li></ul><p>实际使用的索引，如果为 null 则表示没有使用索引。因此会出现 possible_keys 列有可能被用到的索引，但是 key 列为 null。</p><ul><li><strong>key_len</strong></li></ul><p>表示索引中使用的字节数，在不损失精确性的情况下长度越短越好。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度。即 key_len 是根据表定义计算而来。</p><ul><li><strong>ref</strong></li></ul><p>显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值。</p><ul><li><strong>rows</strong></li></ul><p>根据表统计信息及索引选用情况，估算出找到所需的记录所需要读取的行数。</p><ul><li><p><strong>Extra</strong></p><p><em>ref EXPLAIN的参数解析及简单应用</em> </p></li></ul><h3 id="3、索引失效的几种情况？"><a href="#3、索引失效的几种情况？" class="headerlink" title="3、索引失效的几种情况？"></a>3、索引失效的几种情况？</h3><p>1）like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效；</p><p>2）or 语句前后没有同时使用索引。当 or 左右查询字段只有一个是索引，该索引失效，只有左右查询字段均为索引时，才会生效；</p><p>3）联合索引不使用第一列，索引失效；</p><p>4）数据类型出现隐式转化。如 varchar 不加单引号的话可能会自动转换为 int 型，使索引无效，产生全表扫描；</p><p>5）在索引列上使用 IS NULL 或 IS NOT NULL操作。最好给列设置默认值。</p><p>6）在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p><p>7）对索引字段进行计算操作、字段上使用函数。</p><p>8）当 MySQL 觉得全表扫描更快时（数据少）;</p><p> <em>ref Mysql索引查询失效的情况</em> </p><h3 id="4、Where-子句如何优化？"><a href="#4、Where-子句如何优化？" class="headerlink" title="4、Where 子句如何优化？"></a>4、Where 子句如何优化？</h3><h3 id="5、超大分页或深度分页如何处理？"><a href="#5、超大分页或深度分页如何处理？" class="headerlink" title="5、超大分页或深度分页如何处理？"></a>5、超大分页或深度分页如何处理？</h3><p>说道 MySQL 的分页，我们首先想到的就是 offset、limit 操作，但随着页数的增加，查询性能指数级增大。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/32bd3df9d76a53784496e494172508a2.png" alt="img"></p><p>这是由于 MySQL 并不是跳过 offset 的行数，而是取 offset + limit 行，然后丢弃前 offset 行，返回 limit 行，当offset特别大的时候，效率就非常的低下。</p><p>此处我们就可以采用<strong>覆盖索引</strong>+<strong>延迟关联</strong>技术来减少偏移量的定位进行优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##查询语句</span><br><span class="line">select id from product limit <span class="number">10000000</span>, <span class="number">10</span></span><br><span class="line">##优化方式一</span><br><span class="line">SELECT * FROM product WHERE ID &gt; =(select id from product limit <span class="number">10000000</span>, <span class="number">1</span>) limit <span class="number">10</span></span><br><span class="line">##优化方式二</span><br><span class="line">SELECT * FROM product a <span class="title function_">JOIN</span> <span class="params">(select id from product limit <span class="number">10000000</span>, <span class="number">10</span>)</span> b ON a.ID = b.id</span><br></pre></td></tr></table></figure><p> <em>ref mysql优化：覆盖索引（延迟关联）</em> </p><h3 id="6、大表查询如何优化？"><a href="#6、大表查询如何优化？" class="headerlink" title="6、大表查询如何优化？"></a>6、大表查询如何优化？</h3><p>可以从<strong>分库分表、读写分离以及缓存</strong>三个维度分别阐述。</p><h2 id="8-3-实践"><a href="#8-3-实践" class="headerlink" title="8.3 实践"></a>8.3 实践</h2><h3 id="几种常见名次问题"><a href="#几种常见名次问题" class="headerlink" title="几种常见名次问题"></a>几种常见名次问题</h3><p> <em>ref MySQL排名函数实现</em> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1-基本概念&quot;&gt;&lt;a href=&quot;#1-1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本概念&quot;&gt;&lt;/a&gt;1.1 基本概念&lt;/h2&gt;&lt;h3 id=&quot;1、MySQL有哪些数据库类型？&quot;&gt;&lt;a href=&quot;#1、MySQL有哪些数据库</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022 11月7日 每日面试题</title>
    <link href="https://manamn.space/2022/11/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022%2011%E6%9C%887%E6%97%A5%20%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://manamn.space/2022/11/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022%2011%E6%9C%887%E6%97%A5%20%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-11-13T14:20:56.000Z</published>
    <updated>2022-12-13T13:44:07.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-11月7日-每日面试题"><a href="#2022-11月7日-每日面试题" class="headerlink" title="2022 11月7日 每日面试题"></a>2022 11月7日 每日面试题</h1><h1 id="1、谈谈你的职业规划"><a href="#1、谈谈你的职业规划" class="headerlink" title="1、谈谈你的职业规划"></a>1、谈谈你的职业规划</h1><blockquote><ol><li>一个固定技术的方向发展<ol><li>先找到一个安稳的工作</li><li>完成公司的工作任务</li><li>业务对技术深度研究</li><li>如果公司有这样的晋升的机会</li></ol></li></ol></blockquote><h1 id="2、SpringBoot的核心注解"><a href="#2、SpringBoot的核心注解" class="headerlink" title="2、SpringBoot的核心注解"></a>2、SpringBoot的核心注解</h1><blockquote></blockquote><h1 id="3、MySQL索引有哪几类-？"><a href="#3、MySQL索引有哪几类-？" class="headerlink" title="3、MySQL索引有哪几类 ？"></a>3、MySQL索引有哪几类 ？</h1><blockquote><p><strong>1、普通索引</strong></p><p>即不应用任何限制条件的索引，该索引可以在任何数据类型中创建。字段本身的约束条件可以判断其值是否为空或唯一。</p><p><strong>2、唯一索引</strong></p><p>使用UNIQUE参数可以设置唯一索引。创建该索引时，索引的值必须唯一。主键是一种特殊唯一索引。</p><p><strong>3、全文索引</strong></p><p>使用FULLTEXT参数可以设置全文索引。全文索引只能创建在CHAR、VARCHAR、TEXT类型的字段上。查询数据量较大的字符串类型字段时，使用全文索引可以提高查询速度。注意：全文索引在默认情况下是对大小写字母不敏感的，可以通过使用二进制对索引的列进行排序以执行大小写敏感的全文索引。MySQL中只有MyISAM存储引擎支持全文索引。</p><p><strong>4、单列索引</strong></p><p>顾名思义，单列索引值对应一个字段的索引。可以包括上述的三种索引方式。应用该索引的条件只需要保证该索引值对应一个字段即可。</p><p><strong>5、多列索引</strong></p><p>多列索引是在表的多个字段上创建一个索引。该索引只想创建时对应的多个字段，可以通过这几个字段进行查询。要想应用该索引，用户必须使用这些字段中的第一个字段。</p><p><strong>6、空间索引</strong></p><p>使用SPATIAL参数可以设置控件索引。控件索引只能建立在控件数据类型（LINESTRING、POINT、GEOMETRY等）上，这样可以提高系统获取控件数据的效率。MySQL中只有MyISAM存储引擎支持空间索引，且该字段不能为空值。</p></blockquote><h1 id="4、Java中有哪些容器-？"><a href="#4、Java中有哪些容器-？" class="headerlink" title="4、Java中有哪些容器 ？"></a>4、Java中有哪些容器 ？</h1><blockquote><ul><li>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</li><li>Collection</li><li>List</li><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li><li>Set</li><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li><li>Map</li><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></blockquote><h1 id="5、类中静态代码块、实例代码块、构造方法执行次序-？"><a href="#5、类中静态代码块、实例代码块、构造方法执行次序-？" class="headerlink" title="5、类中静态代码块、实例代码块、构造方法执行次序 ？"></a>5、类中静态代码块、实例代码块、构造方法执行次序 ？</h1><blockquote><p>1、父类静态代码块优先于子类静态代码块执行，而且是最早执行</p><p>2、父类实例方法和父类构造方法紧接着执行</p><p>3、子类的实例代码块和子类的构造方法紧接着再执行</p><p>4、第二次实例化对象时，父类和子类的静态代码块都将不会再执行</p><p>5、静态代码块先执行，并且只执行一次，在类加载阶段执行</p><p>6、如果类没有加载，先加载类：先加载基类，后加载子类，基类的静态代码块先执行，子类的代码块后执行，并且都只执行一次</p><p>7、当有对象创建的时候，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行</p><p>注意：</p><ol><li>new哪个类的对象，编译器就会调用该类的构造方法</li><li>new子类对象：编译器会调用子类的构造方法<ol><li>从基类继承下来的成员变量，通过super（）调用基类构造方法</li><li>子类新增加的成员</li></ol></li><li>基类构造方法中的内容先打印，然后子类构造方法中的内容后打印</li></ol></blockquote><h1 id="6、Collection-和-Collections-有什么区别？"><a href="#6、Collection-和-Collections-有什么区别？" class="headerlink" title="6、Collection 和 Collections 有什么区别？"></a>6、Collection 和 Collections 有什么区别？</h1><blockquote><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li></ul></blockquote><h1 id="7、说一下-HashMap-的实现原理？"><a href="#7、说一下-HashMap-的实现原理？" class="headerlink" title="7、说一下 HashMap 的实现原理？"></a>7、说一下 HashMap 的实现原理？</h1><blockquote><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p></blockquote><h1 id="8、如何决定使用-HashMap-还是-TreeMap？"><a href="#8、如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="8、如何决定使用 HashMap 还是 TreeMap？"></a>8、如何决定使用 HashMap 还是 TreeMap？</h1><blockquote><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p></blockquote><h1 id="9、ArrayList-和-LinkedList-的区别是什么？"><a href="#9、ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="9、ArrayList 和 LinkedList 的区别是什么？"></a>9、ArrayList 和 LinkedList 的区别是什么？</h1><blockquote><p> 数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p><ul><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li></ul></blockquote><h1 id="10、Array-和-ArrayList-有何区别？"><a href="#10、Array-和-ArrayList-有何区别？" class="headerlink" title="10、Array 和 ArrayList 有何区别？"></a>10、Array 和 ArrayList 有何区别？</h1><blockquote><p>一、Array 是静态的,所以一个数据一旦创建就 无法更改他的大小。</p><p>如果这时候我们需要在数组中添加其他的元素的时候，就必须要新建一个数组且数组长度比原数组长度多一，然后再把数组中的内容复制到新数组中，最后再根据下标添加需要的内容。</p><p>二、ArrayList 是Java集合框架类的一员,可以称它为一个动态数组.</p><p>ArrayList的长度是可变的，java程序中自带了添加方法，可以自动新增一个数组并且添加完后会自动抛弃旧数组。并且，每次添加新数组的时候都会自动检查数组中的空间是否足够。</p><p>三、ArrayList与Array的区别</p><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</p><p>注意：Array在储存时，只能储存同一种数据类型，如果定义的是整数类数组，那么这个数组中就只能存储整数。而ArrayList在存储整数数据类型的时候，会把整数变成Object。</p><p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p></blockquote><h1 id="11、说一下你对跳槽的看法-？"><a href="#11、说一下你对跳槽的看法-？" class="headerlink" title="11、说一下你对跳槽的看法 ？"></a>11、说一下你对跳槽的看法 ？</h1><blockquote><p>两面性 </p></blockquote><h1 id="12、你身边的朋友都是怎么评价你的-？"><a href="#12、你身边的朋友都是怎么评价你的-？" class="headerlink" title="12、你身边的朋友都是怎么评价你的 ？"></a>12、你身边的朋友都是怎么评价你的 ？</h1><blockquote><ul><li>性格方面外向开朗</li><li>对我比较信任</li></ul></blockquote><h1 id="13、订单表和商品表是两表联查-下单了商品a-把商品-a-改成-商品b，如何解决-？"><a href="#13、订单表和商品表是两表联查-下单了商品a-把商品-a-改成-商品b，如何解决-？" class="headerlink" title="13、订单表和商品表是两表联查 下单了商品a 把商品 a 改成 商品b，如何解决 ？"></a>13、订单表和商品表是两表联查 下单了商品a 把商品 a 改成 商品b，如何解决 ？</h1><blockquote></blockquote><h1 id="14、数据库中订单表带地址的字段是如何创建的-？用冗余的还是用多表联查的好-？"><a href="#14、数据库中订单表带地址的字段是如何创建的-？用冗余的还是用多表联查的好-？" class="headerlink" title="14、数据库中订单表带地址的字段是如何创建的 ？用冗余的还是用多表联查的好 ？"></a>14、数据库中订单表带地址的字段是如何创建的 ？用冗余的还是用多表联查的好 ？</h1><blockquote></blockquote><h1 id="15、jQuery如果span标签的值-？"><a href="#15、jQuery如果span标签的值-？" class="headerlink" title="15、jQuery如果span标签的值 ？"></a>15、jQuery如果span标签的值 ？</h1><blockquote><p>通过id获取</p></blockquote><h1 id="16、事务的隔离级别"><a href="#16、事务的隔离级别" class="headerlink" title="16、事务的隔离级别"></a>16、事务的隔离级别</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-11月7日-每日面试题&quot;&gt;&lt;a href=&quot;#2022-11月7日-每日面试题&quot; class=&quot;headerlink&quot; title=&quot;2022 11月7日 每日面试题&quot;&gt;&lt;/a&gt;2022 11月7日 每日面试题&lt;/h1&gt;&lt;h1 id=&quot;1、谈谈你的职业规</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022年11月1日 每日面试题</title>
    <link href="https://manamn.space/2022/11/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022%E5%B9%B411%E6%9C%881%E6%97%A5/"/>
    <id>https://manamn.space/2022/11/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022%E5%B9%B411%E6%9C%881%E6%97%A5/</id>
    <published>2022-11-13T14:17:25.000Z</published>
    <updated>2022-12-13T13:08:20.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-11月1日-每日面试题"><a href="#2022-11月1日-每日面试题" class="headerlink" title="2022 11月1日 每日面试题"></a>2022 11月1日 每日面试题</h1><h1 id="1、Vue的生命周期"><a href="#1、Vue的生命周期" class="headerlink" title="1、Vue的生命周期"></a>1、Vue的生命周期</h1><h1 id="2、Vue的路由有几种模式"><a href="#2、Vue的路由有几种模式" class="headerlink" title="2、Vue的路由有几种模式"></a>2、Vue的路由有几种模式</h1><blockquote><p><strong>Hash模式</strong> ：使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载，其显示的网路路径中会有 “#” 号，有一点点丑。这是最安全的模式，因为他兼容所有的浏览器和服务器。</p><p><strong>History</strong> ： 美化后的hash模式，会去掉路径中的 “#”。依赖于Html5 的history，pushState API,所以要担心IE9以及一下的版本。并且还包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作。就是浏览器左上角的前进、后退等按钮进行的操作。 abstract模式 ：适用于所有</p><p><strong>abstract模式</strong> ：  JavaScript环境，例如服务器端使用Node.js。如果没有浏览器API，路由器将自动被强制进入此模式。</p></blockquote><h1 id="3、ArrayList和-LinkedList怎么去重-？"><a href="#3、ArrayList和-LinkedList怎么去重-？" class="headerlink" title="3、ArrayList和 LinkedList怎么去重 ？"></a>3、ArrayList和 LinkedList怎么去重 ？</h1><blockquote><ol><li><strong>第一种方式 ：</strong>首先创建一个新的集合，放入数据，然后再创建一个集合，将原来集合的内容放入这个集合中，通过迭代器对这个集合进行迭代，遍历每一个数据，与之前的进行contains方法比较，如果不包含的话，直接放入新集合，否则直接去除。</li><li><strong>第二种方式 ：</strong> 首先创建一个新的集合，放入一些重复的数据，然后再创建一个LinkedHashSet集合，将原来集合作为LinkedHashSet的参数，进行去重。如果再去重的基础上还需要增加排序功能，则可以直接使用HashSet。</li></ol></blockquote><h1 id="4、说一下HTTP-有哪些请求方法-？"><a href="#4、说一下HTTP-有哪些请求方法-？" class="headerlink" title="4、说一下HTTP 有哪些请求方法 ？"></a>4、说一下HTTP 有哪些请求方法 ？</h1><h1 id="5、说一下平时软件BUG的排查过程"><a href="#5、说一下平时软件BUG的排查过程" class="headerlink" title="5、说一下平时软件BUG的排查过程"></a>5、说一下平时软件BUG的排查过程</h1><h1 id="6、-在数据库中添加到一条数据，id是自动递增的，怎么获取到这条数据的id-？"><a href="#6、-在数据库中添加到一条数据，id是自动递增的，怎么获取到这条数据的id-？" class="headerlink" title="6、 在数据库中添加到一条数据，id是自动递增的，怎么获取到这条数据的id ？"></a>6、 在数据库中添加到一条数据，id是自动递增的，怎么获取到这条数据的id ？</h1><blockquote></blockquote><h1 id="7、MySQL加入有500条数据-，如果使用分页-，怎么加快查询速度-？"><a href="#7、MySQL加入有500条数据-，如果使用分页-，怎么加快查询速度-？" class="headerlink" title="7、MySQL加入有500条数据 ，如果使用分页 ，怎么加快查询速度 ？"></a>7、MySQL加入有500条数据 ，如果使用分页 ，怎么加快查询速度 ？</h1><blockquote><p>方法1 :  <strong>建立主键或唯一索引, 利用索引(假设每页10条)</strong></p><ul><li>语句样式: MySQL中,可用如下方法: SELECT <em> FROM 表名称 WHERE id_pk &gt; (pageNum</em>10) LIMIT M<ul><li>适应场景: 适用于数据量多的情况(元组数上万)</li><li>原因: 索引扫描,速度会很快. 有朋友提出: 因为数据查询出来并不是按照pk_id排序的，所以会有漏掉数据的情况，只能方法2</li></ul></li></ul></blockquote><h1 id="8、动态代理是什么"><a href="#8、动态代理是什么" class="headerlink" title="8、动态代理是什么 ?"></a>8、动态代理是什么 ?</h1><blockquote><p>动态代理就是，在程序运行期间，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。</p><p>代理类在程序运行期间，创建的代理对象称之为动态代理对象。这种情况下，创建的代理对象，并不是事先在Java代码中定义好的。而是在运行期间，根据我们在动态代理对象中的“指示”，动态生成的。也就是说，你想获取哪个对象的代理，动态代理就会为你动态的生成这个对象的代理对象。动态代理可以对被代理对象的方法进行功能增强。有了动态代理的技术，那么就可以在不修改方法源码的情况下，增强被代理对象的方法的功能，在方法执行前后做任何你想做的事情。</p></blockquote><h1 id="9、为什么从上家公司离职-？"><a href="#9、为什么从上家公司离职-？" class="headerlink" title="9、为什么从上家公司离职 ？"></a>9、为什么从上家公司离职 ？</h1><blockquote><p>回家发展 + 其他</p></blockquote><h1 id="10、项目中你收获了什么-？"><a href="#10、项目中你收获了什么-？" class="headerlink" title="10、项目中你收获了什么 ？"></a>10、项目中你收获了什么 ？</h1><blockquote><ul><li>项目经验</li><li>技术提升</li><li>沟通能力 + 人际交往能力</li><li>综合素质</li></ul></blockquote><h1 id="11、项目中遇到问题你是怎么解决的-？"><a href="#11、项目中遇到问题你是怎么解决的-？" class="headerlink" title="11、项目中遇到问题你是怎么解决的 ？"></a>11、项目中遇到问题你是怎么解决的 ？</h1><blockquote><ul><li>百度 + 自己解决</li><li>找同事</li></ul></blockquote><h1 id="12、当你的意见和领导的意见不统一时-怎么办-？"><a href="#12、当你的意见和领导的意见不统一时-怎么办-？" class="headerlink" title="12、当你的意见和领导的意见不统一时 怎么办 ？"></a>12、当你的意见和领导的意见不统一时 怎么办 ？</h1><blockquote><ul><li>首先跟领导沟通 + 然后获取最好的解决的方法  </li></ul></blockquote><h1 id="13、Java的内容是不是自学的-？"><a href="#13、Java的内容是不是自学的-？" class="headerlink" title="13、Java的内容是不是自学的 ？"></a>13、Java的内容是不是自学的 ？</h1><blockquote><ul><li>自学</li><li>看书 + 看视频</li><li>学习方法 + 学习计划</li><li>从大学就开始接触Java这门课程  +自己感兴趣 + 上网去找了一些有关的资料与书籍 + 掌握基础知识  + 做一些练手的项目</li></ul></blockquote><h1 id="14、你觉得你有什么优势-？"><a href="#14、你觉得你有什么优势-？" class="headerlink" title="14、你觉得你有什么优势 ？"></a>14、你觉得你有什么优势 ？</h1><blockquote><ol><li>自学能力强</li><li>能够快速适应企业要求</li><li>岗位可以完全胜任</li><li>贵公司的要求我都符合 + 有足够的工作经验</li></ol></blockquote><h1 id="15、你来公司是否可以独立工作-？还是需要有人带-？"><a href="#15、你来公司是否可以独立工作-？还是需要有人带-？" class="headerlink" title="15、你来公司是否可以独立工作 ？还是需要有人带 ？"></a>15、你来公司是否可以独立工作 ？还是需要有人带 ？</h1><blockquote><p>在公司需要的相关问题我个人是没有任何问题 ，项目的业务流程问题和业务逻辑需要一个人来带我熟悉一下。</p></blockquote><h1 id="16、自学过程中遇到的最大问题-？"><a href="#16、自学过程中遇到的最大问题-？" class="headerlink" title="16、自学过程中遇到的最大问题 ？"></a>16、自学过程中遇到的最大问题 ？</h1><blockquote><ol><li>自律性</li><li>学习资源问题 —-》 现在网上资源很多 鱼龙混杂 需要有分辨能力</li><li>项目案例问题 —-》  学习之后需要一个项目案例来练手</li><li>出现BUG</li></ol><p>如果解决上述问题</p></blockquote><h1 id="17、自学过程中有没有做过什么小的项目-？请详细介绍一下"><a href="#17、自学过程中有没有做过什么小的项目-？请详细介绍一下" class="headerlink" title="17、自学过程中有没有做过什么小的项目 ？请详细介绍一下"></a>17、自学过程中有没有做过什么小的项目 ？请详细介绍一下</h1><blockquote><ul><li>这个项目时做什么的</li><li>项目的功能模块   <ul><li>登录 </li><li>注册</li><li>发表文章</li><li>后台管理</li><li>评论</li><li>……</li></ul></li><li>这些功能模块是怎样实现的</li></ul></blockquote><h1 id="18、大学期间所获得的荣誉-？"><a href="#18、大学期间所获得的荣誉-？" class="headerlink" title="18、大学期间所获得的荣誉 ？"></a>18、大学期间所获得的荣誉 ？</h1><blockquote></blockquote><h1 id="19、你觉得学校的课程对你的工作有什么帮助嘛-？"><a href="#19、你觉得学校的课程对你的工作有什么帮助嘛-？" class="headerlink" title="19、你觉得学校的课程对你的工作有什么帮助嘛 ？"></a>19、你觉得学校的课程对你的工作有什么帮助嘛 ？</h1><blockquote></blockquote><h1 id="20、你来我们公司面试之前有了解过我们公司吗？"><a href="#20、你来我们公司面试之前有了解过我们公司吗？" class="headerlink" title="20、你来我们公司面试之前有了解过我们公司吗？"></a>20、你来我们公司面试之前有了解过我们公司吗？</h1><blockquote></blockquote><h1 id="21、谈一谈你的职业规划-？"><a href="#21、谈一谈你的职业规划-？" class="headerlink" title="21、谈一谈你的职业规划 ？"></a>21、谈一谈你的职业规划 ？</h1><blockquote></blockquote><h1 id="22、如果工作出现了失误，给公司造成了经济损失-，你会怎么办-？"><a href="#22、如果工作出现了失误，给公司造成了经济损失-，你会怎么办-？" class="headerlink" title="22、如果工作出现了失误，给公司造成了经济损失 ，你会怎么办 ？"></a>22、如果工作出现了失误，给公司造成了经济损失 ，你会怎么办 ？</h1><blockquote><ul><li><p>我在之前工作当中是没有出现过这样的问题的。</p></li><li><p>我会加强工作的严谨性。</p></li><li><p>如果出现了这种问题 我会首先主动承担这些问题。</p></li></ul></blockquote><h1 id="23、IOC控制反转是如何实现-？"><a href="#23、IOC控制反转是如何实现-？" class="headerlink" title="23、IOC控制反转是如何实现 ？"></a>23、IOC控制反转是如何实现 ？</h1><blockquote><p>将对象交给Spring进行管理</p></blockquote><h1 id="24、Java和-JavaScript的区别-？"><a href="#24、Java和-JavaScript的区别-？" class="headerlink" title="24、Java和 JavaScript的区别 ？"></a>24、Java和 JavaScript的区别 ？</h1><blockquote><p>1.用处不一样：</p><p>它们最本质的不同就是用途：Java目前被广泛应用于PC端、手机端、互联网、数据中心等等；</p><p>而JavaScript则被主要用于嵌入文本到HTML页面，读写HTML元素，控制cookies等。</p><p>2.出身不同：</p><p>Javascript与Java是由不同的公司开发的不同产品。Javascript是Netscape公司的脚本语言；</p><p>而Java是SUN Microsystems 公司推出的新一代面向对象的程序设计语言。</p><p>3.嵌入方式不同：</p><p>在HTML文档中，两种编程语言的标识不同，Javascript 使用&lt;script&gt;&lt;/script&gt; 来标识；而 Java 使用 Applet 来标识。</p><p>4.语言类型不同：</p><p>JavaScript 是动态类型语言；而 Java 是静态类型语言。</p><p>5.所采取的变量不同：</p><p>JavaScript 中的变量声明采用弱类型，即变量在使用前不需作声明，而是解释器在运行时检查其数据类型。Java 采用强类型变量检查，即所有变量在编译之前必须作声明。</p><p>6.代码格式不同：</p><p>Javascript 的代码是一种动态的，可以直接嵌入 HTML 文档，并且可动态装载，编写 HTML 文档就像编辑文本文件一样方便，其独立文件的格式为<em>.js。Java 是一种与 HTML 无关的格式，必须通过像 HTML 中引用外媒体那么进行装载，其代码以字节代码的形式保存在独立的文档中，其独立文件的格式为 </em>.class。</p><p>Java 和 JavaScript 相同之处：</p><p>它们的语法和 C 语言都很相似；它们都是面向对象的（虽然实现的方式略有不同）；JavaScript 在设计时参照了 Java 的命名规则；总而言之，JavaScript 除了长得和 Java 比较像之外，语言风格相去甚远。JavaScript 在设计时所参考的对象不包括 Java，而包括了像 Self 和 Scheme 这样的语言。</p></blockquote><h1 id="25、SpringBoot特有的注解-？"><a href="#25、SpringBoot特有的注解-？" class="headerlink" title="25、SpringBoot特有的注解 ？"></a>25、SpringBoot特有的注解 ？</h1><blockquote><ul><li><strong>@SpringBootApplication</strong></li><li><strong>@EnableAutoConfiguration</strong></li><li><strong>@ComponentScan</strong></li><li><strong>@SpringBootConfig</strong></li><li><strong>@Contoller</strong></li><li><strong>@RestContoller</strong></li></ul></blockquote><h1 id="26、什么是序列化-，什么是反序列化-？"><a href="#26、什么是序列化-，什么是反序列化-？" class="headerlink" title="26、什么是序列化 ，什么是反序列化 ？"></a>26、什么是序列化 ，什么是反序列化 ？</h1><blockquote><p><strong>序列化 ：</strong>Java序列化就是指把Java对象转换为字节序列的过程</p><p><strong>反序列化 ：</strong>Java反序列化就是指把字节序列恢复为Java对象的过程。</p><p>序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序<a href="https://so.csdn.net/so/search?q=字节流&amp;spm=1001.2101.3001.7020">字节流</a>,以便在网络上传输或者保存在本地文件中。</p><p>序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。</p><p>总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p></blockquote><h1 id="27、传输文件时-，怎么防止文件损坏-？"><a href="#27、传输文件时-，怎么防止文件损坏-？" class="headerlink" title="27、传输文件时 ，怎么防止文件损坏 ？"></a>27、传输文件时 ，怎么防止文件损坏 ？</h1><blockquote><p>网络问题</p></blockquote><h1 id="28、既然有了字节流-，为什么还要有字符流-？"><a href="#28、既然有了字节流-，为什么还要有字符流-？" class="headerlink" title="28、既然有了字节流 ，为什么还要有字符流 ？"></a>28、既然有了字节流 ，为什么还要有字符流 ？</h1><blockquote><p>字节是最小的单位</p><p>在生活中，我们肯定时常会读取文本文件，如程序的配置文件：json，yaml，properties等，在读取文件时我们肯定不希望是获取字节流形式，而是想要获取其字符形式。</p><p>通常，如果不使用字符流但是我们需要字符流的时候就利用InputStreamReader和InputStreamWriter这两个类来将字节流进行转换得到字符流，这个过程需要JVM进行转换，是非常耗时的，同样假如我们不知道编码方式就很容易出现乱码的问题，</p><p>所以I/O流就干净利索的提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。当然图片和音频这些文件我们还是用字节流比较好。涉及到字符的我们就使用字符流比较好。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-11月1日-每日面试题&quot;&gt;&lt;a href=&quot;#2022-11月1日-每日面试题&quot; class=&quot;headerlink&quot; title=&quot;2022 11月1日 每日面试题&quot;&gt;&lt;/a&gt;2022 11月1日 每日面试题&lt;/h1&gt;&lt;h1 id=&quot;1、Vue的生命周</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022年11月13日 每日面试题</title>
    <link href="https://manamn.space/2022/11/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022%E5%B9%B411%E6%9C%8813%E6%97%A5/"/>
    <id>https://manamn.space/2022/11/13/%E9%9D%A2%E8%AF%95%E9%A2%98/2022%E5%B9%B411%E6%9C%8813%E6%97%A5/</id>
    <published>2022-11-13T14:14:46.000Z</published>
    <updated>2022-12-13T13:07:50.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022-11月13日-每日面试题"><a href="#2022-11月13日-每日面试题" class="headerlink" title="2022 11月13日 每日面试题"></a>2022 11月13日 每日面试题</h1><h1 id="1、谈谈你对面向对象的理解"><a href="#1、谈谈你对面向对象的理解" class="headerlink" title="1、谈谈你对面向对象的理解"></a>1、谈谈你对面向对象的理解</h1><blockquote><ol><li>面向对象的三大基本特征 ：封装、继承、多态。</li><li>其中,封装是指将对象的状态信息隐藏在对象内部,不允许外部程序直接访问对象内部信息,让外部程序通过该类提供的方法来实现对内部信息的操作和访问,这种做法有助于规范使用者的行为,让使用者只能通过事先预定的方法访问数据,提高了代码的可维护性；</li><li>继承是面向对象实现代码复用的重要手段,Java通过extends作为关键字实现类的继承,实现继承的类被称为子类,被继承的类称为父类（有的也被称为基类和超类）,父类和子类的关系是一种一般和特殊的关系；</li><li>多态的实现离不开继承,在设计程序时,我们可以将参数的类型定义为父类型。在调用程序时,则可以根据实际情况,传入该父类型的某个子类型的实例,这样就实现了多态。对于父类型,可以有三种形式,即普通的类、抽象类、接口。对于子类型,则要根据它自身的特征,重写父类的某些方法,或实现抽象类/接口的某些抽象方法。 </li></ol></blockquote><h1 id="2、int和Integer有什么区别"><a href="#2、int和Integer有什么区别" class="headerlink" title="2、int和Integer有什么区别"></a>2、int和Integer有什么区别</h1><blockquote><ol><li>Integer是int的包装类，而int是Java中基本数据类型。</li><li>Integer变量必须实例化后才能使用，而int变量不需要。</li><li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值</li><li>Integer的默认值为null，而int的默认值为0。</li></ol></blockquote><h1 id="3、说说-amp-和-amp-amp-的区别"><a href="#3、说说-amp-和-amp-amp-的区别" class="headerlink" title="3、说说&amp;和&amp;&amp;的区别"></a>3、说说&amp;和&amp;&amp;的区别</h1><blockquote><ol><li>按位与；</li><li>逻辑与。</li></ol><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</p></blockquote><h1 id="4、说说你对AOP的理解"><a href="#4、说说你对AOP的理解" class="headerlink" title="4、说说你对AOP的理解"></a>4、说说你对AOP的理解</h1><blockquote><ol><li>AOP是一种编程思想，是通过预编译方式和运行期间动态代理的方式实现不修改源码的情况下给程序动态统一添加功能的技术。面向对象编程将程序抽象成各个层次的对象，而面向切面编程则将程序抽象成各个切面。所谓切面，相当于应用对象之间的横切点，我们可以将其单独    抽象为单独的模块。</li><li>AOP技术利用一种称为<strong>横切</strong>的技术剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命名为切面。所谓的切面,简单来说就是与业务无关,却为业务模块所共同调用的逻辑,将其封装起来便于减少系统的重复代码,降低模块的耦合度,有利用未来的可操作性和可维护性。</li><li>利用AOP可以对业务逻辑各个部分进行隔离开来，从而使业务逻辑部分之间的耦合度降低，提高程序的可重用性，提高开发效率。</li><li>AOP可以有多种实现方式,而Spring AOP支持如下两种实现方式。<ol><li>JDK动态代理 ： 这是Java提供的动态代理技术，可以在运行时创建接口的动态实例。Spring AOP默认采用这种方式,在接口的代理实例中织入代码。</li><li>CGLIB动态代理 ：采用底层的字节码技术，在运行时创建子类的代理的实例。当目标对象不存在接口的时候，Spring AOP就会采用这种方式,在子类实例中织入代码。</li></ol></li><li>在应用场景方面,Spring AOP为IoC的使用提供了更多的便利,一方面,应用可以直接使用AOP的功能,设计应用的横切关注点,把跨越应用程序多个模块的功能抽象出来,并通过简单的AOP的使用,灵活地编制到模块中,比如可以通过AOP实现应用程序中的日志功能。另一方面,在Spring内部,例如事务处理之类的一些支持模块也是通过Spring AOP来实现的。</li></ol></blockquote><h1 id="5、谈谈你对IoC的理解"><a href="#5、谈谈你对IoC的理解" class="headerlink" title="5、谈谈你对IoC的理解"></a>5、谈谈你对IoC的理解</h1><blockquote><ol><li>IOC是控制反转的意思，是一种面向对象编程的设计思想。在不采用这种思想的情况下,我们需要自己维护对象与对象之间的依赖关系,很容易造成对象之间的耦合度过高,在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题,它可以帮我们维护对象与对象之间的依赖关系,并且降低对象之间的耦合度。</li><li>说到IOC就不得不说说DI，DI是依赖注入的意思，它是IOC实现的实现方式。由于IOC这个词汇比较抽象而DI比较直观,所以很多时候我们就用DI来代替它,在很多时候我们简单地将IOC和DI划等号,这是一种习惯。实现依赖注入的关键是IOC容器,它的本质就是一个工厂。</li></ol></blockquote><h1 id="6、请说说你对反射的了解"><a href="#6、请说说你对反射的了解" class="headerlink" title="6、请说说你对反射的了解"></a>6、请说说你对反射的了解</h1><blockquote><ol><li>Java程序中，许多对象在运行时都会有编译时异常和运行时异常两种。例如多态的情况下Car c = new Animal(); 这行代码运行时会生成一个c变量,在编译时该变量的类型是Car,运行时该变量类型为Animal；另外还有更极端的情况,例如程序在运行时接收到了外部传入的一个对象,这个对象的编译时类型是Object,但程序又需要调用这个对象运行时类型的方法,这种情况下,有两种解决方法：第一种做法是假设在编译时和运行时都完全知道类型的具体信息,在这种情况下,可以先使用instanceof运算符进行判断,再利用强制类型转换将其转换成其运行时类型的变量。第二种做法是编译时根本无法预知该对象和类可能属于哪些类,程序只依靠运行时信息来发现该对象和类的真实信息,这就必须使用反射。    </li><li>具体来说,通过反射机制,我们可以实现如下的操作：<ol><li>程序运行中，可以通过反射创建任意一个类的实例，并访问该实例的成员。</li><li>程序运行中，可以通过反射机制生成一个类的动态代理类或动态代理对象。</li></ol></li><li>Java的反射机制在实际项目中应用广泛,常见的应用场景有：<ol><li>使用JDBC时,如果要创建数据库的连接,则需要先通过反射机制加载数据库的驱动程序。</li><li>多数框架都支持注解/XML配置,从配置中解析出来的类是字符串,需要利用反射机制实例化；</li><li>面向切面编程（AOP）的实现方案,是在程序运行时创建目标对象的代理类,这必须由反射机制来实现。</li></ol></li></ol></blockquote><h1 id="7、说说你对ArrayList的理解"><a href="#7、说说你对ArrayList的理解" class="headerlink" title="7、说说你对ArrayList的理解"></a>7、说说你对ArrayList的理解</h1><blockquote><ol><li>ArrayList是基于数组实现的，它的内部封装了一个Object[]数组。通过默认的构造器创建容器时，该数组首先被初始化为空数组，之后在首次添加数据时初始化长度为10。我们也可以使用有参构造器来创建容器，并通过参数来显示的指定数组的容量，此时该数组被初始化为指定容量的数组。</li><li>如果向ArrayList中添加数据会造成超出数组长度限制，则会触发自动扩容，然后再添加数据。扩容就是数组拷贝，将旧数组的内容拷贝到新的数组中，而新数组的长度为原来数组长度的1.5倍。</li><li>ArrayList支持缩容，但不会自动缩容,即便是ArrayList中只剩下少量数据时也不会主动缩容。如果我们希望缩减ArrayList的容量,则需要自己调用它的trimToSize()方法,届时数组将按照元素的实际个数进行缩减。</li><li>Set、List、Queue都是Collection的子接口,它们都继承了父接口的iterator()方法,从而具备了迭代的能力。但是,相比于另外两个接口,List还单独提供了listIterator()方法,增强了迭代能力。iterator()方法返回Iterator迭代器,listIterator()方法返回ListIterator迭代器,并且ListIterator是Iterator的子接口。ListIterator在Iterator的基础上,增加了向前遍历的支持,增加了在迭代过程中修改数据的支持。</li></ol></blockquote><h1 id="8、说说Spring-Boot的自动装配"><a href="#8、说说Spring-Boot的自动装配" class="headerlink" title="8、说说Spring Boot的自动装配"></a>8、说说Spring Boot的自动装配</h1><blockquote><ol><li>使用Spring Boot时,我们需要引入对应的Starters,Spring Boot启动时便会自动加载相关依赖,配置相应的初始化参数,以最快捷、简单的形式对第三方软件进行集成,这便是Spring Boot的自动配置功能。</li><li>整个自动装配的过程是 ： SpringBoot 通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类,当某个AutoConfiguration类满足其注解@Conditional指定的生效条件时，实例化该AutoConfiguration类中定义的Bean（组件等）,注入Spring容器，就可以完成依赖框架的自动配置</li><li>@EnableAutoConfiguration 作用 从classpath中搜索所有META-INF/spring.factories配置文件然后,将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器 只有spring.boot.enableautoconfiguration为true（默认为true）的时候,才启用自动配置 @EnableAutoConfiguration还可以根据class来排除（exclude）,或是根据class name（excludeName）来排除 其内部实现的关键点有 1. ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中 2. SpringFactoriesLoader 该类可以从classpath中搜索所有META-INF/spring.factories配置文件,并读取配置</li></ol></blockquote><h1 id="9、请你说说Java的特点和优点-为什么要选择Java？"><a href="#9、请你说说Java的特点和优点-为什么要选择Java？" class="headerlink" title="9、请你说说Java的特点和优点,为什么要选择Java？"></a>9、请你说说Java的特点和优点,为什么要选择Java？</h1><blockquote><ol><li>Java是一门非常纯粹的面向对象的编程语言，它在吸收C++语言优点的同时去除了C语言中令人难以理解的多继承，指针等概念。所以Java语言在保证了强大功能的基础上,还比C++语言更为简单易用。</li><li>Java语言极好的实现了面向对象理论，是静态面向对象语言的代表，它的存在保证了程序员可以用优雅的思维方式进行复杂的编程 。</li><li>Java还拥有平台的独立性，可以做到”一次编译,到处运行”。Java还提供了很多内置的类库，,通过这些类库,简化了开发人员的程序设计工作,缩短了项目的开发时间,最重要的是Java提供了垃圾回收器,这也将开发人员从对内存的管理中解脱出来。同时Java拥有良好的安全性和健壮性，Java语言常常使用在网络环境中，为了增强程序的安全性,java语言提供了一个防止恶意代码攻击的安全机制（数组边界检测和Bytecode校验等）。Java的强类型机制、垃圾回收器、异常处理和安全检查机制使用Java语言编写的程序有很好的健壮性</li><li>此外，Java还提供了对Web应用开发的支持。例如Applet、Servlet和JSP可以用来开发Web应用程序；Socket、RMI可以用来开发分布式应用程序的类库。 </li><li>JVM（Java虚拟机）是Java跨平台的关键。在运行程序之前，Java源代码(.java)需要经过编译器，将源代码翻译为字节码(.class)，但字节码不能直接运行，所以必须通过JVM将字节码翻译为特定平台的机器码运行程序。但跨平台的是Java程序、而不是JVM,所以需要在不同平台下安装不同版本的JVM。</li></ol></blockquote><h1 id="10、SpringBoot的启动流程"><a href="#10、SpringBoot的启动流程" class="headerlink" title="10、SpringBoot的启动流程"></a>10、SpringBoot的启动流程</h1><blockquote><p> 当Spring Boot项目创建完成后会默认生成一个Application的入口类,这个类中的mn方法可以启动Spring Boot项目，在mn方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication的实例化操作,然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。SpringApplication调用的run方法重点做了以下操作 ：</p><ol><li>获取监听参数配置</li><li>打印Bannner信息</li><li>创建并初始化容器</li><li>监听器发送通知</li></ol></blockquote><h1 id="11、介绍一下Spring-MVC的执行流程"><a href="#11、介绍一下Spring-MVC的执行流程" class="headerlink" title="11、介绍一下Spring MVC的执行流程"></a>11、介绍一下Spring MVC的执行流程</h1><blockquote><ol><li>用户点击某个路径，发起HttpRequest请求，该请求会被提交到DispacherServelet；</li><li>由 DispatcherServlet 请求一个或多个处理器映射器(HandlerMapping),并返回一个执行链(HandlerExecutionChn)。</li><li>DispatcherServlet将执行链返回的Handle信息发送给处理器适配器(HandlerAdapter)；</li><li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler方法(常称为 Controller)；</li><li>Handle执行完毕之后会返回给HandleAdapter一个ModelAndView对象(Spring MVC的底层对象,包括 Model 数据模型和 View 视图信息)；</li><li>HandlerAdapter 接收到 ModelAndView 对象后,将其返回给 DispatcherServlet ；</li><li>DispatcherServlet接收到ModelAndView 对象后，会请求视图解析器(ViewResolver)对视图进行解析； </li><li>ViewResolver 根据 View 信息匹配到相应的视图结果,并返回给 DispatcherServlet；</li><li>DispatcherServlet 接收到具体的 View 视图后,进行视图渲染。</li><li>最后将渲染的视图返回给用户。</li></ol></blockquote><h1 id="12、请你说说List与Set的区别"><a href="#12、请你说说List与Set的区别" class="headerlink" title="12、请你说说List与Set的区别"></a>12、请你说说List与Set的区别</h1><blockquote><p>List和Set都是Collection接口的子接口,它们的主要区别在于元素的有序性和重复性： List代表有序的元素可以重复的集合,集合中每个元素都有对应的顺序索引,它默认按元素的添加顺序设置元素的索引,并且可以通过索引来访问指定位置的集合元素。另外,List允许使用重复元素。 Set代表无序的元素不可重复的集合,它通常不能记住元素的添加顺序。Set集合不允许包含相同的元素,如果试图把两个相同的元素加入同一个Set,则会引发失败,添加方法将会返回false。 加分回答 虽然Set代表无序的集合,但是它有支持排序的实现类,即TreeSet。TreeSet可以确保集合元素处于排序状态,并支持自然排序和定制排序两种排序方式,它的底层是由TreeMap实现的。TreeSet也是非线程安全的,但是它内部元素的值不能为null。</p></blockquote><h1 id="13、在MyBatis中-和-有什么区别"><a href="#13、在MyBatis中-和-有什么区别" class="headerlink" title="13、在MyBatis中$和#有什么区别"></a>13、在MyBatis中$和#有什么区别</h1><blockquote><p>使用$设置参数时,MyBatis会创建普通的SQL语句,然后在执行SQL 语句时将参数拼入SQL,而使用#设置参数时,MyBatis会创建预编译的SQL语句,然后在执行SQL时MyBatis会为预编译SQL中的占位符赋值。预编译的SQL语句执行效率高,并且可以防止注入攻击,效率和安全性都大大优于前者，但在解决一些特殊问题,如在一些根据不同的条件产生不同的动态列中,我们要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL就只能使用￥。</p></blockquote><h1 id="14、请你说说Java基本数据类型和引用类型"><a href="#14、请你说说Java基本数据类型和引用类型" class="headerlink" title="14、请你说说Java基本数据类型和引用类型"></a>14、请你说说Java基本数据类型和引用类型</h1><blockquote><p>Java的数据类型分为基本数据类型和引用数据类型两大类。 基本数据类型共有八大类,这八大数据类型又可分为四小类,分别是整数类型（byte/short/int/long）、浮点类型（float、double）、字符类型（char）和布尔类型（boolean）。其中,int是最常用的整数类型,double是最为常用的浮点类型,除了布尔类型之外的其他7个类型,都可以看做是数字类型,它们相互之间可以进行类型转换。 引用类型包括数组、类、接口类型,还有一种特殊的null类型,所谓引用数据类型就是对一个对象的引用,对象包括实例和数组两种。  对于基本数据类型,你需要了解每种类型所占据的内存空间。 </p><ol><li>byte：1字节（8位）,数据范围是 <code>-2^7 ~ 2^7-1</code>。 </li><li>short：2字节（16位）,数据范围是 <code>-2^15 ~ 2^15-1</code>。 </li><li>int：4字节（32位）,数据范围是 <code>-2^31 ~ 2^31-1</code>。 </li><li>long：8字节（64位）,数据范围是 <code>-2^63 ~ 2^63-1</code>。 </li><li>float：4字节（32位）,数据范围大约是 <code>-3.4*10^38 ~ 3.4*10^38</code>。 </li><li>double：8字节（64位）,数据范围大约是 <code>-1.8*10^308 ~ 1.8*10^308</code>。 </li><li>char：2字节（16位）,数据范围是 <code>\u0000 ~ \uffff</code>。 </li><li>boolean：Java规范没有明确的规定,不同的JVM有不同的实现机制。</li></ol></blockquote><h1 id="15、请介绍一下访问修饰符"><a href="#15、请介绍一下访问修饰符" class="headerlink" title="15、请介绍一下访问修饰符"></a>15、请介绍一下访问修饰符</h1><blockquote><p>Java除了提供的三个访问修饰符分别代表三个访问级别之外还有一个不加修饰符的访问级别,它们访问级别控制从小到大为： private-&gt;default-&gt;protected-&gt;public 他们访问级别分别如下：</p><ol><li>private：类中被private修饰的成员只能在当前类的内部被访问。根据这点,我们可以使用它来修饰成员变量,从而将成员变量隐藏在这个类的内部。</li><li>default：如果类中的成员或者一个外部类不使用任何访问修饰符来进行修饰,那么他就是default级别的,default访问控制的类成员或者外部类可以被相同包下的其他类访问。 </li><li>protected：如果一个类成员被protected访问修饰符修饰,那么这个成员不但可以被同一个包下的其他类访问,还可以被其他包下的子类访问。一般来讲,如果一个方法被protected修饰,那么通常是希望它的子类来重写它。</li><li>public：这是Java中最宽松的访问级别,如果类成员被这个修饰符修饰,那么无论访问类和被访问类在不在一个包下,有没有父子关系,这个类成员都可以被访问到。``</li></ol></blockquote><h1 id="16、请你说一下抽象类和接口的区别"><a href="#16、请你说一下抽象类和接口的区别" class="headerlink" title="16、请你说一下抽象类和接口的区别"></a>16、请你说一下抽象类和接口的区别</h1><blockquote><p>接口和抽象类相同点有：</p><ol><li>接口和抽象类都不能被实例化,它们都位于继承树的顶端,用于被其它类实现和继承。</li><li>接口和抽象类都可以有抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法 在用法上,接口和抽象类也有如下差异：<ol><li>接口里只能包含抽象方法和默认方法,不能为普通方法提供方法实现；抽象类则可以包含普通方法。</li><li>接口里只能定义静态常量,不能定义普通成员变量；抽象类里既可以定义普通成员变量,也可以定义静态常量。</li><li>接口里不包含构造器；抽象类可以包含构造器,但抽象类的构造器并不是用于创建对象,而是让其子类调用这些构造器来完成属于抽象类的初始化操作 。</li><li>接口里不能包含初始化块,抽象类则可以包含初始化块。</li><li>一个类最多只能有一个父类,包括抽象类；但一个类可以直接实现多个接口,通过实现多个接口可以弥补Java单继承的不足 总之,接口通常是定义允许多个实现的类型的最佳途径,但当演变的容易性比灵活性和功能更加重要时,应该使用抽象类来定义类型。 </li></ol></li></ol></blockquote><h1 id="17、String、StringBuffer、Stringbuilder有什么区别"><a href="#17、String、StringBuffer、Stringbuilder有什么区别" class="headerlink" title="17、String、StringBuffer、Stringbuilder有什么区别"></a>17、String、StringBuffer、Stringbuilder有什么区别</h1><blockquote><p>Java中提供了String,StringBuffer两个类来封装字符串,并且提供了一系列方法来操作字符串对象。 String是一个不可变类,也就是说,一个String对象创建之后,直到这个对象销毁为止,对象中的字符序列都不能被改变。 StringBuffer对象则代表一个字符序列可变的字符串,当一个StringBuffer对象被创建之后,我们可以通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()、等方法来改变这个字符串对象的字符序列。当通过StringBuffer得到期待中字符序列的字符串时,就可以通过toString()方法将其转换为String对象。 StringBuilder类是JDK1.5中新增的类,他也代表了字符串对象。和StringBuffer类相比,它们有共同的父类<code>AbstractStringBuilder</code>,二者无论是构造器还是方法都基本相同,不同的一点是,StringBuilder没有考虑线程安全问题,也正因如此,StringBuilder比StringBuffer性能略高。因此,如果是在单线程下操作大量数据,应优先使用StringBuilder类；如果是在多线程下操作大量数据,应优先使用StringBuilder类。</p></blockquote><h1 id="18、请你说说HashMap底层原理"><a href="#18、请你说说HashMap底层原理" class="headerlink" title="18、请你说说HashMap底层原理"></a>18、请你说说HashMap底层原理</h1><blockquote><p> 在JDK8中,HashMap底层是采用“数组+链表+红黑树”来实现的。 HashMap是基于哈希算法来确定元素的位置（槽）的,当我们向集合中存入数据时,它会计算传入的Key的哈希值,并利用哈希值取余来确定槽的位置。如果元素发生碰撞,也就是这个槽已经存在其他的元素了,则HashMap会通过链表将这些元素组织起来。如果碰撞进一步加剧,某个链表的长度达到了8,则HashMap会创建红黑树来代替这个链表,从而提高对这个槽中数据的查找的速度。 HashMap中,数组的默认初始容量为16,这个容量会以2的指数进行扩容。具体来说,当数组中的元素达到一定比例的时候HashMap就会扩容,这个比例叫做负载因子,默认为0.75。自动扩容机制,是为了保证HashMap初始时不必占据太大的内存,而在使用期间又可以实时保证有足够大的空间。采用2的指数进行扩容,是为了利用位运算,提高扩容运算的效率。</p></blockquote><h1 id="19、数据库为什么不用红黑树而用B-树？"><a href="#19、数据库为什么不用红黑树而用B-树？" class="headerlink" title="19、数据库为什么不用红黑树而用B+树？"></a>19、数据库为什么不用红黑树而用B+树？</h1><blockquote><p>首先,红黑树是一种近似平衡二叉树（不完全平衡）,结点非黑即红的树,它的树高最高不会超过 2*log(n),因此查找的时间复杂度为 O(log(n)),无论是增删改查,它的性能都十分稳定； 但是,红黑树本质还是二叉树,在数据量非常大时,需要访问+判断的节点数还是会比较多,同时数据是存在磁盘上的,访问需要进行磁盘IO,导致效率较低； 而B+树是多叉的,可以有效减少磁盘IO次数；同时B+树增加了叶子结点间的连接,能保证范围查询时找到起点和终点后快速取出需要的数据。 </p></blockquote><h1 id="20、请你说说ArrayList和LinkedList的区别"><a href="#20、请你说说ArrayList和LinkedList的区别" class="headerlink" title="20、请你说说ArrayList和LinkedList的区别"></a>20、请你说说ArrayList和LinkedList的区别</h1><blockquote><ol><li>ArrayList的实现是基于数组,LinkedList的实现是基于双向链表。</li><li>对于随机访问ArrayList要优于LinkedList,ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问,而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起,查找某个元素的时间复杂度是O(N)。 </li><li>对于插入和删除操作,LinkedList要优于ArrayList,因为当元素被添加到LinkedList任意位置的时候,不需要像ArrayList那样重新计算大小或者是更新索引。 </li><li>LinkedList比ArrayList更占内存,因为LinkedList的节点除了存储数据,还存储了两个引用,一个指向前一个元素,一个指向后一个元素。</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2022-11月13日-每日面试题&quot;&gt;&lt;a href=&quot;#2022-11月13日-每日面试题&quot; class=&quot;headerlink&quot; title=&quot;2022 11月13日 每日面试题&quot;&gt;&lt;/a&gt;2022 11月13日 每日面试题&lt;/h1&gt;&lt;h1 id=&quot;1、谈谈你</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>每日面试题</title>
    <link href="https://manamn.space/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://manamn.space/2022/10/30/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-30T15:33:17.000Z</published>
    <updated>2022-12-13T13:01:49.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日面试题"><a href="#每日面试题" class="headerlink" title="每日面试题"></a>每日面试题</h1><h1 id="1、三次握手，四次挥手中，为什么要挥手四次"><a href="#1、三次握手，四次挥手中，为什么要挥手四次" class="headerlink" title="1、三次握手，四次挥手中，为什么要挥手四次"></a>1、三次握手，四次挥手中，为什么要挥手四次</h1><blockquote><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p></blockquote><h1 id="2、LinkedList和ArrayList的去重方法"><a href="#2、LinkedList和ArrayList的去重方法" class="headerlink" title="2、LinkedList和ArrayList的去重方法"></a>2、LinkedList和ArrayList的去重方法</h1><blockquote><p>方法1.  使用迭代器删除重复元素，可保持原来的顺序。</p><p>方法2. 使用hashset的无重复特性，不能保持原来的顺序。</p></blockquote><h1 id="3、事务的执行流程"><a href="#3、事务的执行流程" class="headerlink" title="3、事务的执行流程"></a>3、事务的执行流程</h1><blockquote><ol><li>查询数据若Buffer Pool存在，则输出，不存在则读取磁盘中的数据并放入Buffer Pool； </li><li>更新操作，会先将数据的旧值写入undo log，以便回滚。（保证原子性）； </li><li>更新Buffer Pool（内存）数据； </li><li>将更新数据写入到Redo Log Buffer（内存中）； </li><li>准备提交事务，会调用fsync将Redo Log Buffer的值刷入到redo log日志文件中，状态为prepare； </li><li>准备提交事务，binlog 日志写入磁盘； </li><li>binlog写入成功后，将redo log的状态变更为commit；</li></ol></blockquote><h1 id="4、对a-b-c三个字段建立联合索引，那么查询时使用其中的2个作为查询条件，是否还会走索引？"><a href="#4、对a-b-c三个字段建立联合索引，那么查询时使用其中的2个作为查询条件，是否还会走索引？" class="headerlink" title="4、对a,b,c三个字段建立联合索引，那么查询时使用其中的2个作为查询条件，是否还会走索引？"></a>4、对a,b,c三个字段建立联合索引，那么查询时使用其中的2个作为查询条件，是否还会走索引？</h1><blockquote><p>根据查询字段的位置不同来决定，如查询 a,     a,b    a,b,c    a,c   都可以走索引的，其他条件的查询不能走索引。组合索引 有“最左前缀”原则。 就是只从最左面的开始组合，并不是所有只要含有这三列存在的字段的查询都会用到该组合索引。</p></blockquote><h1 id="5、如果创建索引"><a href="#5、如果创建索引" class="headerlink" title="5、如果创建索引"></a>5、如果创建索引</h1><blockquote><p>1.手动创建按：create index 索引名称 on 表名(字段名) </p><p>2.自动创建：通过约束，系统创建</p></blockquote><h1 id="6、造轮子还是用轮子"><a href="#6、造轮子还是用轮子" class="headerlink" title="6、造轮子还是用轮子"></a>6、造轮子还是用轮子</h1><blockquote><p>按自己的理解来选择，逻辑通顺即可；例如：我选造轮子，因为自主创造能给予自己成就感。</p></blockquote><h1 id="7、mybatis的批量操作"><a href="#7、mybatis的批量操作" class="headerlink" title="7、mybatis的批量操作"></a>7、mybatis的批量操作</h1><blockquote><p>主要是批量删除，在xml文件中正常执行delet语句， 条件判断where id in(x,y,n),括号里的就是索要删除的编号，获得的方法就是对传过来的id集合进行遍历，获取到需要删除的id，然后正常执行sql语句</p></blockquote><h1 id="8、抽象类和接口的区别"><a href="#8、抽象类和接口的区别" class="headerlink" title="8、抽象类和接口的区别"></a>8、抽象类和接口的区别</h1><h1 id="9、介绍一下你最近做的一个的项目？"><a href="#9、介绍一下你最近做的一个的项目？" class="headerlink" title="9、介绍一下你最近做的一个的项目？"></a>9、介绍一下你最近做的一个的项目？</h1><blockquote><p>最近做的一个项目是必胜客宅急送，它是一个B2C模式的在线订餐系统，主要实现了商家与用户之间的在线订餐流程和追踪管理，主要技术栈： 后端主要是使用SSM框架+Redis缓存+MySQL进行开发的，前端主要是使用jsp、jstl、layui、handlebars模板引擎等，该系统主要有超级管理员和普通用户两个角色。 超级管理员拥有分类管理、餐品管理、用户管理、订单追踪等功能；用户拥有注册/登陆、地址管理、餐品挑选、购物车管理、订单管理等功能。 其中，分类管理主要是配合餐品的管理，可以对已有的分类进行修改或删除操作，对未有的分类进行添加。餐品管理主要是对线上的餐品进行一个 管理，可以添加、修改、上架/下架处理等，只有上架的商品用户才可以在菜单中进行选择，订单管理主要是针对当前平台中所有用户的订单进行 追踪，查看和一些操作等；普通用户在注册成功后，会自动登录，用户可以修改密码，完善信息等，比如添加送餐地址、送餐地址每位用户可以存在 多个不同的。普通用户也有订单追踪的功能模块，不过他和超级管理员的不同，用户查看的历史订单以及订单的状态只能是自己的。</p></blockquote><h1 id="10、-购物车的实现流程？"><a href="#10、-购物车的实现流程？" class="headerlink" title="10、 购物车的实现流程？"></a>10、 购物车的实现流程？</h1><blockquote><p>首先购物车的具备的功能有：用户可以在登录状态下将商品添加到购物车，用户可以在未登录状态下将商品添加到购物车，用户可以使用购物车一起结算下单，用户可以查询自己的购物车，用户可以在购物车中修改购买商品的数量。用户可以在购物车中删除商品。购物车中会展示商品优惠信息，提示购物车商品价格变化。每一个购物车信息，都是一个对象，因为购物车中不止一条数据，因此最终会是对象的数组；由于购物车是一个读多写多的场景，为了应对高并发场景，所有购物车采用的存储方案也和其他功能，有所差别。在该项目中我们采用的是redis + mysql，购物车的结构是一个双层Map：Map<String,Map<String,String>&gt; 第一层Map，Key是用户id，第二层Map，Key是购物车中商品id，值是购物车数据，user-key是游客id，不管有没有登录都会有这个cookie信息。 两个功能：新增商品到购物车、查询购物车。新增商品：判断是否登录，是：则添加商品到后台Redis+mysql中，把user的唯一标识符作为key。否：则添加商品到后台Redis+mysql中，使用随机生成的user-key作为key。查询购物车列表：判断是否登录否：直接根据user-key查询redis中数据并展示是：已登录，则需要先根据user-key查询redis是否有数据。有：需要先合并数据（redis + mysql），而后查询。否：直接去后台查询redis，而后返回。</p></blockquote><h1 id="11、同一个事务，多个人操作，会有什么问题？"><a href="#11、同一个事务，多个人操作，会有什么问题？" class="headerlink" title="11、同一个事务，多个人操作，会有什么问题？"></a>11、同一个事务，多个人操作，会有什么问题？</h1><blockquote><p>可能出现的问题，脏读，覆盖更新 关于这类问题一般会考虑到用数据库锁的机制来解决，数据库锁分为乐观锁和悲观锁 乐观锁 乐观锁并不锁住任何东西，而是在提交事务时检查自己上次读取这条记录后，是否有其他事务修改了这条记录，如果没有则提交，如果被修改了则回滚。如果并发的可能性并不大，那么锁定策略带来的性能消耗是非常小的 悲观锁 与乐观锁相比，悲观锁则是一把真正的锁了，它通过SQL语句“select for update”锁住数据，这时如果其他事务来更新时会等待，悲观锁会锁住整张表，性能较低，导致其他的事务不能访问</p></blockquote><h1 id="12、讲讲SSM整合"><a href="#12、讲讲SSM整合" class="headerlink" title="12、讲讲SSM整合"></a>12、讲讲SSM整合</h1><blockquote><p>1、准备工作      1)导入依赖     2）创建表     3）包结构 </p><p>2、配置web.xml </p><p>3、创建SpringMVC的配置文件并配置 </p><p>4、搭建MyBatis环境      1）创建属性文件jdbc.properties     2)创建MyBatis的核心配置文件mybatis-config.xml     3）创建Mapper接口和映射文件     4）创建日志文件log4j.xml </p><p>5、创建Spring的配置文件并配置 </p><p>6、测试功能      </p><p>1)创建组件     2）创建控制层组件Controller     3)创建接口Service及其实现类     4）创建页面     5)访问测试功能</p></blockquote><h1 id="13、如何保证用户模块的数据安全？"><a href="#13、如何保证用户模块的数据安全？" class="headerlink" title="13、如何保证用户模块的数据安全？"></a>13、如何保证用户模块的数据安全？</h1><blockquote><p>主要使用三类加密算法 对称加密算法 加密和解密使用相同的密钥。对称加密算法加密解密速度快，但安全性较差 常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES 非对称加密算法 加密和解密使用不同的密钥，也称为公私钥加密。非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比非对称加密慢上1000倍。但安全性比对称加密算法高 常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） Hash算法 Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。Hash算法常用在不可还原的密码存储、信息完整性校验等 常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p></blockquote><h1 id="14、Spring的常用方法"><a href="#14、Spring的常用方法" class="headerlink" title="14、Spring的常用方法"></a>14、Spring的常用方法</h1><blockquote><p>equals：字符串是否相同         </p><p>valueOf：其他类型转字符串             </p><p>charAt：获取指定下标位置的字符                 </p><p>concat：追加字符串到当前字符串 </p><p>isEmpty：字符串长度是否为0<br>contains：是否包含目标字符串        </p><p>startsWith：是否以目标字符串开头                </p><p>endsWith：是否以目标字符串结束 </p><p>format：格式化字符串               </p><p>getBytes：获取字符串的字节数组    </p><p>getChars：获取字符串的指定长度字符数组    </p><p>toCharArray：获取字符串的字符数组 </p><p>join：以某字符串，连接某字符串数组   </p><p>length：字符串字符数          </p><p>matches：字符串是否匹配正则表达式           </p><p>replace：字符串替换 </p><p>replaceAll：带正则字符串替换    </p><p>replaceFirst：替换第一个出现的目标字符串    </p><p>split：以某正则表达式分割字符串  </p><p>substring：截取字符串                              </p><p>toLowerCase：字符串转小写      </p><p>toUpperCase：字符串转大写</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;每日面试题&quot;&gt;&lt;a href=&quot;#每日面试题&quot; class=&quot;headerlink&quot; title=&quot;每日面试题&quot;&gt;&lt;/a&gt;每日面试题&lt;/h1&gt;&lt;h1 id=&quot;1、三次握手，四次挥手中，为什么要挥手四次&quot;&gt;&lt;a href=&quot;#1、三次握手，四次挥手中，为什么要挥手四</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="每日面试题" scheme="https://manamn.space/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法</title>
    <link href="https://manamn.space/2022/10/25/ES6%E8%AF%AD%E6%B3%95/"/>
    <id>https://manamn.space/2022/10/25/ES6%E8%AF%AD%E6%B3%95/</id>
    <published>2022-10-25T06:18:33.000Z</published>
    <updated>2022-12-13T13:07:16.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>能够说出使用let关键字声明变量的特点</li><li>能够使用解构赋值从数组中提取值</li><li>能够说出箭头函数拥有的特性</li><li>能够使用剩余参数接收剩余的函数参数</li><li>能够使用拓展运算符拆分数组</li><li>能够说出模板字符串拥有的特性</li></ul><h2 id="ES6相关概念（★★）"><a href="#ES6相关概念（★★）" class="headerlink" title="ES6相关概念（★★）"></a>ES6相关概念（★★）</h2><h3 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h3><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/es-version.png" alt=""></p><h3 id="为什么使用-ES6"><a href="#为什么使用-ES6" class="headerlink" title="为什么使用 ES6 ?"></a>为什么使用 ES6 ?</h3><p>每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。</p><ul><li>变量提升特性增加了程序运行时的不可预测性</li><li>语法过于松散，实现相同的功能，不同的人可能会写出不同的代码</li></ul><h2 id="ES6新增语法"><a href="#ES6新增语法" class="headerlink" title="ES6新增语法"></a>ES6新增语法</h2><h3 id="let（★★★）"><a href="#let（★★★）" class="headerlink" title="let（★★★）"></a>let（★★★）</h3><p>ES6中新增了用于声明变量的关键字</p><h4 id="let声明的变量只在所处于的块级有效"><a href="#let声明的变量只在所处于的块级有效" class="headerlink" title="let声明的变量只在所处于的块级有效"></a>let声明的变量只在所处于的块级有效</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a is not defined </span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    tmp = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/let%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt=""></p><p><strong>经典面试题图解：</strong>此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/let%E9%9D%A2%E8%AF%95%E9%A2%982.png" alt=""></p><p><strong>经典面试题图解：</strong>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>let关键字就是用来声明变量的</li><li>使用let关键字声明的变量具有块级作用域</li><li>在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的</li><li>防止循环变量变成全局变量</li><li>使用let关键字声明的变量没有变量提升</li><li>使用let关键字声明的变量具有暂时性死区特性</li></ul><h3 id="const（★★★）"><a href="#const（★★★）" class="headerlink" title="const（★★★）"></a>const（★★★）</h3><p>声明常量，常量就是值（内存地址）不能变化的量</p><h4 id="具有块级作用域"><a href="#具有块级作用域" class="headerlink" title="具有块级作用域"></a>具有块级作用域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure><h4 id="声明常量时必须赋值"><a href="#声明常量时必须赋值" class="headerlink" title="声明常量时必须赋值"></a>声明常量时必须赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span>; <span class="comment">// Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><h4 id="常量赋值后，值不能修改"><a href="#常量赋值后，值不能修改" class="headerlink" title="常量赋值后，值不能修改"></a>常量赋值后，值不能修改</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">100</span>; <span class="comment">// Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ary = [<span class="number">100</span>, <span class="number">200</span>];</span><br><span class="line">ary[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">ary[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ary); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]; </span></span><br><span class="line">ary = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>const声明的变量是一个常量</li><li>既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值</li><li>声明 const时候必须要给定值</li></ul><h3 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a>let、const、var 的区别</h3><ul><li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</li><li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</li><li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/var&amp;let&amp;const%E5%8C%BA%E5%88%AB.png" alt=""></p><h3 id="解构赋值（★★★）"><a href="#解构赋值（★★★）" class="headerlink" title="解构赋值（★★★）"></a>解构赋值（★★★）</h3><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)<span class="comment">//1</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(b)<span class="comment">//2</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(c)<span class="comment">//3</span></span><br><span class="line"><span class="comment">//如果解构不成功，变量的值为undefined</span></span><br></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &#x27;zhangsan&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: myName, <span class="attr">age</span>: myAge&#125; = person; <span class="comment">// myName myAge 属于别名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName); <span class="comment">// &#x27;zhangsan&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myAge); <span class="comment">// 20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>解构赋值就是把数据结构分解，然后给变量进行赋值</li><li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</li><li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li><li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li></ul><h3 id="箭头函数（★★★）"><a href="#箭头函数（★★★）" class="headerlink" title="箭头函数（★★★）"></a>箭头函数（★★★）</h3><p>ES6中新增的定义函数的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; &#123;&#125; <span class="comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;&#125;<span class="comment">//代表把一个函数赋值给fn</span></span><br></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//es6写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果形参只有一个，可以省略小括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span> (v) &#123;</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//es6写法</span></span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">fn</span> = v =&gt; v;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>&#125; </span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span> () &#123; </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//this 指向 是obj对象</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</span></span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">const</span> resFn = fn.<span class="title function_">call</span>(obj); </span><br><span class="line"> <span class="title function_">resFn</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li>箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁</li><li>箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line"><span class="attr">say</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">say</span>();<span class="comment">//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域</span></span><br></pre></td></tr></table></figure><h3 id="剩余参数（★★）"><a href="#剩余参数（★★）" class="headerlink" title="剩余参数（★★）"></a>剩余参数（★★）</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (first, ...args) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(first); <span class="comment">// 10</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(args); <span class="comment">// [20, 30] </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剩余参数和解构配合使用"><a href="#剩余参数和解构配合使用" class="headerlink" title="剩余参数和解构配合使用"></a>剩余参数和解构配合使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [s1, ...s2] = students; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1);  <span class="comment">// &#x27;wangwu&#x27; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);  <span class="comment">// [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ES6-的内置对象扩展"><a href="#ES6-的内置对象扩展" class="headerlink" title="ES6 的内置对象扩展"></a>ES6 的内置对象扩展</h2><h3 id="Array-的扩展方法（★★）"><a href="#Array-的扩展方法（★★）" class="headerlink" title="Array 的扩展方法（★★）"></a>Array 的扩展方法（★★）</h3><h4 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h4><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">...ary  <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...ary);    <span class="comment">// 1 2 3,相当于下面的代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="扩展运算符可以应用于合并数组"><a href="#扩展运算符可以应用于合并数组" class="headerlink" title="扩展运算符可以应用于合并数组"></a>扩展运算符可以应用于合并数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一 </span></span><br><span class="line"> <span class="keyword">let</span> ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> <span class="keyword">let</span> ary2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"> <span class="keyword">let</span> ary3 = [...ary1, ...ary2];</span><br><span class="line"> <span class="comment">// 方法二 </span></span><br><span class="line"> ary1.<span class="title function_">push</span>(...ary2);</span><br></pre></td></tr></table></figure><h5 id="将类数组或可遍历对象转换为真正的数组"><a href="#将类数组或可遍历对象转换为真正的数组" class="headerlink" title="将类数组或可遍历对象转换为真正的数组"></a>将类数组或可遍历对象转换为真正的数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oDivs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line">oDivs = [...oDivs];</span><br></pre></td></tr></table></figure><h4 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h4><p>将伪数组或可遍历对象转换为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个集合</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//转成数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; </span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;length&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newAry = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function"><span class="params">item</span> =&gt;</span> item *<span class="number">2</span>)<span class="comment">//[2,4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：如果是对象，那么属性需要写对应的索引</p><h4 id="实例方法：find"><a href="#实例方法：find" class="headerlink" title="实例方法：find()"></a>实例方法：find()</h4><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [&#123;</span><br><span class="line">     <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"> &#125;, &#123; </span><br><span class="line">     <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span></span><br><span class="line"> &#125;]; </span><br><span class="line"> <span class="keyword">let</span> target = ary.<span class="title function_">find</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item.<span class="property">id</span> == <span class="number">2</span>);<span class="comment">//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例方法：findIndex"><a href="#实例方法：findIndex" class="headerlink" title="实例方法：findIndex()"></a>实例方法：findIndex()</h4><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> index = ary.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value &gt; <span class="number">9</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a>实例方法：includes()</h4><p>判断某个数组是否包含给定的值，返回布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>) <span class="comment">// true </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a>String 的扩展方法</h3><h4 id="模板字符串（★★★）"><a href="#模板字符串（★★★）" class="headerlink" title="模板字符串（★★★）"></a>模板字符串（★★★）</h4><p>ES6新增的创建字符串的方式，使用反引号定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">`zhangsan`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="模板字符串中可以解析变量"><a href="#模板字符串中可以解析变量" class="headerlink" title="模板字符串中可以解析变量"></a>模板字符串中可以解析变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;张三&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> sayHello = <span class="string">`hello,my name is <span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// hello, my name is zhangsan</span></span><br></pre></td></tr></table></figure><h5 id="模板字符串中可以换行"><a href="#模板字符串中可以换行" class="headerlink" title="模板字符串中可以换行"></a>模板字符串中可以换行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> html = <span class="string">` &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt; `</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="在模板字符串中可以调用函数"><a href="#在模板字符串中可以调用函数" class="headerlink" title="在模板字符串中可以调用函数"></a>在模板字符串中可以调用函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;</span>;</span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">let</span> greet = <span class="string">`<span class="subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(greet); <span class="comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith() 和 endsWith()"></a>实例方法：startsWith() 和 endsWith()</h4><ul><li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li><li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">str.<span class="title function_">startsWith</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true </span></span><br><span class="line">str.<span class="title function_">endsWith</span>(<span class="string">&#x27;!&#x27;</span>)       <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h4><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>)      <span class="comment">// &quot;xxx&quot; </span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2</span>)  <span class="comment">// &quot;hellohello&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Set-数据结构（★★）"><a href="#Set-数据结构（★★）" class="headerlink" title="Set 数据结构（★★）"></a>Set 数据结构（★★）</h3><p>ES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成  Set  数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></table></figure><p>Set函数可以接受一个数组作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);<span class="comment">//&#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">3</span>); <span class="comment">// 向 set 结构中添加值 </span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>)             <span class="comment">// 删除 set 结构中的2值   </span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>)                <span class="comment">// 表示 set 结构中是否有1这个值 返回布尔值 </span></span><br><span class="line">s.<span class="title function_">clear</span>()               <span class="comment">// 清除 set 结构中的所有值</span></span><br><span class="line"><span class="comment">//注意：删除的是元素的值，不是代表的索引</span></span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6语法&quot;&gt;&lt;a href=&quot;#ES6语法&quot; class=&quot;headerlink&quot; title=&quot;ES6语法&quot;&gt;&lt;/a&gt;ES6语法&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目</summary>
      
    
    
    
    <category term="ES6" scheme="https://manamn.space/categories/ES6/"/>
    
    
    <category term="ES6" scheme="https://manamn.space/tags/ES6/"/>
    
    <category term="JavaScript" scheme="https://manamn.space/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC面试题</title>
    <link href="https://manamn.space/2022/10/25/%E9%9D%A2%E8%AF%95%E9%A2%98/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://manamn.space/2022/10/25/%E9%9D%A2%E8%AF%95%E9%A2%98/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-25T05:17:42.000Z</published>
    <updated>2022-12-13T12:56:18.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC面试题"><a href="#SpringMVC面试题" class="headerlink" title="SpringMVC面试题"></a>SpringMVC面试题</h1><h1 id="1、什么是-Spring-的-MVC-框架？"><a href="#1、什么是-Spring-的-MVC-框架？" class="headerlink" title="1、什么是 Spring 的 MVC 框架？"></a>1、什么是 Spring 的 MVC 框架？</h1><blockquote><p>Spring 配备构建 Web 应用的全功能 MVC 框架。Spring 可以很便捷地和其他MVC 框架集成，如 Struts，Spring 的 MVC 框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。</p></blockquote><h1 id="2、DispatcherServlet"><a href="#2、DispatcherServlet" class="headerlink" title="2、DispatcherServlet"></a>2、DispatcherServlet</h1><blockquote><p>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP请求和响应。</p></blockquote><h1 id="3、WebApplicationContext"><a href="#3、WebApplicationContext" class="headerlink" title="3、WebApplicationContext"></a>3、WebApplicationContext</h1><blockquote><p>WebApplicationContext 继承了 ApplicationContext 并增加了一些 WEB 应用必备的特有功能，它不同于一般的 ApplicationContext ，因为它能处理主题，并找到被关联的 servlet。</p></blockquote><h1 id="4、什么是-Spring-MVC-框架的控制器？"><a href="#4、什么是-Spring-MVC-框架的控制器？" class="headerlink" title="4、什么是 Spring MVC 框架的控制器？"></a>4、什么是 Spring MVC 框架的控制器？</h1><blockquote><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring 用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p></blockquote><h1 id="5、SpringMVC的执行流程"><a href="#5、SpringMVC的执行流程" class="headerlink" title="5、SpringMVC的执行流程"></a>5、SpringMVC的执行流程</h1><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/clipboard-1608014092374.png" alt="img" style="zoom:150%;" /></p><blockquote><p>1） 用户发送请求</p><p>2）前端控制器获得用户请求的URL，发送URL给处理器映射</p><p>3）处理器映射将Handler（包装方法信息）返回给前端控制器</p><p>4）前端控制器发送Handler给处理器适配器，适配器执行Handler方法</p><p>5）执行Handler方法后，返回ModelAndView（逻辑视图）给前端控制器</p><p>6）前端控制器将ModelAndView发送给视图解析器，解析出物理视图返回给前端控制器</p><p>7）前端控制器渲染视图，发送视图给用户</p></blockquote><h1 id="6、说说你对Spring-MVC的理解"><a href="#6、说说你对Spring-MVC的理解" class="headerlink" title="6、说说你对Spring MVC的理解"></a>6、说说你对Spring MVC的理解</h1><p>MVC是一种设计模式</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221020235338362.png" alt="image-20221020235338362"></p><blockquote><p>M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity）</p><p>V-View 视图（做界面的展示 jsp，html……）</p><p>C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面）</p><p>springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2</p><p>加上sring的整合，但是这里有一个疑惑就是，springMVC和spring是什么样的关系呢？这个在百度</p><p>百科上有一个很好的解释：意思是说，springMVC是spring的一个后续产品，其实就是spring在原</p><p>有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块</p><p>（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC</p><p>就是spring的一个子模块，所以根本不需要同spring进行整合。</p></blockquote><h1 id="7、SpringMVC常用的注解有哪些？"><a href="#7、SpringMVC常用的注解有哪些？" class="headerlink" title="7、SpringMVC常用的注解有哪些？"></a>7、SpringMVC常用的注解有哪些？</h1><blockquote><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户。</p></blockquote><h1 id="8、SpringMVC组件说明"><a href="#8、SpringMVC组件说明" class="headerlink" title="8、SpringMVC组件说明"></a>8、SpringMVC组件说明</h1><p>以下组件通常使用框架提供实现：</p><blockquote><p>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p><p>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p>HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。</p><p>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p><p><strong>组件：</strong></p><ol><li><p><strong>前端控制器DispatcherServlet(不需要工程师开发)，由框架提供</strong> ，</p><p><strong>作用 ：</strong> </p><p>接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。</p></li><li><p><strong>处理器映射器HandlerMapping (不需要工程师开发)，由框架提供</strong>，</p><p><strong>作用 ：</strong></p><p>根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p></li><li><p><strong>处理器适配器HandlerAdapter</strong></p><p><strong>作用 ：</strong></p><p>按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 </p></li><li><p><strong>处理器Handler(需要工程师开发)</strong> </p><p><strong>注意：编写Handler时按照HandlerAdapter的要求去做，</strong></p><p><strong>这样适配器才可以去正确执行Handler</strong> </p><p>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p></li><li><p><strong>视图解析器View resolver(不需要工程师开发),由框架提供</strong>，</p><p><strong>作用 ：</strong></p><p>进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p><p> springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p></li></ol></blockquote><p><strong>核心架构的具体流程步骤如下：</strong></p><blockquote><p>1、首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制； </p><p>2、DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略； </p><p>3、DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器； </p><p>4、HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</p><p> 5、ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图</p><p>名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</p><p> 6、View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术； </p><p>7、返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringMVC面试题&quot;&gt;&lt;a href=&quot;#SpringMVC面试题&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC面试题&quot;&gt;&lt;/a&gt;SpringMVC面试题&lt;/h1&gt;&lt;h1 id=&quot;1、什么是-Spring-的-MVC-框架？&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="SpringMVC" scheme="https://manamn.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试题</title>
    <link href="https://manamn.space/2022/10/25/%E9%9D%A2%E8%AF%95%E9%A2%98/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://manamn.space/2022/10/25/%E9%9D%A2%E8%AF%95%E9%A2%98/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-10-25T05:15:37.000Z</published>
    <updated>2022-10-25T06:32:06.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spirng面试题"><a href="#Spirng面试题" class="headerlink" title="Spirng面试题"></a>Spirng面试题</h1><h1 id="1、什么是Spring-？"><a href="#1、什么是Spring-？" class="headerlink" title="1、什么是Spring ？"></a>1、什么是Spring ？</h1><blockquote><p>Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用，但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。</p></blockquote><h1 id="2、使用Spring的好处是什么-？"><a href="#2、使用Spring的好处是什么-？" class="headerlink" title="2、使用Spring的好处是什么 ？"></a>2、使用Spring的好处是什么 ？</h1><ol><li><p><strong>轻量：</strong>Spring 是轻量的，基本的版本大约 2MB。</p></li><li><p><strong>控制反转：</strong>Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p></li><li><p><strong>面向切面的编程(AOP)：</strong>Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p></li><li><p><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。 </p></li><li><p><strong>MVC 框架</strong>：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。</p></li><li><p><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</p><p><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。</p></li></ol><h1 id="3、Spring由哪些模块组成-？"><a href="#3、Spring由哪些模块组成-？" class="headerlink" title="3、Spring由哪些模块组成 ？"></a>3、Spring由哪些模块组成 ？</h1><ul><li>Core           核心组件 ，提供IOC功能</li><li>Context        上下文组件，提供包的扫描、国际化、事件等功能</li><li>Beans         JavaBean的管理</li><li>SpEL           Spring表达式</li><li>AOP            面向切面编程</li><li>Test             集成单元测试</li><li>MVC            SpringMVC框架</li><li>JDBC           集成JDBC开发</li><li>ORM           数据库开发</li><li>Cloud          微服务开发框架</li><li>Securty       权限控制框架</li></ul><h1 id="4、核心容器-应用上下文模块"><a href="#4、核心容器-应用上下文模块" class="headerlink" title="4、核心容器(应用上下文模块)"></a>4、核心容器(应用上下文模块)</h1><blockquote><p>这是基本的 Spring 模块，提供 spring 框架的基础功能，BeanFactory 是 任何以 spring 为基础的应用的核心。Spring 框架建立在此模块之上，它使 Spring 成为一个容器。</p></blockquote><h1 id="5、-BeanFactory-–-BeanFactory-实现举例"><a href="#5、-BeanFactory-–-BeanFactory-实现举例" class="headerlink" title="5、 BeanFactory – BeanFactory 实现举例"></a>5、 BeanFactory – BeanFactory 实现举例</h1><blockquote><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。</p><p>最常用的 BeanFactory 实现是 XmlBeanFactory 类</p></blockquote><h1 id="6、AOP模块"><a href="#6、AOP模块" class="headerlink" title="6、AOP模块"></a>6、AOP模块</h1><blockquote><p>AOP 模块用于发给我们的 Spring 应用做面向切面的开发， 很多支持由 AOP 联盟提供，这样就确保了 Spring 和其他 AOP 框架的共通性。这个模块将元数据编程引入 Spring。</p></blockquote><h1 id="7、-解释JDBC抽象和DAO模块"><a href="#7、-解释JDBC抽象和DAO模块" class="headerlink" title="7、 解释JDBC抽象和DAO模块"></a>7、 解释JDBC抽象和DAO模块</h1><blockquote><p>通过使用 JDBC 抽象和 DAO 模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用 Spring 的 AOP 模块给 Spring 应用中的对象提供事务管理服务。</p></blockquote><h1 id="8、WEB模块"><a href="#8、WEB模块" class="headerlink" title="8、WEB模块"></a>8、WEB模块</h1><blockquote><p>Spring 的 WEB 模块是构建在 application context 模块基础之上，提供一个适合 web 应用的上下文。这个模块也包括支持多种面向 web 的任务，如透明地处理多个文件上传请求和程序级请求参数的绑定到你的业务对象。它也有对 JakartaStruts 的支持。</p></blockquote><h1 id="9、你们项目中为什么使用Spring框架？"><a href="#9、你们项目中为什么使用Spring框架？" class="headerlink" title="9、你们项目中为什么使用Spring框架？"></a>9、你们项目中为什么使用Spring框架？</h1><blockquote><ul><li><p><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB。</p></li><li><p><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</p></li><li><p><strong>面向切面的编程</strong>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</p></li><li><p><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。</p></li><li><p><strong>MVC框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</p></li><li><p><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</p></li><li><p><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p></li></ul></blockquote><h1 id="10、什么是-Spring-IOC-容器？"><a href="#10、什么是-Spring-IOC-容器？" class="headerlink" title="10、什么是 Spring IOC 容器？"></a>10、什么是 Spring IOC 容器？</h1><blockquote><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期</p></blockquote><h1 id="11、-说说你对Spring的IOC的理解-？"><a href="#11、-说说你对Spring的IOC的理解-？" class="headerlink" title="11、 说说你对Spring的IOC的理解 ？"></a>11、 说说你对Spring的IOC的理解 ？</h1><blockquote><p>（1）IOC就是控制反转，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</p><p>（2）最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</p><p>（3）Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件</p></blockquote><h1 id="12、-IOC的作用？"><a href="#12、-IOC的作用？" class="headerlink" title="12、 IOC的作用？"></a>12、 IOC的作用？</h1><blockquote><p>IOC的主要作用是：解耦。</p><p>解耦，是降低程序耦合度，也就是减少程序代码之间的依赖性，如果代码之间的依赖性很高，修改一处代码会影响很多其他的代码，这就给项目的稳定性带来的问题，不利于代码的扩展和维护。</p><p>没有IOC的程序中，我们使用new来完成对象的创建，如果需要的对象的类型发生改变，就需要手动修改代码。</p><p>有了IOC后，对象的创建由第三方（Spring容器）完成，由Spring来管理应用中所有对象的生命周期，开发者只需要关注自己的业务逻辑，代码更利于扩展和维护。</p></blockquote><h1 id="13、什么是DI-？"><a href="#13、什么是DI-？" class="headerlink" title="13、什么是DI ？"></a>13、什么是DI ？</h1><blockquote><p>DI（Dependency Injection）依赖注入，是IOC另一种说法，也就是对象由容器来管理，注入到我们需要依赖中。</p><p>生活中的DI：我们身体不生产疫苗，由医院生产，需要的使用再注射进来。</p></blockquote><h1 id="14、容器的分类"><a href="#14、容器的分类" class="headerlink" title="14、容器的分类"></a>14、容器的分类</h1><p>Spring的IOC容器分为两种：</p><p>1）BeanFactory</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最简单的容器，给 DI 提供了基本的支持，它用 org.springframework.beans.factory.BeanFactory 接口来定义。BeanFactory 或者相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，在 Spring 中仍然存在具有大量的与 Spring 整合的第三方框架的反向兼容性的目的。</span><br></pre></td></tr></table></figure><p>2）ApplicationContext</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">继承了BeanFactory，添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。通常推荐使用 ApplicationContext。</span><br><span class="line">ApplicationContext 接口的主要实现：</span><br><span class="line">1) FileSystemXmlApplicationContext </span><br><span class="line"><span class="code">基于文件系统中XML文件配置的应用程序上下文</span></span><br><span class="line"><span class="code">2) ClassPathXmlApplicationContext </span></span><br><span class="line"><span class="code">基于ClassPath路径中XML文件配置的应用程序上下文</span></span><br><span class="line"><span class="code">3) AnnotationConfigApplicationConext </span></span><br><span class="line"><span class="code">基于注解配置的应用程序上下文</span></span><br></pre></td></tr></table></figure><h1 id="15、-Bean-工厂和-Application-contexts-有什么区别？"><a href="#15、-Bean-工厂和-Application-contexts-有什么区别？" class="headerlink" title="15、 Bean 工厂和 Application contexts 有什么区别？"></a>15、 Bean 工厂和 Application contexts 有什么区别？</h1><blockquote><p>Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在Application contexts 中以声明的方式处理。Application contexts 实现了MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p></blockquote><h1 id="16、一个Spring容器看起来像什么-？"><a href="#16、一个Spring容器看起来像什么-？" class="headerlink" title="16、一个Spring容器看起来像什么 ？"></a>16、一个Spring容器看起来像什么 ？</h1><blockquote><p>一个定义了一些功能的接口。</p><p>这实现包括属性，它的 Setter ， getter 方法和函数等。</p><p>Spring AOP。</p><p>Spring 的 XML 配置文件。</p><p>使用以上功能的客户端程序</p></blockquote><h1 id="17、-什么是-Spring-beans"><a href="#17、-什么是-Spring-beans" class="headerlink" title="17、 什么是 Spring beans?"></a>17、 什么是 Spring beans?</h1><blockquote><p>Spring beans 是那些形成 Spring 应用的主干的 java 对象。它们被 Spring IOC容器初始化，装配，和管理。这些 beans 通过容器中配置的元数据创建。比如，以 XML 文件中 的形式定义。</p><p>Spring 框架定义的 beans 都是单件 beans。在 bean tag 中有个属性”singleton”，如果它被赋为 TRUE，bean 就是单件，否则就是一个 prototype bean。默认是 TRUE，所以所有在 Spring 框架中的 beans 缺省都是单件。</p></blockquote><h1 id="18、-你怎样定义类的作用域-？"><a href="#18、-你怎样定义类的作用域-？" class="headerlink" title="18、 你怎样定义类的作用域 ？"></a>18、 你怎样定义类的作用域 ？</h1><blockquote><p>当定义一个 在 Spring 里，我们还能给这个 bean 声明一个作用域。它可以通过bean 定义中的 scope 属性来定义。如，当 Spring 要在需要的时候每次生产一个新的 bean 实例，bean 的 scope 属性被指定为 prototype。另一方面，一个 bean每次使用的时候必须返回同一个实例，这个 bean 的 scope 属性 必须设为singleton。</p></blockquote><h1 id="19、-解释-Spring-支持的几种-bean-的作用域"><a href="#19、-解释-Spring-支持的几种-bean-的作用域" class="headerlink" title="19、 解释 Spring 支持的几种 bean 的作用域"></a>19、 解释 Spring 支持的几种 bean 的作用域</h1><blockquote><p><strong>singleton :</strong> bean 在每个 Spring ioc 容器中只有一个实例。</p><p><strong>prototype</strong>：一个 bean 的定义可以有多个实例。</p><p><strong>request</strong>：每次 http 请求都会创建一个 bean，该作用域仅在基于 web的 Spring ApplicationContext 情形下有效。</p><p><strong>session</strong>：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</p><p><strong>global-session</strong>：在一个全局的 HTTP Session 中，一个 bean 定义对应</p><p>一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</p></blockquote><h1 id="20、Spring-框架中的单例-bean-是线程安全的吗"><a href="#20、Spring-框架中的单例-bean-是线程安全的吗" class="headerlink" title="20、Spring 框架中的单例 bean 是线程安全的吗?"></a>20、Spring 框架中的单例 bean 是线程安全的吗?</h1><blockquote><p>不，Spring 框架中的单例 bean 不是线程安全的。</p></blockquote><h1 id="21、解释-Spring-框架中-bean-的生命周期"><a href="#21、解释-Spring-框架中-bean-的生命周期" class="headerlink" title="21、解释 Spring 框架中 bean 的生命周期"></a>21、解释 Spring 框架中 bean 的生命周期</h1><blockquote><p>Spring 容器 从 XML 文件中读取 bean 的定义，并实例化 bean。</p><p>Spring 根据 bean 的定义填充所有的属性。</p><p>如果 bean 实现了 BeanNameAware 接口，Spring 传递 bean 的 ID 到setBeanName 方法。</p><p>如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递beanfactory 给 setBeanFactory 方法。</p><p>如果有任何与 bean 相关联的 BeanPostProcessors，Spring 会在postProcesserBeforeInitialization()方法内调用它们。</p><p>如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，</p><p>如果 bean 声明了初始化方法，调用此初始化方法。</p><p>如果有 BeanPostProcessors 和 bean 关联，这些 bean 的postProcessAfterInitialization() 方法将被调用。</p><p>如果 bean 实现了 DisposableBean，它将调用 destroy()方法。</p></blockquote><h1 id="22、解释不同方式的自动装配"><a href="#22、解释不同方式的自动装配" class="headerlink" title="22、解释不同方式的自动装配"></a>22、解释不同方式的自动装配</h1><p>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p><blockquote><p><strong>no</strong>：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。</p><p><strong>byName：</strong>通过参数名 自动装配，Spring 容器在配置文件中发现 bean的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。</p><p><strong>byType:：</strong>通过参数类型自动装配，Spring 容器在配置文件中发现 bean的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</p><p><strong>constructor：这个方式类似于</strong> byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</p><p><strong>autodetect：</strong>首先尝试使用 constructor 来自动装配，如果无法工作，使用 byType 方式。</p></blockquote><h1 id="23、自动装配有哪些局限性"><a href="#23、自动装配有哪些局限性" class="headerlink" title="23、自动装配有哪些局限性 ?"></a>23、自动装配有哪些局限性 ?</h1><blockquote><p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。</p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p><strong>模糊特性：</strong>自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p></blockquote><h1 id="24、什么是基于-Java-的-Spring-注解配置"><a href="#24、什么是基于-Java-的-Spring-注解配置" class="headerlink" title="24、什么是基于 Java 的 Spring 注解配置?"></a>24、什么是基于 Java 的 Spring 注解配置?</h1><blockquote><p>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring配置而非通过 XML 文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被Spring IOC 容器使用。</p><p>另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。</p></blockquote><h1 id="25、怎样开启注解装配？"><a href="#25、怎样开启注解装配？" class="headerlink" title="25、怎样开启注解装配？"></a>25、怎样开启注解装配？</h1><blockquote><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在 Spring 配置文件中配置 context:annotation-config/元素。</p></blockquote><h1 id="26、-Required-注解"><a href="#26、-Required-注解" class="headerlink" title="26、@Required 注解"></a>26、<strong>@Required</strong> 注解</h1><blockquote><p>这个注解表明 bean 的属性必须在配置的时候设置，通过一个 bean 定义的显式的属性值或通过自动装配，若@Required 注解的 bean 属性未被设置，容器将抛出BeanInitializationException。</p></blockquote><h1 id="27、-Autowired-注解"><a href="#27、-Autowired-注解" class="headerlink" title="27、@Autowired 注解"></a>27、<strong>@Autowired</strong> 注解</h1><blockquote><p>@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required 一样，修饰 setter 方法、构造器、属性或者具有任意名称和/或多个参数的 PN 方法。</p></blockquote><h1 id="28、-Qualifier-注解"><a href="#28、-Qualifier-注解" class="headerlink" title="28、@Qualifier 注解"></a>28、<strong>@Qualifier</strong> 注解</h1><blockquote><p>当有多个相同类型的 bean 却只有一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用以消除这种混淆，指定需要装配的确切的 bean。</p></blockquote><h1 id="29、Autowired和Resource关键字的区别？"><a href="#29、Autowired和Resource关键字的区别？" class="headerlink" title="29、Autowired和Resource关键字的区别？"></a>29、Autowired和Resource关键字的区别？</h1><blockquote><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p></blockquote><p>1、共同点</p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p>2、不同点</p><p>（1）@Autowired</p><blockquote><p>@Autowired为Spring提供的注解，需要导入包</p><p>org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualififier注解一起使用。如下：</p></blockquote><p>（2）@Resource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="comment">// 下面两种@Autowired只要使用一种即可</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的方法上</span></span><br><span class="line"> <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）@Resource</p><blockquote><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</p><p>@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为</p><p>bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自</p><p>动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属</p><p>性，这时将通过反射机制使用byName自动注入策略。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="comment">// 下面两种@Resource只要使用一种即可</span></span><br><span class="line"> <span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的setter方法上</span></span><br><span class="line"> <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p></blockquote><h1 id="30-、Spring-框架中的单例-Bean-是线程安全的么？"><a href="#30-、Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="30 、Spring 框架中的单例 Bean 是线程安全的么？"></a>30 、Spring 框架中的单例 Bean 是线程安全的么？</h1><blockquote><p>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。</p><ul><li><p>关于单例 Bean 的线程安全和并发问题，需要开发者自行去搞定。</p></li><li><p>单例的线程安全问题，并不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</p></li><li><p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态，所以在某种程度上说 Spring 的单例</p><p>Bean 是线程安全的。如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办</p><p>法，就是将多态 Bean 的作用域（Scope）由 Singleton 变更为 Prototype。</p></li></ul></blockquote><h1 id="31、Spring-是怎么解决循环依赖的？"><a href="#31、Spring-是怎么解决循环依赖的？" class="headerlink" title="31、Spring 是怎么解决循环依赖的？"></a>31、Spring 是怎么解决循环依赖的？</h1><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221025102039414.png" alt="image-20221025102039414"></p><blockquote><p>整个流程大致如下：</p><ol><li><p>首先 A 完成初始化第一步并将自己<strong>提前曝光</strong>出来（通过 ObjectFactory 将自己提前曝光），在初始化的时候，发现自己依赖对象 B，此时就会去尝试 get(B)，这个时候发现 B 还没有被创建出来；</p></li><li><p>然后 B 就走创建流程，在 B 初始化的时候，同样发现自己依赖 C，C 也没有被创建出来；</p></li><li><p>这个时候 C 又开始初始化进程，但是在初始化的过程中发现自己依赖 A，于是尝试 get(A)。这个时候由于 A 已经添加至缓存中（一般都是添加至三级缓存 singletonFactories），通过ObjectFactory 提前曝光，所以可以通过 ObjectFactory#getObject() 方法来拿到 A 对象。C 拿到 A 对象后顺利完成初始化，然后将自己添加到一级缓存中；</p></li><li><p>回到 B，B 也可以拿到 C 对象，完成初始化，A 可以顺利拿到 B 完成初始化。到这里整个链路就已经完成了初始化过程了。</p></li></ol><p>关键字：三级缓存，提前曝光。</p></blockquote><h1 id="32、-事务的隔离级别"><a href="#32、-事务的隔离级别" class="headerlink" title="32、 事务的隔离级别"></a>32、 事务的隔离级别</h1><blockquote><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</p><p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</p><p>可重复读(Repeated Read)：在同一个事务内的查询都是事务开始时刻一致的，Mysql的InnoDB默</p><p>认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读（多个事务同时修改同一条记录，事务之间不知道彼此存在，当事务提交之后，后面的事务修改的数据将会覆盖前事务，前一个事务就像发生幻觉一样）</p><p>可串行化(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221025101747416.png" alt="image-20221025101747416"></p><p>不可重复读和幻读的区别主要是：解决不可重复读需要锁定了当前满足条件的记录，而解决幻读需</p><p>要锁定当前满足条件的记录及相近的记录。比如查询某个商品的信息，可重复读事务隔离级别可以</p><p>保证当前商品信息被锁定，解决不可重复读；但是如果统计商品个数，中途有记录插入，可重复读</p><p>事务隔离级别就不能保证两个事务统计的个数相同。</p></blockquote><h1 id="33、Spring事务的传播级别"><a href="#33、Spring事务的传播级别" class="headerlink" title="33、Spring事务的传播级别"></a>33、Spring事务的传播级别</h1><blockquote><p>Spring事务定义了7种传播机制：</p><ol><li>PROPAGATION_REQUIRED:默认的Spring事物传播级别，若当前存在事务，则加入该事务，若</li></ol><p>不存在事务，则新建一个事务。</p><ol><li>PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建</li></ol><p>一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。</p><ol><li>PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，</li></ol><p>则新建一个事务，类似于REQUIRE_NEW。</p><ol><li><p>PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行。</p></li><li><p>PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂起。</p></li><li><p>PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常.</p></li><li><p>PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。</p></li></ol><p>Spring事务传播级别一般不需要定义，默认就是PROPAGATION_REQUIRED，除非在嵌套事务的情</p><p>况下需要重点了解。</p></blockquote><h1 id="34、Spring支持的事务管理系统"><a href="#34、Spring支持的事务管理系统" class="headerlink" title="34、Spring支持的事务管理系统"></a>34、Spring支持的事务管理系统</h1><blockquote><p>Spring 支持两种类型的事务管理：</p><p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p><strong>声明式事务管理：</strong>这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。</p></blockquote><h1 id="35、Spring-框架的事务管理有哪些优点？"><a href="#35、Spring-框架的事务管理有哪些优点？" class="headerlink" title="35、Spring 框架的事务管理有哪些优点？"></a>35、Spring 框架的事务管理有哪些优点？</h1><blockquote><p>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。它为编程式事务</p><p>管理提供了一个简单的API而非一系列复杂的事务API(如JTA).它支持声明式事务管理。</p><p>它可以和Spring 的多种数据访问技术很好的融合。</p><p>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。</p><p>它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).它支持声明式事务管理。</p><p>它可以和Spring 的多种数据访问技术很好的融合。</p><p>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。它为编程式事务</p><p>管理提供了一个简单的API而非一系列复杂的事务API(如JTA).它支持声明式事务管理。它可以和</p><p>Spring 的多种数据访问技术很好的融合。</p></blockquote><h1 id="36、事务的三要素"><a href="#36、事务的三要素" class="headerlink" title="36、事务的三要素"></a>36、事务的三要素</h1><blockquote><p><strong>数据源</strong>：表示具体的事务性资源，是事务的真正处理者，如MySQL等。</p><p><strong>事务管理器</strong>：像一个大管家，从整体上管理事务的处理过程，如打开、提交、回滚等。</p><p><strong>事务应用和属性配置</strong>：像一个标识符，表明哪些方法要参与事务，如何参与事务，以及一些相关属性如隔离级别、超时时间等。</p></blockquote><h1 id="37、事务的本质是什么？"><a href="#37、事务的本质是什么？" class="headerlink" title="37、事务的本质是什么？"></a>37、事务的本质是什么？</h1><blockquote><p>@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并<strong>使用这些元数据来配置 bean</strong>的事务行为<strong>。 大致来说具有两方面功能，一是表明该方法要参与事务</strong>，<strong>二是配置相关属性来定制事务的参与方式和运行行为</strong></p><p>声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后/周围进行事务性增（advice），来驱动事务完成。</p><p>@Transactional注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所</p><p>有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是public的。</p></blockquote><h1 id="38、谈谈你对AOP的理解？"><a href="#38、谈谈你对AOP的理解？" class="headerlink" title="38、谈谈你对AOP的理解？"></a>38、谈谈你对AOP的理解？</h1><blockquote><p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p><p>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20221025102640718.png" alt="image-20221025102640718"></p><p>注意：图中的implements和extend。即一个是接口，一个是实现类。</p><p>当然也可以使用AspectJ，Spring AOP中已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了AOP。</p></blockquote><h1 id="39、SpringAOP和AspectJ-AOP有什么区别-？"><a href="#39、SpringAOP和AspectJ-AOP有什么区别-？" class="headerlink" title="39、SpringAOP和AspectJ AOP有什么区别 ？"></a>39、SpringAOP和AspectJ AOP有什么区别 ？</h1><blockquote><p>Spring AOP是属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。</p><p>AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多</p></blockquote><h1 id="40、AOP的两种代理方式"><a href="#40、AOP的两种代理方式" class="headerlink" title="40、AOP的两种代理方式"></a>40、AOP的两种代理方式</h1><blockquote><p>Spring 提供了 JDK CGLib 种方式来生成代理对象，具体生成代理对象的方式由AopProxyFactory 根据 AdvisedSupport 象的配置来决定。 Spring 默认的代理对象生成策略为:如果是目标类接口，则使用 JDK 动态代理技术，否则使用 CGLib 动态代理技术</p></blockquote><p><strong>JDK 动态代理</strong> </p><blockquote><p>JDK 动态代理主要通过 java.lang.reflect 包中 Proxy 类和1n vocationHandler 接口来实现。 </p><p>1nvocationHandler 一个接口，不同的实现类定义不同的横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编制在一起。</p><p>Proxy 类利用 InvocationHandl er 动态创建一个符合某一接口的实例，生成目标类的代理对象。</p></blockquote><p> <code>JDK .8 Proxy 类的定义如下。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Ser alizable &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID -<span class="number">2222568056686623797L</span>; </span><br><span class="line">/ 在构造方法参数中定义不同的 Inv cationHandler 实现类</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams </span><br><span class="line">&#123; InvocationHandler . class &#125;; </span><br><span class="line"><span class="comment">//2 : pr xy 类缓存列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[] , Class&lt;?&gt;&gt; </span><br><span class="line">proxyClassCache <span class="keyword">new</span> <span class="title class_">WeakCache</span>&lt;&gt; (<span class="keyword">new</span> <span class="title class_">KeyFactory</span>() , <span class="keyword">new</span> </span><br><span class="line"><span class="title class_">ProxyClassFactory</span>()); </span><br><span class="line"><span class="comment">// 当前代理需要调用的 Handler 实例对象(该对象需要经过序列</span></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h; </span><br><span class="line">/ / .. .此处忽略部分实现</span><br><span class="line">/ /<span class="number">4</span>: proxy 类构造函数 参数 InvocationHandler 为当前代理的对象</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(Invocat onHandler h)</span> ( </span><br><span class="line">Objects .requireNonNull(h) ; </span><br><span class="line"><span class="built_in">this</span>.h h;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>CGLib 动态代理</strong> </p><blockquote><p>CGLib Code Gen ti on Library ，它是一个高性能的代码生成类库 可以在运行期间扩展 Java类和实现 Java 接口 CGLib 包的底层通过字</p><p>节码处理框架 ASM 来实现，通过转换字节码生成新的类。</p></blockquote><p><strong>CGLib 动态代理和 JDK 动态代理的区别</strong> </p><blockquote><p>JDK 只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则只能通过 CGLib 创建动态代理来实现。</p></blockquote><h1 id="41、在Spring-AOP-中，关注点和横切关注的区别是什么？"><a href="#41、在Spring-AOP-中，关注点和横切关注的区别是什么？" class="headerlink" title="41、在Spring AOP 中，关注点和横切关注的区别是什么？"></a>41、在Spring AOP 中，关注点和横切关注的区别是什么？</h1><blockquote><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p>那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</p><p>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p></blockquote><h1 id="42、-什么是通知呢？又哪些类型？"><a href="#42、-什么是通知呢？又哪些类型？" class="headerlink" title="42、 什么是通知呢？又哪些类型？"></a>42、 什么是通知呢？又哪些类型？</h1><blockquote><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用五种类型的通知：</p><ul><li><p><strong>before</strong>：前置通知，在一个方法执行前被调用。</p></li><li><p><strong>after:</strong> 在方法执行之后调用的通知，无论方法执行是否成功。</p></li><li><p><strong>after-returning:</strong> 仅当方法成功完成后执行的通知。</p></li><li><p><strong>after-throwing:</strong> 在方法抛出异常退出时执行的通知。</p></li><li><p><strong>around:</strong> 在方法执行之前和之后调用的通知。</p></li></ul></blockquote><h1 id="43、Spring框架中都用到了哪些设计模式？"><a href="#43、Spring框架中都用到了哪些设计模式？" class="headerlink" title="43、Spring框架中都用到了哪些设计模式？"></a>43、Spring框架中都用到了哪些设计模式？</h1><blockquote><ul><li><p><strong>简单工厂模式</strong>：Spring 中的 BeanFactory 就是简单工厂模式的体现。根据传入一个唯一的标识来获得 Bean 对象，但是在传入参数后创建还是传入参数前创建，要根据具体情况来定。</p></li><li><p><strong>工厂模式</strong>：Spring 中的 FactoryBean 就是典型的工厂方法模式，实现了 FactoryBean 接口的 bean是一类叫做 factory 的 bean。其特点是，spring 在使用 getBean() 调用获得该 bean 时，会自动调用该 bean 的 getObject() 方法，所以返回的不是 factory 这个 bean，而是这个 bean.getOjbect()方法的返回值。</p></li><li><p><strong>单例模式</strong>：在 spring 中用到的单例模式有： scope=”singleton” ，注册式单例模式，bean 存放于Map 中。bean name 当做 key，bean 当做 value。</p></li><li><p><strong>原型模式</strong>：在 spring 中用到的原型模式有： scope=”prototype” ，每次获取的是通过克隆生成的新实例，对其进行修改时对原有实例对象不造成任何影响。</p></li><li><p><strong>迭代器模式</strong>：在 Spring 中有个 CompositeIterator 实现了 Iterator，Iterable 接口和 Iterator 接口，这两个都是迭代相关的接口。可以这么认为，实现了 Iterable 接口，则表示某个对象是可被迭代的。Iterator 接口相当于是一个迭代器，实现了 Iterator 接口，等于具体定义了这个可被迭代的对象时如何进行迭代的。</p></li><li><p><strong>代理模式</strong>：Spring 中经典的 AOP，就是使用动态代理实现的，分 JDK 和 CGlib 动态代理。</p></li><li><p><strong>适配器模式</strong>：Spring 中的 AOP 中 AdvisorAdapter 类，它有三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapter、ThrowsAdviceAdapter。Spring会根据不同的 AOP 配置来使用对应的 Advice，与策略模式不同的是，一个方法可以同时拥有多个Advice。Spring 存在很多以 Adapter 结尾的，大多数都是适配器模式。</p></li><li><p><strong>观察者模式</strong>：Spring 中的 Event 和 Listener。spring 事件：ApplicationEvent，该抽象类继承了EventObject 类，JDK 建议所有的事件都应该继承自 EventObject。spring 事件监听器：ApplicationListener，该接口继承了 EventListener 接口，JDK 建议所有的事件监听器都应该继承EventListener。</p></li><li><p><strong>模板模式</strong>：Spring 中的 org.springframework.jdbc.core.JdbcTemplate 就是非常经典的模板模式的应用，里面的 execute 方法，把整个算法步骤都定义好了。</p></li><li><p><strong>责任链模式</strong>：DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理。HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式。</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spirng面试题&quot;&gt;&lt;a href=&quot;#Spirng面试题&quot; class=&quot;headerlink&quot; title=&quot;Spirng面试题&quot;&gt;&lt;/a&gt;Spirng面试题&lt;/h1&gt;&lt;h1 id=&quot;1、什么是Spring-？&quot;&gt;&lt;a href=&quot;#1、什么是Spring-</summary>
      
    
    
    
    <category term="面试题" scheme="https://manamn.space/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="https://manamn.space/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="Spring" scheme="https://manamn.space/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>学习MyBatis-Plus3这一篇就够了</title>
    <link href="https://manamn.space/2022/10/18/%E5%AD%A6%E4%B9%A0MyBatis-Plus3%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://manamn.space/2022/10/18/%E5%AD%A6%E4%B9%A0MyBatis-Plus3%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</id>
    <published>2022-10-18T03:11:26.000Z</published>
    <updated>2022-10-25T06:32:39.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-MyBatis-Plus3概述"><a href="#第一章-MyBatis-Plus3概述" class="headerlink" title="第一章 MyBatis-Plus3概述"></a>第一章 MyBatis-Plus3概述</h2><h3 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h3><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>我们的愿景是成为 MyBatis 最好的搭档，就像魂斗罗中的1P、2P，基友搭配，效率翻倍。</p><h3 id="1-2、特性"><a href="#1-2、特性" class="headerlink" title="1.2、特性"></a>1.2、特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 </li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 </li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 </li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 </li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 </li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 </li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ） </li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 </li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 </li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 </li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 </li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="1-3、框架结构"><a href="#1-3、框架结构" class="headerlink" title="1.3、框架结构"></a>1.3、框架结构</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/65f466de040a62eab8cda68ecab3578a.png" alt="img"></p><h3 id="1-4、项目地址"><a href="#1-4、项目地址" class="headerlink" title="1.4、项目地址"></a>1.4、项目地址</h3><p><strong>官网地址</strong>： <a href="https://baomidou.com/">点击打开</a></p><p><strong>源码地址</strong>： <a href="https://github.com/baomidou/mybatis-plus">点击打开</a></p><p><strong>文档地址</strong>： <a href="https://baomidou.com/guide/">点击打开</a></p><p><strong>配置地址</strong>： <a href="https://baomidou.com/config/">点击打开</a></p><h3 id="1-5、版本介绍"><a href="#1-5、版本介绍" class="headerlink" title="1.5、版本介绍"></a>1.5、版本介绍</h3><p>全新的 MyBatis-Plus 3.0 版本基于 JDK8，提供了 lambda 形式的调用，所以安装集成 MP3.0 要求如下：</p><ul><li>JDK 8+ </li><li>Maven or Gradle</li></ul><h3 id="1-6、快速安装"><a href="#1-6、快速安装" class="headerlink" title="1.6、快速安装"></a>1.6、快速安装</h3><ul><li><p>Spring Boot </p><ul> -  Maven： <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>3.4.0</version></dependency>  -  Gradle： compile group: 'com.baomidou', name: 'mybatis-plus-boot-starter', version: '3.4.0'  </ul>  </li><li><p>Spring MVC </p><ul> -  Maven： <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus</artifactId> <version>3.4.0</version></dependency>  -  Gradle： compile group: 'com.baomidou', name: 'mybatis-plus', version: '3.4.0'  </ul> </li></ul><blockquote><p>警告：引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</p></blockquote><h3 id="1-7、开发环境"><a href="#1-7、开发环境" class="headerlink" title="1.7、开发环境"></a>1.7、开发环境</h3><ul><li>Jdk：jdk1.8.0_261 </li><li>Idea：IntelliJ IDEA 2020.1.2 x64 </li><li>Maven：apache-maven-3.3.9 </li><li>MySQL：mysql-5.5.61-win64</li></ul><h2 id="第二章-MyBatis-Plus3增删改查"><a href="#第二章-MyBatis-Plus3增删改查" class="headerlink" title="第二章 MyBatis-Plus3增删改查"></a>第二章 MyBatis-Plus3增删改查</h2><h3 id="2-1、项目搭建"><a href="#2-1、项目搭建" class="headerlink" title="2.1、项目搭建"></a>2.1、项目搭建</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/8be2ec054e4a7b740f7adb4df6906189.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6c3b9654874782e1102fff95eef1bcd7.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7e7a8d317a71928953d45116e5dd061e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/af2a6e8b43a2be67485d3f4887c66917.png" alt="img"></p><p>新建完成以后，打开pom.xml后添加以下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.1</span><span class="number">.49</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.18</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在src/main/java目录中，创建以下包文件</p><ul><li>com.caochenlei.mpdemo.pojo </li><li>com.caochenlei.mpdemo.mapper</li></ul><h3 id="2-2、项目配置（1）"><a href="#2-2、项目配置（1）" class="headerlink" title="2.2、项目配置（1）"></a>2.2、项目配置（1）</h3><p>MyBatis-Plus 的配置异常的简单，我们仅需要一些简单的配置即可使用 MyBatis-Plus 的强大功能！</p><ul><li><p>Spring Boot 工程： </p><p><ul> </p><ul><li>配置 MapperScan 注解 <pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span><br><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">“com.caochenlei.mpdemo.mapper”</span><span class="token punctuation">)</span><br><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MpDemoApplication</span> <span class="token punctuation">&#123;</li></ul></li></ul><pre><code>  &lt;!-- --&gt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;  &lt;!-- --&gt;&lt;/span&gt;    &lt;span class=&quot;token class-name&quot;&gt;SpringApplication&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;MpDemoApplication&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;</code></pre><p><span class="token punctuation">}</span><br>&lt;/code&gt;&lt;/pre&gt;<br> &lt;/ul&gt;  </p><ul><li><p>Spring MVC 工程： </p><ul> -  配置 MapperScan 对象 <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"> <property name="basePackage" value="com.caochenlei.mpdemo.mapper"/></bean>  -  调整 SqlSessionFactory 为 MyBatis-Plus 的 SqlSessionFactory <bean id="sqlSessionFactory" class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean"> <property name="dataSource" ref="dataSource"/></bean>  </ul> </li></ul><h3 id="2-3、项目配置（2）"><a href="#2-3、项目配置（2）" class="headerlink" title="2.3、项目配置（2）"></a>2.3、项目配置（2）</h3><p>application.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#mysql</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">#mybatis-plus</span><br><span class="line">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h3 id="2-4、数据导入"><a href="#2-4、数据导入" class="headerlink" title="2.4、数据导入"></a>2.4、数据导入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">## 创建库</span><br><span class="line">CREATE DATABASE mp;</span><br><span class="line">## 使用库</span><br><span class="line">USE mp;</span><br><span class="line">## 创建表</span><br><span class="line">CREATE TABLE <span class="title function_">tbl_employee</span><span class="params">(</span></span><br><span class="line"><span class="params">   id INT(<span class="number">11</span>)</span> PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">   last_name <span class="title function_">VARCHAR</span><span class="params">(<span class="number">50</span>)</span>,</span><br><span class="line">   email <span class="title function_">VARCHAR</span><span class="params">(<span class="number">50</span>)</span>,</span><br><span class="line">   gender <span class="title function_">CHAR</span><span class="params">(<span class="number">1</span>)</span>,</span><br><span class="line">   age INT</span><br><span class="line">);</span><br><span class="line">## 导入数据</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;tom@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">22</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;jerry@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">25</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Black&#x27;</span>,<span class="string">&#x27;black@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;White&#x27;</span>,<span class="string">&#x27;white@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">35</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tiger&#x27;</span>,<span class="string">&#x27;tiger@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">28</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Bobby&#x27;</span>,<span class="string">&#x27;bobby@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">16</span>);</span><br><span class="line">## 查询数据</span><br><span class="line">SELECT * FROM tbl_employee;</span><br></pre></td></tr></table></figure><h3 id="2-5、创建实体"><a href="#2-5、创建实体" class="headerlink" title="2.5、创建实体"></a>2.5、创建实体</h3><p>com.caochenlei.mpdemo.pojo.Employee</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;tbl_employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;last_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;email&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;gender&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer gender;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Integer id, String lastName, String email, Integer gender, Integer age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(Integer gender)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, lastName=&#x27;&quot;</span> + lastName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, gender=&quot;</span> + gender +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、创建接口"><a href="#2-6、创建接口" class="headerlink" title="2.6、创建接口"></a>2.6、创建接口</h3><p>com.caochenlei.mpdemo.mapper.EmployeeMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Employee&gt; &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7、测试准备"><a href="#2-7、测试准备" class="headerlink" title="2.7、测试准备"></a>2.7、测试准备</h3><p>com.caochenlei.mpdemo.MpDemoApplicationTests</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MpDemoApplicationTests</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        List&lt;Employee&gt; employees = employeeMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        employees.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8、增删改查"><a href="#2-8、增删改查" class="headerlink" title="2.8、增删改查"></a>2.8、增删改查</h3><h4 id="2-8-1、insert"><a href="#2-8-1、insert" class="headerlink" title="2.8.1、insert"></a>2.8.1、insert</h4><p><strong>需求描述</strong>：插入一个员工，员工姓名为“张三”、邮箱为”zhangsan@qq.com”、男性、25岁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.insert(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="literal">null</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;zhangsan@qq.com&quot;</span>, <span class="number">0</span>, <span class="number">25</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-2、updateById"><a href="#2-8-2、updateById" class="headerlink" title="2.8.2、updateById"></a>2.8.2、updateById</h4><p><strong>需求信息</strong>：将id为1的员工的姓名更改为”Jennie”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 先查询</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    employee.setLastName(<span class="string">&quot;Jennie&quot;</span>);</span><br><span class="line">    <span class="comment">// 再修改</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.updateById(employee);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-3、selectById"><a href="#2-8-3、selectById" class="headerlink" title="2.8.3、selectById"></a>2.8.3、selectById</h4><p><strong>需求描述</strong>：查询id为1的员工信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-4、selectByMap"><a href="#2-8-4、selectByMap" class="headerlink" title="2.8.4、selectByMap"></a>2.8.4、selectByMap</h4><p><strong>需求描述</strong>：查询性别为男性（0）且年龄在25岁的员工信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;gender&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">25</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = employeeMapper.selectByMap(map);</span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-5、selectBatchIds"><a href="#2-8-5、selectBatchIds" class="headerlink" title="2.8.5、selectBatchIds"></a>2.8.5、selectBatchIds</h4><p><strong>需求描述</strong>：查询id分别为1、2、3的员工的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    List&lt;Employee&gt; employees = employeeMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-6、deleteById"><a href="#2-8-6、deleteById" class="headerlink" title="2.8.6、deleteById"></a>2.8.6、deleteById</h4><p><strong>需求信息</strong>：删除id为1的员工信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.deleteById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-7、deleteByMap"><a href="#2-8-7、deleteByMap" class="headerlink" title="2.8.7、deleteByMap"></a>2.8.7、deleteByMap</h4><p><strong>需求描述</strong>：删除性别为男性（0）且年龄在25岁的员工信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;gender&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8-8、deleteBatchIds"><a href="#2-8-8、deleteBatchIds" class="headerlink" title="2.8.8、deleteBatchIds"></a>2.8.8、deleteBatchIds</h4><p><strong>需求描述</strong>：删除id分别为4、5、6的员工的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.deleteBatchIds(Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-MyBatis-Plus3注解介绍"><a href="#第三章-MyBatis-Plus3注解介绍" class="headerlink" title="第三章 MyBatis-Plus3注解介绍"></a>第三章 MyBatis-Plus3注解介绍</h2><h3 id="3-1、-TableName"><a href="#3-1、-TableName" class="headerlink" title="3.1、@TableName"></a>3.1、@TableName</h3><p>描述：表名注解</p><h3 id="3-2、-TableId"><a href="#3-2、-TableId" class="headerlink" title="3.2、@TableId"></a>3.2、@TableId</h3><p>描述：主键注解</p><p><strong>IdType</strong></p><h3 id="3-3、-TableField"><a href="#3-3、-TableField" class="headerlink" title="3.3、@TableField"></a>3.3、@TableField</h3><p>描述：字段注解(非主键)</p><p><strong>FieldStrategy</strong></p><p><strong>FieldFill</strong></p><h3 id="3-4、-Version"><a href="#3-4、-Version" class="headerlink" title="3.4、@Version"></a>3.4、@Version</h3><p>描述：乐观锁注解、标记 @Verison 在字段上</p><h3 id="3-5、-EnumValue"><a href="#3-5、-EnumValue" class="headerlink" title="3.5、@EnumValue"></a>3.5、@EnumValue</h3><p>描述：通枚举类注解（注解在枚举字段上）</p><h3 id="3-6、-TableLogic"><a href="#3-6、-TableLogic" class="headerlink" title="3.6、@TableLogic"></a>3.6、@TableLogic</h3><p>描述：表字段逻辑处理注解（逻辑删除）</p><h3 id="3-7、-SqlParser"><a href="#3-7、-SqlParser" class="headerlink" title="3.7、@SqlParser"></a>3.7、@SqlParser</h3><p>描述：租户注解，支持method上以及mapper接口上</p><h3 id="3-8、-KeySequence"><a href="#3-8、-KeySequence" class="headerlink" title="3.8、@KeySequence"></a>3.8、@KeySequence</h3><p>描述：序列主键策略 oracle</p><p>属性：value、resultMap</p><h2 id="第四章-MyBatis-Plus3条件构造器"><a href="#第四章-MyBatis-Plus3条件构造器" class="headerlink" title="第四章 MyBatis-Plus3条件构造器"></a>第四章 MyBatis-Plus3条件构造器</h2><h3 id="4-1、数据导入"><a href="#4-1、数据导入" class="headerlink" title="4.1、数据导入"></a>4.1、数据导入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">## 使用库</span><br><span class="line">USE mp;</span><br><span class="line">## 清空表</span><br><span class="line">TRUNCATE TABLE tbl_employee;</span><br><span class="line">## 导入数据</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan0&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">21</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan1&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">22</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan2&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">23</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan3&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan4&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">25</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan5&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">26</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan6&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">27</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan7&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">28</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan8&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">29</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Allan9&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby0&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">21</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby1&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">22</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby2&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby3&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby4&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">25</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby5&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">26</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby6&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">27</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby7&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">28</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby8&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">29</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Baby9&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom0&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">21</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom1&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">22</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom3&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom4&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">25</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom5&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">26</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom6&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">27</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom7&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">28</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom8&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">1</span>,<span class="number">29</span>);</span><br><span class="line">INSERT INTO <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,age)</span> VALUES(<span class="string">&#x27;Tom9&#x27;</span>,<span class="string">&#x27;123@qq.com&#x27;</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line">## 查询数据</span><br><span class="line">SELECT * FROM tbl_employee;</span><br></pre></td></tr></table></figure><h3 id="4-2、构造器简介"><a href="#4-2、构造器简介" class="headerlink" title="4.2、构造器简介"></a>4.2、构造器简介</h3><p>MyBatis-Plus 通过 EntityWrapper（简称 EW，MP 封装的一个查询条件构造器）或者 Condition（与 EW 类似） 来让用户自由的构建查询条件，简单便捷，没有额外的负担， 能够有效提高开发效率，它主要用于处理 sql 拼接，排序，实体参数查询等。</p><blockquote><p>注意：使用的是数据库字段，不是 Java 属性！</p><p>警告：MyBatis-Plus不支持以及不赞成在 RPC 调用中把 Wrapper 进行传输，Wrapper 很重，传输 Wrapper 可以类比为你的 controller 用 map 接收值(开发一时爽，维护火葬场)，正确的 RPC 调用姿势是写一个 DTO 进行传输，被调用方再根据 DTO 执行相应的操作。</p></blockquote><h3 id="4-3、构造器使用（1）"><a href="#4-3、构造器使用（1）" class="headerlink" title="4.3、构造器使用（1）"></a>4.3、构造器使用（1）</h3><h4 id="4-3-1、带条件的查询"><a href="#4-3-1、带条件的查询" class="headerlink" title="4.3.1、带条件的查询"></a>4.3.1、带条件的查询</h4><p><strong>需求描述</strong>：查询所有姓名的包含B、且姓名为女（1）、且年龄大于24岁的员工信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    QueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">            .like(<span class="string">&quot;last_name&quot;</span>,<span class="string">&quot;B&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;gender&quot;</span>,<span class="number">1</span>)</span><br><span class="line">            .gt(<span class="string">&quot;age&quot;</span>,<span class="number">24</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = employeeMapper.selectList(queryWrapper);</span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需求描述</strong>：查询所有员工信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    List&lt;Employee&gt; employees = employeeMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需求描述</strong>：查询所有女生的数量（1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList3</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    QueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;gender&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> employeeMapper.selectCount(queryWrapper);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2、带条件的修改"><a href="#4-3-2、带条件的修改" class="headerlink" title="4.3.2、带条件的修改"></a>4.3.2、带条件的修改</h4><p><strong>需求信息</strong>：将年龄大于25岁的女生（1）的性别修改为男生（0）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    UpdateWrapper&lt;Employee&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper</span><br><span class="line">        .eq(<span class="string">&quot;gender&quot;</span>, <span class="number">1</span>)</span><br><span class="line">        .gt(<span class="string">&quot;age&quot;</span>, <span class="number">25</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    employee.setGender(<span class="number">0</span>);</span><br><span class="line">    employeeMapper.update(employee, updateWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3、带条件的删除"><a href="#4-3-3、带条件的删除" class="headerlink" title="4.3.3、带条件的删除"></a>4.3.3、带条件的删除</h4><p><strong>需求信息</strong>：将姓名带有“Tom”的员工信息删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    QueryWrapper&lt;Employee&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;last_name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、构造器使用（2）"><a href="#4-4、构造器使用（2）" class="headerlink" title="4.4、构造器使用（2）"></a>4.4、构造器使用（2）</h3><p><strong>参数说明</strong>：</p><ul><li>以下出现的第一个入参boolean condition表示该条件<strong>是否</strong>加入最后生成的sql中 </li><li>以下代码块内的多个方法均为从上往下补全个别boolean类型的入参，默认为true </li><li>以下出现的泛型Param均为Wrapper的子类实例(均具有AbstractWrapper的所有方法) </li><li>以下方法在入参中出现的R为泛型，在普通wrapper中是String，在LambdaWrapper中是<strong>函数</strong>(例：Entity::getId,Entity为实体类，getId为字段id的<strong>getMethod</strong>) </li><li>以下方法入参中的R column均表示数据库字段，当R具体类型为String时则为数据库字段名(<strong>字段名是数据库关键字的自己用转义符包裹</strong>)！而不是实体类数据字段名，另当R具体类型为SFunction时项目runtime不支持eclipse自家的编译器 </li><li>以下举例均为使用普通wrapper，入参为Map和List的均以json形式表现 </li><li>使用中如果入参的Map或者List为<strong>空</strong>，则不会加入最后生成的sql中</li></ul><p><strong>AbstractWrapper</strong>：</p><p>说明：AbstractWrapper 是 QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件，entity 属性也用于生成 sql 的 where 条件，注意 entity 生成的 where 条件与使用各个 api 生成的 where 条件<strong>没有任何关联行为</strong></p><h4 id="4-4-1、allEq"><a href="#4-4-1、allEq" class="headerlink" title="4.4.1、allEq"></a>4.4.1、allEq</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allEq(Map&lt;R, V&gt; params)</span><br><span class="line">allEq(Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br></pre></td></tr></table></figure><ul><li>全部 eq (或个别 isNull）</li></ul><p>个别参数说明：</p><p>params：key为数据库字段名，value为字段值 null2IsNull：为true则在map的value为null时调用 isNull方法，为false时则忽略value为null的</p><ul><li>例1: allEq({id:1,name:”老王”,age:null})—&gt;id = 1 and name = ‘老王’ and age is null </li><li>例2: allEq({id:1,name:”老王”,age:null}, false)—&gt;id = 1 and name = ‘老王’</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params)</span><br><span class="line">allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br><span class="line">allEq(<span class="type">boolean</span> condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, <span class="type">boolean</span> null2IsNull)</span><br></pre></td></tr></table></figure><p>个别参数说明：</p><p>filter : 过滤函数，是否允许字段传入比对条件中 params 与 null2IsNull : 同上</p><ul><li>例1: allEq((k,v) -&gt; k.indexOf(“a”) &gt;= 0, {id:1,name:”老王”,age:null})—&gt;name = ‘老王’ and age is null </li><li>例2: allEq((k,v) -&gt; k.indexOf(“a”) &gt;= 0, {id:1,name:”老王”,age:null}, false)—&gt;name = ‘老王’</li></ul><h4 id="4-4-2、eq"><a href="#4-4-2、eq" class="headerlink" title="4.4.2、eq"></a>4.4.2、eq</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eq(R column, Object val)</span><br><span class="line">eq(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>等于 = </li><li>例: eq(“name”, “老王”)—&gt;name = ‘老王’</li></ul><h4 id="4-4-3、ne"><a href="#4-4-3、ne" class="headerlink" title="4.4.3、ne"></a>4.4.3、ne</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ne(R column, Object val)</span><br><span class="line">ne(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>不等于 &lt;&gt; </li><li>例: ne(“name”, “老王”)—&gt;name &lt;&gt; ‘老王’</li></ul><h4 id="4-4-4、gt"><a href="#4-4-4、gt" class="headerlink" title="4.4.4、gt"></a>4.4.4、gt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gt(R column, Object val)</span><br><span class="line">gt(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>大于 &gt; </li><li>例: gt(“age”, 18)—&gt;age &gt; 18</li></ul><h4 id="4-4-5、ge"><a href="#4-4-5、ge" class="headerlink" title="4.4.5、ge"></a>4.4.5、ge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ge(R column, Object val)</span><br><span class="line">ge(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>大于等于 &gt;= </li><li>例: ge(“age”, 18)—&gt;age &gt;= 18</li></ul><h4 id="4-4-6、lt"><a href="#4-4-6、lt" class="headerlink" title="4.4.6、lt"></a>4.4.6、lt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lt(R column, Object val)</span><br><span class="line">lt(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>小于 &lt; </li><li>例: lt(“age”, 18)—&gt;age &lt; 18</li></ul><h4 id="4-4-7、le"><a href="#4-4-7、le" class="headerlink" title="4.4.7、le"></a>4.4.7、le</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">le(R column, Object val)</span><br><span class="line">le(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>小于等于 &lt;= </li><li>例: le(“age”, 18)—&gt;age &lt;= 18</li></ul><h4 id="4-4-8、between"><a href="#4-4-8、between" class="headerlink" title="4.4.8、between"></a>4.4.8、between</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">between(R column, Object val1, Object val2)</span><br><span class="line">between(<span class="type">boolean</span> condition, R column, Object val1, Object val2)</span><br></pre></td></tr></table></figure><ul><li>BETWEEN 值1 AND 值2 </li><li>例: between(“age”, 18, 30)—&gt;age between 18 and 30</li></ul><h4 id="4-4-9、notBetween"><a href="#4-4-9、notBetween" class="headerlink" title="4.4.9、notBetween"></a>4.4.9、notBetween</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notBetween(R column, Object val1, Object val2)</span><br><span class="line">notBetween(<span class="type">boolean</span> condition, R column, Object val1, Object val2)</span><br></pre></td></tr></table></figure><ul><li>NOT BETWEEN 值1 AND 值2 </li><li>例: notBetween(“age”, 18, 30)—&gt;age not between 18 and 30</li></ul><h4 id="4-4-10、like"><a href="#4-4-10、like" class="headerlink" title="4.4.10、like"></a>4.4.10、like</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">like(R column, Object val)</span><br><span class="line">like(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>LIKE ‘%值%’ </li><li>例: like(“name”, “王”)—&gt;name like ‘%王%’</li></ul><h4 id="4-4-11、notLike"><a href="#4-4-11、notLike" class="headerlink" title="4.4.11、notLike"></a>4.4.11、notLike</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notLike(R column, Object val)</span><br><span class="line">notLike(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>NOT LIKE ‘%值%’ </li><li>例: notLike(“name”, “王”)—&gt;name not like ‘%王%’</li></ul><h4 id="4-4-12、likeLeft"><a href="#4-4-12、likeLeft" class="headerlink" title="4.4.12、likeLeft"></a>4.4.12、likeLeft</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">likeLeft(R column, Object val)</span><br><span class="line">likeLeft(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>LIKE ‘%值’ </li><li>例: likeLeft(“name”, “王”)—&gt;name like ‘%王’</li></ul><h4 id="4-4-13、likeRight"><a href="#4-4-13、likeRight" class="headerlink" title="4.4.13、likeRight"></a>4.4.13、likeRight</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">likeRight(R column, Object val)</span><br><span class="line">likeRight(<span class="type">boolean</span> condition, R column, Object val)</span><br></pre></td></tr></table></figure><ul><li>LIKE ‘值%’ </li><li>例: likeRight(“name”, “王”)—&gt;name like ‘王%’</li></ul><h4 id="4-4-14、isNull"><a href="#4-4-14、isNull" class="headerlink" title="4.4.14、isNull"></a>4.4.14、isNull</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNull(R column)</span><br><span class="line">isNull(<span class="type">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure><ul><li>字段 IS NULL </li><li>例: isNull(“name”)—&gt;name is null</li></ul><h4 id="4-4-15、isNotNull"><a href="#4-4-15、isNotNull" class="headerlink" title="4.4.15、isNotNull"></a>4.4.15、isNotNull</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNotNull(R column)</span><br><span class="line">isNotNull(<span class="type">boolean</span> condition, R column)</span><br></pre></td></tr></table></figure><ul><li>字段 IS NOT NULL </li><li>例: isNotNull(“name”)—&gt;name is not null</li></ul><h4 id="4-4-16、in"><a href="#4-4-16、in" class="headerlink" title="4.4.16、in"></a>4.4.16、in</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in(R column, Collection&lt;?&gt; value)</span><br><span class="line">in(<span class="type">boolean</span> condition, R column, Collection&lt;?&gt; value)</span><br></pre></td></tr></table></figure><ul><li>字段 IN (value.get(0), value.get(1), …) </li><li>例: in(“age”,{1,2,3})—&gt;age in (1,2,3)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in(R column, Object... values)</span><br><span class="line">in(<span class="type">boolean</span> condition, R column, Object... values)</span><br></pre></td></tr></table></figure><ul><li>字段 IN (v0, v1, …) </li><li>例: in(“age”, 1, 2, 3)—&gt;age in (1,2,3)</li></ul><h4 id="4-4-17、notIn"><a href="#4-4-17、notIn" class="headerlink" title="4.4.17、notIn"></a>4.4.17、notIn</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notIn(R column, Collection&lt;?&gt; value)</span><br><span class="line">notIn(<span class="type">boolean</span> condition, R column, Collection&lt;?&gt; value)</span><br></pre></td></tr></table></figure><ul><li>字段 NOT IN (value.get(0), value.get(1), …) </li><li>例: notIn(“age”,{1,2,3})—&gt;age not in (1,2,3)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notIn(R column, Object... values)</span><br><span class="line">notIn(<span class="type">boolean</span> condition, R column, Object... values)</span><br></pre></td></tr></table></figure><ul><li>字段 NOT IN (v0, v1, …) </li><li>例: notIn(“age”, 1, 2, 3)—&gt;age not in (1,2,3)</li></ul><h4 id="4-4-18、inSql"><a href="#4-4-18、inSql" class="headerlink" title="4.4.18、inSql"></a>4.4.18、inSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inSql(R column, String inValue)</span><br><span class="line">inSql(<span class="type">boolean</span> condition, R column, String inValue)</span><br></pre></td></tr></table></figure><ul><li>字段 IN ( sql语句 ) </li><li>例: inSql(“age”, “1,2,3,4,5,6”)—&gt;age in (1,2,3,4,5,6) </li><li>例: inSql(“id”, “select id from table where id &lt; 3”)—&gt;id in (select id from table where id &lt; 3)</li></ul><h4 id="4-4-19、notInSql"><a href="#4-4-19、notInSql" class="headerlink" title="4.4.19、notInSql"></a>4.4.19、notInSql</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notInSql(R column, String inValue)</span><br><span class="line">notInSql(<span class="type">boolean</span> condition, R column, String inValue)</span><br></pre></td></tr></table></figure><ul><li>字段 NOT IN ( sql语句 ) </li><li>例: notInSql(“age”, “1,2,3,4,5,6”)—&gt;age not in (1,2,3,4,5,6) </li><li>例: notInSql(“id”, “select id from table where id &lt; 3”)—&gt;id not in (select id from table where id &lt; 3)</li></ul><h4 id="4-4-20、groupBy"><a href="#4-4-20、groupBy" class="headerlink" title="4.4.20、groupBy"></a>4.4.20、groupBy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupBy(R... columns)</span><br><span class="line">groupBy(<span class="type">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure><ul><li>分组：GROUP BY 字段, … </li><li>例: groupBy(“id”, “name”)—&gt;group by id,name</li></ul><h4 id="4-4-21、orderByAsc"><a href="#4-4-21、orderByAsc" class="headerlink" title="4.4.21、orderByAsc"></a>4.4.21、orderByAsc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderByAsc(R... columns)</span><br><span class="line">orderByAsc(<span class="type">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure><ul><li>排序：ORDER BY 字段, … ASC </li><li>例: orderByAsc(“id”, “name”)—&gt;order by id ASC,name ASC</li></ul><h4 id="4-4-22、orderByDesc"><a href="#4-4-22、orderByDesc" class="headerlink" title="4.4.22、orderByDesc"></a>4.4.22、orderByDesc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderByDesc(R... columns)</span><br><span class="line">orderByDesc(<span class="type">boolean</span> condition, R... columns)</span><br></pre></td></tr></table></figure><ul><li>排序：ORDER BY 字段, … DESC </li><li>例: orderByDesc(“id”, “name”)—&gt;order by id DESC,name DESC</li></ul><h4 id="4-4-23、orderBy"><a href="#4-4-23、orderBy" class="headerlink" title="4.4.23、orderBy"></a>4.4.23、orderBy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderBy(<span class="type">boolean</span> condition, <span class="type">boolean</span> isAsc, R... columns)</span><br></pre></td></tr></table></figure><ul><li>排序：ORDER BY 字段, … </li><li>例: orderBy(true, true, “id”, “name”)—&gt;order by id ASC,name ASC</li></ul><h4 id="4-4-24、having"><a href="#4-4-24、having" class="headerlink" title="4.4.24、having"></a>4.4.24、having</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">having(String sqlHaving, Object... params)</span><br><span class="line">having(<span class="type">boolean</span> condition, String sqlHaving, Object... params)</span><br></pre></td></tr></table></figure><ul><li>HAVING ( sql语句 ) </li><li>例: having(“sum(age) &gt; 10”)—&gt;having sum(age) &gt; 10 </li><li>例: having(“sum(age) &gt; {0}”, 11)—&gt;having sum(age) &gt; 11</li></ul><h4 id="4-4-25、func"><a href="#4-4-25、func" class="headerlink" title="4.4.25、func"></a>4.4.25、func</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(Consumer&lt;Children&gt; consumer)</span><br><span class="line">func(<span class="type">boolean</span> condition, Consumer&lt;Children&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>func 方法(主要方便在出现if…else下调用不同方法能不断链) </li><li>例: func(i -&gt; if(true) {i.eq(“id”, 1)} else {i.ne(“id”, 1)})</li></ul><h4 id="4-4-26、or"><a href="#4-4-26、or" class="headerlink" title="4.4.26、or"></a>4.4.26、or</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or()</span><br><span class="line">or(<span class="type">boolean</span> condition)</span><br></pre></td></tr></table></figure><ul><li>拼接 OR</li></ul><p>注意事项:</p><p>主动调用or表示紧接着下一个<strong>方法</strong>不是用and连接!(不调用or则默认为使用and连接)</p><ul><li>例: eq(“id”,1).or().eq(“name”,”老王”)—&gt;id = 1 or name = ‘老王’</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or(Consumer&lt;Param&gt; consumer)</span><br><span class="line">or(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>OR 嵌套 </li><li>例: or(i -&gt; i.eq(“name”, “李白”).ne(“status”, “活着”))—&gt;or (name = ‘李白’ and status &lt;&gt; ‘活着’)</li></ul><h4 id="4-4-27、and"><a href="#4-4-27、and" class="headerlink" title="4.4.27、and"></a>4.4.27、and</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and(Consumer&lt;Param&gt; consumer)</span><br><span class="line">and(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>AND 嵌套 </li><li>例: and(i -&gt; i.eq(“name”, “李白”).ne(“status”, “活着”))—&gt;and (name = ‘李白’ and status &lt;&gt; ‘活着’)</li></ul><h4 id="4-4-28、nested"><a href="#4-4-28、nested" class="headerlink" title="4.4.28、nested"></a>4.4.28、nested</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nested(Consumer&lt;Param&gt; consumer)</span><br><span class="line">nested(<span class="type">boolean</span> condition, Consumer&lt;Param&gt; consumer)</span><br></pre></td></tr></table></figure><ul><li>正常嵌套 不带 AND 或者 OR </li><li>例: nested(i -&gt; i.eq(“name”, “李白”).ne(“status”, “活着”))—&gt;(name = ‘李白’ and status &lt;&gt; ‘活着’)</li></ul><h4 id="4-4-29、apply"><a href="#4-4-29、apply" class="headerlink" title="4.4.29、apply"></a>4.4.29、apply</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply(String applySql, Object... params)</span><br><span class="line">apply(<span class="type">boolean</span> condition, String applySql, Object... params)</span><br></pre></td></tr></table></figure><ul><li>拼接 sql</li></ul><p>注意事项:</p><p>该方法可用于数据库<strong>函数</strong>动态入参的params对应前面applySql内部的{index}部分，这样是不会有sql注入风险的，反之会有!</p><ul><li>例: apply(“id = 1”)—&gt;id = 1 </li><li>例: apply(“date_format(dateColumn,’%Y-%m-%d’) = ‘2008-08-08’”)—&gt;date_format(dateColumn,’%Y-%m-%d’) = ‘2008-08-08’”) </li><li>例: apply(“date_format(dateColumn,’%Y-%m-%d’) = {0}”, “2008-08-08”)—&gt;date_format(dateColumn,’%Y-%m-%d’) = ‘2008-08-08’”)</li></ul><h4 id="4-4-30、last"><a href="#4-4-30、last" class="headerlink" title="4.4.30、last"></a>4.4.30、last</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">last(String lastSql)</span><br><span class="line">last(<span class="type">boolean</span> condition, String lastSql)</span><br></pre></td></tr></table></figure><ul><li>无视优化规则直接拼接到 sql 的最后</li></ul><p>注意事项:</p><p>只能调用一次，多次调用以最后一次为准，有sql注入的风险，请谨慎使用</p><ul><li>例: last(“limit 1”)</li></ul><h4 id="4-4-31、exists"><a href="#4-4-31、exists" class="headerlink" title="4.4.31、exists"></a>4.4.31、exists</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists(String existsSql)</span><br><span class="line">exists(<span class="type">boolean</span> condition, String existsSql)</span><br></pre></td></tr></table></figure><ul><li>拼接 EXISTS ( sql语句 ) </li><li>例: exists(“select id from table where age = 1”)—&gt;exists (select id from table where age = 1)</li></ul><h4 id="4-4-32、notExists"><a href="#4-4-32、notExists" class="headerlink" title="4.4.32、notExists"></a>4.4.32、notExists</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">notExists(String notExistsSql)</span><br><span class="line">notExists(<span class="type">boolean</span> condition, String notExistsSql)</span><br></pre></td></tr></table></figure><ul><li>拼接 NOT EXISTS ( sql语句 ) </li><li>例: notExists(“select id from table where age = 1”)—&gt;not exists (select id from table where age = 1)</li></ul><h2 id="第五章-MyBatis-Plus3代码生成器"><a href="#第五章-MyBatis-Plus3代码生成器" class="headerlink" title="第五章 MyBatis-Plus3代码生成器"></a>第五章 MyBatis-Plus3代码生成器</h2><h3 id="5-1、数据导入"><a href="#5-1、数据导入" class="headerlink" title="5.1、数据导入"></a>5.1、数据导入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## 删除表</span><br><span class="line">DROP TABLE IF EXISTS `tbl_user`;</span><br><span class="line">## 创建表</span><br><span class="line">CREATE TABLE `tbl_user` (</span><br><span class="line">  `id` BIGINT(<span class="number">20</span>) NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `name` VARCHAR(<span class="number">30</span>) DEFAULT NULL COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `email` VARCHAR(<span class="number">30</span>) DEFAULT NULL COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span></span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=<span class="number">6</span> DEFAULT CHARSET=utf8 COMMENT=<span class="string">&#x27;用户&#x27;</span>;</span><br><span class="line">## 导入数据</span><br><span class="line">INSERT  INTO `tbl_user`(`id`,`name`,`age`,`email`) VALUES (<span class="number">1</span>,<span class="string">&#x27;Jone&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;test1@baomidou.com&#x27;</span>);</span><br><span class="line">INSERT  INTO `tbl_user`(`id`,`name`,`age`,`email`) VALUES (<span class="number">2</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;test2@baomidou.com&#x27;</span>);</span><br><span class="line">INSERT  INTO `tbl_user`(`id`,`name`,`age`,`email`) VALUES (<span class="number">3</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">28</span>,<span class="string">&#x27;test3@baomidou.com&#x27;</span>);</span><br><span class="line">INSERT  INTO `tbl_user`(`id`,`name`,`age`,`email`) VALUES (<span class="number">4</span>,<span class="string">&#x27;Sandy&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;test4@baomidou.com&#x27;</span>);</span><br><span class="line">INSERT  INTO `tbl_user`(`id`,`name`,`age`,`email`) VALUES (<span class="number">5</span>,<span class="string">&#x27;Billie&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2、代码生成器简介"><a href="#5-2、代码生成器简介" class="headerlink" title="5.2、代码生成器简介"></a>5.2、代码生成器简介</h3><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p><h3 id="5-3、代码生成器使用"><a href="#5-3、代码生成器使用" class="headerlink" title="5.3、代码生成器使用"></a>5.3、代码生成器使用</h3><h4 id="5-3-1、添加依赖"><a href="#5-3-1、添加依赖" class="headerlink" title="5.3.1、添加依赖"></a>5.3.1、添加依赖</h4><p>pom.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">5.1</span><span class="number">.49</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.4</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.2</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.18</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;!-- 插件管理 --&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.5</span>&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">    &lt;!-- 资源管理 --&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**<span class="comment">/*.properties&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                &lt;include&gt;**/</span>*.xml&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;**<span class="comment">/*.conf&lt;/include&gt;</span></span><br><span class="line"><span class="comment">            &lt;/includes&gt;</span></span><br><span class="line"><span class="comment">            &lt;filtering&gt;false&lt;/filtering&gt;</span></span><br><span class="line"><span class="comment">        &lt;/resource&gt;</span></span><br><span class="line"><span class="comment">        &lt;resource&gt;</span></span><br><span class="line"><span class="comment">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span></span><br><span class="line"><span class="comment">            &lt;includes&gt;</span></span><br><span class="line"><span class="comment">                &lt;include&gt;**/</span>*.properties&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;**<span class="comment">/*.xml&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                &lt;include&gt;**/</span>*.conf&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtering&gt;<span class="literal">false</span>&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h4 id="5-3-2、添加配置"><a href="#5-3-2、添加配置" class="headerlink" title="5.3.2、添加配置"></a>5.3.2、添加配置</h4><p>application.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#server</span><br><span class="line">server.port=<span class="number">8080</span></span><br><span class="line"></span><br><span class="line">#mysql</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">#mybatis-plus</span><br><span class="line">mybatis-plus.mapper-locations=classpath*:**/mapper/xml<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h4 id="5-3-3、启动配置"><a href="#5-3-3、启动配置" class="headerlink" title="5.3.3、启动配置"></a>5.3.3、启动配置</h4><p>MpDemoApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.caochenlei.mpdemo.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpDemoApplication</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        SpringApplication.run(MpDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-4、代码生成"><a href="#5-3-4、代码生成" class="headerlink" title="5.3.4、代码生成"></a>5.3.4、代码生成</h4><p>CodeGenerator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">scanner</span><span class="params">(String tip)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">help</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        help.append(<span class="string">&quot;请输入&quot;</span> + tip + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="type">String</span> <span class="variable">ipt</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">return</span> ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusException</span>(<span class="string">&quot;请输入正确的&quot;</span> + tip + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);<span class="comment">//设置代码生成路径</span></span><br><span class="line">        gc.setFileOverride(<span class="literal">true</span>);<span class="comment">//是否覆盖以前文件</span></span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);<span class="comment">//是否打开生成目录</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;caochenlei&quot;</span>);<span class="comment">//设置项目作者名称</span></span><br><span class="line">        gc.setIdType(IdType.AUTO);<span class="comment">//设置主键策略</span></span><br><span class="line">        gc.setBaseResultMap(<span class="literal">true</span>);<span class="comment">//生成基本ResultMap</span></span><br><span class="line">        gc.setBaseColumnList(<span class="literal">true</span>);<span class="comment">//生成基本ColumnList</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);<span class="comment">//去掉服务默认前缀</span></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mp?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.caochenlei.mpdemo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setXml(<span class="string">&quot;mapper.xml&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">&quot;service.impl&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        sc.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        sc.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        sc.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        sc.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        sc.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">        sc.setTablePrefix(<span class="string">&quot;tbl_&quot;</span>);</span><br><span class="line">        sc.setInclude(scanner(<span class="string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        mpg.setStrategy(sc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代码</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-5、工程结构"><a href="#5-3-5、工程结构" class="headerlink" title="5.3.5、工程结构"></a>5.3.5、工程结构</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/507411d125be89ac7b1503b464eb90a1.png" alt="img"></p><h4 id="5-3-6、添加代码"><a href="#5-3-6、添加代码" class="headerlink" title="5.3.6、添加代码"></a>5.3.6、添加代码</h4><p>UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> userService.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-7、启动运行"><a href="#5-3-7、启动运行" class="headerlink" title="5.3.7、启动运行"></a>5.3.7、启动运行</h4><p>MpDemoApplication.java 中运行主方法以此来启动整个工程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.caochenlei.mpdemo.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MpDemoApplication</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        SpringApplication.run(MpDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-8、测试方法"><a href="#5-3-8、测试方法" class="headerlink" title="5.3.8、测试方法"></a>5.3.8、测试方法</h4><p>使用浏览器打开：<a href="http://localhost:8080/user/all">http://localhost:8080/user/all</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/977da9d6221c512517877b24352f06cc.png" alt="img"></p><h4 id="5-3-9、温馨提示"><a href="#5-3-9、温馨提示" class="headerlink" title="5.3.9、温馨提示"></a>5.3.9、温馨提示</h4><p>需要Lombok插件支持，只需要安装一下就可以了，打开 IDEA，进入 File -&gt; Settings -&gt; Plugins，安装完成后重启</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f856df73917ee06e6db169372466527a.png" alt="img"></p><h3 id="5-4、代码生成器方法"><a href="#5-4、代码生成器方法" class="headerlink" title="5.4、代码生成器方法"></a>5.4、代码生成器方法</h3><p>通用 Service CRUD 封装 IService 接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆，泛型 T 为任意实体对象，建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类，对象 Wrapper 为 条件构造器。</p><h4 id="5-4-1、save"><a href="#5-4-1、save" class="headerlink" title="5.4.1、save"></a>5.4.1、save</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-2、saveOrUpdate"><a href="#5-4-2、saveOrUpdate" class="headerlink" title="5.4.2、saveOrUpdate"></a>5.4.2、saveOrUpdate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-3、remove"><a href="#5-4-3、remove" class="headerlink" title="5.4.3、remove"></a>5.4.3、remove</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-4、update"><a href="#5-4-4、update" class="headerlink" title="5.4.4、update"></a>5.4.4、update</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-5、get"><a href="#5-4-5、get" class="headerlink" title="5.4.5、get"></a>5.4.5、get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-6、list"><a href="#5-4-6、list" class="headerlink" title="5.4.6、list"></a>5.4.6、list</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-7、page"><a href="#5-4-7、page" class="headerlink" title="5.4.7、page"></a>5.4.7、page</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 无条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page)</span>;</span><br><span class="line"><span class="comment">// 条件分页查询</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">pageMaps</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-8、count"><a href="#5-4-8、count" class="headerlink" title="5.4.8、count"></a>5.4.8、count</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><h4 id="5-4-9、chain"><a href="#5-4-9、chain" class="headerlink" title="5.4.9、chain"></a>5.4.9、chain</h4><p>query</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式查询 普通</span></span><br><span class="line">QueryChainWrapper&lt;T&gt; <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 链式查询 lambda 式。注意：不支持 Kotlin</span></span><br><span class="line">LambdaQueryChainWrapper&lt;T&gt; <span class="title function_">lambdaQuery</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">query().eq(<span class="string">&quot;column&quot;</span>, value).one();</span><br><span class="line">lambdaQuery().eq(Entity::getId, value).list();</span><br></pre></td></tr></table></figure><p>update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式更改 普通</span></span><br><span class="line">UpdateChainWrapper&lt;T&gt; <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 链式更改 lambda 式。注意：不支持 Kotlin </span></span><br><span class="line">LambdaUpdateChainWrapper&lt;T&gt; <span class="title function_">lambdaUpdate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line">update().eq(<span class="string">&quot;column&quot;</span>, value).remove();</span><br><span class="line">lambdaUpdate().eq(Entity::getId, value).update(entity);</span><br></pre></td></tr></table></figure><h2 id="第六章-MyBatis-Plus3配置详解"><a href="#第六章-MyBatis-Plus3配置详解" class="headerlink" title="第六章 MyBatis-Plus3配置详解"></a>第六章 MyBatis-Plus3配置详解</h2><h3 id="6-1、配置概述"><a href="#6-1、配置概述" class="headerlink" title="6.1、配置概述"></a>6.1、配置概述</h3><p>本文讲解了MyBatis-Plus在使用过程中的配置选项，其中部分配置继承自MyBatis原生所支持的配置。</p><h3 id="6-2、配置方式"><a href="#6-2、配置方式" class="headerlink" title="6.2、配置方式"></a>6.2、配置方式</h3><ul><li><p>Spring Boot： </p><ul> -  application.properties（本文采用） mybatis-plus.mapper-locations=classpath*:**/mapper/xml/*.xmlmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl......  -  application.yaml（推荐使用） mybatis-plus:......configuration: ......global-config: ...... db-config:   ......  </ul>  </li><li><p>Spring MVC： </p><p><ul> </p><ul><li><bean id="sqlSessionFactory" class="com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean"><property name="configuration" ref="configuration"/> <!--  非必须  --><property name="globalConfig" ref="globalConfig"/> <!--  非必须  -->......</bean></li></ul></li></ul><bean id="configuration" class="com.baomidou.mybatisplus.core.MybatisConfiguration">    ......</bean><bean id="globalConfig" class="com.baomidou.mybatisplus.core.config.GlobalConfig">    <property name="dbConfig" ref="dbConfig"/> <!--  非必须  -->    ......</bean><p><bean id="dbConfig" class="com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig"><br>    ……</bean><br> &lt;/ul&gt; </p><h3 id="6-3、配置选项"><a href="#6-3、配置选项" class="headerlink" title="6.3、配置选项"></a>6.3、配置选项</h3><h4 id="6-3-1、mapperLocations"><a href="#6-3-1、mapperLocations" class="headerlink" title="6.3.1、mapperLocations"></a>6.3.1、mapperLocations</h4><ul><li>类型：String[] </li><li>默认值：[“classpath<em>:/mapper/**/</em>.xml”]</li></ul><p>MyBatis Mapper 所对应的 XML 文件位置，如果您在 Mapper 中有自定义方法（XML 中有自定义实现），需要进行该配置，告诉 Mapper 所对应的 XML 文件位置，Maven 多模块项目的扫描路径需以 classpath*: 开头 （即加载多个 jar 包下的 XML 文件）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.mapper-locations=classpath*:**/mapper/xml<span class="comment">/*.xml</span></span><br></pre></td></tr></table></figure><h4 id="6-3-2、typeAliasesPackage"><a href="#6-3-2、typeAliasesPackage" class="headerlink" title="6.3.2、typeAliasesPackage"></a>6.3.2、typeAliasesPackage</h4><ul><li>类型：String </li><li>默认值：null</li></ul><p>MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名，注册后在 Mapper 对应的 XML 文件中可以直接使用类名，而不用使用全限定的类名（即 XML 中调用的时候不用包含包名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.type-aliases-<span class="keyword">package</span>=com.caochenlei.mpdemo.pojo</span><br></pre></td></tr></table></figure><h4 id="6-3-3、typeHandlersPackage"><a href="#6-3-3、typeHandlersPackage" class="headerlink" title="6.3.3、typeHandlersPackage"></a>6.3.3、typeHandlersPackage</h4><ul><li>类型：String </li><li>默认值：null</li></ul><p>TypeHandler 扫描路径，如果配置了该属性，SqlSessionFactoryBean 会把该包下面的类注册为对应的 TypeHandler，TypeHandler 通常用于自定义类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.type-handlers-<span class="keyword">package</span>=com.caochenlei.mpdemo.type</span><br></pre></td></tr></table></figure><h4 id="6-3-4、typeEnumsPackage"><a href="#6-3-4、typeEnumsPackage" class="headerlink" title="6.3.4、typeEnumsPackage"></a>6.3.4、typeEnumsPackage</h4><ul><li>类型：String </li><li>默认值：null</li></ul><p>枚举类 扫描路径，如果配置了该属性，会将路径下的枚举类进行注入，让实体类字段能够简单快捷的使用枚举属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.type-enums-<span class="keyword">package</span>=com.caochenlei.mpdemo.myenum</span><br></pre></td></tr></table></figure><h4 id="6-3-5、checkConfigLocation"><a href="#6-3-5、checkConfigLocation" class="headerlink" title="6.3.5、checkConfigLocation"></a>6.3.5、checkConfigLocation</h4><ul><li>类型：boolean </li><li>默认值：false</li></ul><p>启动时是否检查 MyBatis XML 文件的存在，默认不检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.check-config-location=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="6-3-6、executorType"><a href="#6-3-6、executorType" class="headerlink" title="6.3.6、executorType"></a>6.3.6、executorType</h4><ul><li>类型：ExecutorType </li><li>默认值：simple</li></ul><p>通过该属性可指定 MyBatis 的执行器，MyBatis 的执行器总共有三种：</p><ul><li>ExecutorType.SIMPLE：该执行器类型不做特殊的事情，为每个语句的执行创建一个新的预处理语句（PreparedStatement） </li><li>ExecutorType.REUSE：该执行器类型会复用预处理语句（PreparedStatement） </li><li>ExecutorType.BATCH：该执行器类型会批量执行所有的更新语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.executor-type=simple</span><br></pre></td></tr></table></figure><h4 id="6-3-7、configurationProperties"><a href="#6-3-7、configurationProperties" class="headerlink" title="6.3.7、configurationProperties"></a>6.3.7、configurationProperties</h4><ul><li>类型：Properties </li><li>默认值：null</li></ul><p>指定外部化 MyBatis Properties 配置，通过该配置可以抽离配置，实现不同环境的配置部署。</p><h4 id="6-3-8、configuration"><a href="#6-3-8、configuration" class="headerlink" title="6.3.8、configuration"></a>6.3.8、configuration</h4><ul><li>类型：Configuration </li><li>默认值：null</li></ul><p>原生 MyBatis 所支持的配置，本部分（Configuration）的配置大都为 MyBatis 原生支持的配置，这意味着您可以通过 MyBatis XML 配置文件的形式进行配置。</p><h5 id="6-3-8-1、mapUnderscoreToCamelCase"><a href="#6-3-8-1、mapUnderscoreToCamelCase" class="headerlink" title="6.3.8.1、mapUnderscoreToCamelCase"></a>6.3.8.1、mapUnderscoreToCamelCase</h5><ul><li>类型：boolean </li><li>默认值：true</li></ul><p>是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。此属性在 MyBatis 中原默认值为 false，在 MyBatis-Plus 中，此属性也将用于生成最终的 SQL 的 select body，如果您的数据库命名符合规则无需使用 @TableField 注解指定数据库字段名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.map-underscore-to-camel-<span class="keyword">case</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="6-3-8-2、defaultEnumTypeHandler"><a href="#6-3-8-2、defaultEnumTypeHandler" class="headerlink" title="6.3.8.2、defaultEnumTypeHandler"></a>6.3.8.2、defaultEnumTypeHandler</h5><ul><li>类型：Class&lt;? extends TypeHandler </li><li>默认值：org.apache.ibatis.type.EnumTypeHandler</li></ul><p>默认枚举处理类，如果配置了该属性，枚举将统一使用指定处理器进行处理。</p><p>需要注意，它的取值可以有以下几种，可以使用内置，也可以自定义：</p><ul><li>org.apache.ibatis.type.EnumTypeHandler : 存储枚举的名称 </li><li>org.apache.ibatis.type.EnumOrdinalTypeHandler : 存储枚举的索引 </li><li>com.baomidou.mybatisplus.extension.handlers.MybatisEnumTypeHandler : 枚举类需要实现IEnum接口或字段标记@EnumValue注解.(3.1.2以下版本为EnumTypeHandler)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.<span class="keyword">default</span>-<span class="keyword">enum</span>-type-handler=org.apache.ibatis.type.EnumTypeHandler</span><br></pre></td></tr></table></figure><h5 id="6-3-8-3、aggressiveLazyLoading"><a href="#6-3-8-3、aggressiveLazyLoading" class="headerlink" title="6.3.8.3、aggressiveLazyLoading"></a>6.3.8.3、aggressiveLazyLoading</h5><ul><li>类型：boolean </li><li>默认值：true</li></ul><p>当设置为 true 的时候，懒加载的对象可能被任何懒属性全部加载，否则，每个属性都按需加载。需要和 lazyLoadingEnabled 一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.aggressive-lazy-loading=<span class="literal">true</span></span><br><span class="line">mybatis-plus.configuration.lazy-loading-enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="6-3-8-4、autoMappingBehavior"><a href="#6-3-8-4、autoMappingBehavior" class="headerlink" title="6.3.8.4、autoMappingBehavior"></a>6.3.8.4、autoMappingBehavior</h5><ul><li>类型：AutoMappingBehavior </li><li>默认值：partial</li></ul><p>MyBatis 自动映射策略，通过该配置可指定 MyBatis 是否并且如何来自动映射数据表字段与对象的属性，总共有 3 种可选值：</p><ul><li>AutoMappingBehavior.NONE：不启用自动映射 </li><li>AutoMappingBehavior.PARTIAL：只对非嵌套的 resultMap 进行自动映射 </li><li>AutoMappingBehavior.FULL：对所有的 resultMap 都进行自动映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.auto-mapping-behavior=partial</span><br></pre></td></tr></table></figure><h5 id="6-3-8-5、autoMappingUnknownColumnBehavior"><a href="#6-3-8-5、autoMappingUnknownColumnBehavior" class="headerlink" title="6.3.8.5、autoMappingUnknownColumnBehavior"></a>6.3.8.5、autoMappingUnknownColumnBehavior</h5><ul><li>类型：AutoMappingUnknownColumnBehavior </li><li>默认值：NONE</li></ul><p>MyBatis 自动映射时未知列或未知属性处理策略，通过该配置可指定 MyBatis 在自动映射过程中遇到未知列或者未知属性时如何处理，总共有 3 种可选值：</p><ul><li>AutoMappingUnknownColumnBehavior.NONE：不做任何处理 (默认值) </li><li>AutoMappingUnknownColumnBehavior.WARNING：以日志的形式打印相关警告信息 </li><li>AutoMappingUnknownColumnBehavior.FAILING：当作映射失败处理，并抛出异常和详细信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.auto-mapping-unknown-column-behavior=none</span><br></pre></td></tr></table></figure><h5 id="6-3-8-6、localCacheScope"><a href="#6-3-8-6、localCacheScope" class="headerlink" title="6.3.8.6、localCacheScope"></a>6.3.8.6、localCacheScope</h5><ul><li>类型：String </li><li>默认值：SESSION</li></ul><p>Mybatis一级缓存，默认为 SESSION。</p><ul><li>SESSION：session级别缓存，同一个session相同查询语句不会再次查询数据库 </li><li>STATEMENT：关闭一级缓存</li></ul><p>单服务架构中（有且仅有只有一个程序提供相同服务），一级缓存开启不会影响业务，只会提高性能。 微服务架构中需要关闭一级缓存，原因：Service1先查询数据，若之后Service2修改了数据，之后Service1又再次以同样的查询条件查询数据，因走缓存会出现查处的数据不是最新数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.local-cache-scope=session</span><br></pre></td></tr></table></figure><h5 id="6-3-8-7、cacheEnabled"><a href="#6-3-8-7、cacheEnabled" class="headerlink" title="6.3.8.7、cacheEnabled"></a>6.3.8.7、cacheEnabled</h5><ul><li>类型：boolean </li><li>默认值：true</li></ul><p>开启Mybatis二级缓存，默认为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.cache-enabled=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="6-3-8-8、callSettersOnNulls"><a href="#6-3-8-8、callSettersOnNulls" class="headerlink" title="6.3.8.8、callSettersOnNulls"></a>6.3.8.8、callSettersOnNulls</h5><ul><li>类型：boolean </li><li>默认值：false</li></ul><p>指定当结果集中值为 null 的时候是否调用映射对象的 Setter（Map 对象时为 put）方法，通常运用于有 Map.keySet() 依赖或 null 值初始化的情况。</p><p>通俗的讲，即 MyBatis 在使用 resultMap 来映射查询结果中的列，如果查询结果中包含空值的列，则 MyBatis 在映射的时候，不会映射这个字段，这就导致在调用到该字段的时候由于没有映射，取不到而报空指针异常。</p><p>当您遇到类似的情况，请针对该属性进行相关配置以解决以上问题。</p><blockquote><p>注意：基本类型（int、boolean 等）是不能设置成 null 的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.call-setters-on-nulls=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="6-3-8-9、configurationFactory"><a href="#6-3-8-9、configurationFactory" class="headerlink" title="6.3.8.9、configurationFactory"></a>6.3.8.9、configurationFactory</h5><ul><li>类型：Class&lt;?&gt; </li><li>默认值：null</li></ul><p>指定一个提供 Configuration 实例的工厂类。该工厂生产的实例将用来加载已经被反序列化对象的懒加载属性值，其必须包含一个签名方法static Configuration getConfiguration()。（从 3.2.3 版本开始）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.configuration-factory=</span><br></pre></td></tr></table></figure><h5 id="6-3-8-10、MyBatis3的配置属性"><a href="#6-3-8-10、MyBatis3的配置属性" class="headerlink" title="6.3.8.10、MyBatis3的配置属性"></a>6.3.8.10、MyBatis3的配置属性</h5><p>这里只列出 MyBatis3 的 settings 标签的属性，更多配置，请自行探索！</p><p>我们这里以日志打印为例，一般使用驼峰命名对应 “ - ”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><h4 id="6-3-9、globalConfig"><a href="#6-3-9、globalConfig" class="headerlink" title="6.3.9、globalConfig"></a>6.3.9、globalConfig</h4><ul><li>类型：com.baomidou.mybatisplus.core.config.GlobalConfig </li><li>默认值：GlobalConfig::new</li></ul><p>MyBatis-Plus 全局策略配置。</p><h5 id="6-3-9-1、banner"><a href="#6-3-9-1、banner" class="headerlink" title="6.3.9.1、banner"></a>6.3.9.1、banner</h5><ul><li>类型：boolean </li><li>默认值：true</li></ul><p>是否控制台 print mybatis-plus 的 LOGO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.banner=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="6-3-9-2、enableSqlRunner"><a href="#6-3-9-2、enableSqlRunner" class="headerlink" title="6.3.9.2、enableSqlRunner"></a>6.3.9.2、enableSqlRunner</h5><ul><li>类型：boolean </li><li>默认值：false</li></ul><p>是否初始化 SqlRunner(com.baomidou.mybatisplus.extension.toolkit.SqlRunner)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.enable-sql-runner=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="6-3-9-3、superMapperClass"><a href="#6-3-9-3、superMapperClass" class="headerlink" title="6.3.9.3、superMapperClass"></a>6.3.9.3、superMapperClass</h5><ul><li>类型：Class </li><li>默认值：com.baomidou.mybatisplus.core.mapper.Mapper.class</li></ul><p>通用Mapper父类(影响sqlInjector，只有这个的子类的 mapper 才会注入 sqlInjector 内的 method)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.<span class="built_in">super</span>-mapper-class=com.baomidou.mybatisplus.core.mapper.Mapper</span><br></pre></td></tr></table></figure><h5 id="6-3-9-4、dbConfig"><a href="#6-3-9-4、dbConfig" class="headerlink" title="6.3.9.4、dbConfig"></a>6.3.9.4、dbConfig</h5><ul><li>类型：com.baomidou.mybatisplus.core.config.GlobalConfig$DbConfig </li><li>默认值：null</li></ul><p>MyBatis-Plus 全局策略中的 DB 策略配置。</p><ul><li>类型：com.baomidou.mybatisplus.annotation.IdType </li><li>默认值：ASSIGN_ID</li></ul><p>全局默认主键类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.id-type=assign_id</span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：null</li></ul><p>表名前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.table-prefix=tbl_</span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：null</li></ul><p>schema。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.schema=</span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：null</li></ul><p>字段 format，例: %s，(对主键无效)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.column-format=</span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：null</li></ul><p>entity 的字段(property)的 format，只有在 column as property 这种情况下生效例: %s，(对主键无效)(since 3.3.0)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.property-format=</span><br></pre></td></tr></table></figure><ul><li>类型：boolean </li><li>默认值：true</li></ul><p>表名是否使用驼峰转下划线命名，只对表名生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.table-underline=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>类型：boolean </li><li>默认值：false</li></ul><p>大写命名，对表名和字段名均生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.capital-mode=<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：null</li></ul><p>全局的entity的逻辑删除字段属性名，(逻辑删除下有效)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.logic-delete-field=</span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：1</li></ul><p>逻辑已删除值，(逻辑删除下有效)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.logic-delete-value=<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>类型：String </li><li>默认值：0</li></ul><p>逻辑未删除值，(逻辑删除下有效)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value=<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>类型：com.baomidou.mybatisplus.annotation.FieldStrategy </li><li>默认值：NOT_NULL</li></ul><p>字段验证策略之 insert，在 insert 的时候的字段验证策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.insert-strategy=not_null</span><br></pre></td></tr></table></figure><ul><li>类型：com.baomidou.mybatisplus.annotation.FieldStrategy </li><li>默认值：NOT_NULL</li></ul><p>字段验证策略之 update，在 update 的时候的字段验证策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.update-strategy=not_null</span><br></pre></td></tr></table></figure><ul><li>类型：com.baomidou.mybatisplus.annotation.FieldStrategy </li><li>默认值：NOT_NULL</li></ul><p>字段验证策略之 select，在 select 的时候的字段验证策略既 wrapper 根据内部 entity 生成的 where 条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.global-config.db-config.select-strategy=not_null</span><br></pre></td></tr></table></figure><h3 id="6-4、配置小结"><a href="#6-4、配置小结" class="headerlink" title="6.4、配置小结"></a>6.4、配置小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#mybatis-plus</span><br><span class="line">mybatis-plus.mapper-locations=classpath*:**/mapper/xml<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">mybatis-plus.type-aliases-package=com.caochenlei.mpdemo.pojo</span></span><br><span class="line"><span class="comment">mybatis-plus.type-handlers-package=com.caochenlei.mpdemo.type</span></span><br><span class="line"><span class="comment">mybatis-plus.type-enums-package=com.caochenlei.mpdemo.enum</span></span><br><span class="line"><span class="comment">mybatis-plus.check-config-location=false</span></span><br><span class="line"><span class="comment">mybatis-plus.executor-type=simple</span></span><br><span class="line"><span class="comment">#mybatis-plus.configuration</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.map-underscore-to-camel-case=true</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.default-enum-type-handler=org.apache.ibatis.type.EnumTypeHandler</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.aggressive-lazy-loading=true</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.lazy-loading-enabled=true</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.auto-mapping-behavior=partial</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.auto-mapping-unknown-column-behavior=none</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.local-cache-scope=session</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.cache-enabled=true</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.call-setters-on-nulls=false</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.configuration-factory=</span></span><br><span class="line"><span class="comment">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="comment">#mybatis-plus.global-config</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.banner=true</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.enable-sql-runner=false</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.super-mapper-class=com.baomidou.mybatisplus.core.mapper.Mapper</span></span><br><span class="line"><span class="comment">#mybatis-plus.global-config.db-config</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.id-type=assign_id</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.table-prefix=tbl_</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.schema=</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.column-format=</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.property-format=</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.table-underline=true</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.capital-mode=false</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.logic-delete-field=</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.logic-delete-value=1</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.logic-not-delete-value=0</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.insert-strategy=not_null</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.update-strategy=not_null</span></span><br><span class="line"><span class="comment">mybatis-plus.global-config.db-config.select-strategy=not_null</span></span><br></pre></td></tr></table></figure><h2 id="第七章-MyBatis-Plus3插件扩展"><a href="#第七章-MyBatis-Plus3插件扩展" class="headerlink" title="第七章 MyBatis-Plus3插件扩展"></a>第七章 MyBatis-Plus3插件扩展</h2><p>创建包：com.caochenlei.mpdemo.config</p><p>新建类：com.caochenlei.mpdemo.config.MybatisPlusConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-1、分页插件"><a href="#7-1、分页插件" class="headerlink" title="7.1、分页插件"></a>7.1、分页插件</h3><p><strong>插件功能</strong>：提供数据分页功能。</p><p><strong>添加插件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>属性设置</strong>：</p><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPagination</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    Page&lt;Employee&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    Page&lt;Employee&gt; employeePage = employeeMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    employeePage.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span> + employeePage.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span> + employeePage.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;记录数：&quot;</span> + employeePage.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span> + employeePage.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span> + employeePage.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ef7a42c27c059478bfbe84310c4637d7.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e4dbaf11ff219aa5137b4a8f961b6a3.png" alt="img"></p><h3 id="7-2、执行分析插件"><a href="#7-2、执行分析插件" class="headerlink" title="7.2、执行分析插件"></a>7.2、执行分析插件</h3><p><strong>插件功能</strong>：防止全表更新与全表删除，依次保护数据库的安全，建议开发环境使用，不建议生产环境使用。</p><p><strong>添加插件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">// 添加执行分析插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBlockAttack</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.delete(<span class="literal">null</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/641483b91f9ed98157682515ef5e60f1.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/664ba37d9b3b759ff38eb5f4e4695b65.png" alt="img"></p><h3 id="7-3、性能分析插件"><a href="#7-3、性能分析插件" class="headerlink" title="7.3、性能分析插件"></a>7.3、性能分析插件</h3><p><strong>插件功能</strong>：该功能依赖 p6spy 组件，完美的输出打印 SQL 及执行时长， 3.1.0 以上版本支持。</p><p><strong>添加依赖</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;p6spy&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;p6spy&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.9</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>修改配置</strong>：application.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#mysql</span><br><span class="line">#spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">#spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">#spring.datasource.username=root</span><br><span class="line">#spring.datasource.password=<span class="number">123456</span></span><br><span class="line">#p6spy</span><br><span class="line">spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">spring.datasource.url=jdbc:p6spy:mysql:<span class="comment">//localhost:3306/mp</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong>：spy.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">3.2</span><span class="number">.1</span>以上使用</span><br><span class="line">modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><br><span class="line"># 日志输出到控制台</span><br><span class="line">appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br><span class="line"># 使用日志系统记录 sql</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line"># 设置 p6spy driver 代理</span><br><span class="line">deregisterdrivers=<span class="literal">true</span></span><br><span class="line"># 取消JDBC URL前缀</span><br><span class="line">useprefix=<span class="literal">true</span></span><br><span class="line"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><br><span class="line">excludecategories=info,debug,result,commit,resultset</span><br><span class="line"># 日期格式</span><br><span class="line">dateformat=yyyy-MM-dd HH:mm:ss</span><br><span class="line"># 实际驱动可多个</span><br><span class="line">driverlist=com.mysql.jdbc.Driver</span><br><span class="line"># 是否开启慢SQL记录</span><br><span class="line">outagedetection=<span class="literal">true</span></span><br><span class="line"># 慢SQL记录标准 <span class="number">2</span> 秒</span><br><span class="line">outagedetectioninterval=<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>注意问题</strong>：</p><ul><li>driver-class-name 为 p6spy 提供的驱动类 </li><li>url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址 </li><li>打印出sql为null，在excludecategories增加commit </li><li>批量操作不打印sql，去除excludecategories中的batch </li><li>批量操作打印重复的问题请使用MybatisPlusLogFactory (3.2.1新增） </li><li>该插件有性能损耗，不建议生产环境使用</li></ul><p><strong>添加插件</strong>：该插件不用添加自动集成</p><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPagination</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    Page&lt;Employee&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    Page&lt;Employee&gt; employeePage = employeeMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    employeePage.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span> + employeePage.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span> + employeePage.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;记录数：&quot;</span> + employeePage.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span> + employeePage.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span> + employeePage.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/26a31d71304c1436eb2704d48992c1b9.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d88232ccd0d7529af7092cbd64c4bc22.png" alt="img"></p><h3 id="7-4、乐观锁插件"><a href="#7-4、乐观锁插件" class="headerlink" title="7.4、乐观锁插件"></a>7.4、乐观锁插件</h3><p><strong>插件功能</strong>：当要更新一条记录的时候，希望这条记录没有被别人更新，可以使用乐观锁，MyBatis-Plus就提供了乐观锁插件。</p><p><strong>实现方式</strong>：乐观锁实现方式如下</p><ol><li>取出记录时，获取当前version </li><li>更新时，带上这个version </li><li>执行更新时， set version = newVersion where version = oldVersion </li><li>如果version不对，就更新失败</li></ol><p><strong>添加字段</strong>：</p><ul><li>数据库： ALTER TABLE <code>tbl_employee</code> ADD COLUMN <code>version</code> INT(11) DEFAULT ‘1’ NULL AFTER <code>age</code>;  </li><li>实体类： <pre><code class="prism language-java"><span class="token annotation punctuation">@Version</span><br><span class="token keyword">private</span> <span class="token class-name">Integer</span> version<span class="token punctuation">;</span></li></ul><p><span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><pre><code>&lt;!-- --&gt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; version&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;</code></pre><p><span class="token punctuation">}</span></p><p><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setVersion</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> version<span class="token punctuation">)</span> <span class="token punctuation">{</p><pre><code>&lt;!-- --&gt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;version &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; version&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;</code></pre><p><span class="token punctuation">}</span><br>&lt;/code&gt;&lt;/pre&gt; </p><p><strong>注意事项</strong>：</p><ul><li>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime </li><li>整数类型下 newVersion = oldVersion + 1 </li><li>newVersion 会回写到 entity 中 </li><li>仅支持 updateById(id) 与 update(entity, wrapper) 方法 </li><li>在 update(entity, wrapper) 方法下， wrapper 不能复用</li></ul><p><strong>添加插件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">// 添加执行分析插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">        <span class="comment">// 添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    employee.setLastName(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> employeeMapper.updateById(employee);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/821729e40b177862b0abfcf4e4231186.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a00a4b3630f16ef199493ed1973abd99.png" alt="img"></p><h3 id="7-5、快速开发插件"><a href="#7-5、快速开发插件" class="headerlink" title="7.5、快速开发插件"></a>7.5、快速开发插件</h3><p><strong>插件功能</strong>：可以通过接口方法名直接创建对应mapper中的sql标签，还可以Mapper和xml可以来回跳，更多功能自行探索！</p><p><strong>计划支持：</strong></p><ul><li>连接数据源之后 xml 里自动提示字段 </li><li>sql 增删改查 </li><li>集成 MP 代码生成 </li><li>其它</li></ul><p><strong>安装方法</strong>：</p><p>需要MybatisX插件支持，只需要安装一下就可以了，打开 IDEA，进入 File -&gt; Settings -&gt; Plugins，安装完成后重启</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9b1803a41d1f4694f99347527f8de08f.png" alt="img"></p><h2 id="第八章-MyBatis-Plus3其它功能"><a href="#第八章-MyBatis-Plus3其它功能" class="headerlink" title="第八章 MyBatis-Plus3其它功能"></a>第八章 MyBatis-Plus3其它功能</h2><h3 id="8-1、Sql-注入器"><a href="#8-1、Sql-注入器" class="headerlink" title="8.1、Sql 注入器"></a>8.1、Sql 注入器</h3><p>根据 MybatisPlus 的 AutoSqlInjector 可以自定义各种你想要的 SQL 注入到全局中，相当于自定义 MybatisPlus 自动注入的方法。之前需要在 xml 中进行配置的 SQL 语句，现在通过扩展 AutoSqlInjector 在加载 mybatis 环境时就注入。</p><p><strong>接口方法</strong>：然后在添加一个@Repository注解</p><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：我们不需要编写xml映射，因为我们会采用sql注入的形式，在 MybatisPlus 启动的时候就注入。</p></blockquote><p><strong>创建对象</strong>：在该com.caochenlei.mpdemo.injector(没有创建)包下创建MyMappedStatement.java、MySqlInjector.java</p><p>MyMappedStatement.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMappedStatement</span> <span class="keyword">extends</span> <span class="title class_">AbstractMethod</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MappedStatement <span class="title function_">injectMappedStatement</span><span class="params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 接口中的方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;deleteAll&quot;</span>;</span><br><span class="line">        <span class="comment">// 该方法执行语句</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from &quot;</span> + tableInfo.getTableName();</span><br><span class="line">        <span class="comment">// 创建SqlSource</span></span><br><span class="line">        <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> languageDriver.createSqlSource(configuration, sql, modelClass);</span><br><span class="line">        <span class="comment">// 构造一个删除的MappedStatement并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.addDeleteMappedStatement(mapperClass, method, sqlSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySqlInjector.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySqlInjector</span> <span class="keyword">extends</span> <span class="title class_">DefaultSqlInjector</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title function_">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        List&lt;AbstractMethod&gt; methodList = <span class="built_in">super</span>.getMethodList(mapperClass);</span><br><span class="line">        methodList.add(<span class="keyword">new</span> <span class="title class_">MyMappedStatement</span>());</span><br><span class="line">        <span class="keyword">return</span> methodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释“执行分析插件”</strong>：会影响代码执行，它会阻止全表删除操作，所以先注释掉，反正我们已经学会了</p><p>MybatisPlusConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">// 添加执行分析插件</span></span><br><span class="line">        <span class="comment">//interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());</span></span><br><span class="line">        <span class="comment">// 添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加“自定义SQL注入对象”</strong>：</p><p>MybatisPlusConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="comment">// 添加执行分析插件</span></span><br><span class="line">        <span class="comment">//interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());</span></span><br><span class="line">        <span class="comment">// 添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MySqlInjector <span class="title function_">mySqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySqlInjector</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteAll</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    userMapper.deleteAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：没有写xml映射代码，它也会执行删除，原因是我们在启动的时候自动注入了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8901fa75eec495fab89d3ffd559d2abf.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/883cc595767e5fd3017979d14c2cabc9.png" alt="img"></p><h3 id="8-2、逻辑删除"><a href="#8-2、逻辑删除" class="headerlink" title="8.2、逻辑删除"></a>8.2、逻辑删除</h3><p><strong>逻辑删除</strong>：数据删除并不会真正的从数据库中将数据删除掉，而是将当前被删除的这条数据中的一个逻辑删除字段置为删除状态。</p><p><strong>导入数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">## 删除表</span><br><span class="line">DROP TABLE IF EXISTS `tbl_student`;</span><br><span class="line">## 创建表</span><br><span class="line">CREATE TABLE `tbl_student` (</span><br><span class="line">  `id` INT(<span class="number">11</span>) NOT NULL AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `name` VARCHAR(<span class="number">255</span>) DEFAULT NULL COMMENT <span class="string">&#x27;学生姓名&#x27;</span>,</span><br><span class="line">  `age` INT(<span class="number">11</span>) DEFAULT NULL COMMENT <span class="string">&#x27;学生年龄&#x27;</span>,</span><br><span class="line">  `grade` VARCHAR(<span class="number">255</span>) DEFAULT NULL COMMENT <span class="string">&#x27;学生年纪&#x27;</span>,</span><br><span class="line">  `status` VARCHAR(<span class="number">255</span>) DEFAULT NULL COMMENT <span class="string">&#x27;学生状态&#x27;</span>,</span><br><span class="line">  `deleted` INT(<span class="number">11</span>) DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除（0:未删除、1:已删除）&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span></span><br><span class="line">) DEFAULT CHARSET=utf8 COMMENT=<span class="string">&#x27;学生&#x27;</span>;</span><br><span class="line">## 导入数据</span><br><span class="line">INSERT  INTO `tbl_student`(`id`,`name`,`age`,`grade`,`status`,`deleted`) VALUES (<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,NULL,NULL,NULL,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>代码生成</strong>：运行代码生成器，生成代码</p><p><img src="https://img-blog.csdnimg.cn/img_convert/92791979b98be99a4ee2ef244f7cf906.png" alt="img"></p><p><strong>添加配置</strong>：application.properties，如果以下配置已经存在，请忽略此步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#那个字段是逻辑删除字段，也可以在字段上添加注解<span class="meta">@TableLogic</span>，在这里边配置是全局生效</span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-field=deleted</span><br><span class="line">#删除后字段的值为<span class="number">1</span></span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-value=<span class="number">1</span></span><br><span class="line">#未删除字段的值为<span class="number">0</span></span><br><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLogicDelete</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> studentMapper.deleteById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7daeb4912188a1b2af8ad40085745949.png" alt="img"></p><p><strong>数据库截图</strong>：你会发现数据还存在，只是将其中的逻辑删除标志由0改为了1，代表逻辑删除</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0b556934a55f689bfb3db00b5a6873ca.png" alt="img"></p><h3 id="8-3、通用枚举"><a href="#8-3、通用枚举" class="headerlink" title="8.3、通用枚举"></a>8.3、通用枚举</h3><p>实现自定义枚举有两种方式，一种是使用注解而另一种是使用实现接口IEnum的方式，在接下来的案例中，我们会分别使用这两种进行讲解，这样可以让大家学的更全面一些。</p><h4 id="8-3-1、保存枚举值"><a href="#8-3-1、保存枚举值" class="headerlink" title="8.3.1、保存枚举值"></a>8.3.1、保存枚举值</h4><p><strong>添加配置</strong>：application.properties，如果有以下配置，请忽略此步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.type-enums-<span class="keyword">package</span>=com.caochenlei.mpdemo.myenum</span><br><span class="line">mybatis-plus.configuration.<span class="keyword">default</span>-<span class="keyword">enum</span>-type-handler=org.apache.ibatis.type.EnumOrdinalTypeHandler</span><br></pre></td></tr></table></figure><p><strong>创建枚举类</strong>：com.caochenlei.mpdemo.myenum.AgeEnum</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AgeEnum</span> <span class="keyword">implements</span> <span class="title class_">IEnum</span>&lt;Integer&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    ONE(<span class="number">1</span>, <span class="string">&quot;一岁&quot;</span>),</span><br><span class="line">    TWO(<span class="number">2</span>, <span class="string">&quot;二岁&quot;</span>),</span><br><span class="line">    THREE(<span class="number">3</span>, <span class="string">&quot;三岁&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    AgeEnum(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//数值作为枚举值保存到数据库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改实体类</strong>：com.caochenlei.mpdemo.pojo.Student</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AgeEnum age;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgeEnum</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    student.setAge(AgeEnum.THREE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> studentMapper.insert(student);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bfcf1f48b9b9e90adcdcaf4f954b2eb2.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8272d33940f9d93110fe427cbe878d4f.png" alt="img"></p><h4 id="8-3-2、保存枚举名称"><a href="#8-3-2、保存枚举名称" class="headerlink" title="8.3.2、保存枚举名称"></a>8.3.2、保存枚举名称</h4><p><strong>添加配置</strong>：application.properties，如果有以下配置，请忽略此步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus.type-enums-<span class="keyword">package</span>=com.caochenlei.mpdemo.myenum</span><br><span class="line">mybatis-plus.configuration.<span class="keyword">default</span>-<span class="keyword">enum</span>-type-handler=org.apache.ibatis.type.EnumOrdinalTypeHandler</span><br></pre></td></tr></table></figure><p><strong>创建枚举类</strong>：com.caochenlei.mpdemo.myenum.GradeEnum</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">GradeEnum</span> &#123;</span><br><span class="line">   </span><br><span class="line">    PRIMARY(<span class="number">1</span>, <span class="string">&quot;小学&quot;</span>),</span><br><span class="line">    SECONDORY(<span class="number">2</span>, <span class="string">&quot;中学&quot;</span>),</span><br><span class="line">    HIGH(<span class="number">3</span>, <span class="string">&quot;高中&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="meta">@EnumValue</span><span class="comment">//描述作为枚举值保存到数据库</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    GradeEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改实体类</strong>：com.caochenlei.mpdemo.pojo.Student</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生年纪</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> GradeEnum grade;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGradeEnum</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    student.setGrade(GradeEnum.HIGH);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> studentMapper.insert(student);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8ba82a7d54d3985f7d819a229b97d90c.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f6e92716d8b48a7aa7c6438850a3312.png" alt="img"></p><h3 id="8-4、自动填充功能"><a href="#8-4、自动填充功能" class="headerlink" title="8.4、自动填充功能"></a>8.4、自动填充功能</h3><p>我们现在有一个需求，每当插入一个学生的时候，自动的给学生状态设置为”插入“，每当修改的时候，如果状态标志位为null，就把标志字段设置为”修改“，这时候就需要自动填充功能了。</p><p>metaobject：元对象，是 Mybatis 提供的一个用于更加方便，更加优雅的访问对象的属性，给对象的属性设置值的一个对象，还会用于包装对象，支持对 Object 、Map、Collection等对象进行包装，本质上 metaObject 获取对象的属性值或者是给对象的属性设置值，最终是要通过 Reflector 获取到属性的对应方法的 Invoker，最终 invoke。</p><p><strong>添加注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> String status;</span><br></pre></td></tr></table></figure><p><strong>创建包</strong>：com.caochenlei.mpdemo.metaObjectHandler</p><p><strong>创建自动填充功能处理器</strong>：com.caochenlei.mpdemo.metaObjectHandler.MyMetaObjectHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        System.out.println(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;status&quot;</span>,String.class,<span class="string">&quot;插入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        System.out.println(<span class="string">&quot;start update fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;status&quot;</span>,String.class,<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册自动填充功能处理器</strong>：MybatisPlusConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyMetaObjectHandler <span class="title function_">myMetaObjectHandler</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyMetaObjectHandler</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：依次执行两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testInsertFill</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;小六&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> studentMapper.insert(student);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateFill</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectById(<span class="number">4</span>);</span><br><span class="line">    student.setName(<span class="string">&quot;李四-修改&quot;</span>);</span><br><span class="line">    student.setStatus(<span class="literal">null</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> studentMapper.updateById(student);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p>testInsertFill之后</p><p><img src="https://img-blog.csdnimg.cn/img_convert/586a3c21258c9fa468a13ac37c3a2ed3.png" alt="img"></p><p>testUpdateFill之后</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5815d12e6c80e4fe647da717da1e31a9.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p>testInsertFill之后</p><p><img src="https://img-blog.csdnimg.cn/img_convert/508bdb0ae5d4d9aac62446e132cee21e.png" alt="img"></p><p>testUpdateFill之后</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f90de454b8e3e005c3e654bce82d69e0.png" alt="img"></p><h3 id="8-5、字段类型处理器"><a href="#8-5、字段类型处理器" class="headerlink" title="8.5、字段类型处理器"></a>8.5、字段类型处理器</h3><p>字段类型处理器，用于 JavaType 与 JdbcType 之间的转换，用于 PreparedStatement 设置参数值和从 ResultSet 或 CallableStatement 中取出一个值，本文讲解 mybaits-plus 内置常用类型处理器如何通过TableField注解快速注入到 mybatis 容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@TableName(autoResultMap = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意！！ 必须开启映射注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableName</span>(autoResultMap = true)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 以下两种类型处理器，二选一，也可以同时存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意！！ 选择对应的 JSON 处理器也必须存在对应 JSON 解析依赖包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(typeHandler = JacksonTypeHandler.class)</span></span><br><span class="line">    <span class="comment">// @TableField(typeHandler = FastjsonTypeHandler.class)</span></span><br><span class="line">    <span class="keyword">private</span> OtherInfo otherInfo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-6、自定义ID生成器"><a href="#8-6、自定义ID生成器" class="headerlink" title="8.6、自定义ID生成器"></a>8.6、自定义ID生成器</h3><p><strong>导入数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 删除表</span><br><span class="line">DROP TABLE IF EXISTS `tbl_product`;</span><br><span class="line">## 新建表</span><br><span class="line">CREATE TABLE `tbl_product` (</span><br><span class="line">  `pid` <span class="type">int</span>(<span class="number">11</span>) NOT NULL COMMENT <span class="string">&#x27;商品主键&#x27;</span>,</span><br><span class="line">  `pname` varchar(<span class="number">255</span>) DEFAULT NULL COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="title function_">KEY</span> <span class="params">(`pid`)</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=<span class="string">&#x27;商品&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>生成代码</strong>：运行CodeGenerator</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ab9befd263d092403766e1a247cc7281.png" alt="img"></p><p><strong>温馨提示</strong>：自3.3.0开始，默认使用雪花算法+UUID(不含中划线)</p><p><strong>重写方法</strong>：</p><p><strong>创建包</strong>：com.caochenlei.mpdemo.incrementer</p><p><strong>创建类</strong>：com.caochenlei.mpdemo.incrementer.CustomIdGenerator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomIdGenerator</span> <span class="keyword">implements</span> <span class="title class_">IdentifierGenerator</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(Object entity)</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//可以将当前传入的class全类名来作为bizKey或者提取参数来生成bizKey进行分布式Id调用生成</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bizKey</span> <span class="operator">=</span> entity.getClass().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;bizKey:&quot;</span> + bizKey);</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> SystemMetaObject.forObject(entity);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) metaObject.getValue(<span class="string">&quot;pname&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> al.getAndAdd(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;为&quot;</span> + name + <span class="string">&quot;生成主键值-&gt;:&quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册类</strong>：MybatisPlusConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IdentifierGenerator <span class="title function_">customIdGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomIdGenerator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改主键策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品主键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableId(value = &quot;pid&quot;, type = IdType.ASSIGN_ID)</span></span><br><span class="line"><span class="keyword">private</span> Long pid;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomIdGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    product.setPname(<span class="string">&quot;手机&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> productMapper.insert(product);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/853e9cb8c2bc17468478d61774dc52df.png" alt="img"></p><p><strong>数据库截图</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/608baf9ae39a92debdbbd29f121b791b.png" alt="img"></p><h3 id="8-7、Sequence主键"><a href="#8-7、Sequence主键" class="headerlink" title="8.7、Sequence主键"></a>8.7、Sequence主键</h3><p>在实际开发中，我们经常会使用到MySQL和Oracle数据库，但是这两种数据库对于主键有不同的策略，如下：</p><ul><li>MySQL：支持主键自增，type = IdType.Auto </li><li>Oracle：支持序列自增，type = IdType.INPUT</li></ul><p>那我们Oracle又要如何使用主键策略，在这里，我们就不进行一步一步介绍了，我们只提出解决方法</p><ol><li><p>在实体类对象上添加注解@KeySequence(value=”序列名”, clazz=主键属性类型.class)  </p></li><li><p>在实体类对象的主键字段上添加注解@TableId(value = “主键名称”, type = IdType.INPUT) <pre><code class="prism language-java"><span class="token annotation punctuation">@KeySequence</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">“SEQ_ORACLE_INTEGER_KEY”</span><span class="token punctuation">,</span> clazz <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><br><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">YourEntity</span> <span class="token punctuation">{</p><p><!-- -->&lt;/span&gt;</p><p><span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">“ID”</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span>INPUT<span class="token punctuation">)</span><br><span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span></p></li></ol><p><span class="token punctuation">}</span><br>&lt;/code&gt;&lt;/pre&gt;  </p><ol><li><p>在全局配置中注册com.baomidou.mybatisplus.incrementer.OracleKeyGenerator <pre><code class="prism language-java"><span class="token annotation punctuation">@Bean</span><br><span class="token keyword">public</span> <span class="token class-name">IKeyGenerator</span> <span class="token function">keyGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</p><p><!-- -->&lt;/span&gt;<br><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">oracleKeyGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br>&lt;/code&gt;&lt;/pre&gt; </p></li></ol><p>除了Oracle，MyBatis-Plus还内置支持以下数据库序列：</p><ul><li>DB2KeyGenerator </li><li>H2KeyGenerator </li><li>KingbaseKeyGenerator </li><li>OracleKeyGenerator </li><li>PostgreKeyGenerator</li></ul><p>如果内置支持不满足你的需求，可实现IKeyGenerator接口来进行扩展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-MyBatis-Plus3概述&quot;&gt;&lt;a href=&quot;#第一章-MyBatis-Plus3概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 MyBatis-Plus3概述&quot;&gt;&lt;/a&gt;第一章 MyBatis-Plus3概述&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="MyBatis-Plus" scheme="https://manamn.space/categories/MyBatis-Plus/"/>
    
    
    <category term="框架" scheme="https://manamn.space/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="MyBatis-Plus" scheme="https://manamn.space/tags/MyBatis-Plus/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript这一篇就够了</title>
    <link href="https://manamn.space/2022/10/18/%E5%AD%A6%E4%B9%A0JavaScript%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://manamn.space/2022/10/18/%E5%AD%A6%E4%B9%A0JavaScript%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</id>
    <published>2022-10-18T02:51:37.000Z</published>
    <updated>2022-10-18T02:53:38.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1、JavaScript的起源"><a href="#1-1、JavaScript的起源" class="headerlink" title="1.1、JavaScript的起源"></a>1.1、JavaScript的起源</h2><p>JavaScript诞生于1995年，它的出现主要是用于处理网页中的前端验证。所谓的前端验证，就是指检查用户输入的内容是否符合一定的规则。比如：用户名的长度，密码的长度，邮箱的格式等。但是，有的同学可能会有疑问，这些验证，后端不也可以进行验证吗？确实，后端程序的确可以进行这些验证，但你要清楚，在1995年那个年代，网速是非常慢的，向后端发送一个请求，浏览器很久才能得到响应，那这无疑是一种非常不好的用户体验。</p><p>为了解决前端验证的问题，当时的浏览器巨头NetScape（网景）公司就开发出一种脚本语言，起初命名为LiveScript，后来由于SUN公司的介入更名为了JavaScript。但是你要清楚，Java和JavaScript是没有什么关系的，只不过当时Java非常流行，为了蹭热度，才将LiveScript更名为JavaScript，它们的关系就像雷锋和雷峰塔的关系一样，没啥关系。</p><p>但是，浏览器开发商不止网景一家，还有一个大家都知道的公司，微软公司，它们的主打产品是IE（Internet Explorer）浏览器，当网景公司的Netscape Navigator浏览器推出JavaScript语言时，微软就急了啊，好家伙，人网景都推出了专门用于前端验证的语言，不仅大大减少了后端程序的压力，还提高了用户的体验。我微软这么大的公司不也得整一个，在1996年，微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript。</p><p>于是在市面上存在两个版本的JavaScript，一个网景公司的JavaScript和微软的JScript，虽然当时浏览器的巨头是网景，但是网景的浏览器是收费的，虽然微软的IE浏览器在全球的市场份额远远不及网景，但是微软的拳头产品是Windows操作系统，每一个操作系统都自带一个IE浏览器并且免费，那么，未来的发展大家可能也想到了，网景让微软给干倒闭了，1998年11月，网景被美国在线（AOL）收购。</p><p>老大哥就是老大哥，为了抢先获得规则制定权，网景最先将JavaScript作为草案提交给欧洲计算机制造商协会，也就是ECMA组织，希望能将JavaScript做成行业标准，最终在网景、SUN以及微软等公司的参与下，由一众程序员和相关组织人员组成的第39技术委员会也就是TC39发布了ECMA-262标准，这个标准定义了名为ECMAScript的全新脚本语言，为啥又来了个ECMAScript？</p><p>因为Java是SUN的商标，SUN授权了NetScape可以叫JavaScript，但是ECMA没有SUN的授权就不能叫JavaScript，哪怕NetScape成员特别希望ECMA把它叫做JavaScript，但是ECMA也有成员并不希望这个标准就叫JavaScript，总之经过几轮磋商和博弈，ECMAScript这个名字就定下来。</p><p>我们可以简单看一下历史事件发展表：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/34ceed720299546a8161deab88fe16aa.png" alt="img"></p><h2 id="1-2、JavaScript的组成"><a href="#1-2、JavaScript的组成" class="headerlink" title="1.2、JavaScript的组成"></a>1.2、JavaScript的组成</h2><p>ECMAScript是一个标准，而这个标准需要由各个厂商去实现，不同的浏览器厂商对该标准会有不同的实现。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/584d9295990909d32b3338dbbbe9c037.png" alt="img"></p><p>我们已经知道ECMAScript是JavaScript标准，所以一般情况下这两个词我们认为是一个意思。但是实际上JavaScript的含义却要更大一些。一个完整的JavaScript实现应该由以下三个部分构成：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fafb929ac005ed0e9e2dedb433fe8eab.png" alt="img"></p><p>由此我们也知道了我们所要学习的内容就是这三部分，它们具体的含义后边章节会具体介绍。</p><h2 id="1-3、JavaScript的特点"><a href="#1-3、JavaScript的特点" class="headerlink" title="1.3、JavaScript的特点"></a>1.3、JavaScript的特点</h2><p><strong>解释型语言</strong></p><p>JavaScript是一门解释型语言，所谓解释型值语言是指不需要被编译为机器码在执行，而是直接执行。由于少了编译这一步骤，所以解释型语言开发起来尤为轻松，但是解释型语言运行较慢也是它的劣势。不过解释型语言中使用了JIT技术，使得运行速度得以改善。</p><p><strong>动态语言</strong></p><p>JavaScript是一门动态语言，所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的。比如一个变量，这一时刻是个整型，下一时刻可能会变成字符串了。当然这个问题我们以后再谈。不过在补充一句动态语言相比静态语言性能上要差一些，不过由于JavaScript中应用的JIT技术，所以JavaScript可能是运行速度最快的动态语言了。</p><p><strong>类似于 C 和 Java 的语法结构</strong></p><p>JavaScript的语法结构与C和Java很像，向for、if、while等语句和Java的基本上是一模一样的。所以有过C和Java基础的同学学习起来会轻松很多。不过JavaScript和与Java的关系也仅仅是看起来像而已。</p><p><strong>基于原型的面向对象</strong></p><p>JavaScript是一门面向对象的语言。啥是对象？下次聊。</p><p>Java也是一门面向对象的语言，但是与Java不同JavaScript是基于原型的面向对象。啥是原型？下次聊。</p><p><strong>严格区分大小写</strong></p><p>JavaScript是严格区分大小写的，也就是abc和Abc会被解析器认为是两个不同的东西。</p><h2 id="1-4、JavaScript的使用"><a href="#1-4、JavaScript的使用" class="headerlink" title="1.4、JavaScript的使用"></a>1.4、JavaScript的使用</h2><h3 id="1-4-1、标签引用"><a href="#1-4-1、标签引用" class="headerlink" title="1.4.1、标签引用"></a>1.4.1、标签引用</h3><p>在HTML中在script标签中就可以编写JavaScript代码，以下是一个简单演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    alert(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-2、文件引用"><a href="#1-4-2、文件引用" class="headerlink" title="1.4.2、文件引用"></a>1.4.2、文件引用</h3><p>在一个单独的js文件中也可以编写JavaScript代码，然后在HTML文件中使用script标签进行引用，以下是一个简单演示。</p><p>main.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;main.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;Hello,World!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="1-5、JavaScript的输出"><a href="#1-5、JavaScript的输出" class="headerlink" title="1.5、JavaScript的输出"></a>1.5、JavaScript的输出</h2><h3 id="1-5-1、页面输出"><a href="#1-5-1、页面输出" class="headerlink" title="1.5.1、页面输出"></a>1.5.1、页面输出</h3><p>如何使用JavaScript向页面输出一句话，请参考以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.write(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-2、控制台输出"><a href="#1-5-2、控制台输出" class="headerlink" title="1.5.2、控制台输出"></a>1.5.2、控制台输出</h3><p>如何使用JavaScript向控制台输出一句话，请参考以下代码。</p><blockquote><p>注意：页面按F12弹出控制台</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(<span class="string">&quot;输出一条日志&quot;</span>);<span class="comment">//最常用</span></span><br><span class="line">    console.info(<span class="string">&quot;输出一条信息&quot;</span>);</span><br><span class="line">    console.warn(<span class="string">&quot;输出一条警告&quot;</span>);</span><br><span class="line">    console.error(<span class="string">&quot;输出一条错误&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0ce4f104e24737e922449dfcd54951f2.png" alt="img"></p><h3 id="1-5-3、弹出窗口输出"><a href="#1-5-3、弹出窗口输出" class="headerlink" title="1.5.3、弹出窗口输出"></a>1.5.3、弹出窗口输出</h3><p>如何使用JavaScript向弹出窗口输出一句话，请参考以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    alert(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="1-6、JavaScript的注释"><a href="#1-6、JavaScript的注释" class="headerlink" title="1.6、JavaScript的注释"></a>1.6、JavaScript的注释</h2><p>注释中的内容不会被解析器解析执行，但是会在源码中显示，我们一般会使用注释对程序中的内容进行解释。</p><p>JS中的注释和Java的的一致，分为两种：</p><ul><li>单行注释：// 注释内容 </li><li>多行注释：/<em> 注释内容 </em>/</li></ul><h3 id="1-6-1、单行注释"><a href="#1-6-1、单行注释" class="headerlink" title="1.6.1、单行注释"></a>1.6.1、单行注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 这是注释内容</span></span><br><span class="line">    console.log(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="1-6-2、多行注释"><a href="#1-6-2、多行注释" class="headerlink" title="1.6.2、多行注释"></a>1.6.2、多行注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是注释内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    console.log(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-1、标识符"><a href="#2-1、标识符" class="headerlink" title="2.1、标识符"></a>2.1、标识符</h2><p>所谓标识符，就是指给变量、函数、属性或函数的参数起名字。</p><p>标识符可以是按照下列格式规则组合起来的一或多个字符：</p><ul><li>第一个字符必须是一个字母、下划线（ _ ）或一个美元符号（ $ ）。 </li><li>其它字符可以是字母、下划线、美元符号或数字。 </li><li>按照惯例，ECMAScript 标识符采用驼峰命名法。 </li><li>标识符不能是关键字和保留字符。</li></ul><p><strong>关键字：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/06bab955dce3d478eb0ee1880efdbf13.png" alt="img"></p><p><strong>保留字符：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/321c5fb7e148d7fa99e59440083b0a4b.png" alt="img"></p><p><strong>其它不建议使用的标识符：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/612f0462d3cde3f2fa410ccd8b6da15b.png" alt="img"></p><p><strong>单个单词的标识符举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name、age、gender、hobby</span><br></pre></td></tr></table></figure><p><strong>多个单词的标识符举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentName、studentAge、studentGender、studentHobby</span><br></pre></td></tr></table></figure><h2 id="2-2、字面量和变量"><a href="#2-2、字面量和变量" class="headerlink" title="2.2、字面量和变量"></a>2.2、字面量和变量</h2><h3 id="2-2-1、字面量"><a href="#2-2-1、字面量" class="headerlink" title="2.2.1、字面量"></a>2.2.1、字面量</h3><p>字面量实际上就是一些固定的值，比如：1、2 、3、true、false、null、NaN、“hello”，字面量都是不可以改变的，由于字面量不是很方便使用，所以在JavaScript中很少直接使用字面量，使用的而是变量。</p><h3 id="2-2-2、变量"><a href="#2-2-2、变量" class="headerlink" title="2.2.2、变量"></a>2.2.2、变量</h3><p>变量的作用是给某一个值或对象标注名称。比如我们的程序中有一个值123，这个值我们是需要反复使用的，这个时候 我们最好将123这个值赋值给一个变量，然后通过变量去使用123这个值。</p><p><strong>变量的声明：</strong> 使用var关键字声明一个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure><p><strong>变量的赋值：</strong> 使用=为变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p><strong>声明和赋值同时进行：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h2 id="2-3、数据类型"><a href="#2-3、数据类型" class="headerlink" title="2.3、数据类型"></a>2.3、数据类型</h2><h3 id="2-3-1、类型分类"><a href="#2-3-1、类型分类" class="headerlink" title="2.3.1、类型分类"></a>2.3.1、类型分类</h3><p>数据类型决定了一个数据的特征，比如：123和”123”，直观上看这两个数据都是123，但实际上前者是一个数字，而后者是一个字符串。</p><p>对于不同的数据类型我们在进行操作时会有很大的不同。</p><p>JavaScript中一共有5种基本数据类型：</p><ul><li>字符串型（String） </li><li>数值型（Number） </li><li>布尔型（Boolean） </li><li>undefined型（Undefined） </li><li>null型（Null）</li></ul><p>这5种之外的类型都称为Object，所以总的来看JavaScript中共有六种数据类型。</p><h3 id="2-3-2、typeof运算符"><a href="#2-3-2、typeof运算符" class="headerlink" title="2.3.2、typeof运算符"></a>2.3.2、typeof运算符</h3><p>使用typeof操作符可以用来检查一个变量的数据类型。</p><p><strong>使用方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof 数据</span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof <span class="number">123</span>);</span><br><span class="line">console.log(typeof <span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">console.log(typeof <span class="literal">true</span>);</span><br><span class="line">console.log(typeof undefined);</span><br><span class="line">console.log(typeof <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b9ba0a296f0c0a973fae0c2bda964929.png" alt="img"></p><h3 id="2-3-3、String"><a href="#2-3-3、String" class="headerlink" title="2.3.3、String"></a>2.3.3、String</h3><p>String用于表示一个字符序列，即字符串。字符串需要使用 <strong>单引号</strong> 或 <strong>双引号</strong> 括起来。</p><p><strong>转义字符：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8cd27bded82d24387ae42b8444f0d25e.png" alt="img"></p><blockquote><p>注意：使用typeof运算符检查字符串时，会返回”string”。</p></blockquote><h3 id="2-3-4、Number"><a href="#2-3-4、Number" class="headerlink" title="2.3.4、Number"></a>2.3.4、Number</h3><p>Number 类型用来表示整数和浮点数，最常用的功能就是用来表示10进制的整数和浮点数。</p><p>Number表示的数字大小是有限的，如果超过了这个范围，则会返回 ±Infinity。</p><ul><li>最大值：+1.7976931348623157e+308 </li><li>最小值：-1.7976931348623157e+308 </li><li>0以上的最小值：5e-324</li></ul><p><strong>特殊的数字：</strong></p><ul><li>Infinity：正无穷 </li><li>-Infinity：负无穷 </li><li>NaN：非法数字（Not A Number）</li></ul><p><strong>其它的进制：</strong></p><ul><li>二进制：0b 开头表示二进制，但是，并不是所有的浏览器都支持 </li><li>八进制：0 开头表示八进制 </li><li>十六进制：0x 开头表示十六进制</li></ul><blockquote><p>注意：使用typeof检查一个Number类型的数据时（包括NaN 和 Infinity），会返回”number”。</p></blockquote><h3 id="2-3-5、Boolean"><a href="#2-3-5、Boolean" class="headerlink" title="2.3.5、Boolean"></a>2.3.5、Boolean</h3><p>布尔型也被称为逻辑值类型或者真假值类型。</p><p>布尔型只能够取真（true）和假（false）两种数值。除此以外， 其它的值都不被支持。</p><h3 id="2-3-6、Undefined"><a href="#2-3-6、Undefined" class="headerlink" title="2.3.6、Undefined"></a>2.3.6、Undefined</h3><p>Undefined 类型只有一个值，即特殊的 undefined。</p><p>在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。</p><blockquote><p>注意：使用typeof对没有初始化和没有声明的变量，会返回“undefined”。</p></blockquote><h3 id="2-3-7、Null"><a href="#2-3-7、Null" class="headerlink" title="2.3.7、Null"></a>2.3.7、Null</h3><p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。</p><p>undefined值实际上是由null值衍生出来的，所以如果比较undefined和null是否相等，会返回true。</p><blockquote><p>注意：从语义上看null表示的是一个空的对象，所以使用typeof检查null会返回一个Object。</p></blockquote><h2 id="2-4、强制类型转换"><a href="#2-4、强制类型转换" class="headerlink" title="2.4、强制类型转换"></a>2.4、强制类型转换</h2><p>强制类型转换指将一个数据类型强制转换为其它的数据类型。一般是指，将其它的数据类型转换为String、Number、Boolean。</p><h3 id="2-4-1、转换为String类型"><a href="#2-4-1、转换为String类型" class="headerlink" title="2.4.1、转换为String类型"></a>2.4.1、转换为String类型</h3><p>将其它数值转换为字符串有三种方式：toString()、String()、 拼串。</p><ul><li>方式一：调用被转换数据类型的toString()方法，该方法不会影响到原变量，它会将转换的结果返回，但是注意：null和undefined这两个值没有toString()方法，如果调用它们的方法，会报错。 var a = 123;<br>a = a.toString();<br>console.log(a);<br>console.log(typeof a);  </li><li>方式二：调用String()函数，并将被转换的数据作为参数传递给函数，使用String()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法，但是对于null和undefined，就不会调用toString()方法，它会将 null 直接转换为 “null”，将 undefined 直接转换为 “undefined”。 var a = 123;<br>a = String(a);<br>console.log(a);<br>console.log(typeof a);</li></ul><p>var b = undefined;<br>b = String(b);<br>console.log(b);<br>console.log(typeof b);</p><p>var c = null;<br>c = String(c);<br>console.log(c);<br>console.log(typeof c);  </p><ul><li>方式三：为任意的数据类型 +”” var a = 123;<br>a = a + “”;<br>console.log(a);<br>console.log(typeof a); </li></ul><h3 id="2-4-2、转换为Number类型"><a href="#2-4-2、转换为Number类型" class="headerlink" title="2.4.2、转换为Number类型"></a>2.4.2、转换为Number类型</h3><p>有三个函数可以把非数值转换为数值：Number()、parseInt() 和parseFloat()。Number()可以用来转换任意类型的数据，而后两者只能用于转换字符串。parseInt()只会将字符串转换为整数，而parseFloat()可以将字符串转换为浮点数。</p><ul><li><p>方式一：使用Number()函数 </p><ul> - 字符串 --&gt; 数字 <ul>  - 如果是纯数字的字符串，则直接将其转换为数字  - 如果字符串中有非数字的内容，则转换为NaN  - 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0 </ul>  - 布尔 --&gt; 数字 <ul>  - true 转成 1  - false 转成 0 </ul>  - null --&gt; 数字 <ul>  - null 转成 0 </ul>  - undefined --&gt; 数字 <ul>  - undefined 转成 NaN </ul>  </ul>  </li><li><p>方式二：这种方式专门用来对付字符串，parseInt() 把一个字符串转换为一个整数 var a = “123”;<br>a = parseInt(a);<br>console.log(a);<br>console.log(typeof a);  </p></li><li>方式三：这种方式专门用来对付字符串，parseFloat() 把一个字符串转换为一个浮点数 var a = “123.456”;<br>a = parseFloat(a);<br>console.log(a);<br>console.log(typeof a); </li></ul><blockquote><p>注意：如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作</p></blockquote><h3 id="2-4-3、转换为Boolean类型"><a href="#2-4-3、转换为Boolean类型" class="headerlink" title="2.4.3、转换为Boolean类型"></a>2.4.3、转换为Boolean类型</h3><p>将其它的数据类型转换为Boolean，只能使用Boolean()函数。</p><ul><li><p>使用Boolean()函数 </p><ul> - 数字 —&gt; 布尔  <ul>   - 除了0和NaN，其余的都是true  </ul>  - 字符串 —&gt; 布尔  <ul>   - 除了空串，其余的都是true  </ul>  - null和undefined都会转换为false - 对象也会转换为true </ul> </li></ul><h2 id="2-5、运算符"><a href="#2-5、运算符" class="headerlink" title="2.5、运算符"></a>2.5、运算符</h2><p>运算符也叫操作符，通过运算符可以对一个或多个值进行运算并获取运算结果。</p><p>比如：typeof就是运算符，可以来获得一个值的类型，它会将该值的类型以字符串的形式返回（number string boolean undefined object）</p><h3 id="2-5-1、算术运算符"><a href="#2-5-1、算术运算符" class="headerlink" title="2.5.1、算术运算符"></a>2.5.1、算术运算符</h3><p>算术运算符用于表达式计算。</p><p>y=5，下面的表格解释了这些算术运算符：</p><h3 id="2-5-2、关系运算符"><a href="#2-5-2、关系运算符" class="headerlink" title="2.5.2、关系运算符"></a>2.5.2、关系运算符</h3><p>关系运算符在逻辑语句中使用，以测定变量或值是否相等。</p><p>x=5，下面的表格解释了比较运算符：</p><h3 id="2-5-3、赋值运算符"><a href="#2-5-3、赋值运算符" class="headerlink" title="2.5.3、赋值运算符"></a>2.5.3、赋值运算符</h3><p>赋值运算符用于给 JavaScript 变量赋值。</p><p>x=10 和 y=5，下面的表格解释了赋值运算符：</p><h3 id="2-5-4、逻辑运算符"><a href="#2-5-4、逻辑运算符" class="headerlink" title="2.5.4、逻辑运算符"></a>2.5.4、逻辑运算符</h3><p>逻辑运算符用于测定变量或值之间的逻辑。</p><p>给定 x=6 以及 y=3，下表解释了逻辑运算符：</p><p>关于逻辑运算符我们可以具体探讨一下：</p><ul><li><p>&amp;&amp; 与：&amp;&amp;可以对符号两侧的值进行与运算并返回结果，运算规则如下： </p><ul> - 两个值中只要有一个值为false，就返回false，只有两个值都为true时，才会返回true - JS中的“与”属于短路的与，如果第一个值为false，则不会检查第二个值 - 非布尔值时：如果两个都为true，则返回第二个值，如果两个值中有false，则返回靠前的false的值 </ul>  </li><li><p>|| 或：||可以对符号两侧的值进行或运算并返回结果，运算规则如下： </p><ul> - 两个值中只要有一个true，就返回true，只有两个值都为false，才会返回false - JS中的“或”属于短路的或，如果第一个值为true，则不会检查第二个值 - 非布尔值时：如果两个都为false ，则返回第二个值，如果两个值中有true，则返回靠前的true的值 </ul>  </li><li><p>! 非：!可以用来对一个值进行非运算，所谓非运算就是对一个布尔值进行取反操作，true变false，false变true，运算规则如下： </p><ul> - 如果对一个值进行两次取反，它不会变化 - 非布尔值时：先会将其转换为布尔值，然后再取反，所以我们可以利用该特点，来将一个其它的数据类型转换为布尔值，可以为一个任意数据类型取两次反，来将其转换为布尔值，原理和Boolean()函数一样 </ul> </li></ul><h3 id="2-5-5、比较运算符"><a href="#2-5-5、比较运算符" class="headerlink" title="2.5.5、比较运算符"></a>2.5.5、比较运算符</h3><p>比较运算符用来比较两个值是否相等，如果相等会返回true，否则返回false。</p><ul><li><p>使用 <strong>==</strong> 来做相等运算 </p><ul> - 当使用==来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后在比较 </ul>  </li><li><p>使用 <strong>!=</strong> 来做不相等运算 </p><ul> - 不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false，不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false </ul>  </li><li><p>使用 <strong>===</strong> 来做全等运算 </p><ul> - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换，如果两个值的类型不同，直接返回false </ul>  </li><li><p>使用 <strong>!==</strong> 来做不全等运算 </p><ul> - 用来判断两个值是否不全等，它和不等类似，不同的是它不会做自动的类型转换，如果两个值的类型不同，直接返回true </ul> </li></ul><h3 id="2-5-6、条件运算符"><a href="#2-5-6、条件运算符" class="headerlink" title="2.5.6、条件运算符"></a>2.5.6、条件运算符</h3><p>JavaScript 还包含了基于某些条件对变量进行赋值的条件运算符。</p><p>语法：variablename=(condition)?value1:value2;</p><p>举例：result=(age&lt;18)?”年龄太小”:”年龄合适”;</p><p>执行流程：如果condition为true，则执行语句1，并返回执行结果，如果为false，则执行语句2，并返回执行结果。</p><h3 id="2-5-7、逗号运算符"><a href="#2-5-7、逗号运算符" class="headerlink" title="2.5.7、逗号运算符"></a>2.5.7、逗号运算符</h3><p>使用逗号可以在一条语句中执行多次操作。</p><p>比如：var num1=1, num2=2, num3=3;</p><p>使用逗号运算符分隔的语句会从左到右顺 序依次执行。</p><h2 id="2-6、运算符优先级"><a href="#2-6、运算符优先级" class="headerlink" title="2.6、运算符优先级"></a>2.6、运算符优先级</h2><p>运算符优先级由上到下依次减小，对于同级运算符，采用从左向右依次执行的方法。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/695dff6b3d3117760c6fba7c0b09895b.png" alt="img"></p><h2 id="2-7、代码块"><a href="#2-7、代码块" class="headerlink" title="2.7、代码块"></a>2.7、代码块</h2><h3 id="2-7-1、语句"><a href="#2-7-1、语句" class="headerlink" title="2.7.1、语句"></a>2.7.1、语句</h3><p>前边我所说表达式和运算符等内容可以理解成是我们一 门语言中的单词，短语。而语句（statement）就是我们这个语言中一句一句完 整的话了。语句是一个程序的基本单位，JavaScript的程序就是由一条一条语句构成的，每一条语句使用;结尾。</p><p>JavaScript中的语句默认是由上至下顺序执行的，但是我们也可以通过一些流程控制语句来控制语句的执行顺序。</p><h3 id="2-7-2、代码块"><a href="#2-7-2、代码块" class="headerlink" title="2.7.2、代码块"></a>2.7.2、代码块</h3><p>代码块是在大括号 {} 中所写的语句，以此将多条语句的集合视为一条语句来使用。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    a++;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般使用代码块将需要一起执行的语句进行分组，需要注意的是，代码块结尾不需要加 分号。</p><h2 id="2-8、条件语句"><a href="#2-8、条件语句" class="headerlink" title="2.8、条件语句"></a>2.8、条件语句</h2><p>条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句，最基本的条件语句：</p><ul><li>if…else </li><li>switch…case</li></ul><h3 id="2-8-1、if…else"><a href="#2-8-1、if…else" class="headerlink" title="2.8.1、if…else"></a>2.8.1、if…else</h3><p>if…else语句是一种最基本的控制语句，它让JavaScript可以有条件的执行语句。</p><ul><li><p>第一种形式： if(expression)<br>statement <pre><code class="prism language-javascript"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><br><span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“未成年”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt;  </p></li><li><p>第二种形式： if(expression)<br>statement<br>else<br>statement <pre><code class="prism language-javascript"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span><br><span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“未成年”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“已成年”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt;  </p></li><li><p>第三种形式： if(expression1)<br>statement<br>else if(expression2)<br>statement<br>else<br>statement <pre><code class="prism language-javascript"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><br><span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“小于18岁了”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">==</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“已经18岁了”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“大于18岁了”</span><span class="token punctuation">)</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt; </p></li></ul><h3 id="2-8-2、switch…case"><a href="#2-8-2、switch…case" class="headerlink" title="2.8.2、switch…case"></a>2.8.2、switch…case</h3><p>switch…case是另一种流程控制语句。</p><p>switch语句更适用于多条分支使用同一条语句的情况。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (语句) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">case</span> 表达式<span class="number">1</span>:</span><br><span class="line">        语句...</span><br><span class="line">    <span class="keyword">case</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：需要注意的是一旦符合case的条件程序会一直运行到结束，所以我们一般会在case中添加break作为语句的结束。</p></blockquote><p><strong>案例演示1：根据today的数值，输出今天是星期几。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">today</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (today) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        console.log(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        console.log(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例演示2：根据month的数值，输出对应月份的天数，2月默认28天。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">month</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        console.log(<span class="string">&quot;31天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        console.log(<span class="string">&quot;30天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        console.log(<span class="string">&quot;28天&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        console.log(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-9、循环语句"><a href="#2-9、循环语句" class="headerlink" title="2.9、循环语句"></a>2.9、循环语句</h2><p>循环语句和条件语句一样，也是基本的控制语句，只要满足一定的条件将会一直执行，最基本的循环语句：</p><ul><li>while </li><li>do…while </li><li>for</li></ul><h3 id="2-9-1、while"><a href="#2-9-1、while" class="headerlink" title="2.9.1、while"></a>2.9.1、while</h3><p>while语句是一个最基本的循环语句，while语句也被称为while循环。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">   </span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例演示：输出1-10。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-2、do…while"><a href="#2-9-2、do…while" class="headerlink" title="2.9.2、do…while"></a>2.9.2、do…while</h3><p>do…while和while非常类似，只不过它会在循环的尾部而不是顶部检查表达式的值，因此，do…while循环会至少执行一次。相比于while，do…while的使用情况并不 是很多。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">   </span><br><span class="line">    语句...</span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure><p><strong>案例演示：输出1-10。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="2-9-3、for"><a href="#2-9-3、for" class="headerlink" title="2.9.3、for"></a>2.9.3、for</h3><p>for语句也是循环控制语句，我们也称它为for循环。大部分循环都会有一个计数器用以控制循环执行的次数， 计数器的三个关键操作是初始化、检测和更新。for语句 就将这三步操作明确为了语法的一部分。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式 ; 条件表达式 ; 更新表达式)&#123;</span><br><span class="line">   </span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例演示：输出1-10。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-4、跳转控制"><a href="#2-9-4、跳转控制" class="headerlink" title="2.9.4、跳转控制"></a>2.9.4、跳转控制</h3><ul><li>break：结束最近的一次循环，可以在循环和switch语句中使用。 </li><li>continue：结束本次循环，执行下一次循环，只能在循环中使用。</li></ul><p>那如果我们想要跳出多层循环或者跳到指定位置该怎么办呢？可以为循环语句创建一个label，来标识当前的循环，如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-10、对象基础"><a href="#2-10、对象基础" class="headerlink" title="2.10、对象基础"></a>2.10、对象基础</h2><h3 id="2-10-1、概述"><a href="#2-10-1、概述" class="headerlink" title="2.10.1、概述"></a>2.10.1、概述</h3><p>Object类型，我们也称为一个对象，是JavaScript中的引用数据类型。它是一种复合值，它将很多值聚合到一起，可以通过名字访问这些值。对象也可以看做是属性的无序集合，每个属性都是一个名/值对。对象除了可以创建自有属性，还可以通过从一个名为原型的对象那里继承属性。除了字符串、数字、true、false、null和undefined之外，JavaScript中的值都是对象。</p><h3 id="2-10-2、创建对象"><a href="#2-10-2、创建对象" class="headerlink" title="2.10.2、创建对象"></a>2.10.2、创建对象</h3><p>创建对象有两种方式：</p><ul><li><p>第一种方式： var person = new Object();<br>person.name = “孙悟空”;<br>person.age = 18;<br>console.log(person);  </p></li><li><p>第二种方式： <pre><code class="prism language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>name<span class="token punctuation">:</span> <span class="token string">“孙悟空”</span><span class="token punctuation">,</span><br>age<span class="token punctuation">:</span> <span class="token number">18</span><br><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span><br>&lt;/code&gt;&lt;/pre&gt; </p></li></ul><h3 id="2-10-3、访问属性"><a href="#2-10-3、访问属性" class="headerlink" title="2.10.3、访问属性"></a>2.10.3、访问属性</h3><p>访问属性的两种方式：</p><ul><li>第一种方式：使用 . 来访问 对象.属性名  </li><li>第二种方式：使用 [] 来访问 对象[‘属性名’] </li></ul><h3 id="2-10-4、删除属性"><a href="#2-10-4、删除属性" class="headerlink" title="2.10.4、删除属性"></a>2.10.4、删除属性</h3><p>删除对象的属性可以使用delete关键字，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete 对象.属性名</span><br></pre></td></tr></table></figure><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">person.age = <span class="number">18</span>;</span><br><span class="line">console.log(person);</span><br><span class="line"></span><br><span class="line">delete person.name</span><br><span class="line">console.log(person);</span><br></pre></td></tr></table></figure><h3 id="2-10-5、遍历对象"><a href="#2-10-5、遍历对象" class="headerlink" title="2.10.5、遍历对象"></a>2.10.5、遍历对象</h3><p>枚举遍历对象中的属性，可以使用for … in语句循环，对象中有几个属性，循环体就会执行几次。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> 变量 in 对象) &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> personKey in person) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">personVal</span> <span class="operator">=</span> person[personKey];</span><br><span class="line">    console.log(personKey + <span class="string">&quot;:&quot;</span> + personVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-6、数据类型梳理"><a href="#2-10-6、数据类型梳理" class="headerlink" title="2.10.6、数据类型梳理"></a>2.10.6、数据类型梳理</h3><h4 id="2-10-6-1、基本数据类型"><a href="#2-10-6-1、基本数据类型" class="headerlink" title="2.10.6.1、基本数据类型"></a>2.10.6.1、基本数据类型</h4><p>JavaScript中的变量可能包含两种不同数据类型的值：基本数据类型和引用数据类型。</p><p>JavaScript中一共有5种基本数据类型：String、Number、 Boolean、Undefined、Null。</p><p>基本数据类型的值是无法修改的，是不可变的。</p><p>基本数据类型的比较是值的比较，也就是只要两个变量的值相等，我们就认为这两个变量相等。</p><h4 id="2-10-6-2、引用数据类型"><a href="#2-10-6-2、引用数据类型" class="headerlink" title="2.10.6.2、引用数据类型"></a>2.10.6.2、引用数据类型</h4><p>引用类型的值是保存在内存中的对象。</p><p>当一个变量是一个对象时，实际上变量中保存的并不是对象本身，而是对象的引用。</p><p>当从一个变量向另一个变量复制引用类型的值时，会将对象的引用复制到变量中，并不是创建一个新的对象。</p><p>这时，两个变量指向的是同一个对象。因此，改变其中一个变量会影响另一个。</p><h3 id="2-10-7、栈和堆梳理"><a href="#2-10-7、栈和堆梳理" class="headerlink" title="2.10.7、栈和堆梳理"></a>2.10.7、栈和堆梳理</h3><p>JavaScript在运行时数据是保存到栈内存和堆内存当中的。</p><p>简单来说栈内存用来保存变量和基本类型，堆内存是用来保存对象。</p><p>我们在声明一个变量时，实际上就是在栈内存中创建了一个空间用来保存变量。</p><p>如果是基本类型则在栈内存中直接保存，如果是引用类型则会在堆内存中保存，变量中保存的实际上对象在堆内存中的地址。</p><p>当我们写了下边这几句代码的时候，栈内存和堆内存的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> &#123;</span><br><span class="line">   name: <span class="string">&#x27;sunwukong&#x27;</span>, age: <span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure><p>栈的特点：先进后出，后进先出</p><p><img src="https://img-blog.csdnimg.cn/img_convert/48487fd2d563e9a30beaf4fe8273285f.png" alt="img"></p><h2 id="2-11、函数"><a href="#2-11、函数" class="headerlink" title="2.11、函数"></a>2.11、函数</h2><h3 id="2-11-1、概述"><a href="#2-11-1、概述" class="headerlink" title="2.11.1、概述"></a>2.11.1、概述</h3><p>函数是由一连串的子程序（语句的集合）所组成的，可以被外部程序调用，向函数传递参数之后，函数可以返回一定的值。</p><p>通常情况下，JavaScript代码是自上而下执行的，不过函数体内部的代码则不是这样。如果只是对函数进行了声明，其中的代码并不会执行，只有在调用函数时才会执行函数体内部的代码。</p><p>这里要注意的是JavaScript中的函数也是一个对象，使用typeof检查一个函数对象时，会返回function。</p><h3 id="2-11-2、函数创建"><a href="#2-11-2、函数创建" class="headerlink" title="2.11.2、函数创建"></a>2.11.2、函数创建</h3><ul><li><p>使用 函数对象 来创建一个函数（几乎不用） 语法格式： var 函数名 = new Function(“执行语句”); 示例代码： var fun = new Function(“console.log(‘这是我的第一个函数’);”);  </p></li><li><p>使用 函数声明 来创建一个函数（比较常用） 语法格式： <pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">函数名</span><span class="token punctuation">(</span><span class="token punctuation">[</span>形参<span class="token number">1</span><span class="token punctuation">,</span>形参<span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">…</span><span class="token punctuation">,</span>形参<span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>语句<span class="token operator">…</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt; 示例代码： <pre><code class="prism language-javascript"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“这是我的第二个函数”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt;  </p></li><li><p>使用 函数表达式 来创建一个函数（比较常用） 语法格式： <pre><code class="prism language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">函数名</span>  <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">[</span>形参<span class="token number">1</span><span class="token punctuation">,</span>形参<span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">…</span><span class="token punctuation">,</span>形参<span class="token constant">N</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>语句<span class="token operator">…</span><span class="token punctuation">.</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt; 示例代码： <pre><code class="prism language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">fun</span>  <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p><!-- -->&lt;/span&gt;<br>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“这是我的第三个函数”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span><br>&lt;/code&gt;&lt;/pre&gt; </p></li></ul><h3 id="2-11-3、函数调用"><a href="#2-11-3、函数调用" class="headerlink" title="2.11.3、函数调用"></a>2.11.3、函数调用</h3><ul><li><p>对于无参函数调用： <pre><code class="prism language-javascript"><span class="token comment">// 函数声明</span><br><span class="token keyword">var</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p> <!-- -->&lt;/span&gt;<br> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“哈哈，我执行啦！”</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span></p></li></ul><p><span class="token comment">// 函数调用</span><br><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>&lt;/code&gt;&lt;/pre&gt;  </p><ul><li><p>对于有参函数调用： <pre><code class="prism language-javascript"><span class="token comment">// 函数声明</span><br><span class="token keyword">var</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><p> <!-- -->&lt;/span&gt;<br> <span class="token keyword">var</span> result <span class="token operator">=</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span><br> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">“num1 + num2 = “</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">&#125;</span></p></li></ul><p><span class="token comment">// 函数调用</span><br><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>&lt;/code&gt;&lt;/pre&gt; </p><h3 id="2-11-4、函数参数"><a href="#2-11-4、函数参数" class="headerlink" title="2.11.4、函数参数"></a>2.11.4、函数参数</h3><ul><li>JS中的所有的参数传递都是按值传递的，也就是说把函数外部的值赋值给函数内部的参数，就和把值从一个变量赋值给另一个变量是一样的，在调用函数时，可以在()中指定实参（实际参数），实参将会赋值给函数中对应的形参 </li><li>调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能，则需要对参数进行类型的检查，函数的实参可以是任意的数据类型 </li><li>调用函数时，解析器也不会检查实参的数量，多余实参不会被赋值，如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined</li></ul><h3 id="2-11-5、函数返回值"><a href="#2-11-5、函数返回值" class="headerlink" title="2.11.5、函数返回值"></a>2.11.5、函数返回值</h3><p>可以使用 return 来设置函数的返回值，return后的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。</p><blockquote><p>注意：在函数中return后的语句都不会执行，如果return语句后不跟任何值就相当于返回一个undefined，如果函数中不写return，则也会返回undefined，return后可以跟任意类型的值</p></blockquote><p>语法格式：return 值</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">sum</span><span class="params">(num1, num2)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h3 id="2-11-6、嵌套函数"><a href="#2-11-6、嵌套函数" class="headerlink" title="2.11.6、嵌套函数"></a>2.11.6、嵌套函数</h3><p>嵌套函数：在函数中声明的函数就是嵌套函数，嵌套函数只能在当前函数中可以访问，在当前函数外无法访问。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">fu</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    function <span class="title function_">zi</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我是儿子&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fu();</span><br></pre></td></tr></table></figure><h3 id="2-11-7、匿名函数"><a href="#2-11-7、匿名函数" class="headerlink" title="2.11.7、匿名函数"></a>2.11.7、匿名函数</h3><p>匿名函数：没有名字的函数就是匿名函数，它可以让一个变量来接收，也就是用 “函数表达式” 方式创建和接收。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">fun</span> <span class="operator">=</span> function () &#123;</span><br><span class="line">   </span><br><span class="line">    alert(<span class="string">&quot;我是一个匿名函数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun();</span><br></pre></td></tr></table></figure><h3 id="2-11-8、立即执行函数"><a href="#2-11-8、立即执行函数" class="headerlink" title="2.11.8、立即执行函数"></a>2.11.8、立即执行函数</h3><p>立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数，立即执行函数往往只会执行一次。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">   </span><br><span class="line">    alert(<span class="string">&quot;我是一个匿名函数&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="2-11-9、对象中的函数"><a href="#2-11-9、对象中的函数" class="headerlink" title="2.11.9、对象中的函数"></a>2.11.9、对象中的函数</h3><p>对象的属性值可以是任何的数据类型，也可以是个函数。</p><p>如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法，调用这个函数就说调用对象的方法（method）。</p><blockquote><p>注意：方法和函数只是名称上的区别，没有其它别的区别</p></blockquote><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayHello: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(name + <span class="string">&quot; hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello();</span><br></pre></td></tr></table></figure><h3 id="2-11-10、this对象"><a href="#2-11-10、this对象" class="headerlink" title="2.11.10、this对象"></a>2.11.10、this对象</h3><p>解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，this会指向不同的对象</p><ul><li>以函数的形式调用时，this永远都是window </li><li>以方法的形式调用时，this就是调用方法的那个对象</li></ul><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个全局变量name</span></span><br><span class="line"><span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;全局变量name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个函数</span></span><br><span class="line">function <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">    sayName: fun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望调用obj.sayName()时可以输出obj的名字而不是全局变量name的名字</span></span><br><span class="line">obj.sayName();</span><br></pre></td></tr></table></figure><h2 id="2-12、对象进阶"><a href="#2-12、对象进阶" class="headerlink" title="2.12、对象进阶"></a>2.12、对象进阶</h2><h3 id="2-12-1、用工厂方法创建对象"><a href="#2-12-1、用工厂方法创建对象" class="headerlink" title="2.12.1、用工厂方法创建对象"></a>2.12.1、用工厂方法创建对象</h3><p>我们之前已经学习了如何创建一个对象，那我们要是想要创建多个对象又该怎么办？聪明的同学可能会说，直接在写几个对象不就好了吗？比如下边的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;猪八戒&quot;</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;沙和尚&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person1);</span><br><span class="line">console.log(person2);</span><br><span class="line">console.log(person3);</span><br></pre></td></tr></table></figure><p>的确，上述代码确实可以创建多个对象，但是，这样的解决方案真的好吗？对于少量对象可能使用，我们假设说，要用循环创建1000个对象，那你这种办法似乎就没用了，我们可以这么做，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用工厂模式创建对象</span></span><br><span class="line">function <span class="title function_">createPerson</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建新的对象</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 设置对象属性</span></span><br><span class="line">    obj.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">    obj.age = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">// 设置对象方法</span></span><br><span class="line">    obj.sayName = function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> createPerson();</span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> createPerson();</span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> createPerson();</span><br><span class="line"></span><br><span class="line">console.log(person1);</span><br><span class="line">console.log(person2);</span><br><span class="line">console.log(person3);</span><br></pre></td></tr></table></figure><p>上述代码看起来更加简洁，但是你会发现每一个人都是孙悟空，我们要是想要给每一个人不同的属性值，请参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用工厂模式创建对象</span></span><br><span class="line">function <span class="title function_">createPerson</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建新的对象</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 设置对象属性</span></span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    <span class="comment">// 设置对象方法</span></span><br><span class="line">    obj.sayName = function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> createPerson(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> createPerson(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> createPerson(<span class="string">&quot;沙和尚&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">console.log(person1);</span><br><span class="line">console.log(person2);</span><br><span class="line">console.log(person3);</span><br></pre></td></tr></table></figure><p>现在再看上述代码，发现好像已经完美的解决了创建多个对象的难题，那我们是不是可以用循环批量创建1000个对象了呢？那我们就来试试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用工厂模式创建对象</span></span><br><span class="line">function <span class="title function_">createPerson</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建新的对象</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 设置对象属性</span></span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    <span class="comment">// 设置对象方法</span></span><br><span class="line">    obj.sayName = function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> createPerson(<span class="string">&quot;person&quot;</span> + i, <span class="number">18</span>);</span><br><span class="line">    console.log(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就实现了批量创建对象的功能，至于对象的名称和年龄，我们可以通过名称数组和年龄数组来获取，但这并不是我们本小节的重点，我们就忽略了。</p><h3 id="2-12-2、用构造函数创建对象"><a href="#2-12-2、用构造函数创建对象" class="headerlink" title="2.12.2、用构造函数创建对象"></a>2.12.2、用构造函数创建对象</h3><p>在前一节中，我们学会了使用工厂模式创建对象，但是，你会发现我们所创建的对象类型都是Object，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用工厂模式创建对象</span></span><br><span class="line">function <span class="title function_">createPerson</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建新的对象</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 设置对象属性</span></span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    <span class="comment">// 设置对象方法</span></span><br><span class="line">    obj.sayName = function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> createPerson(<span class="string">&quot;person&quot;</span> + i, <span class="number">18</span>);</span><br><span class="line">    console.log(typeof person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5c87b435343a519cbd7badefc46dbeb2.png" alt="img"></p><p>那这有问题吗？看起来有，看起来好像又没有，每创建一个都是对象，但是在实际生活中，人应该是一个确定的类别，属于人类，对象是一个笼统的称呼，万物皆对象，它并不能确切的指明当前对象是人类，那我们要是既想实现创建对象的功能，同时又能明确所创建出来的对象是人类，那么似乎问题就得到了解决，这就用到了构造函数，每一个构造函数你都可以理解为一个类别，用构造函数所创建的对象我们也成为类的实例，那我们来看看是如何做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来创建对象</span></span><br><span class="line">function <span class="title function_">Person</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">// 设置对象的方法</span></span><br><span class="line">    <span class="built_in">this</span>.sayName = function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;沙和尚&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">console.log(person1);</span><br><span class="line">console.log(person2);</span><br><span class="line">console.log(person3);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7705f04f8327430a55a646c735cd6e33.png" alt="img"></p><p>那这构造函数到底是什么呢？我来解释一下：</p><p>构造函数：构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写，构造函数和普通函数的还有一个区别就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。</p><p>那构造函数是怎么执行创建对象的过程呢？我再来解释一下：</p><ol><li>调用构造函数，它会立刻创建一个新的对象 </li><li>将新建的对象设置为函数中this，<strong>在构造函数中可以使用this来引用新建的对象</strong> </li><li>逐行执行函数中的代码 </li><li>将新建的对象作为返回值返回</li></ol><p>你会发现构造函数有点类似工厂方法，但是它创建对象和返回对象都给我们隐藏了，使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。我们将通过一个构造函数创建的对象，称为是该类的实例。</p><p>现在，this又出现了一种新的情况，为了不让大家混淆，我再来梳理一下：</p><ul><li>当以函数的形式调用时，this是window </li><li>当以方法的形式调用时，谁调用方法this就是谁 </li><li>当以构造函数的形式调用时，this就是新创建的那个对象</li></ul><p>我们可以使用 instanceof 运算符检查一个对象是否是一个类的实例，它返回true或false</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 <span class="keyword">instanceof</span> 构造函数</span><br></pre></td></tr></table></figure><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1 <span class="keyword">instanceof</span> Person);</span><br></pre></td></tr></table></figure><h3 id="2-12-3、原型"><a href="#2-12-3、原型" class="headerlink" title="2.12.3、原型"></a>2.12.3、原型</h3><p>在前一节中，我们学习了使用构造函数的方式进行创建对象，但是，它还是存在一个问题，那就是，你会发现，每一个对象的属性不一样这是一定的，但是它的方法似乎好像是一样的，如果我创建1000个对象，那岂不是内存中就有1000个相同的方法，那要是有10000个，那对内存的浪费可不是一点半点的，我们有没有什么好的办法解决，没错，我们可以把函数抽取出来，作为全局函数，在构造函数中直接引用就可以了，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来创建对象</span></span><br><span class="line">function <span class="title function_">Person</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">// 设置对象的方法</span></span><br><span class="line">    <span class="built_in">this</span>.sayName = sayName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽取方法为全局函数</span></span><br><span class="line">function <span class="title function_">sayName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;沙和尚&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName();</span><br><span class="line">person2.sayName();</span><br><span class="line">person3.sayName();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/05f5cdbe83821c5ab8262a4b0d3096fe.png" alt="img"></p><p>但是，在全局作用域中定义函数却不是一个好的办法，为什么呢？因为，如果要是涉及到多人协作开发一个项目，别人也有可能叫sayName这个方法，这样在工程合并的时候就会导致一系列的问题，污染全局作用域，那该怎么办呢？有没有一种方法，我只在Person这个类的全局对象中添加一个函数，然后在类中引用？答案肯定是有的，这就需要原型对象了，我们先看看怎么做的，然后在详细讲解原型对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来创建对象</span></span><br><span class="line">function <span class="title function_">Person</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Person类的原型对象中添加方法</span></span><br><span class="line">Person.prototype.sayName = function() &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;沙和尚&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">person1.sayName();</span><br><span class="line">person2.sayName();</span><br><span class="line">person3.sayName();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7a39d722ae8c06f66b47748bfc3bfa9b.png" alt="img"></p><p>那原型（prototype）到底是什么呢？</p><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象就是我们所谓的原型对象，即显式原型，原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p><p>如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过<strong>proto</strong>（隐式原型）来访问该属性。当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。</p><p>以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。</p><h3 id="2-12-4、原型链"><a href="#2-12-4、原型链" class="headerlink" title="2.12.4、原型链"></a>2.12.4、原型链</h3><p>访问一个对象的属性时，先在自身属性中查找，找到返回， 如果没有，再沿着<strong>proto</strong>这条链向上查找，找到返回，如果最终没找到，返回undefined，这就是原型链，又称隐式原型链，它的作用就是查找对象的属性(方法)。</p><p>我们使用一张图来梳理一下上一节原型案例的代码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/34f5a7f9ab460f148c64a66e8632634b.png" alt="img"></p><blockquote><p>注意：Object对象是所有对象的祖宗，Object的原型对象指向为null，也就是没有原型对象</p></blockquote><h3 id="2-12-5、toString方法"><a href="#2-12-5、toString方法" class="headerlink" title="2.12.5、toString方法"></a>2.12.5、toString方法</h3><p>toString()函数用于将当前对象以字符串的形式返回。该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法，所有主流浏览器均支持该函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来创建对象</span></span><br><span class="line">function <span class="title function_">Person</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象的一个实例对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">console.log(p.toString());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bf8a0035d661c976f986b7bfa8f62bad.png" alt="img"></p><p>JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。</p><p>注意：这里我们只是演示toString()方法，其它的一些没有讲到的知识后边会将，我们只看效果就可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">console.log(str.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="type">var</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">15.26540</span>;</span><br><span class="line">console.log(num.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔</span></span><br><span class="line"><span class="type">var</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">console.log(bool.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;</span><br><span class="line">   name: <span class="string">&quot;张三&quot;</span>, age: <span class="number">18</span>&#125;;</span><br><span class="line">console.log(obj.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">var</span> <span class="variable">array</span> <span class="operator">=</span> [<span class="string">&quot;CodePlayer&quot;</span>, <span class="literal">true</span>, <span class="number">12</span>, -<span class="number">5</span>];</span><br><span class="line">console.log(array.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期</span></span><br><span class="line"><span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2013</span>, <span class="number">7</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">11</span>, <span class="number">59</span>, <span class="number">230</span>);</span><br><span class="line">console.log(date.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">var</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;自定义错误信息&quot;</span>);</span><br><span class="line">console.log(error.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line">console.log(Function.toString());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/203f4736a13382fc30ab2054631445b5.png" alt="img"></p><h3 id="2-12-6、hasOwnProperty方法"><a href="#2-12-6、hasOwnProperty方法" class="headerlink" title="2.12.6、hasOwnProperty方法"></a>2.12.6、hasOwnProperty方法</h3><p>前边章节我们学过，如何遍历一个对象所有的属性和值，那我们要是判断当前对象是否包含指定的属性或方法可以使用 in 运算符来检查，如下代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个构造函数</span></span><br><span class="line">function <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向MyClass的原型中添加一个name属性</span></span><br><span class="line">MyClass.prototype.name = <span class="string">&quot;我是原型中的名字&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个MyClass的实例</span></span><br><span class="line"><span class="type">var</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">mc.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</span></span><br><span class="line">console.log(<span class="string">&quot;age&quot;</span> in mc);</span><br><span class="line">console.log(<span class="string">&quot;name&quot;</span> in mc);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/55a9e1b3a9e36a0e344877c964e436e4.png" alt="img"></p><p>如果我只想要检查自身对象是否含有某个方法或属性，我们可以使用Object的hasOwnProperty()方法，它返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。如下代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个构造函数</span></span><br><span class="line">function <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向MyClass的原型中添加一个name属性</span></span><br><span class="line">MyClass.prototype.name = <span class="string">&quot;我是原型中的名字&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个MyClass的实例</span></span><br><span class="line"><span class="type">var</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">mc.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true</span></span><br><span class="line">console.log(<span class="string">&quot;age&quot;</span> in mc);</span><br><span class="line">console.log(<span class="string">&quot;name&quot;</span> in mc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性，使用该方法只有当对象自身中含有属性时，才会返回true</span></span><br><span class="line">console.log(mc.hasOwnProperty(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">console.log(mc.hasOwnProperty(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/dd0f3747a1ca02da2d727f344cb2372f.png" alt="img"></p><p>有同学可能会有疑问，我的这个MyClass类对象中没有hasOwnProperty这个方法啊，它是哪来的？对了，就是原型中的，在执行方法的时候它会通过原型链进行查找，这个方法是Object的特有方法，如下代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个构造函数</span></span><br><span class="line">function <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向MyClass的原型中添加一个name属性</span></span><br><span class="line">MyClass.prototype.name = <span class="string">&quot;我是原型中的名字&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个MyClass的实例</span></span><br><span class="line"><span class="type">var</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">mc.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前对象</span></span><br><span class="line">console.log(mc.hasOwnProperty(<span class="string">&quot;hasOwnProperty&quot;</span>));</span><br><span class="line"><span class="comment">// 检查当前对象的原型对象</span></span><br><span class="line">console.log(mc.__proto__.hasOwnProperty(<span class="string">&quot;hasOwnProperty&quot;</span>));</span><br><span class="line"><span class="comment">// 检查当前对象的原型对象的原型对象</span></span><br><span class="line">console.log(mc.__proto__.__proto__.hasOwnProperty(<span class="string">&quot;hasOwnProperty&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9ba1a18eb6768ea310dbf0c77b72dde0.png" alt="img"></p><h3 id="2-12-7、对象继承"><a href="#2-12-7、对象继承" class="headerlink" title="2.12.7、对象继承"></a>2.12.7、对象继承</h3><p>前边我们一直在说继承，那什么是继承？它有什么作用？如何实现继承？将会是本章节探讨的问题。</p><p>面向对象的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。但是在JavaScript中没有类的概念，前边我们说所的类只是我们自己这么叫，大家要清楚。因此它的对象也与基于类的对象有所不同。实际上，JavaScript语言是通过一种叫做原型（prototype）的方式来实现面向对象编程的。</p><p>那实现继承有一个最大的好处就是子对象可以使用父对象的属性和方法，从而简化了一些代码。</p><p>JavaScript有六种非常经典的对象继承方式，但是我们只学习前三种：</p><ul><li><strong>原型链继承</strong> </li><li><strong>借用构造函数继承</strong> </li><li><strong>组合继承（重要）</strong> </li><li>原型式继承 </li><li>寄生式继承 </li><li>寄生组合式继承</li></ul><h4 id="2-12-7-1、原型链继承"><a href="#2-12-7-1、原型链继承" class="headerlink" title="2.12.7.1、原型链继承"></a>2.12.7.1、原型链继承</h4><p><strong>核心思想：</strong> 子类型的原型为父类型的一个实例对象</p><p><strong>基本做法：</strong></p><ol><li>定义父类型构造函数 </li><li>给父类型的原型添加方法 </li><li>定义子类型的构造函数 </li><li>创建父类型的对象赋值给子类型的原型 </li><li>将子类型原型的构造属性设置为子类型 </li><li>给子类型原型添加方法 </li><li>创建子类型的对象: 可以调用父类型的方法</li></ol><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类型构造函数</span></span><br><span class="line">function <span class="title function_">SupperType</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.supProp = <span class="string">&#x27;Supper property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给父类型的原型添加方法</span></span><br><span class="line">SupperType.prototype.showSupperProp = function () &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.supProp);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类型的构造函数</span></span><br><span class="line">function <span class="title function_">SubType</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.subProp = <span class="string">&#x27;Sub property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建父类型的对象赋值给子类型的原型</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> <span class="title class_">SupperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子类型原型的构造属性设置为子类型</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给子类型原型添加方法</span></span><br><span class="line">SubType.prototype.showSubProp = function () &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.subProp)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类型的对象: 可以调用父类型的方法</span></span><br><span class="line"><span class="type">var</span> <span class="variable">subType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">subType.showSupperProp();</span><br><span class="line">subType.showSubProp();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bac6a9902796a74b61ed2fd9e959fa44.png" alt="img"></p><p><strong>缺点描述：</strong></p><ol><li>原型链继承多个实例的引用类型属性指向相同，一个实例修改了原型属性，另一个实例的原型属性也会被修改 </li><li>不能传递参数 </li><li>继承单一</li></ol><h4 id="2-12-7-2、借用构造函数继承"><a href="#2-12-7-2、借用构造函数继承" class="headerlink" title="2.12.7.2、借用构造函数继承"></a>2.12.7.2、借用构造函数继承</h4><p><strong>核心思想：</strong> 使用.call()和.apply()将父类构造函数引入子类函数，使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类</p><p><strong>基本做法：</strong></p><ol><li>定义父类型构造函数 </li><li>定义子类型的构造函数 </li><li>给子类型的原型添加方法 </li><li>创建子类型的对象然后调用</li></ol><p><strong>案例演示：</strong></p><p>借用构造函数继承的重点就在于SuperType<strong>.call(this, name)</strong>，调用了SuperType构造函数，这样，SubType的每个实例都会将SuperType中的属性复制一份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类型构造函数</span></span><br><span class="line">function <span class="title function_">SuperType</span><span class="params">(name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.showSupperName = function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类型的构造函数</span></span><br><span class="line">function <span class="title function_">SubType</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 在子类型中调用call方法继承自SuperType</span></span><br><span class="line">    SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给子类型的原型添加方法</span></span><br><span class="line">SubType.prototype.showSubName = function () &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类型的对象然后调用</span></span><br><span class="line"><span class="type">var</span> <span class="variable">subType</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">20</span>);</span><br><span class="line">subType.showSupperName();</span><br><span class="line">subType.showSubName();</span><br><span class="line">console.log(subType.name);</span><br><span class="line">console.log(subType.age);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f463d70717ecb12cd6885ae465e21e62.png" alt="img"></p><p><strong>缺点描述：</strong></p><ol><li>只能继承父类的实例属性和方法，不能继承原型属性和方法 </li><li>无法实现构造函数的复用，每个子类都有父类实例函数的副本，影响性能，代码会臃肿</li></ol><h4 id="2-12-7-3、组合继承"><a href="#2-12-7-3、组合继承" class="headerlink" title="2.12.7.3、组合继承"></a>2.12.7.3、组合继承</h4><p><strong>核心思想：</strong> 原型链+借用构造函数的组合继承</p><p><strong>基本做法：</strong></p><ol><li>利用原型链实现对父类型对象的方法继承 </li><li>利用super()借用父类型构建函数初始化相同属性</li></ol><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">Person</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.setName = function (name) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">Student</span><span class="params">(name, age, price)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    Person.call(<span class="built_in">this</span>, name, age); <span class="comment">// 为了得到父类型的实例属性和方法</span></span><br><span class="line">    <span class="built_in">this</span>.price = price; <span class="comment">// 添加子类型私有的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 为了得到父类型的原型属性和方法</span></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">// 修正constructor属性指向</span></span><br><span class="line">Student.prototype.setPrice = function (price) &#123;</span><br><span class="line">    <span class="comment">// 添加子类型私有的方法 </span></span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">24</span>, <span class="number">15000</span>);</span><br><span class="line">console.log(s.name, s.age, s.price);</span><br><span class="line">s.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">s.setPrice(<span class="number">16000</span>);</span><br><span class="line">console.log(s.name, s.age, s.price);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/14c2cf0500c8dbb4a4584180dc4da6eb.png" alt="img"></p><p><strong>缺点描述：</strong></p><ol><li>父类中的实例属性和方法既存在于子类的实例中，又存在于子类的原型中，不过仅是内存占用，因此，在使用子类创建实例对象时，其原型中会存在<strong>两份相同的属性和方法</strong> 。</li></ol><blockquote><p>注意：<strong>这个方法是JavaScript中最常用的继承模式</strong>。</p></blockquote><h3 id="2-12-8、垃圾回收"><a href="#2-12-8、垃圾回收" class="headerlink" title="2.12.8、垃圾回收"></a>2.12.8、垃圾回收</h3><p>垃圾回收（GC）：就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾，这些垃圾积攒过多以后，会导致程序运行的速度过慢，所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾。</p><p>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。</p><p>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作，我们需要做的只是要将不再使用的对象设置null即可。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来创建对象</span></span><br><span class="line">function <span class="title function_">Person</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 设置对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">person3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;沙和尚&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">person1 = <span class="literal">null</span>;</span><br><span class="line">person2 = <span class="literal">null</span>;</span><br><span class="line">person3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="2-13、作用域"><a href="#2-13、作用域" class="headerlink" title="2.13、作用域"></a>2.13、作用域</h2><p>作用域指一个变量的作用的范围，在JS中一共有两种作用域：</p><ul><li>全局作用域 </li><li>函数作用域</li></ul><h3 id="2-13-1、声明提前"><a href="#2-13-1、声明提前" class="headerlink" title="2.13.1、声明提前"></a>2.13.1、声明提前</h3><ul><li>变量的声明提前：使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不使用var关键字，则变量不会被声明提前 </li><li>函数的声明提前：使用函数声明形式创建的函数 function 函数名()&#123;&#125; ，它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数。使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用</li></ul><h3 id="2-13-2、作用域"><a href="#2-13-2、作用域" class="headerlink" title="2.13.2、作用域"></a>2.13.2、作用域</h3><h4 id="2-13-2-1、全局作用域"><a href="#2-13-2-1、全局作用域" class="headerlink" title="2.13.2.1、全局作用域"></a>2.13.2.1、全局作用域</h4><ul><li>直接编写在script标签中的JavaScript代码，都在全局作用域 </li><li>全局作用域在页面打开时创建，在页面关闭时销毁 </li><li>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用 </li><li><p>在全局作用域中： </p><ul> - 创建的变量都会作为window对象的属性保存 - 创建的函数都会作为window对象的方法保存 </ul>  </li><li><p>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到</p></li></ul><h4 id="2-13-2-2、函数作用域"><a href="#2-13-2-2、函数作用域" class="headerlink" title="2.13.2.2、函数作用域"></a>2.13.2.2、函数作用域</h4><ul><li>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁 </li><li>每调用一次函数就会创建一个新的函数作用域，它们之间是互相独立的 </li><li>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量 </li><li>在函数中要访问全局变量可以使用window对象 </li><li>作用域链：当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错ReferenceError</li></ul><h3 id="2-13-3、作用域链"><a href="#2-13-3、作用域链" class="headerlink" title="2.13.3、作用域链"></a>2.13.3、作用域链</h3><p>多个上下级关系的作用域形成的链，它的方向是从下向上的(从内到外)，查找变量时就是沿着作用域链来查找的。</p><p>查找一个变量的查找规则：</p><ol><li>在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2 </li><li>在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3 </li><li>再次执行2的相同操作，直到全局作用域，如果还找不到就抛出找不到的ReferenceError异常</li></ol><h2 id="3-1、数组对象"><a href="#3-1、数组对象" class="headerlink" title="3.1、数组对象"></a>3.1、数组对象</h2><h3 id="3-1-1、概述"><a href="#3-1-1、概述" class="headerlink" title="3.1.1、概述"></a>3.1.1、概述</h3><p>数组也是对象的一种，数组是一种用于表达有顺序关系的值的集合的语言结构，也就是同类数据元素的有序集合。</p><p>数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据。但是在JavaScript中是支持数组可以是不同的元素，这跟JavaScript的弱类型有关，此处不用纠结，我们大多数时候都是相同类型元素的集合。数组内的各个值被称作元素，每一个元素都可以通过索引（下标）来快速读取，索引是从零开始的整数。</p><p>使用typeof检查一个数组对象时，会返回object。</p><h3 id="3-1-2、创建数组"><a href="#3-1-2、创建数组" class="headerlink" title="3.1.2、创建数组"></a>3.1.2、创建数组</h3><h4 id="3-1-2-1、使用对象创建"><a href="#3-1-2-1、使用对象创建" class="headerlink" title="3.1.2.1、使用对象创建"></a>3.1.2.1、使用对象创建</h4><ul><li>同类型有序数组创建： var arr = new Array();<br>arr[0] = 1;<br>arr[1] = 2;<br>arr[2] = 3;<br>arr[3] = 4;<br>arr[4] = 5;<br>arr[5] = 6;<br>arr[6] = 7;<br>arr[7] = 8;<br>arr[8] = 9;  </li><li>不同类型有序数组创建： var arr = new Array();<br>arr[0] = 1;<br>arr[1] = “2”;<br>arr[2] = 3;<br>arr[3] = “4”;<br>arr[4] = 5;<br>arr[5] = “6”;<br>arr[6] = 7;<br>arr[7] = “8”;<br>arr[8] = 9; </li></ul><h4 id="3-1-2-2、使用字面量创建"><a href="#3-1-2-2、使用字面量创建" class="headerlink" title="3.1.2.2、使用字面量创建"></a>3.1.2.2、使用字面量创建</h4><ul><li>同类型有序数组创建： var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];  </li><li>不同类型有序数组创建： var arr = [1, “2”, 3, “4”, 5, “6”, 7, “8”, 9]; </li></ul><h3 id="3-1-3、遍历数组"><a href="#3-1-3、遍历数组" class="headerlink" title="3.1.3、遍历数组"></a>3.1.3、遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-4、数组属性"><a href="#3-1-4、数组属性" class="headerlink" title="3.1.4、数组属性"></a>3.1.4、数组属性</h3><p><strong>constructor属性演示：返回创建数组对象的原型函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">console.log(arr.constructor);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/980c0ed39d3282e2b8e77253c8bf098b.png" alt="img"></p><p><strong>length属性演示：设置或返回数组元素的个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">console.log(arr.length);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d5b5c2bc0e188b9d4feec0c58c69c244.png" alt="img"></p><h3 id="3-1-5、数组方法"><a href="#3-1-5、数组方法" class="headerlink" title="3.1.5、数组方法"></a>3.1.5、数组方法</h3><p><strong>push()方法演示：该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.push(<span class="string">&quot;唐僧&quot;</span>, <span class="string">&quot;蜘蛛精&quot;</span>, <span class="string">&quot;白骨精&quot;</span>, <span class="string">&quot;玉兔精&quot;</span>);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7aae1c9934e6bba6de27079ceb77ec36.png" alt="img"></p><p><strong>pop()方法演示：该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.pop();</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/043cc91f4298568ea371a41dd605ac72.png" alt="img"></p><p><strong>unshift()方法演示：该方法向数组开头添加一个或多个元素，并返回新的数组长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.unshift(<span class="string">&quot;牛魔王&quot;</span>, <span class="string">&quot;二郎神&quot;</span>);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a5a0ced2f25131ef28b91ce82c35581f.png" alt="img"></p><p><strong>shift()方法演示：该方法可以删除数组的第一个元素，并将被删除的元素作为返回值返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.shift();</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/dd77a3a74059c9856680794c3b349bab.png" alt="img"></p><p><strong>forEach()方法演示：该方法可以用来遍历数组</strong></p><p>forEach()方法需要一个函数作为参数，像这种函数，由我们创建但是不由我们调用的，我们称为回调函数。数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素，以实参的形式传递进来，我们可以来定义形参，来读取这些内容，浏览器会在回调函数中传递三个参数：</p><ul><li>第一个参数：就是当前正在遍历的元素 </li><li>第二个参数：就是当前正在遍历的元素的索引 </li><li>第三个参数：就是正在遍历的数组</li></ul><blockquote><p>注意：这个方法只支持IE8以上的浏览器，IE8及以下的浏览器均不支持该方法，所以如果需要兼容IE8，则不要使用forEach()，还是使用for循环来遍历数组。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line">arr.forEach(function (value, index, obj) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(value + <span class="string">&quot; #### &quot;</span> + index + <span class="string">&quot; #### &quot;</span> + obj);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/23e5a69cb38d91535b27ab372e689258.png" alt="img"></p><p><strong>slice()方法演示：该方法可以用来从数组提取指定元素，该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回</strong></p><p>参数：</p><ul><li>第一个参数：截取开始的位置的索引，包含开始索引 </li><li>第二个参数：截取结束的位置的索引，不包含结束索引，第二个参数可以省略不写，此时会截取从开始索引往后的所有元素</li></ul><blockquote><p>注意：索引可以传递一个负值，如果传递一个负值，则从后往前计算，-1代表倒数第一个，-2代表倒数第二个。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>, <span class="string">&quot;唐僧&quot;</span>, <span class="string">&quot;白骨精&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">console.log(result);</span><br><span class="line">result = arr.slice(<span class="number">3</span>);</span><br><span class="line">console.log(result);</span><br><span class="line">result = arr.slice(<span class="number">1</span>, -<span class="number">2</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/18ad817362706339461665656b5b81bd.png" alt="img"></p><p><strong>splice()方法演示：该方法可以用于删除数组中的指定元素，该方法会影响到原数组，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回</strong></p><p>参数：</p><ul><li>第一个参数：表示开始位置的索引 </li><li>第二个参数：表示要删除的元素数量 </li><li>第三个参数及以后参数：可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>, <span class="string">&quot;唐僧&quot;</span>, <span class="string">&quot;白骨精&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.splice(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br><span class="line">result = arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;牛魔王&quot;</span>, <span class="string">&quot;铁扇公主&quot;</span>, <span class="string">&quot;红孩儿&quot;</span>);</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/45074ba5bb641f6dc53536e6471f1fd2.png" alt="img"></p><p><strong>concat()方法演示：该方法可以连接两个或多个数组，并将新的数组返回，该方法不会对原数组产生影响</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">arr2</span> <span class="operator">=</span> [<span class="string">&quot;白骨精&quot;</span>, <span class="string">&quot;玉兔精&quot;</span>, <span class="string">&quot;蜘蛛精&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">arr3</span> <span class="operator">=</span> [<span class="string">&quot;二郎神&quot;</span>, <span class="string">&quot;太上老君&quot;</span>, <span class="string">&quot;玉皇大帝&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.concat(arr2, arr3, <span class="string">&quot;牛魔王&quot;</span>, <span class="string">&quot;铁扇公主&quot;</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/12c0858ad255003ba9ddd66ebb9a0df2.png" alt="img"></p><p><strong>join()方法演示：该方法可以将数组转换为一个字符串，该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回，在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，如果不指定连接符，则默认使用，作为连接符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> arr.join(<span class="string">&quot;@-@&quot;</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/891029712402377b772676696ae3ec72.png" alt="img"></p><p><strong>reverse()方法演示：该方法用来反转数组（前边的去后边，后边的去前边），该方法会直接修改原数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙和尚&quot;</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e7a4076da2a80e71ea4ce4c6e5010656.png" alt="img"></p><p><strong>sort()方法演示：该方法可以用来对数组中的元素进行排序，也会影响原数组，默认会按照Unicode编码进行排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/59057f1ac69677343efe214d0582f5d7.png" alt="img"></p><blockquote><p>注意：即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，所以对数字进排序时，可能会得到错误的结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/248ba29f0450aba65c0f1015b35b6fe3.png" alt="img"></p><p>我们可以自己来指定排序的规则，我们可以在sort()添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边，浏览器会根据回调函数的返回值来决定元素的顺序，如下：</p><ul><li>如果返回一个大于0的值，则元素会交换位置 </li><li>如果返回一个小于0的值，则元素位置不变 </li><li>如果返回一个等于0的值，则认为两个元素相等，也不交换位置</li></ul><p>经过上边的规则，我们可以总结下：</p><ul><li>如果需要升序排列，则返回 a-b </li><li>如果需要降序排列，则返回 b-a</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr.sort(function (a, b) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ed84d161d2ae11b8981ea2edae1eabbd.png" alt="img"></p><h2 id="3-2、函数对象"><a href="#3-2、函数对象" class="headerlink" title="3.2、函数对象"></a>3.2、函数对象</h2><h3 id="3-2-1、call-和apply"><a href="#3-2-1、call-和apply" class="headerlink" title="3.2.1、call()和apply()"></a>3.2.1、call()和apply()</h3><p>call()和apply()这两个方法都是函数对象的方法，需要通过函数对象来调用，当对函数调用call()和apply()都会调用函数执行，在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this，call()方法可以将实参在对象之后依次传递，apply()方法需要将实参封装到一个数组中统一传递，如下演示：</p><p><strong>call()方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">fun</span><span class="params">(a, b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    console.log(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    console.log(<span class="string">&quot;fun = &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">fun.call(obj, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9367eeccb7a3dc02fd5827257e5ade96.png" alt="img"></p><blockquote><p>注意：默认fun()函数调用，this指向的是window对象，你可以使用call()调用函数，在调用的时候传入一个对象，这个对象就是this所指向的对象，也就是说，可以自己指定this的指向，然后从第二个参数开始，实参将会依次传递</p></blockquote><p><strong>apply()方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">fun</span><span class="params">(a, b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    console.log(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">    console.log(<span class="string">&quot;fun = &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fun(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">fun.apply(obj, [<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/23760ffdfa7792bce72a94e90b62c3f1.png" alt="img"></p><blockquote><p>注意：默认fun()函数调用，this指向的是window对象，你可以使用apply()调用函数，在调用的时候传入一个对象，这个对象就是this所指向的对象，也就是说，可以自己指定this的指向，然后从第二个参数开始，需要制定一个实参数组进行参数传递</p></blockquote><h3 id="3-2-2、this指向"><a href="#3-2-2、this指向" class="headerlink" title="3.2.2、this指向"></a>3.2.2、this指向</h3><ul><li>以函数形式调用时，this永远都是window </li><li>以方法的形式调用时，this是调用方法的对象 </li><li>以构造函数的形式调用时，this是新创建的那个对象 </li><li>使用call和apply调用时，this是传入的那个指定对象</li></ul><h3 id="3-2-3、arguments参数"><a href="#3-2-3、arguments参数" class="headerlink" title="3.2.3、arguments参数"></a>3.2.3、arguments参数</h3><p>在调用函数时，浏览器每次都会传递进两个隐含的参数：</p><ol><li>函数的上下文对象： <strong>this</strong> </li><li>封装实参的对象： <strong>arguments</strong></li></ol><p>this对象我们已经学习过了，那arguments对象是什么呢？</p><p>arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度，在调用函数时，我们所传递的实参都会在arguments中保存，比如：arguments.length 可以用来获取实参的长度，我们即使不定义形参，也可以通过arguments来使用实参，只不过比较麻烦，例如：</p><ul><li>arguments[0]：表示第一个实参 </li><li>arguments[1]：表示第二个实参 </li><li>…</li></ul><p>它里边有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象。</p><p><strong>arguments对象演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">fun</span><span class="params">(a, b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 通过下标获取第一个参数</span></span><br><span class="line">    console.log(arguments[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 通过下标获取第二个参数</span></span><br><span class="line">    console.log(arguments[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 获取实参的个数</span></span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    <span class="comment">// 看看它的函数对象</span></span><br><span class="line">    console.log(arguments.callee);</span><br><span class="line">    console.log(arguments.callee == fun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3b55a97ff8f86bdbea0bae14b0298a06.png" alt="img"></p><h2 id="3-3、Date对象"><a href="#3-3、Date对象" class="headerlink" title="3.3、Date对象"></a>3.3、Date对象</h2><p>在JavaScript中使用Date对象来表示一个时间，如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间。</p><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">console.log(date);</span><br><span class="line"></span><br><span class="line">console.log(date.getFullYear());<span class="comment">//获取当前日期对象的年份(四位数字年份)</span></span><br><span class="line">console.log(date.getMonth());<span class="comment">//获取当前日期对象的月份(0 ~ 11)</span></span><br><span class="line">console.log(date.getDate());<span class="comment">//获取当前日期对象的日数(1 ~ 31)</span></span><br><span class="line">console.log(date.getHours());<span class="comment">//获取当前日期对象的小时(0 ~ 23)</span></span><br><span class="line">console.log(date.getMinutes());<span class="comment">//获取当前日期对象的分钟(0 ~ 59)</span></span><br><span class="line">console.log(date.getSeconds());<span class="comment">//获取当前日期对象的秒钟(0 ~ 59)</span></span><br><span class="line">console.log(date.getMilliseconds());<span class="comment">//获取当前日期对象的毫秒(0 ~ 999)</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ee5fd11e5e77b473d3380597b79a4c29.png" alt="img"></p><p><strong>更多方法：</strong>  <a href="https://www.w3school.com.cn/js/jsref_obj_date.asp">参考网站</a></p><h2 id="3-4、Math对象"><a href="#3-4、Math对象" class="headerlink" title="3.4、Math对象"></a>3.4、Math对象</h2><p>Math和其它的对象不同，它不是一个构造函数，它属于一个工具类不用创建对象，它里边封装了数学运算相关的属性和方法。</p><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*固定值*/</span></span><br><span class="line">console.log(<span class="string">&quot;PI = &quot;</span> + Math.PI);</span><br><span class="line">console.log(<span class="string">&quot;E  = &quot;</span> + Math.E);</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">/*正数*/</span></span><br><span class="line">console.log(Math.abs(<span class="number">1</span>));        <span class="comment">//可以用来计算一个数的绝对值</span></span><br><span class="line">console.log(Math.ceil(<span class="number">1.1</span>));     <span class="comment">//可以对一个数进行向上取整，小数位只有有值就自动进1</span></span><br><span class="line">console.log(Math.floor(<span class="number">1.99</span>));   <span class="comment">//可以对一个数进行向下取整，小数部分会被舍掉</span></span><br><span class="line">console.log(Math.round(<span class="number">1.4</span>));    <span class="comment">//可以对一个数进行四舍五入取整</span></span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">/*负数*/</span></span><br><span class="line">console.log(Math.abs(-<span class="number">1</span>));       <span class="comment">//可以用来计算一个数的绝对值</span></span><br><span class="line">console.log(Math.ceil(-<span class="number">1.1</span>));    <span class="comment">//可以对一个数进行向上取整，小数部分会被舍掉</span></span><br><span class="line">console.log(Math.floor(-<span class="number">1.99</span>));  <span class="comment">//可以对一个数进行向下取整，小数位只有有值就自动进1</span></span><br><span class="line">console.log(Math.round(-<span class="number">1.4</span>));   <span class="comment">//可以对一个数进行四舍五入取整</span></span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">/*随机数*/</span></span><br><span class="line"><span class="comment">//Math.random()：可以用来生成一个0-1之间的随机数</span></span><br><span class="line"><span class="comment">//生成一个0-x之间的随机数：Math.round(Math.random()*x)</span></span><br><span class="line"><span class="comment">//生成一个x-y之间的随机数：Math.round(Math.random()*(y-x)+x)</span></span><br><span class="line">console.log(Math.round(Math.random() * <span class="number">10</span>));            <span class="comment">//生成一个0-10之间的随机数</span></span><br><span class="line">console.log(Math.round(Math.random() * (<span class="number">10</span> - <span class="number">1</span>) + <span class="number">1</span>));  <span class="comment">//生成一个1-10之间的随机数</span></span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"><span class="comment">/*数学运算*/</span></span><br><span class="line">console.log(Math.pow(<span class="number">12</span>, <span class="number">3</span>));   <span class="comment">//Math.pow(x,y)：返回x的y次幂</span></span><br><span class="line">console.log(Math.sqrt(<span class="number">4</span>));      <span class="comment">//Math.sqrt(x) ：返回x的平方根</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e533a1267ab2c8fe8d2497baa2cb23fb.png" alt="img"></p><p><strong>更多方法：</strong>  <a href="https://www.w3school.com.cn/jsref/jsref_obj_math.asp">参考网站</a></p><h2 id="3-5、String对象"><a href="#3-5、String对象" class="headerlink" title="3.5、String对象"></a>3.5、String对象</h2><h3 id="3-5-1、概述"><a href="#3-5-1、概述" class="headerlink" title="3.5.1、概述"></a>3.5.1、概述</h3><p>在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象</p><ul><li>String()：可以将基本数据类型字符串转换为String对象 </li><li>Number()：可以将基本数据类型的数字转换为Number对象 </li><li>Boolean()：可以将基本数据类型的布尔值转换为Boolean对象</li></ul><p>但是注意：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果，在这一章节中，我们重点介绍String()对象的属性和方法。</p><h3 id="3-5-2、字符串属性"><a href="#3-5-2、字符串属性" class="headerlink" title="3.5.2、字符串属性"></a>3.5.2、字符串属性</h3><p><strong>constructor属性演示：返回创建字符串对象的原型函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.constructor);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/96b81bd4968fcb14ad0575f7d55f1010.png" alt="img"></p><p><strong>length属性演示：可以用来获取字符串的长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c0f40802f9a0e11f45574f494c15381c.png" alt="img"></p><h3 id="3-5-3、字符串方法"><a href="#3-5-3、字符串方法" class="headerlink" title="3.5.3、字符串方法"></a>3.5.3、字符串方法</h3><p><strong>charAt()方法演示：该方法可以根据索引获取指定位置的字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.charAt(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/762781eebb3617228550594503fc4316.png" alt="img"></p><p><strong>charCodeAt()方法演示：该方法获取指定位置字符的字符编码（Unicode编码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.charCodeAt(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ad3be8e9fb9508f9c930501166be335d.png" alt="img"></p><p><strong>concat()方法演示：该方法可以用来连接两个或多个字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.concat(<span class="string">&quot;你好，&quot;</span>, <span class="string">&quot;世界！&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/33dde050d46ecb020361b5c926db7d6b.png" alt="img"></p><p><strong>indexof()方法演示：该方法可以检索一个字符串中是否含有指定内容，如果字符串中含有该内容，则会返回其第一次出现的索引，如果没有找到指定的内容，则返回-1，可以指定一个第二个参数，指定开始查找的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.indexOf(<span class="string">&quot;o&quot;</span>));</span><br><span class="line">console.log(str.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9f06bce7729598899f4b2185ea999f32.png" alt="img"></p><p><strong>lastIndexOf()方法演示：该方法的用法和indexOf()一样，不同的是indexOf是从前往后找，而lastIndexOf是从后往前找，也可以指定开始查找的位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">console.log(str.lastIndexOf(<span class="string">&quot;o&quot;</span>));</span><br><span class="line">console.log(str.lastIndexOf(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><p><strong>slice()方法演示：可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到内容返回</strong></p><p>参数：</p><ul><li>第一个参数：开始位置的索引（包括开始位置） </li><li>第二个参数：结束位置的索引（不包括结束位置），如果省略第二个参数，则会截取到后边所有的</li></ul><blockquote><p>注意：也可以传递一个负数作为参数，负数的话将会从后边计算</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">console.log(result);</span><br><span class="line">result = str.slice(<span class="number">1</span>);</span><br><span class="line">console.log(result);</span><br><span class="line">result = str.slice(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/224c58a44617a2687c8a7b1192d0c10d.png" alt="img"></p><p><strong>substring()方法演示：可以用来截取一个字符串，它和slice()类似</strong></p><p>参数：</p><ul><li>第一个参数：开始截取位置的索引（包括开始位置） </li><li>第二个参数：结束位置的索引（不包括结束位置），如果省略第二个参数，则会截取到后边所有的</li></ul><blockquote><p>注意：不同的是这个方法不能接受负值作为参数，如果传递了一个负值，则默认使用0，而且它还自动调整参数的位置，如果第二个参数小于第一个，则自动交换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.substring(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">console.log(result);</span><br><span class="line">result = str.substring(<span class="number">1</span>);</span><br><span class="line">console.log(result);</span><br><span class="line">result = str.substring(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3fd21d1ce6e521c3d809c43cffee13f0.png" alt="img"></p><p><strong>substr()方法演示：该方法用来截取字符串</strong></p><p>参数：</p><ul><li>第一个参数：截取开始位置的索引 </li><li>第二个参数：截取的长度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.substr(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a2e08ece31ebafc8158b8361b12626ba.png" alt="img"></p><p><strong>split()方法演示：该方法可以将一个字符串拆分为一个数组，需要一个字符串作为参数，将会根据该字符串去拆分数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e3d890ba555951588bb43b629ecf1966.png" alt="img"></p><p><strong>toUpperCase()方法演示：将一个字符串转换为大写并返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.toUpperCase();</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/422f98ce2a511c228816c8043c8095b3.png" alt="img"></p><p><strong>toLowerCase()方法演示：将一个字符串转换为小写并返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.toLowerCase();</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/2dfc8bed3884f0db0360d80d76ce1b05.png" alt="img"></p><h2 id="3-6、RegExp对象"><a href="#3-6、RegExp对象" class="headerlink" title="3.6、RegExp对象"></a>3.6、RegExp对象</h2><h3 id="3-6-1、概述"><a href="#3-6-1、概述" class="headerlink" title="3.6.1、概述"></a>3.6.1、概述</h3><p>正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来。</p><p>使用typeof检查正则对象，会返回object。</p><h3 id="3-6-2、创建正则对象"><a href="#3-6-2、创建正则对象" class="headerlink" title="3.6.2、创建正则对象"></a>3.6.2、创建正则对象</h3><h4 id="3-6-2-1、使用对象创建"><a href="#3-6-2-1、使用对象创建" class="headerlink" title="3.6.2.1、使用对象创建"></a>3.6.2.1、使用对象创建</h4><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;正则表达式&quot;</span>,<span class="string">&quot;匹配模式&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>匹配模式：</strong></p><ul><li>i：忽略大小写 </li><li>g：全局匹配模式 </li><li>ig：忽略大小写且全局匹配模式</li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个正则表达式可以来检查一个字符串中是否含有a</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> reg.test(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3de3a4f311d8e818a57dddae72dcd497.png" alt="img"></p><h4 id="3-6-2-2、使用字面量创建"><a href="#3-6-2-2、使用字面量创建" class="headerlink" title="3.6.2.2、使用字面量创建"></a>3.6.2.2、使用字面量创建</h4><p><strong>语法格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = /正则表达式/匹配模式;</span><br></pre></td></tr></table></figure><p><strong>匹配模式：</strong></p><ul><li>i：忽略大小写 </li><li>g：全局匹配模式 </li><li>m：执行多行匹配</li></ul><blockquote><p>注意：可以为一个正则表达式设置多个匹配模式，且顺序无所谓</p></blockquote><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个正则表达式可以来检查一个字符串中是否含有a</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /a/i;</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> reg.test(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3de3a4f311d8e818a57dddae72dcd497.png" alt="img"></p><h3 id="3-6-3、正则进阶"><a href="#3-6-3、正则进阶" class="headerlink" title="3.6.3、正则进阶"></a>3.6.3、正则进阶</h3><p><strong>需求信息：创建一个正则表达式，检查一个字符串中是否有a或b</strong></p><p><strong>语法格式：使用 | 表示或者的意思</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个正则表达式可以来检查一个字符串中是否含有a</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /a|b|c/;</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> reg.test(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c377efe675435e89e278d9a0dc1ff3d3.png" alt="img"></p><p>试想一下，如果我们现在要是想要检查一个字符串是否含有小写字母，那我们是不是可以reg = /a|b|c|d|e|f|g … /;这么写，但是你会发现，好啰嗦啊，怎么这么麻烦呢，有没有一种更简单的方式，答案是肯定的。</p><p><strong>需求信息：创建一个正则表达式，检查一个字符串中是否有字母</strong></p><p><strong>语法格式：[ ] 里的内容也是或的关系</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个正则表达式可以来检查一个字符串中是否含有字母</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /[A-z]/;</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Abc&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> reg.test(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f1a2578a46f59e6d39637b115f799062.png" alt="img"></p><p><strong>常见组合：</strong></p><ul><li>[a-z]：任意小写字母 </li><li>[A-Z]：任意大写字母 </li><li>[A-z]：任意字母 </li><li>[0-9]：任意数字</li></ul><p><strong>需求信息：创建一个正则表达式，检查一个字符串中是否含有 abc 或 adc 或 aec</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个正则表达式可以来检查一个字符串中是否含有abc或adc或aec</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /a[bde]c/;</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> reg.test(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>那现在我们已经学会了判断是否包含，那要是判断除了某些字符序列该咋整，只需要这么写<sup><a href="#fn_字符序列" id="reffn_字符序列">字符序列</a></sup></p><p><strong>常见组合：</strong></p><ul><li><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>：除了任意小写字母 </li><li><sup><a href="#fn_A-Z" id="reffn_A-Z">A-Z</a></sup>：除了任意大写字母 </li><li><sup><a href="#fn_A-z" id="reffn_A-z">A-z</a></sup>：除了任意字母 </li><li><sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>：除了任意数字</li></ul><p><strong>需求信息：创建一个正则表达式，检查一个字符串中是否除了数字还有其它字母</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个正则表达式可以来检查一个字符串中是否除了数字还有其它字母</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /[^<span class="number">0</span>-<span class="number">9</span>]/;</span><br><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> reg.test(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h3 id="3-6-4、正则方法"><a href="#3-6-4、正则方法" class="headerlink" title="3.6.4、正则方法"></a>3.6.4、正则方法</h3><p>这些正则方法其实都是字符串的方法，但是它的参数需要传递正则表达式，在这里，我就先称为正则方法。</p><p><strong>split()方法演示：该方法可以将一个字符串拆分为一个数组，方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串，这个方法即使不指定全局匹配，也会全都插分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1a2b3c4d5e6f7&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.split(/[A-z]/);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/63fc37cd99f403812856c9c60ddb2c08.png" alt="img"></p><p><strong>search()方法演示：该方法可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1，它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串，serach()只会查找第一个，即使设置全局匹配也没用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello abc hello aec afc&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.search(/a[bef]c/);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8ba6eb1153172af98f7b11e8f3b0b0f9.png" alt="img"></p><p><strong>match()方法演示：该方法可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认情况下我们的match()只会找到第一个符合要求的内容，找到以后就停止检索，我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，可以为一个正则表达式设置多个匹配模式，且顺序无所谓，match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.match(/[a-z]/ig);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/691bd30df6aa462310da2ffecac54eb7.png" alt="img"></p><p><strong>replace()方法演示：该方法可以将字符串中指定内容替换为新的内容，默认只会替换第一个，但是可以设置全局匹配替换全部</strong></p><p>参数：</p><ul><li>第一个参数：被替换的内容，可以接受一个正则表达式作为参数 </li><li>第二个参数：新的内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1a2a3a4a5e6f7A8B9C&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> str.replace(/[a-z]/gi, <span class="string">&quot;@_@&quot;</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/588f6ab348d21f0bcd080929ca09d10c.png" alt="img"></p><h3 id="3-6-5、正则量词"><a href="#3-6-5、正则量词" class="headerlink" title="3.6.5、正则量词"></a>3.6.5、正则量词</h3><p>通过量词可以设置一个内容出现的次数，量词只对它前边的一个内容起作用，如果有多个内容可以使用 () 括起来，常见量词如下：</p><ul><li>&#123;n&#125; ：正好出现n次 </li><li>&#123;m,&#125; ：出现m次及以上 </li><li>&#123;m,n&#125; ：出现m-n次 </li><li><ul><li>：至少一个，相当于&#123;1,&#125; </li></ul></li><li><ul><li>：0个或多个，相当于&#123;0,&#125; </li></ul></li><li>? ：0个或1个，相当于&#123;0,1&#125;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abbc&quot;</span>;</span><br><span class="line"></span><br><span class="line">reg = /(ab)&#123;<span class="number">3</span>&#125;/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">reg = /b&#123;<span class="number">3</span>&#125;/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">reg = /ab&#123;<span class="number">1</span>,<span class="number">3</span>&#125;c/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">reg = /ab&#123;<span class="number">3</span>,&#125;c/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">reg = /ab+c/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">reg = /ab*c/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line">reg = /ab?c/;</span><br><span class="line">console.log(reg.test(str));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/fdb8c9ee6adea6a14e18374c788f85e7.png" alt="img"></p><h3 id="3-6-6、正则高阶"><a href="#3-6-6、正则高阶" class="headerlink" title="3.6.6、正则高阶"></a>3.6.6、正则高阶</h3><p>如果我们要检查或者说判断是否以某个字符或者字符序列开头或者结尾就会使用^和$。</p><ul><li>^ ：表示开头，注意它在<sup><a href="#fn_字符序列" id="reffn_字符序列">字符序列</a></sup>表达的意思不一样 </li><li>$ ：表示结尾</li></ul><p><strong>需求描述：检查一个字符串中是否以a开头</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcabca&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /^a/;</span><br><span class="line">console.log(reg.test(str));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5c5989022efc8ce11868c4804fc8fc77.png" alt="img"></p><p><strong>需求描述：检查一个字符串中是否以a结尾</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcabca&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /a$/;</span><br><span class="line">console.log(reg.test(str));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9a455bcd1ce063d8fa63dd522febef83.png" alt="img"></p><p>那如果我们想要检查一个字符串中是否含有.和\就会使用转义字符</p><ul><li>. ：表示. </li><li>\ ：表示\</li></ul><blockquote><p>注意：使用构造函数时，由于它的参数是一个字符串，而<code>\</code>是字符串中转义字符，如果要使用<code>\</code>则需要使用<code>\</code>来代替</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">reg1</span> <span class="operator">=</span> /\./;</span><br><span class="line"><span class="type">var</span> <span class="variable">reg2</span> <span class="operator">=</span> /\\/;</span><br><span class="line"><span class="type">var</span> <span class="variable">reg3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">reg4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\\\&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了以上两种特殊的字符，其实还有很多如下所示：</p><ul><li>\w ：任意字母、数字、<em>，相当于[A-z0-9</em>] </li><li>\W ：除了字母、数字、<em>，相当于[^A-z0-9</em>] </li><li>\d ：任意的数字，相当于[0-9] </li><li>\D ：除了任意的数字，相当于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup> </li><li>\s ：空格 </li><li>\S ：除了空格 </li><li>\b ：单词边界 </li><li>\B ：除了单词边界</li></ul><p>这里边我们就演示最后四个，其它的都比较简单，后边的案例也会涉及，这里就不演示了</p><p><strong>需求描述：创建一个正则表达式，去除掉字符串中的前后的空格</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;  hello child  &quot;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /^\s*|\s*$/g;</span><br><span class="line">console.log(str);</span><br><span class="line">str = str.replace(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/2a12f2a885901b15c8d1bf8cab4cf0d1.png" alt="img"></p><p><strong>需求描述：创建一个正则表达式，检查一个字符串中是否含有单词child</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello child&quot;</span></span><br><span class="line"><span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> /\bchild\b/;</span><br><span class="line">console.log(reg.test(str));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5722c7e9902b36d90565949787051b76.png" alt="img"></p><h3 id="3-6-7、正则案例"><a href="#3-6-7、正则案例" class="headerlink" title="3.6.7、正则案例"></a>3.6.7、正则案例</h3><h4 id="3-6-7-1、检查手机号"><a href="#3-6-7-1、检查手机号" class="headerlink" title="3.6.7.1、检查手机号"></a>3.6.7.1、检查手机号</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">phoneStr</span> <span class="operator">=</span> <span class="string">&quot;15131494600&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">phoneReg</span> <span class="operator">=</span> /^<span class="number">1</span>[<span class="number">3</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">9</span>&#125;$/;</span><br><span class="line">console.log(phoneReg.test(phoneStr));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8add452c5bd9cef4daaba4ee1cb67bb1.png" alt="img"></p><h4 id="3-6-7-2、检查邮箱号"><a href="#3-6-7-2、检查邮箱号" class="headerlink" title="3.6.7.2、检查邮箱号"></a>3.6.7.2、检查邮箱号</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">emailStr</span> <span class="operator">=</span> <span class="string">&quot;abc.def@163.com&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">emailReg</span> <span class="operator">=</span> /^\w&#123;<span class="number">3</span>,&#125;(\.\w+)*@[A-z0-<span class="number">9</span>]+(\.[A-z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;$/;</span><br><span class="line">console.log(emailReg.test(emailStr));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5ffafe5f8f29c55fd80f9b07fb079c09.png" alt="img"></p><h2 id="4-1、DOM概述"><a href="#4-1、DOM概述" class="headerlink" title="4.1、DOM概述"></a>4.1、DOM概述</h2><p>当网页被加载时，浏览器会创建页面的文档对象模型（<strong>D</strong>ocument <strong>O</strong>bject <strong>M</strong>odel）。</p><p>HTML <strong>DOM</strong> 模型被结构化为 <strong>对象树</strong> ：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/910bb72bbde0f438991f02a6cda866d7.png" alt="img"></p><p>通过这个对象模型，JavaScript 获得创建动态 HTML 的所有力量：</p><ul><li>JavaScript 能改变页面中的所有 HTML 元素 </li><li>JavaScript 能改变页面中的所有 HTML 属性 </li><li>JavaScript 能改变页面中的所有 CSS 样式 </li><li>JavaScript 能删除已有的 HTML 元素和属性 </li><li>JavaScript 能添加新的 HTML 元素和属性 </li><li>JavaScript 能对页面中所有已有的 HTML 事件作出反应 </li><li>JavaScript 能在页面中创建新的 HTML 事件</li></ul><p>换言之：HTML DOM 是关于如何获取、更改、添加或删除 HTML 元素的标准。</p><h2 id="4-2、DOM文档节点"><a href="#4-2、DOM文档节点" class="headerlink" title="4.2、DOM文档节点"></a>4.2、DOM文档节点</h2><h3 id="4-2-1、节点概述"><a href="#4-2-1、节点概述" class="headerlink" title="4.2.1、节点概述"></a>4.2.1、节点概述</h3><p>节点Node，是构成我们网页的最基本的组成部分，网页中的每一个部分都可以称为是一个节点。</p><p>比如：html标签、属性、文本、注释、整个文档等都是一个节点。</p><p>虽然都是节点，但是实际上它们的具体类型是不同的。</p><p>比如：标签我们称为元素节点、属性称为属性节点、文本称为 文本节点、文档称为文档节点。</p><p>节点的类型不同，属性和方法也都不尽相同。</p><p>节点：Node——构成HTML文档最基本的单元。</p><p>常用节点分为四类：</p><ul><li>文档节点：整个HTML文档 </li><li>元素节点：HTML文档中的HTML标签 </li><li>属性节点：元素的属性 </li><li>文本节点：HTML标签中的文本内容</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6c58b926da64501f486305b5afe3d9f8.png" alt="img"></p><h3 id="4-2-2、节点属性"><a href="#4-2-2、节点属性" class="headerlink" title="4.2.2、节点属性"></a>4.2.2、节点属性</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/2271dc3f0f61e890fe4cb76817fc6942.png" alt="img"></p><h3 id="4-2-3、文档节点"><a href="#4-2-3、文档节点" class="headerlink" title="4.2.3、文档节点"></a>4.2.3、文档节点</h3><p>文档节点（Document）代表的是整个HTML文 档，网页中的所有节点都是它的子节点。</p><p>document对象作为window对象的属性存在的，我们不用获取可以直接使用。</p><p>通过该对象我们可以在整个文档访问内查找节点对象，并可以通过该对象创建各种节点对象。</p><h3 id="4-2-4、元素节点"><a href="#4-2-4、元素节点" class="headerlink" title="4.2.4、元素节点"></a>4.2.4、元素节点</h3><p>HTML中的各种标签都是元素节点（Element），这也是我们最常用的一个节点。</p><p>浏览器会将页面中所有的标签都转换为一个元素节点， 我们可以通过document的方法来获取元素节点。</p><p>例如：document.getElementById()，根据id属性值获取一个元素节点对象。</p><h3 id="4-2-5、属性节点"><a href="#4-2-5、属性节点" class="headerlink" title="4.2.5、属性节点"></a>4.2.5、属性节点</h3><p>属性节点（Attribute）表示的是标签中的一个一个的属 性，这里要注意的是属性节点并非是元素节点的子节点，而是元素节点的一部分。可以通过元素节点来获取指定的属性节点。</p><p>例如：元素节点.getAttributeNode(“属性名”)，根据元素节点的属性名获取一个属性节点对象。</p><blockquote><p>注意：我们一般不使用属性节点。</p></blockquote><h3 id="4-2-6、文本节点"><a href="#4-2-6、文本节点" class="headerlink" title="4.2.6、文本节点"></a>4.2.6、文本节点</h3><p>文本节点（Text）表示的是HTML标签以外的文本内容，任意非HTML的文本都是文本节点，它包括可以字面解释的纯文本内容。文本节点一般是作为元素节点的子节点存在的。获取文本节点时，一般先要获取元素节点，在通过元素节点获取文本节点。</p><p>例如：元素节点.firstChild;，获取元素节点的第一个子节点，一般为文本节点。</p><h2 id="4-3、DOM文档操作"><a href="#4-3、DOM文档操作" class="headerlink" title="4.3、DOM文档操作"></a>4.3、DOM文档操作</h2><p>文档对象代表您的网页,，如果您希望访问 HTML 页面中的任何元素，那么您总是从访问 document 对象开始。</p><p>下面是一些如何使用 document 对象来访问和操作 HTML 的实例。</p><h3 id="4-3-1、查找-HTML-元素"><a href="#4-3-1、查找-HTML-元素" class="headerlink" title="4.3.1、查找 HTML 元素"></a>4.3.1、查找 HTML 元素</h3><h4 id="4-3-1-1、方法介绍"><a href="#4-3-1-1、方法介绍" class="headerlink" title="4.3.1.1、方法介绍"></a>4.3.1.1、方法介绍</h4><h4 id="4-3-1-2、方法演示"><a href="#4-3-1-2、方法演示" class="headerlink" title="4.3.1.2、方法演示"></a>4.3.1.2、方法演示</h4><p><strong>需求描述：创建一个按钮，通过id获取按钮节点对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;我是按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">    console.log(btn);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a4a12435040d0fb10c21046d3da4f685.png" alt="img"></p><p><strong>需求描述：创建一个按钮，通过标签名获取按钮节点对象数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button&gt;我是按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">    console.log(btn);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e9e294078eb1d88399cf087561187bc4.png" alt="img"></p><p><strong>需求描述：创建一个按钮，通过类名获取按钮节点对象数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button class=<span class="string">&quot;btn&quot;</span>&gt;我是按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementsByClassName(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">    console.log(btn);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/cbf99da44967f7bd855435581c483059.png" alt="img"></p><p><strong>需求描述：创建一个按钮，通过CSS选择器选择该按钮</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button class=<span class="string">&quot;btn&quot;</span>&gt;我是按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.querySelector(<span class="string">&quot;.btn&quot;</span>);</span><br><span class="line">    console.log(btn);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/1f0792d8e76b9363a509ad6ac7d85244.png" alt="img"></p><p><strong>需求描述：创建一个无序列表，通过CSS选择器选择该列表的所有li</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul class=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">4</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> document.querySelectorAll(<span class="string">&quot;.list li&quot;</span>);</span><br><span class="line">    console.log(list);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/80f710098d194f71233b1fcfb324f4e2.png" alt="img"></p><h3 id="4-3-2、获取-HTML-的值"><a href="#4-3-2、获取-HTML-的值" class="headerlink" title="4.3.2、获取 HTML 的值"></a>4.3.2、获取 HTML 的值</h3><h4 id="4-3-2-1、方法介绍"><a href="#4-3-2-1、方法介绍" class="headerlink" title="4.3.2.1、方法介绍"></a>4.3.2.1、方法介绍</h4><h4 id="4-3-2-2、方法演示"><a href="#4-3-2-2、方法演示" class="headerlink" title="4.3.2.2、方法演示"></a>4.3.2.2、方法演示</h4><p><strong>需求描述：创建一个按钮，然后获取按钮的文本内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;我是按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">    console.log(btn.innerText);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d836aa32b6a43979de51338534ba2bf9.png" alt="img"></p><p><strong>需求描述：创建一个div，然后在div中插入一个h1标题，获取div中的html代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;我是Box中的大标题&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    console.log(box.innerHTML);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/4a8f1dd5b26a043cd7b9078c0cfd0421.png" alt="img"></p><p><strong>需求描述：创建一个超链接，默认为空，设置href属性为<a href="https://www.baidu.com">https://www.baidu.com</a> ，使用JavaScript代码读取href属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a id=<span class="string">&quot;a&quot;</span> href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    console.log(a.href);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8758c3b09d1558dac07d0732a14a629b.png" alt="img"></p><p><strong>需求描述：创建一个超链接，默认为空，设置href属性为<a href="https://www.baidu.com">https://www.baidu.com</a> ，使用JavaScript代码读取href属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a id=<span class="string">&quot;a&quot;</span> href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    console.log(a.getAttribute(<span class="string">&quot;href&quot;</span>));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e7a6fe98a043b1c21f89becc7beae27a.png" alt="img"></p><p><strong>需求描述：创建一个正方形div，默认颜色为红色，使用JavaScript代码获取div的宽度</strong></p><blockquote><p>注意：如果CSS的样式名中含有-，这种名称在JS中是不合法的比如background-color，需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写，我们通过style属性设置的样式都是行内样式，同样的获取也是行内样式，而行内样式有较高的优先级，所以通过JS修改的样式往往会立即显示，但是如果在样式中写了!important，则此时样式会有最高的优先级，即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效，所以尽量不要为样式添加!important</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width: 100px;height: 100px;background: red;&quot;</span> id=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    console.log(box.style.width);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3ee1de03ba68d6321c0b6922c74ebd52.png" alt="img"></p><p><strong>拓展知识1：</strong></p><p>通过style属性设置和读取的都是内联样式，无法读取样式表中的样式或者说正在应用的样式，如果想要读取当前正在应用的样式属性我们可以使用元素.currentStyle.样式名来获取元素的当前显示的样式，它可以用来读取当前元素正在显示的样式，如果当前元素没有设置该样式，则获取它的默认值，但是currentStyle只有IE浏览器支持，其它的浏览器都不支持，在其它浏览器中可以使用getComputedStyle()这个方法来获取元素当前的样式，这个方法是window的方法，可以直接使用，但是需要两个参数：</p><ul><li>第一个参数：要获取样式的元素 </li><li>第二个参数：可以传递一个伪元素，一般都传null</li></ul><p>该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过 对象.样式名 来读取样式，如果获取的样式没有设置，则会获取到真实的值，而不是默认值，比如：没有设置width，它不会获取到auto，而是一个长度，但是该方法不支持IE8及以下的浏览器。通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性，因此，我们可以写一个适配各个浏览器的读取元素样式的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        <span class="comment">/*样式表的样式*/</span></span><br><span class="line">        #box &#123;</span><br><span class="line">    </span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width: 100px;height: 100px;&quot;</span> id=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*通用的获取元素样式的方法*/</span></span><br><span class="line">    function <span class="title function_">getStyle</span><span class="params">(obj, name)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (window.getComputedStyle) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//正常浏览器的方式，具有getComputedStyle()方法</span></span><br><span class="line">            <span class="keyword">return</span> getComputedStyle(obj, <span class="literal">null</span>)[name];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//IE8的方式，没有getComputedStyle()方法</span></span><br><span class="line">            <span class="keyword">return</span> obj.currentStyle[name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(getStyle(box, <span class="string">&quot;width&quot;</span>));</span><br><span class="line">    console.log(getStyle(box, <span class="string">&quot;height&quot;</span>));</span><br><span class="line">    console.log(getStyle(box, <span class="string">&quot;background-color&quot;</span>));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>谷歌浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2fb2f2ff61d0469329039464d23bfe7.png" alt="img"></p><p>火狐浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0a114c32d9776f919ba9506fb2eb818b.png" alt="img"></p><p>IE9-IE11 浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6739e07782087f92acbb30a595ccc6b8.png" alt="img"></p><p>IE5-IE8 浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7df8d96f441bf30cb7c20dc10624c4b0.png" alt="img"></p><p>有同学会说，在IE5-IE8 浏览器中，老师这不是还不一样吗？因此我们建议设置颜色数值一般采用rgb或者rgba，最好不要采用英文单词的这种颜色值，这样最终展示出来的效果就一致了。</p><p><strong>拓展知识2：编写一段兼容性代码，用来获取任意标签的文本内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span> id=<span class="string">&quot;a&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(getInnerText(a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取任意标签的内容*/</span></span><br><span class="line">    function <span class="title function_">getInnerText</span><span class="params">(element)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断浏览器是否支持textContent,如果支持，则使用textContent获取内容，否则使用innerText获取内容。</span></span><br><span class="line">        <span class="keyword">if</span>(typeof element.textContent == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.innerText;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.textContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>谷歌浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3ca6eddc64116c4fa953a9ce64da0b11.png" alt="img"></p><p>火狐浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/65e9ac0e97150902e3cd508ba236db81.png" alt="img"></p><p>IE5-IE11浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/53431bc5beb1b82d241e2666a56f28e4.png" alt="img"></p><h3 id="4-3-3、改变-HTML-的值"><a href="#4-3-3、改变-HTML-的值" class="headerlink" title="4.3.3、改变 HTML 的值"></a>4.3.3、改变 HTML 的值</h3><h4 id="4-3-3-1、方法介绍"><a href="#4-3-3-1、方法介绍" class="headerlink" title="4.3.3.1、方法介绍"></a>4.3.3.1、方法介绍</h4><h4 id="4-3-3-2、方法演示"><a href="#4-3-3-2、方法演示" class="headerlink" title="4.3.3.2、方法演示"></a>4.3.3.2、方法演示</h4><p><strong>需求描述：创建一个按钮，然后改变按钮的文本内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;我是按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">    btn.innerText = <span class="string">&quot;我是JavaScript的按钮&quot;</span>;</span><br><span class="line">    console.log(btn);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/56582292e6ee61fccb1dc8c90e55972c.png" alt="img"></p><p><strong>需求描述：创建一个div，然后在div中插入一个h1标题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    box.innerHTML = <span class="string">&quot;&lt;h1&gt;我是Box中的大标题&lt;/h1&gt;&quot;</span>;</span><br><span class="line">    console.log(box);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a010c647556b98b0de90a75c1ff08cdc.png" alt="img"></p><p><strong>需求描述：创建一个超链接，默认为空，使用JavaScript代码设置href属性为<a href="https://www.baidu.com">https://www.baidu.com</a> </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a id=<span class="string">&quot;a&quot;</span> href=<span class="string">&quot;&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    a.href=<span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br><span class="line">    console.log(a);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/71fb6639e98948a6ca3ee290f44f8012.png" alt="img"></p><p><strong>需求描述：创建一个超链接，默认为空，使用JavaScript代码设置href属性为<a href="https://www.baidu.com">https://www.baidu.com</a> </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a id=<span class="string">&quot;a&quot;</span> href=<span class="string">&quot;&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    a.setAttribute(<span class="string">&quot;href&quot;</span>, <span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">    console.log(a);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b600ef7b34cbc27bea3ad887b22e1c38.png" alt="img"></p><p><strong>需求描述：创建一个正方形div，默认颜色为红色，使用JavaScript代码改变为绿色</strong></p><blockquote><p>注意：如果CSS的样式名中含有-，这种名称在JS中是不合法的比如background-color，需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写，我们通过style属性设置的样式都是行内样式，同样的获取也是行内样式，而行内样式有较高的优先级，所以通过JS修改的样式往往会立即显示，但是如果在样式中写了!important，则此时样式会有最高的优先级，即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效，所以尽量不要为样式添加!important</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot;width: 100px;height: 100px;background: red;&quot;</span> id=<span class="string">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    box.style.background = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    console.log(box);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0564f9033a71ffc937e9f87f1a65c378.png" alt="img"></p><p><strong>拓展知识1：</strong></p><p>修改节点的内容除了常用的innerHTML和innerText之外，还有insertAdjacentHTML和insertAdjacentText方法，可以在指定的地方插入内容。insertAdjacentText方法与insertAdjacentHTML方法类似，只不过是插入纯文本，参数相同。</p><p>语法说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.insertAdjacentHTML(where,html);</span><br><span class="line">object.insertAdjacentText(where,text)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>where： </p><ul> - beforeBegin：插入到开始标签的前面 - beforeEnd：插入到结束标签的前面 - afterBegin：插入到开始标签的后面 - afterEnd：插入到结束标签的后面 </ul>   </li><li><p>html：一段html代码  </p></li><li>text：一段文本值 </li></ul><p>注意事项：</p><ol><li>这两个方法必须等文档加载好后才能执行，否则会出错。 </li><li>insertAdjacentText只能插入普通文本，insertAdjacentHTML插入html代码。 </li><li>使用insertAdjacentHTML方法插入script脚本文件时，必须在script元素上定义defer属性。 </li><li>使用insertAdjacentHTML方法插入html代码后，页面上的元素集合将发生变化。 </li><li>insertAdjacentHTML方法不适用于单个的空的元素标签(如img，input等)。</li></ol><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;insert&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;你是我的小丫小苹果&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">div</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;insert&quot;</span>);</span><br><span class="line">    div.insertAdjacentHTML(<span class="string">&#x27;beforeBegin&#x27;</span>, <span class="string">&#x27;你是我的小丫小苹果&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c05be7bed36cf98940ef9a6b9bbd46c5.png" alt="img"></p><p><strong>拓展知识2：编写一段兼容性代码，用来设置任意标签的文本内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span> id=<span class="string">&quot;a&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    setInnerText(a, <span class="string">&quot;你要打开百度吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(getInnerText(a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取任意标签的内容*/</span></span><br><span class="line">    function <span class="title function_">getInnerText</span><span class="params">(element)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断浏览器是否支持textContent,如果支持，则使用textContent获取内容，否则使用innerText获取内容。</span></span><br><span class="line">        <span class="keyword">if</span> (typeof element.textContent == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.innerText;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.textContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置任意标签的内容*/</span></span><br><span class="line">    function <span class="title function_">setInnerText</span><span class="params">(element, text)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断浏览器是否支持textContent,如果支持，则使用textContent设置内容，否则使用innerText设置内容。</span></span><br><span class="line">        <span class="keyword">if</span> (typeof element.textContent == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.innerText = text;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.textContent = text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>谷歌浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/92617ad540982bffb28242c851b98e0d.png" alt="img"></p><p>火狐浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2a5fd2976d0c0c248d7781e77f4758ea.png" alt="img"></p><p>IE5-IE11浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/554e2179110d1e9d1c6c3944ae928f88.png" alt="img"></p><h3 id="4-3-4、修改-HTML-元素"><a href="#4-3-4、修改-HTML-元素" class="headerlink" title="4.3.4、修改 HTML 元素"></a>4.3.4、修改 HTML 元素</h3><h4 id="4-3-4-1、方法介绍"><a href="#4-3-4-1、方法介绍" class="headerlink" title="4.3.4.1、方法介绍"></a>4.3.4.1、方法介绍</h4><h4 id="4-3-4-2、方法演示"><a href="#4-3-4-2、方法演示" class="headerlink" title="4.3.4.2、方法演示"></a>4.3.4.2、方法演示</h4><p><strong>案例演示1：创建一个ul列表，然后在该列表中追加4个li标签</strong></p><p>第一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">ul</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li1</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">text1</span> <span class="operator">=</span> document.createTextNode(<span class="string">&quot;列表项1&quot;</span>);</span><br><span class="line">    li1.appendChild(text1);</span><br><span class="line">    ul.appendChild(li1);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li2</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">text2</span> <span class="operator">=</span> document.createTextNode(<span class="string">&quot;列表项2&quot;</span>);</span><br><span class="line">    li2.appendChild(text2);</span><br><span class="line">    ul.appendChild(li2);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li3</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">text3</span> <span class="operator">=</span> document.createTextNode(<span class="string">&quot;列表项3&quot;</span>);</span><br><span class="line">    li3.appendChild(text3);</span><br><span class="line">    ul.appendChild(li3);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li4</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">text4</span> <span class="operator">=</span> document.createTextNode(<span class="string">&quot;列表项4&quot;</span>);</span><br><span class="line">    li4.appendChild(text4);</span><br><span class="line">    ul.appendChild(li4);</span><br><span class="line"></span><br><span class="line">    document.getElementsByTagName(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].appendChild(ul);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f807b292838456cc317d127c135fca49.png" alt="img"></p><p>第二种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">ul</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li1</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    li1.innerHTML = <span class="string">&quot;列表项1&quot;</span>;</span><br><span class="line">    ul.appendChild(li1);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li2</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    li2.innerHTML = <span class="string">&quot;列表项2&quot;</span>;</span><br><span class="line">    ul.appendChild(li2);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li3</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    li3.innerHTML = <span class="string">&quot;列表项3&quot;</span>;</span><br><span class="line">    ul.appendChild(li3);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li4</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    li4.innerHTML = <span class="string">&quot;列表项4&quot;</span>;</span><br><span class="line">    ul.appendChild(li4);</span><br><span class="line"></span><br><span class="line">    document.getElementsByTagName(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].appendChild(ul);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/4e1853b78d8f391e2bb2ee86a16bc733.png" alt="img"></p><p>第三种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">ul</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">li1</span> <span class="operator">=</span> <span class="string">&quot;&lt;li&gt;列表项1&lt;/li&gt;&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">li2</span> <span class="operator">=</span> <span class="string">&quot;&lt;li&gt;列表项2&lt;/li&gt;&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">li3</span> <span class="operator">=</span> <span class="string">&quot;&lt;li&gt;列表项3&lt;/li&gt;&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="string">&quot;&lt;li&gt;列表项4&lt;/li&gt;&quot;</span>;</span><br><span class="line">    ul.innerHTML = li1 + li2 + li3 + li4;</span><br><span class="line"></span><br><span class="line">    document.getElementsByTagName(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].appendChild(ul);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/812211288b9c0fef95fadb038fdf1c84.png" alt="img"></p><p><strong>案例演示2：创建一个ul列表，里边有四个li子元素，删除第一个li，替换最后一个li</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=<span class="string">&quot;ul&quot;</span>&gt;</span><br><span class="line">    &lt;li id=<span class="string">&quot;first&quot;</span>&gt;列表项<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">    &lt;li id=<span class="string">&quot;last&quot;</span>&gt;列表项<span class="number">4</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">ul</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">last</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;last&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除第一个*/</span></span><br><span class="line">    ul.removeChild(first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*替换最后一个*/</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">replaceLi</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    replaceLi.innerHTML = <span class="string">&quot;列表4的替换&quot;</span>;</span><br><span class="line">    ul.replaceChild(replaceLi, last);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/235c25b41f1db4ad92f3f7e9397a3dc8.png" alt="img"></p><p><strong>案例演示3：创建一个ul列表，里边有四个li子元素，在第一个li前边插入一个id为zero的li</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=<span class="string">&quot;ul&quot;</span>&gt;</span><br><span class="line">    &lt;li id=<span class="string">&quot;first&quot;</span>&gt;列表项<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项<span class="number">4</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">ul</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">first</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;first&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">zero</span> <span class="operator">=</span> document.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    zero.innerHTML = <span class="string">&quot;列表0的新增&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    ul.insertBefore(zero, first);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/836f305b817ee0ea7c0368405b20835c.png" alt="img"></p><p><strong>拓展知识：</strong></p><p>动态判断、添加、删除、切换样式，支持IE5-IE11，谷歌浏览器、火狐浏览器等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .b1 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .b2 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn0&quot;</span>&gt;判断b2样式&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn1&quot;</span>&gt;添加b2样式&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn2&quot;</span>&gt;删除b2样式&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn3&quot;</span>&gt;切换b2样式&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span> class=<span class="string">&quot;b1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn0</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn0&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn1</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn2</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn2&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn3</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn3&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">    btn0.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        alert(hasClass(box, <span class="string">&quot;b2&quot;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    btn1.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        addClass(box, <span class="string">&quot;b2&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    btn2.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        removeClass(box, <span class="string">&quot;b2&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    btn3.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        toggleClass(box, <span class="string">&quot;b2&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断一个元素中是否含有指定的class属性值</span></span><br><span class="line"><span class="comment">     * 如果有该class，则返回true，没有则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    function <span class="title function_">hasClass</span><span class="params">(obj, cn)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + cn + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> reg.test(obj.className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 向一个元素中添加指定的class属性值</span></span><br><span class="line"><span class="comment">     * 参数:</span></span><br><span class="line"><span class="comment">     * obj 要添加class属性的元素</span></span><br><span class="line"><span class="comment">     *  cn 要添加的class值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    function <span class="title function_">addClass</span><span class="params">(obj, cn)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查obj中是否含有cn</span></span><br><span class="line">        <span class="keyword">if</span> (!hasClass(obj, cn)) &#123;</span><br><span class="line">    </span><br><span class="line">            obj.className += <span class="string">&quot; &quot;</span> + cn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 删除一个元素中的指定的class属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    function <span class="title function_">removeClass</span><span class="params">(obj, cn)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">var</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\b&quot;</span> + cn + <span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">        obj.className = obj.className.replace(reg, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * toggleClass可以用来切换一个类</span></span><br><span class="line"><span class="comment">     * 如果元素中具有该类，则删除</span></span><br><span class="line"><span class="comment">     * 如果元素中没有该类，则添加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    function <span class="title function_">toggleClass</span><span class="params">(obj, cn)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断obj中是否含有cn</span></span><br><span class="line">        <span class="keyword">if</span> (hasClass(obj, cn)) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 存在，则删除</span></span><br><span class="line">            removeClass(obj, cn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 没有，则添加</span></span><br><span class="line">            addClass(obj, cn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3ce11a8d4ac93137688af293a74c89ab.png" alt="img"></p><h3 id="4-3-5、查找-HTML-父子"><a href="#4-3-5、查找-HTML-父子" class="headerlink" title="4.3.5、查找 HTML 父子"></a>4.3.5、查找 HTML 父子</h3><h4 id="4-3-5-1、方法介绍"><a href="#4-3-5-1、方法介绍" class="headerlink" title="4.3.5.1、方法介绍"></a>4.3.5.1、方法介绍</h4><h4 id="4-3-5-2、方法演示"><a href="#4-3-5-2、方法演示" class="headerlink" title="4.3.5.2、方法演示"></a>4.3.5.2、方法演示</h4><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span>&gt;</span><br><span class="line">    &lt;ul id=<span class="string">&quot;ul&quot;</span>&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;我是超链接<span class="number">1</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li id=<span class="string">&quot;two&quot;</span>&gt;&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;我是超链接<span class="number">2</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;我是超链接<span class="number">3</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;我是超链接<span class="number">4</span>&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">ul</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">two</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(ul.parentNode);</span><br><span class="line">    console.log(ul.parentElement);</span><br><span class="line">    console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(box.childNodes);</span><br><span class="line">    console.log(box.children);</span><br><span class="line">    console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(ul.firstChild);</span><br><span class="line">    console.log(ul.firstElementChild);</span><br><span class="line">    console.log(ul.lastChild);</span><br><span class="line">    console.log(ul.lastElementChild);</span><br><span class="line">    console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">    console.log(two.previousSibling);</span><br><span class="line">    console.log(two.previousElementSibling);</span><br><span class="line">    console.log(two.nextSibling);</span><br><span class="line">    console.log(two.nextElementSibling);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7529554c9039548d1963311ac4759040.png" alt="img"></p><p><strong>兼容性方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取任意一个父级元素的第一个子元素*/</span></span><br><span class="line">function <span class="title function_">getfirstElementChild</span><span class="params">(element)</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(element.firstElementChild) &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> element.firstElementChild;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.firstChild;</span><br><span class="line"><span class="keyword">while</span>(node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">node = node.nextSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取任意一个父级元素的最后一个子元素*/</span></span><br><span class="line">function <span class="title function_">getLastElementChild</span><span class="params">(element)</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(element.lastElementChild) &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> element.lastElementChild;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.lastChild;</span><br><span class="line"><span class="keyword">while</span>(node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">node = node.previousSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取任意一个子元素的前一个兄弟元素*/</span></span><br><span class="line">function <span class="title function_">getPreviousElementSibling</span><span class="params">(element)</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(element.previousElementSibling) &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> element.previousElementSibling;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.previousSibling;</span><br><span class="line"><span class="keyword">while</span>(node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">node = node.previousSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取任意一个子元素的后一个兄弟元素*/</span></span><br><span class="line">function <span class="title function_">getNextElementSibling</span><span class="params">(element)</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(element.nextElementSibling) &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> element.nextElementSibling;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.nextSibling;</span><br><span class="line"><span class="keyword">while</span>(node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">node = node.nextSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;前面的P标签&lt;/p&gt;</span><br><span class="line">    &lt;b&gt;加粗文本&lt;/b&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span> id=<span class="string">&quot;a&quot;</span>&gt;百度一下&lt;/a&gt;</span><br><span class="line">    &lt;i&gt;斜体文本&lt;/i&gt;</span><br><span class="line">    &lt;p&gt;最后的P标签&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/*第一个子元素*/</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">firstNode</span> <span class="operator">=</span> getfirstElementChild(document.getElementById(<span class="string">&quot;container&quot;</span>));</span><br><span class="line">    console.log(firstNode.innerHTML);</span><br><span class="line">    <span class="comment">/*最后一个子元素*/</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">lastNode</span> <span class="operator">=</span> getLastElementChild(document.getElementById(<span class="string">&quot;container&quot;</span>));</span><br><span class="line">    console.log(lastNode.innerHTML);</span><br><span class="line">    <span class="comment">/*指定元素的前一个子元素*/</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">node1</span> <span class="operator">=</span> getPreviousElementSibling(document.getElementById(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    console.log(node1.innerHTML);</span><br><span class="line">    <span class="comment">/*指定元素的后一个子元素*/</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">node2</span> <span class="operator">=</span> getNextElementSibling(document.getElementById(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">    console.log(node2.innerHTML);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取任意一个父级元素的第一个子元素*/</span></span><br><span class="line">    function <span class="title function_">getfirstElementChild</span><span class="params">(element)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (element.firstElementChild) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.firstElementChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.firstChild;</span><br><span class="line">            <span class="keyword">while</span> (node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                node = node.nextSibling;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取任意一个父级元素的最后一个子元素*/</span></span><br><span class="line">    function <span class="title function_">getLastElementChild</span><span class="params">(element)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (element.lastElementChild) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.lastElementChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.lastChild;</span><br><span class="line">            <span class="keyword">while</span> (node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                node = node.previousSibling;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取任意一个子元素的前一个兄弟元素*/</span></span><br><span class="line">    function <span class="title function_">getPreviousElementSibling</span><span class="params">(element)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (element.previousElementSibling) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.previousElementSibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.previousSibling;</span><br><span class="line">            <span class="keyword">while</span> (node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                node = node.previousSibling;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取任意一个子元素的后一个兄弟元素*/</span></span><br><span class="line">    function <span class="title function_">getNextElementSibling</span><span class="params">(element)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (element.nextElementSibling) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> element.nextElementSibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> element.nextSibling;</span><br><span class="line">            <span class="keyword">while</span> (node &amp;&amp; node.nodeType != <span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                node = node.nextSibling;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>谷歌浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/500bbd1a5ea8cd5a53d0b99ff9b131c7.png" alt="img"></p><p>火狐浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4acbcf607aa870893bf658ef282a6e4a.png" alt="img"></p><p>IE5-IE11浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ea8d2c26b705c310c80e275715336d8d.png" alt="img"></p><h2 id="4-4、DOM文档事件"><a href="#4-4、DOM文档事件" class="headerlink" title="4.4、DOM文档事件"></a>4.4、DOM文档事件</h2><h3 id="4-4-1、事件概述"><a href="#4-4-1、事件概述" class="headerlink" title="4.4.1、事件概述"></a>4.4.1、事件概述</h3><p>HTML事件可以触发浏览器中的行为，比方说当用户点击某个 HTML 元素时启动一段 JavaScript。</p><h3 id="4-4-2、窗口事件"><a href="#4-4-2、窗口事件" class="headerlink" title="4.4.2、窗口事件"></a>4.4.2、窗口事件</h3><p>由窗口触发该事件 (同样适用于 &lt;body&gt; 标签)：</p><p><strong>案例演示1：当窗口失去焦点时，输出“窗口失去焦点”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onblur = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;窗口失去焦点&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a85355ebaabbd206e59b7061c5eacf7c.png" alt="img"></p><p><strong>案例演示2：当窗口获取焦点时，输出“窗口获取焦点”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onfocus = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;窗口获取焦点&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c6064b12922f00dd1242c07ec2ff4d6d.png" alt="img"></p><p><strong>案例演示3：当页面文档加载完成后，输出”Hello, World”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/00f5813669d977f3a6dc43df69d0752d.png" alt="img"></p><p><strong>案例演示4：当调整窗口大小时，输出”窗口大小正在改变”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onresize = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;窗口大小正在改变&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ec744b7827119eca9d85dca8b3fddd2c.png" alt="img"></p><h3 id="4-4-3、表单事件"><a href="#4-4-3、表单事件" class="headerlink" title="4.4.3、表单事件"></a>4.4.3、表单事件</h3><p>表单事件在HTML表单中触发 (适用于所有 HTML 元素，但该HTML元素需在form表单内)：</p><p><strong>案例演示1：当文本框获取焦点，文本框背景为红色，当文本框失去焦点，文本框背景为黄色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">textInput</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当文本框获取焦点，文本框背景为红色 */</span></span><br><span class="line">    textInput.onfocus = function () &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当文本框失去焦点，文本框背景为绿色 */</span></span><br><span class="line">    textInput.onblur = function () &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里为什么要用this，你不用this也可以，就直接<code>textInput.style.background = “red”;</code>也不是不可以的，但是方法的调用规则就是谁调用this，this就指向谁，这样我们就可以简化代码了</p></blockquote><p><strong>案例演示2：当文本框内容改变时，鼠标离开文本框，自动将文本框的内容输出到控制台</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">textInput</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当文本框内容改变时，鼠标离开文本框，自动将文本框的内容输出到控制台 */</span></span><br><span class="line">    textInput.onchange = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d4c9ff58b0e1bcea5aaa206660627031.png" alt="img"></p><p><strong>案例演示3：当文本框内容改变时，立即将改变的内容输出到控制台</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">textInput</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当文本框内容改变时，立即将改变的内容输出到控制台 */</span></span><br><span class="line">    textInput.oninput = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/298382000b56c6aadf01a9764c8761f6.png" alt="img"></p><p><strong>案例演示4：如果单击“submit”，则不填写文本字段，将发生警报消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span> required&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">textInput</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果单击“submit”，则不填写文本字段，将发生警报消息 */</span></span><br><span class="line">    textInput.oninvalid = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;请您完善表单内容！&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d6f51bce499dc388317f06cccb0e7e38.png" alt="img"></p><p><strong>案例演示5：当选中文本框的内容时，输出“您已经选择了文本框内容！”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">textInput</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当选中文本框的内容时，输出“您已经选择了文本框内容！” */</span></span><br><span class="line">    textInput.onselect = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;您已经选择了文本框内容！&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/001f570b9680ae5b7d55dcacb7860061.png" alt="img"></p><p><strong>案例演示6：当提交表单的时候，在控制台输出“表单提交”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form id=<span class="string">&quot;myform&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">myform</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;myform&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当提交表单的时候，在控制台输出“表单提交” */</span></span><br><span class="line">    myform.onsubmit = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;表单提交&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">/* 用来阻止表单提交的，你不写它会跳转请求 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/98d3c1ca8f329bfce30b42a26d83efbe.png" alt="img"></p><h3 id="4-4-4、键盘事件"><a href="#4-4-4、键盘事件" class="headerlink" title="4.4.4、键盘事件"></a>4.4.4、键盘事件</h3><p>通过键盘触发事件，类似用户的行为：</p><p><strong>案例演示1：当键盘按下判断当前的按键是不是 a ，如果是就输出true，否则输出false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/* 当键盘按下判断当前的按键是不是 a ，如果是就输出true，否则输出false */</span></span><br><span class="line">    window.onkeydown = function (event) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 解决兼容性问题 */</span></span><br><span class="line">        event = event || window.event;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.keyCode == <span class="number">65</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            console.log(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            console.log(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f596c9f32c2ef61465bde0ff255fa652.png" alt="img"></p><p><strong>案例演示2：使div可以根据不同的方向键向不同的方向移动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span> style=<span class="string">&quot;width: 100px;height: 100px;background: red;position: absolute;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为document绑定一个按键按下的事件</span></span><br><span class="line">    document.onkeydown = function (event) &#123;</span><br><span class="line">    </span><br><span class="line">        event = event || window.event;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义移动速度</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">speed</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择移动方向</span></span><br><span class="line">        <span class="keyword">switch</span> (event.keyCode) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">                box.style.left = box.offsetLeft - speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">                box.style.left = box.offsetLeft + speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">                box.style.top = box.offsetTop - speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">                box.style.top = box.offsetTop + speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6dcd6c4ddbb7e445435bdb5695352fc7.png" alt="img"></p><p><strong>拓展知识：</strong></p><p>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数。</p><p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标的状态。</p><p>在IE8中，响应函数被触发时，浏览器不会传递事件对象，在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的。</p><p>解决事件对象的兼容性问题：event = event || window.event;</p><p><strong>键鼠属性：</strong></p><h3 id="4-4-5、鼠标事件"><a href="#4-4-5、鼠标事件" class="headerlink" title="4.4.5、鼠标事件"></a>4.4.5、鼠标事件</h3><p>通过鼠标触发事件，类似用户的行为：</p><p><strong>案例演示1：创建一个正方形div，默认颜色为黑色，当鼠标移入div，背景颜色变为红色，当鼠标移出div，背景颜色变为绿色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span> style=<span class="string">&quot;width: 100px;height: 100px;background: black;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当鼠标移入div，背景颜色变为红色 */</span></span><br><span class="line">    box.onmouseenter = function () &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当鼠标移出div，背景颜色变为绿色 */</span></span><br><span class="line">    box.onmouseleave = function () &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/037cf65cf7cde9f4375a4ccadd933cc5.png" alt="img"></p><p><strong>案例演示2：编写一个通用的拖拽元素函数，创建两个div，进行拖拽演示，要求兼容IE8、火狐、谷歌等主流浏览器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box1&quot;</span> style=<span class="string">&quot;width: 100px;height: 100px;background: red;position: absolute;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;box2&quot;</span> style=<span class="string">&quot;width: 100px;height: 100px;background: green;position: absolute;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">box1</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">box2</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;box2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    drag(box1);</span><br><span class="line">    drag(box2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 提取一个专门用来设置拖拽的函数</span></span><br><span class="line"><span class="comment">     * 参数：开启拖拽的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    function <span class="title function_">drag</span><span class="params">(obj)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//当鼠标在被拖拽元素上按下时，开始拖拽</span></span><br><span class="line">        obj.onmousedown = function (event) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 解决事件的兼容性问题</span></span><br><span class="line">            event = event || window.event;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置obj捕获所有鼠标按下的事件</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * setCapture()：</span></span><br><span class="line"><span class="comment">             * 只有IE支持，但是在火狐中调用时不会报错，</span></span><br><span class="line"><span class="comment">             * 而如果使用chrome调用，它也会报错</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            obj.setCapture &amp;&amp; obj.setCapture();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obj的偏移量 鼠标.clentX - 元素.offsetLeft</span></span><br><span class="line">            <span class="comment">// obj的偏移量 鼠标.clentY - 元素.offsetTop</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">ol</span> <span class="operator">=</span> event.clientX - obj.offsetLeft;</span><br><span class="line">            <span class="type">var</span> <span class="variable">ot</span> <span class="operator">=</span> event.clientY - obj.offsetTop;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为document绑定一个鼠标移动事件</span></span><br><span class="line">            document.onmousemove = function (event) &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 解决事件的兼容性问题</span></span><br><span class="line">                event = event || window.event;</span><br><span class="line">                <span class="comment">// 当鼠标移动时被拖拽元素跟随鼠标移动</span></span><br><span class="line">                <span class="comment">// 获取鼠标的坐标</span></span><br><span class="line">                <span class="type">var</span> <span class="variable">left</span> <span class="operator">=</span> event.clientX - ol;</span><br><span class="line">                <span class="type">var</span> <span class="variable">top</span> <span class="operator">=</span> event.clientY - ot;</span><br><span class="line">                <span class="comment">// 修改obj的位置</span></span><br><span class="line">                obj.style.left = left + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">                obj.style.top = top + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为document绑定一个鼠标松开事件</span></span><br><span class="line">            document.onmouseup = function () &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 取消document的onmousemove事件</span></span><br><span class="line">                document.onmousemove = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 取消document的onmouseup事件</span></span><br><span class="line">                document.onmouseup = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 当鼠标松开时，取消对事件的捕获</span></span><br><span class="line">                obj.releaseCapture &amp;&amp; obj.releaseCapture();</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，</span></span><br><span class="line"><span class="comment">             * 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，</span></span><br><span class="line"><span class="comment">             * 如果不希望发生这个行为，则可以通过return false来取消默认行为，</span></span><br><span class="line"><span class="comment">             * 但是这招对IE8不起作用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/1ed4299c0d5122603c08a22f9a09dc99.png" alt="img"></p><h3 id="4-4-6、媒体事件"><a href="#4-4-6、媒体事件" class="headerlink" title="4.4.6、媒体事件"></a>4.4.6、媒体事件</h3><p>通过视频（videos），图像（images）或音频（audio） 触发该事件。</p><h3 id="4-4-7、其它事件"><a href="#4-4-7、其它事件" class="headerlink" title="4.4.7、其它事件"></a>4.4.7、其它事件</h3><h3 id="4-4-8、事件冒泡"><a href="#4-4-8、事件冒泡" class="headerlink" title="4.4.8、事件冒泡"></a>4.4.8、事件冒泡</h3><p>事件的冒泡（Bubble）：所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发，在开发中大部分情况冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡。</p><p><strong>案例演示1：创建两个div，叠放在一起，分别绑定单击事件，点击最里边的div，会触发两个div的单击事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #div1 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #div2 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: coral;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">    我是DIV1</span><br><span class="line">    &lt;div id=<span class="string">&quot;div2&quot;</span>&gt;</span><br><span class="line">        我是DIV2</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">div1</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">div2</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;div2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为div1绑定单击事件</span></span><br><span class="line">    div1.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;div1 的单击事件触发了！&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为div2绑定单击事件</span></span><br><span class="line">    div2.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;div2 的单击事件触发了！&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ba87c18f487c6526af5a8a97a10c68bc.png" alt="img"></p><p><strong>案例演示2：创建两个div，叠放在一起，分别绑定单击事件，点击最里边的div，不会触发两个div的单击事件，只会触发自己的单击事件，这时候我们可以取消事件冒泡</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #div1 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #div2 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: coral;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span>&gt;</span><br><span class="line">    我是DIV1</span><br><span class="line">    &lt;div id=<span class="string">&quot;div2&quot;</span>&gt;</span><br><span class="line">        我是DIV2</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">div1</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line">    <span class="type">var</span> <span class="variable">div2</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;div2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为div1绑定单击事件</span></span><br><span class="line">    div1.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;div1 的单击事件触发了！&quot;</span>);</span><br><span class="line">        stopBubble();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为div2绑定单击事件</span></span><br><span class="line">    div2.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;div2 的单击事件触发了！&quot;</span>);</span><br><span class="line">        stopBubble();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消事件冒泡</span></span><br><span class="line">    function <span class="title function_">stopBubble</span><span class="params">(event)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果提供了事件对象，则这是一个非IE浏览器</span></span><br><span class="line">        <span class="keyword">if</span> (event &amp;&amp; event.stopPropagation) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 因此它支持W3C的stopPropagation()方法</span></span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 否则，我们需要使用IE的方式来取消事件冒泡</span></span><br><span class="line">            window.event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/808bc3dd4059e2806c1d0ff5a9de8ac4.png" alt="img"></p><p><strong>案例演示3：当点击a标签的时候，阻止a标签的默认跳转事件，采用事件阻止</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #div1 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #div2 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: coral;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;https://www.baidu.com&quot;</span> id=<span class="string">&quot;a&quot;</span>&gt;打开百度，你就知道！&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为a绑定单击事件</span></span><br><span class="line">    a.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        stopDefault();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止浏览器的默认行为</span></span><br><span class="line">    function <span class="title function_">stopDefault</span><span class="params">(event)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (event &amp;&amp; event.preventDefault) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 阻止默认浏览器动作(W3C)</span></span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// IE中阻止函数器默认动作的方式</span></span><br><span class="line">            window.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bfb4c4a79727ce4a694cf954081825ea.png" alt="img"></p><h3 id="4-4-9、事件委派"><a href="#4-4-9、事件委派" class="headerlink" title="4.4.9、事件委派"></a>4.4.9、事件委派</h3><p>我们希望只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的，我们可以尝试将其绑定给元素的共同的祖先元素，也就是事件的委派。事件的委派，是指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。事件委派是利用了事件冒泡，通过委派可以减少事件绑定的次数，提高程序的性能。</p><p><strong>案例演示：为ul列表中的所有a标签都绑定单击事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul id=<span class="string">&quot;u1&quot;</span>&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=<span class="string">&quot;javascript:;&quot;</span> class=<span class="string">&quot;link&quot;</span>&gt;超链接一&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=<span class="string">&quot;javascript:;&quot;</span> class=<span class="string">&quot;link&quot;</span>&gt;超链接二&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=<span class="string">&quot;javascript:;&quot;</span> class=<span class="string">&quot;link&quot;</span>&gt;超链接三&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">u1</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;u1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为ul绑定一个单击响应函数</span></span><br><span class="line">    u1.onclick = function (event) &#123;</span><br><span class="line">    </span><br><span class="line">        event = event || window.event;</span><br><span class="line">        <span class="comment">// 如果触发事件的对象是我们期望的元素，则执行，否则不执行</span></span><br><span class="line">        <span class="keyword">if</span> (event.target.className == <span class="string">&quot;link&quot;</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            console.log(<span class="string">&quot;我是ul的单击响应函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c91cf2da0f845694fe0be4e024e376d4.png" alt="img"></p><h3 id="4-4-10、事件绑定"><a href="#4-4-10、事件绑定" class="headerlink" title="4.4.10、事件绑定"></a>4.4.10、事件绑定</h3><p>我们以前绑定事件代码只能一个事件绑定一个函数，那我们要是想一个事件对应多个函数，并且不存在兼容性的问题该如何解决呢？</p><p>接下来，我会直接提供两个已经编写好的事件绑定和事件解绑的兼容性代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为元素绑定事件兼容性代码*/</span></span><br><span class="line">function <span class="title function_">addEventListener</span><span class="params">(element, type, fn)</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(element.addEventListener) &#123;</span><br><span class="line">   </span><br><span class="line">element.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent) &#123;</span><br><span class="line">   </span><br><span class="line">element.attachEvent(<span class="string">&quot;on&quot;</span> + type, fn);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">element[<span class="string">&quot;on&quot;</span> + type] = fn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为元素解绑事件兼容性代码*/</span></span><br><span class="line">function <span class="title function_">removeEventListener</span><span class="params">(element, type, fnName)</span> &#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(element.removeEventListener) &#123;</span><br><span class="line">   </span><br><span class="line">element.removeEventListener(type, fnName, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent) &#123;</span><br><span class="line">   </span><br><span class="line">element.detachEvent(<span class="string">&quot;on&quot;</span> + type, fnName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例演示：为按钮1的单击事件绑定两个函数，然后点击按钮2取消按钮1的单机事件绑定函数f1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn1&quot;</span>&gt;按钮<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn2&quot;</span>&gt;按钮<span class="number">2</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;output1 ...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">        console.log(<span class="string">&quot;output2 ...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为按钮1的单击事件绑定两个函数</span></span><br><span class="line">    addEventListener(document.getElementById(<span class="string">&quot;btn1&quot;</span>), <span class="string">&quot;click&quot;</span>, f1);</span><br><span class="line">    addEventListener(document.getElementById(<span class="string">&quot;btn1&quot;</span>), <span class="string">&quot;click&quot;</span>, f2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点击按钮2取消按钮1的单机事件绑定函数f1</span></span><br><span class="line">    document.getElementById(<span class="string">&quot;btn2&quot;</span>).onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        removeEventListener(document.getElementById(<span class="string">&quot;btn1&quot;</span>), <span class="string">&quot;click&quot;</span>, f1);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*为元素绑定事件兼容性代码*/</span></span><br><span class="line">    function <span class="title function_">addEventListener</span><span class="params">(element, type, fn)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    </span><br><span class="line">            element.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    </span><br><span class="line">            element.attachEvent(<span class="string">&quot;on&quot;</span> + type, fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = fn;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*为元素解绑事件兼容性代码*/</span></span><br><span class="line">    function <span class="title function_">removeEventListener</span><span class="params">(element, type, fnName)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">    </span><br><span class="line">            element.removeEventListener(type, fnName, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">    </span><br><span class="line">            element.detachEvent(<span class="string">&quot;on&quot;</span> + type, fnName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">            element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>谷歌浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/565bee515261af37f290f515562dd05a.png" alt="img"></p><p>火狐浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6bf58432640db9359ac8d4d5ccfb3260.png" alt="img"></p><p>IE8-IE11浏览器：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3165e958579ea6d89a76a30a2aea4eb5.png" alt="img"></p><h3 id="4-4-11、事件传播"><a href="#4-4-11、事件传播" class="headerlink" title="4.4.11、事件传播"></a>4.4.11、事件传播</h3><p>事件的传播：关于事件的传播网景公司和微软公司有不同的理解</p><p>微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。</p><p>网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素。</p><p>W3C综合了两个公司的方案，将事件传播分成了三个阶段：</p><ol><li>捕获阶段：在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 </li><li>目标阶段：事件捕获到目标元素，捕获结束开始在目标元素上触发事件 </li><li>冒泡阶段：事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/606369d19295725d727fd8a04285f3e2.png" alt="img"></p><blockquote><p>注意：如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true，一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false，并且注意，IE8及以下的浏览器中没有捕获阶段，我们可以使用<code>event.stopPropagation();</code>取消事件传播。</p></blockquote><h2 id="5-1、BOM概述"><a href="#5-1、BOM概述" class="headerlink" title="5.1、BOM概述"></a>5.1、BOM概述</h2><p>浏览器对象模型（BOM）使 JavaScript 有能力与浏览器”对话”。</p><p>浏览器对象模型（<strong>B</strong>rowser <strong>O</strong>bject <strong>M</strong>odel (BOM)）尚无正式标准。</p><p>由于现代浏览器已经（几乎）实现了 JavaScript 交互性方面的相同方法和属性，因此常被认为是BOM的方法和属性。</p><p>浏览器对象模型（BOM）可以使我们通过JS来操作浏览器，在BOM中为我们提供了一组对象，用来完成对浏览器的操作，常见的BOM对象如下：</p><ul><li>Window：代表的是整个浏览器的窗口，同时window也是网页中的全局对象 </li><li>Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 </li><li>Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 </li><li>History：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效 </li><li>Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息</li></ul><p>这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用。</p><h2 id="5-2、Window对象"><a href="#5-2、Window对象" class="headerlink" title="5.2、Window对象"></a>5.2、Window对象</h2><h3 id="5-2-1、弹出框"><a href="#5-2-1、弹出框" class="headerlink" title="5.2.1、弹出框"></a>5.2.1、弹出框</h3><p><strong>JavaScript 有三种类型的弹出框：警告框、确认框和提示框。</strong></p><h4 id="5-2-1-1、警告框"><a href="#5-2-1-1、警告框" class="headerlink" title="5.2.1.1、警告框"></a>5.2.1.1、警告框</h4><p>如果要确保信息传递给用户，通常会使用警告框。当警告框弹出时，用户将需要单击“确定”来继续。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.alert(<span class="string">&quot;sometext&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：window.alert() 方法可以不带 window 前缀来写。</p></blockquote><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;我是一个警告框！&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="5-2-1-2、确认框"><a href="#5-2-1-2、确认框" class="headerlink" title="5.2.1.2、确认框"></a>5.2.1.2、确认框</h4><p>如果您希望用户验证或接受某个东西，则通常使用“确认”框。</p><p>当确认框弹出时，用户将不得不单击“确定”或“取消”来继续进行。</p><p>如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.confirm(<span class="string">&quot;sometext&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：window.confirm() 方法可以不带 window 前缀来编写。</p></blockquote><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">r</span> <span class="operator">=</span> confirm(<span class="string">&quot;请按按钮&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">true</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    x = <span class="string">&quot;您按了确认！&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">    x = <span class="string">&quot;您按了取消！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-1-3、提示框"><a href="#5-2-1-3、提示框" class="headerlink" title="5.2.1.3、提示框"></a>5.2.1.3、提示框</h4><p>如果您希望用户在进入页面前输入值，通常会使用提示框。</p><p>当提示框弹出时，用户将不得不输入值后单击“确定”或点击“取消”来继续进行。</p><p>如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。</p><p><strong>语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.prompt(<span class="string">&quot;sometext&quot;</span>,<span class="string">&quot;defaultText&quot;</span>);</span><br></pre></td></tr></table></figure><p>window.prompt() 方法可以不带 window 前缀来编写。</p><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> prompt(<span class="string">&quot;请输入您的姓名&quot;</span>, <span class="string">&quot;比尔盖茨&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2、定时事件"><a href="#5-2-2、定时事件" class="headerlink" title="5.2.2、定时事件"></a>5.2.2、定时事件</h3><p><strong>JavaScript 可以在时间间隔内执行，这就是所谓的定时事件（ Timing Events）。</strong></p><p>window 对象允许以指定的时间间隔执行代码，这些时间间隔称为定时事件。</p><p>通过 JavaScript 使用的有两个关键的方法：</p><ul><li>setTimeout(function, milliseconds) 在等待指定的毫秒数后执行函数。  </li><li>setInterval(function, milliseconds) 等同于 setTimeout()，但持续重复执行该函数。 </li></ul><p>setTimeout() 和 setInterval() 都属于 window 对象的方法。</p><h4 id="5-2-2-1、延时器"><a href="#5-2-2-1、延时器" class="headerlink" title="5.2.2.1、延时器"></a>5.2.2.1、延时器</h4><p><strong>setTimeout() 方法：延时器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.setTimeout(function, milliseconds);</span><br></pre></td></tr></table></figure><blockquote><p>注意：window.setTimeout() 方法可以不带 window 前缀来编写。</p></blockquote><ul><li>第一个参数是要执行的函数。 </li><li>第二个参数指示执行之前的毫秒数。</li></ul><p><strong>案例演示：单击按钮，等待 3 秒，然后控制台会输出 “Hello”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    btn.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 创建延时器</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> setTimeout(function () &#123;</span><br><span class="line">    </span><br><span class="line">            console.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清除延时器</span></span><br><span class="line">        <span class="comment">// clearTimeout(timer);        </span></span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-2、定时器"><a href="#5-2-2-2、定时器" class="headerlink" title="5.2.2.2、定时器"></a>5.2.2.2、定时器</h4><p><strong>setInterval() 方法：定时器</strong></p><p>setInterval() 方法在每个给定的时间间隔重复给定的函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.setInterval(function, milliseconds);</span><br></pre></td></tr></table></figure><blockquote><p>注意：window.setInterval() 方法可以不带 window 前缀来写。</p></blockquote><ul><li>第一个参数是要执行的函数。 </li><li>第二个参数每个执行之间的时间间隔的长度。</li></ul><p><strong>案例演示：单击按钮，每隔一秒向控制台输出 “Hello”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> document.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    btn.onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 创建定时器</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> setInterval(function () &#123;</span><br><span class="line">    </span><br><span class="line">            console.log(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除定时器</span></span><br><span class="line">        <span class="comment">// clearInterval(timer);</span></span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>拓展知识：</strong></p><p>做一个通用移动函数来实现小汽车（黑色方块）移动的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        <span class="comment">/*控制器样式*/</span></span><br><span class="line">        .controller &#123;</span><br><span class="line">    </span><br><span class="line">            width: 600px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            line-height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .controller button &#123;</span><br><span class="line">    </span><br><span class="line">            outline: none;</span><br><span class="line">            border: none;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            padding: 0px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            font-size: 16px;</span><br><span class="line">            line-height: 50px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            background-color: #E9E9E9;</span><br><span class="line">            cursor: pointer;</span><br><span class="line">            <span class="type">float</span>: left;</span><br><span class="line">            -webkit-box-sizing: border-box;</span><br><span class="line">            -moz-box-sizing: border-box;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            border: 2px solid #F0F0F0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .controller button:hover &#123;</span><br><span class="line">    </span><br><span class="line">            background-color: #F9F9F9;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*公路样式*/</span></span><br><span class="line">        .road &#123;</span><br><span class="line">    </span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            height: 100px;</span><br><span class="line">            position: relative;</span><br><span class="line">            margin-top: 50px;</span><br><span class="line">            background: #3DB1FF;</span><br><span class="line">            opacity: <span class="number">.90</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .road800 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 800px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: pink;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0px;</span><br><span class="line">            left: 0px;</span><br><span class="line">            z-index: <span class="number">1000</span>;</span><br><span class="line">            opacity: <span class="number">.75</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .road1200 &#123;</span><br><span class="line">    </span><br><span class="line">            width: 1200px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: orange;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0px;</span><br><span class="line">            left: 0px;</span><br><span class="line">            z-index: <span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*小汽车样式*/</span></span><br><span class="line">        div#car &#123;</span><br><span class="line">    </span><br><span class="line">            width: 135px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            display: block;</span><br><span class="line">            background: black;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0px;</span><br><span class="line">            left: 0px;</span><br><span class="line">            z-index: <span class="number">1500</span>;</span><br><span class="line">            -webkit-box-sizing: border-box;</span><br><span class="line">            -moz-box-sizing: border-box;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            <span class="comment">/*border: 1px solid #F0F0F0;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;controller&quot;</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;btn1&quot;</span>&gt;移动到800PX&lt;/button&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;btn2&quot;</span>&gt;移动到1200PX&lt;/button&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;btn3&quot;</span>&gt;回家&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=<span class="string">&quot;road&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;road800&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;road1200&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;car&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.getElementById(<span class="string">&quot;btn1&quot;</span>).onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        move(document.getElementById(<span class="string">&quot;car&quot;</span>), <span class="number">800</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.getElementById(<span class="string">&quot;btn2&quot;</span>).onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        move(document.getElementById(<span class="string">&quot;car&quot;</span>), <span class="number">1200</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.getElementById(<span class="string">&quot;btn3&quot;</span>).onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">        move(document.getElementById(<span class="string">&quot;car&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*移动函数*/</span></span><br><span class="line">    function <span class="title function_">move</span><span class="params">(element, target)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 先清理定时器</span></span><br><span class="line">        clearInterval(element.timeId);</span><br><span class="line">        <span class="comment">// 一会要清理定时器(只产生一个定时器)</span></span><br><span class="line">        element.timeId = setInterval(function () &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 获取对象当前的位置</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">current</span> <span class="operator">=</span> element.offsetLeft;</span><br><span class="line">            <span class="comment">// 每次移动多少像素</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 判断是往正方向走还是往相反方向走</span></span><br><span class="line">            step = current &lt; target ? step : -step;</span><br><span class="line">            <span class="comment">// 每次移动后的距离</span></span><br><span class="line">            current += step;</span><br><span class="line">            <span class="comment">// 判断当前移动后的位置是否到达目标位置</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target - current) &gt; Math.abs(step)) &#123;</span><br><span class="line">    </span><br><span class="line">                element.style.left = current + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 清理定时器</span></span><br><span class="line">                clearInterval(element.timeId);</span><br><span class="line">                element.style.left = target + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ca0829497172a492ca72738eaea27612.png" alt="img"></p><h3 id="5-2-3、常用窗口属性"><a href="#5-2-3、常用窗口属性" class="headerlink" title="5.2.3、常用窗口属性"></a>5.2.3、常用窗口属性</h3><p>两个属性可用用于确定浏览器窗口的尺寸。</p><p>这两个属性都以像素返回尺寸：</p><ul><li>window.innerHeight - 浏览器窗口的内高度（以像素计） </li><li>window.innerWidth - 浏览器窗口的内宽度（以像素计）</li></ul><p>浏览器窗口（浏览器视口）不包括工具栏和滚动条。</p><p>对于 Internet Explorer 8, 7, 6, 5：</p><ul><li>document.documentElement.clientHeight </li><li>document.documentElement.clientWidth</li></ul><p>或</p><ul><li>document.body.clientHeight </li><li>document.body.clientWidth</li></ul><p>一个实用的 JavaScript 解决方案（包括所有浏览器）：该例显示浏览器窗口的高度和宽度（不包括工具栏和滚动条）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="type">var</span> <span class="variable">w</span> <span class="operator">=</span> window.innerWidth</span><br><span class="line">        || document.documentElement.clientWidth</span><br><span class="line">        || document.body.clientWidth;</span><br><span class="line"></span><br><span class="line">    <span class="type">var</span> <span class="variable">h</span> <span class="operator">=</span> window.innerHeight</span><br><span class="line">        || document.documentElement.clientHeight</span><br><span class="line">        || document.body.clientHeight;</span><br><span class="line"></span><br><span class="line">    console.log(w);</span><br><span class="line">    console.log(h);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="5-2-4、其它窗口方法"><a href="#5-2-4、其它窗口方法" class="headerlink" title="5.2.4、其它窗口方法"></a>5.2.4、其它窗口方法</h3><ul><li>window.open() ：打开新的窗口 语法介绍： window.open(URL,name,specs,replace); 参数介绍：  案例演示： <pre><code class="prism language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta&lt;/span&gt; <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>UTF-8<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>openWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;打开窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;</li></ul><p><span class="token comment">&lt;!— 在这里写JavaScript代码，因为JavaScript是由上到下执行的 —&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token script language-javascript"><br>    <span class="token keyword">function</span> <span class="token function">openWin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><pre><code> &lt;!-- --&gt;&lt;/span&gt;    myWindow &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;width=200,height=100&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;p&amp;gt;这是新建窗口&amp;lt;/p&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;</code></pre><p>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br>&lt;/code&gt;&lt;/pre&gt;  </p><ul><li>window.close() ：关闭当前窗口 语法介绍： window.close(); 案例演示： <pre><code class="prism language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta&lt;/span&gt; <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>UTF-8<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>openWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;打开窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>closeWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;关闭窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;</li></ul><p><span class="token comment">&lt;!— 在这里写JavaScript代码，因为JavaScript是由上到下执行的 —&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token script language-javascript"><br>    <span class="token keyword">function</span> <span class="token function">openWin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><pre><code> &lt;!-- --&gt;&lt;/span&gt;    myWindow &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;width=200,height=100&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;p&amp;gt;这是新建窗口&amp;lt;/p&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;closeWin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123; &lt;!-- --&gt;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;</code></pre><p>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br>&lt;/code&gt;&lt;/pre&gt;  </p><ul><li>window.moveTo() ：移动当前窗口 语法介绍： window.moveTo(x,y); 案例演示： <pre><code class="prism language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta&lt;/span&gt; <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>UTF-8<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>openWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;打开窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>moveWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;移动窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;</li></ul><p><span class="token comment">&lt;!— 在这里写JavaScript代码，因为JavaScript是由上到下执行的 —&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token script language-javascript"><br>    <span class="token keyword">function</span> <span class="token function">openWin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><pre><code> &lt;!-- --&gt;&lt;/span&gt;    myWindow &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;width=200,height=100&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;p&amp;gt;这是新建窗口&amp;lt;/p&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;moveWin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123; &lt;!-- --&gt;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;moveTo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;focus&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;</code></pre><p>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br>&lt;/code&gt;&lt;/pre&gt;  </p><ul><li>window.resizeTo() ：调整当前窗口 语法介绍： window.resizeTo(width,height); 案例演示： <pre><code class="prism language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta&lt;/span&gt; <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>UTF-8<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>openWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;打开窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button&lt;/span&gt; <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class=“token punctuation">"</span>resizeWin()<span class=“token punctuation">"</span>&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;调整窗口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;</li></ul><p><span class="token comment">&lt;!— 在这里写JavaScript代码，因为JavaScript是由上到下执行的 —&gt;</span><br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<span class="token script language-javascript"><br>    <span class="token keyword">function</span> <span class="token function">openWin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</p><pre><code> &lt;!-- --&gt;&lt;/span&gt;    myWindow &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; window&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;width=200,height=100&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;p&amp;gt;这是新建窗口&amp;lt;/p&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;resizeWin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123; &lt;!-- --&gt;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resizeTo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;    myWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;focus&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;</code></pre><p>&lt;/span&gt;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html&lt;/span&gt;<span class="token punctuation">&gt;</span>&lt;/span&gt;<br>&lt;/code&gt;&lt;/pre&gt; </p><h2 id="5-3、Navigator对象"><a href="#5-3、Navigator对象" class="headerlink" title="5.3、Navigator对象"></a>5.3、Navigator对象</h2><p>Navigator代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器，由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用userAgent来判断浏览器的信息，userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">ua</span> <span class="operator">=</span> navigator.userAgent;</span><br><span class="line">console.log(ua);</span><br></pre></td></tr></table></figure><p>谷歌浏览器：</p><ul><li>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36</li></ul><p>火狐浏览器：</p><ul><li>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0</li></ul><p>IE11浏览器：</p><ul><li>Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</li></ul><p>IE10浏览器：</p><ul><li>Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</li></ul><p>IE9浏览器：</p><ul><li>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</li></ul><p>IE8浏览器：</p><ul><li>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</li></ul><p>IE7浏览器：</p><ul><li>Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</li></ul><p>于是乎，我们就可以实现对浏览器类型的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">ua</span> <span class="operator">=</span> navigator.userAgent;</span><br><span class="line"><span class="keyword">if</span> (/firefox/i.test(ua)) &#123;</span><br><span class="line">   </span><br><span class="line">    alert(<span class="string">&quot;你是火狐浏览器&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (/chrome/i.test(ua)) &#123;</span><br><span class="line">   </span><br><span class="line">    alert(<span class="string">&quot;你是谷歌浏览器&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (/msie/i.test(ua)) &#123;</span><br><span class="line">   </span><br><span class="line">    alert(<span class="string">&quot;你是IE5-IE10浏览器&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;ActiveXObject&quot;</span> in window) &#123;</span><br><span class="line">   </span><br><span class="line">    alert(<span class="string">&quot;你是IE11浏览器&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了，如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息，比如：ActiveXObject</p></blockquote><h2 id="5-4、Location对象"><a href="#5-4、Location对象" class="headerlink" title="5.4、Location对象"></a>5.4、Location对象</h2><p>Location对象中封装了浏览器的地址栏的信息，如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）</p><h3 id="5-4-1、常用属性"><a href="#5-4-1、常用属性" class="headerlink" title="5.4.1、常用属性"></a>5.4.1、常用属性</h3><p>常用属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(location);          <span class="comment">//输出location对象</span></span><br><span class="line">console.log(location.href);     <span class="comment">//输出当前地址的全路径地址</span></span><br><span class="line">console.log(location.origin);   <span class="comment">//输出当前地址的来源</span></span><br><span class="line">console.log(location.protocol); <span class="comment">//输出当前地址的协议</span></span><br><span class="line">console.log(location.hostname); <span class="comment">//输出当前地址的主机名</span></span><br><span class="line">console.log(location.host);     <span class="comment">//输出当前地址的主机</span></span><br><span class="line">console.log(location.port);     <span class="comment">//输出当前地址的端口号</span></span><br><span class="line">console.log(location.pathname); <span class="comment">//输出当前地址的路径部分</span></span><br><span class="line">console.log(location.search);   <span class="comment">//输出当前地址的?后边的参数部分</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8d92b74a6a79761ba5256a6e533464fb.png" alt="img"></p><p>修改地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="5-4-2、常用方法"><a href="#5-4-2、常用方法" class="headerlink" title="5.4.2、常用方法"></a>5.4.2、常用方法</h3><p>assign()：用来跳转到其它的页面，作用和直接修改location一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.assign(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>reload()：用于重新加载当前页面，作用和刷新按钮一样，如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.reload(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>replace()：可以使用一个新的页面替换当前页面，调用完毕也会跳转页面，它不会生成历史记录，不能使用回退按钮回退</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.replace(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="5-5、History对象"><a href="#5-5、History对象" class="headerlink" title="5.5、History对象"></a>5.5、History对象</h2><p>History对象可以用来操作浏览器向前或向后翻页</p><h3 id="5-5-1、常用属性"><a href="#5-5-1、常用属性" class="headerlink" title="5.5.1、常用属性"></a>5.5.1、常用属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(history);           <span class="comment">//输出history对象</span></span><br><span class="line">console.log(history.length);    <span class="comment">//可以获取到当成访问的链接数量</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3075d1de3bdaf4848f9da17f494d8d8e.png" alt="img"></p><h3 id="5-5-2、常用方法"><a href="#5-5-2、常用方法" class="headerlink" title="5.5.2、常用方法"></a>5.5.2、常用方法</h3><p>back()：可以回退到上一个页面，作用和浏览器的回退按钮一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.back();</span><br></pre></td></tr></table></figure><p>forward()：可以跳转到下一个页面，作用和浏览器的前进按钮一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.forward();</span><br></pre></td></tr></table></figure><p>go()：可以用来跳转到指定的页面，它需要一个整数作为参数</p><ul><li>1：表示向前跳转一个页面，相当于forward() </li><li>2：表示向前跳转两个页面 </li><li>-1：表示向后跳转一个页面，相当于back() </li><li>-2：表示向后跳转两个页面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(-<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="5-6、Screen对象"><a href="#5-6、Screen对象" class="headerlink" title="5.6、Screen对象"></a>5.6、Screen对象</h2><p>Screen 对象包含有关客户端显示屏幕的信息。</p><blockquote><p>注意：没有应用于 screen 对象的公开标准，不过所有浏览器都支持该对象。</p></blockquote><h3 id="5-6-1、Screen对象描述"><a href="#5-6-1、Screen对象描述" class="headerlink" title="5.6.1、Screen对象描述"></a>5.6.1、Screen对象描述</h3><p>每个 Window 对象的 screen 属性都引用一个 Screen 对象。Screen 对象中存放着有关显示浏览器屏幕的信息。JavaScript 程序将利用这些信息来优化它们的输出，以达到用户的显示要求。例如，一个程序可以根据显示器的尺寸选择使用大图像还是使用小图像，它还可以根据显示器的颜色深度选择使用 16 位色还是使用 8 位色的图形。另外，JavaScript 程序还能根据有关屏幕尺寸的信息将新的浏览器窗口定位在屏幕中间。</p><h3 id="5-6-2、Screen对象属性"><a href="#5-6-2、Screen对象属性" class="headerlink" title="5.6.2、Screen对象属性"></a>5.6.2、Screen对象属性</h3><h2 id="6-1、Exception"><a href="#6-1、Exception" class="headerlink" title="6.1、Exception"></a>6.1、Exception</h2><h3 id="6-1-1、异常概述"><a href="#6-1-1、异常概述" class="headerlink" title="6.1.1、异常概述"></a>6.1.1、异常概述</h3><p>在ES3之前JavaScript代码执行的过程中，一旦出现错误，整个JavaScript代码都会停止执行，这样就显的代码非常的不健壮。</p><p>在Java或C#等一些高级语言中，都提供了异常处理机制，可以处理出现的异常，而不会停止整个应用程序。</p><p>从ES3开始，JavaScript也提供了类似的异常处理机制，从而让JavaScript代码变的更健壮，即使执行的过程中出现了异常，也可以让程序具有了一部分的异常恢复能力。</p><p>当错误发生时，JavaScript 提供了错误信息的内置 error 对象。</p><p>error 对象提供两个有用的属性：name 和 message 。</p><p><strong>Error 对象属性</strong></p><p><strong>Error Name Values</strong></p><p>error 的 name 属性可返回六个不同的值：</p><h3 id="6-1-2、异常捕捉"><a href="#6-1-2、异常捕捉" class="headerlink" title="6.1.2、异常捕捉"></a>6.1.2、异常捕捉</h3><p>ES3开始引入了 try-catch 语句，是 JavaScript 中处理异常的标准方式。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 可能发生异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 发生错误执行的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 无论是否出错都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 try…catch 中，try 中一旦出现错误则其它语句不能执行，如果不出现错误则 catch 中的语句不会执行。</p><p>Javascript 参考其它编程语言，也提供了一种 finally 语句：不管 try 中的语句有没有错误，在最后都会执行 finally 中的语句。也就是说，try 中语句不发生错误执行完毕后会执行 finally 中的语句，try 中的语句发生错误，则执行 catch中的语句，catch 中的语句执行完毕后也会执行 finally 中的语句。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(<span class="string">&quot;a未定义肯定报错，你看不见我&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 发生错误执行的代码</span></span><br><span class="line">    console.log(error);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 无论是否出错都会执行的代码</span></span><br><span class="line">    console.log(<span class="string">&quot;finally 执行了 ...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6d678270bcee5c15d0e826cb9c4adb5d.png" alt="img"></p><p>在JavaScript中，如果添加了 finally 语句，则 catch 语句可以省略。但是如果没有 catch 语句，则一旦发生错误就无法捕获这个错误，所以在执行完 finally 中的语句后，程序就会立即停止了。所以，在实际使用中，最好一直带着 catch 语句。如果你写了 catch 语句，则finally 语句也是可以省略的。</p><h3 id="6-1-3、异常演示"><a href="#6-1-3、异常演示" class="headerlink" title="6.1.3、异常演示"></a>6.1.3、异常演示</h3><h4 id="6-1-3-1、Eval-错误"><a href="#6-1-3-1、Eval-错误" class="headerlink" title="6.1.3.1、Eval 错误"></a>6.1.3.1、Eval 错误</h4><p>EvalError 指示 eval() 函数中的错误。更新版本的 JavaScript 不会抛出任何 EvalError，请使用 SyntaxError 代替。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    eval(<span class="string">&quot;alert(&#x27;Hello)&quot;</span>);   <span class="comment">// 缺少 &#x27; 会产生错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3c0561b704e79191f5e4ceda413e1d73.png" alt="img"></p><h4 id="6-1-3-2、范围错误"><a href="#6-1-3-2、范围错误" class="headerlink" title="6.1.3.2、范围错误"></a>6.1.3.2、范围错误</h4><p>RangeError 会在您使用了合法值的范围之外的数字时抛出。</p><p>案例演示：您不能将数字的有效位数设置为 500。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    num.toPrecision(<span class="number">500</span>);   <span class="comment">// 数无法拥有 500 个有效数</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/adaaaf76a0a8ef4a9d70b8bbb5109297.png" alt="img"></p><h4 id="6-1-3-3、引用错误"><a href="#6-1-3-3、引用错误" class="headerlink" title="6.1.3.3、引用错误"></a>6.1.3.3、引用错误</h4><p>假如您使用（引用）了尚未声明的变量，则 ReferenceError 会被抛出：</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    x = y + <span class="number">1</span>;   <span class="comment">// y 无法被引用（使用）</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3a0ccee2ef764c308a9279d68a32fc16.png" alt="img"></p><h4 id="6-1-3-4、语法错误"><a href="#6-1-3-4、语法错误" class="headerlink" title="6.1.3.4、语法错误"></a>6.1.3.4、语法错误</h4><p>假如您计算带语法错误的代码，会 SyntaxError 被抛出：</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    eval(<span class="string">&quot;alert(&#x27;Hello)&quot;</span>);   <span class="comment">// 缺少 &#x27; 会产生错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3c0561b704e79191f5e4ceda413e1d73.png" alt="img"></p><h4 id="6-1-3-5、类型错误"><a href="#6-1-3-5、类型错误" class="headerlink" title="6.1.3.5、类型错误"></a>6.1.3.5、类型错误</h4><p>假如您使用的值不在期望值的范围之内，则 TypeError 被抛出：</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    num.toUpperCase();   <span class="comment">// 您无法将数字转换为大写</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f9f32b39e9d5fe8c4c8abe4a5baa2d20.png" alt="img"></p><h4 id="6-1-3-6、URI-错误"><a href="#6-1-3-6、URI-错误" class="headerlink" title="6.1.3.6、URI 错误"></a>6.1.3.6、URI 错误</h4><p>假如您在 URI 函数中使用非法字符，则 URIError 被抛出：</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    decodeURI(<span class="string">&quot;%%%&quot;</span>);   <span class="comment">// 您无法对这些百分号进行 URI 编码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d20e2e247438b6abbcb0ebb86a85d1da.png" alt="img"></p><h3 id="6-1-4、异常抛出"><a href="#6-1-4、异常抛出" class="headerlink" title="6.1.4、异常抛出"></a>6.1.4、异常抛出</h3><p>在大部分的代码执行过程中，都是出现错误的时候，由浏览器(javascript引擎)抛出异常，然后程序或者停止执行或被try…catch 捕获。</p><p>然而有时候我们在检测到一些不合理的情况发生的时候也可以主动抛出错误，请使用 throw 关键字抛出来主动抛出异常。</p><p>注意事项：</p><ol><li>thow后面就是我们要抛出的异常对象，在以前的时候都是出现错误的时候浏览器抛出异常对象，只是现在是我们自己主动抛出的异常对象。 </li><li>只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。 </li><li>每一个错误类型都可以传入一个参数，表示实际的错误信息。 </li><li>我们可以在适当的时候抛出任何我们想抛出的异常类型。throw new SyntaxError(“语法错误…”);</li></ol><h4 id="6-1-4-1、主动抛出内置异常"><a href="#6-1-4-1、主动抛出内置异常" class="headerlink" title="6.1.4.1、主动抛出内置异常"></a>6.1.4.1、主动抛出内置异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*该函数接收一个数字，返回它的平方。*/</span></span><br><span class="line">function <span class="title function_">foo</span><span class="params">(num)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (typeof num == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;您输入的是一个非法数字！&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo(<span class="number">4</span>));</span><br><span class="line">console.log(foo(<span class="string">&quot;abc&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e007286652aaaa25c0a3cfc3cdf4bdaa.png" alt="img"></p><h4 id="6-1-4-2、主动抛出自定义异常"><a href="#6-1-4-2、主动抛出自定义异常" class="headerlink" title="6.1.4.2、主动抛出自定义异常"></a>6.1.4.2、主动抛出自定义异常</h4><p>我们不仅仅可以抛出js内置的错误类型的对象，也可以自定义错误类型，然后抛出自定义错误类型的对象。</p><p>如果要自定义错误类型，只需要继承任何一个自定义错误类型都可以，一般直接继承Error即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*自定义错误*/</span></span><br><span class="line">function <span class="title function_">MyError</span><span class="params">(message)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">this</span>.message = <span class="string">&quot;注意：这是自定义的错误&quot;</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;自定义错误&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyError.prototype = <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyError</span>(<span class="string">&quot;注意：这是自定义错误类型&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8c8dd5b1b84a1446075ad73a3f9e8414.png" alt="img"></p><h2 id="6-2、JSON"><a href="#6-2、JSON" class="headerlink" title="6.2、JSON"></a>6.2、JSON</h2><h3 id="6-2-1、JSON概述"><a href="#6-2-1、JSON概述" class="headerlink" title="6.2.1、JSON概述"></a>6.2.1、JSON概述</h3><p>JSON：JavaScript Object Notation（JavaScript 对象标记法），它是一种存储和交换数据的语法。</p><p>当数据在浏览器与服务器之间进行交换时，这些数据只能是文本，JSON 属于文本并且我们能够把任何 JavaScript 对象转换为 JSON，然后将 JSON 发送到服务器。我们也能把从服务器接收到的任何 JSON 转换为 JavaScript 对象。以这样的方式，我们能够把数据作为 JavaScript 对象来处理，无需复杂的解析和转译。</p><h3 id="6-2-2、JSON语法"><a href="#6-2-2、JSON语法" class="headerlink" title="6.2.2、JSON语法"></a>6.2.2、JSON语法</h3><p>在json中，每一个数据项，都是由一个键值对（或者说是名值对）组成的，但是键必须是字符串，且由双引号包围，而值必须是以下数据类型之一：</p><ul><li>字符串（在 JSON 中，字符串值必须由双引号编写） </li><li>数字 </li><li>对象（JSON 对象） </li><li>数组 </li><li>布尔 </li><li>null</li></ul><p>JSON 的值不可以是以下数据类型之一：</p><ul><li>函数 </li><li>日期 </li><li>undefined</li></ul><p>因为 JSON 语法由 JavaScript 对象标记法衍生而来，所以很少需要其它额外的软件来处理 JavaScript 中的 JSON。</p><p>通过 JavaScript，您能够创建对象并向其分配数据，就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">62</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;BeiJing&quot;</span>&#125;;</span><br><span class="line">console.log(person);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d3060f7c44592e4b2e269ec2f290155a.png" alt="img"></p><h3 id="6-2-3、JSON数据类型"><a href="#6-2-3、JSON数据类型" class="headerlink" title="6.2.3、JSON数据类型"></a>6.2.3、JSON数据类型</h3><h4 id="6-2-3-1、JSON-字符串"><a href="#6-2-3-1、JSON-字符串" class="headerlink" title="6.2.3.1、JSON 字符串"></a>6.2.3.1、JSON 字符串</h4><p>JSON 中的字符串必须用双引号包围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-3-2、JSON-数字"><a href="#6-2-3-2、JSON-数字" class="headerlink" title="6.2.3.2、JSON 数字"></a>6.2.3.2、JSON 数字</h4><p>JSON 中的数字必须是整数或浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-3-3、JSON-对象"><a href="#6-2-3-3、JSON-对象" class="headerlink" title="6.2.3.3、JSON 对象"></a>6.2.3.3、JSON 对象</h4><p>JSON 中的值可以是对象，JSON 中作为值的对象必须遵守与 JSON 对象相同的规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="string">&quot;employee&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bill Gates&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">62</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;Seattle&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-3-4、JSON-数组"><a href="#6-2-3-4、JSON-数组" class="headerlink" title="6.2.3.4、JSON 数组"></a>6.2.3.4、JSON 数组</h4><p>JSON 中的值可以是数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="string">&quot;employees&quot;</span>: [<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;David&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-3-5、JSON-布尔"><a href="#6-2-3-5、JSON-布尔" class="headerlink" title="6.2.3.5、JSON 布尔"></a>6.2.3.5、JSON 布尔</h4><p>JSON 中的值可以是 true/false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;sale&quot;</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-3-6、JSON-null"><a href="#6-2-3-6、JSON-null" class="headerlink" title="6.2.3.6、JSON null"></a>6.2.3.6、JSON null</h4><p>JSON 中的值可以是 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;middlename&quot;</span>: <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-4、JSON字符串转JS对象"><a href="#6-2-4、JSON字符串转JS对象" class="headerlink" title="6.2.4、JSON字符串转JS对象"></a>6.2.4、JSON字符串转JS对象</h3><p>JSON.parse()：可以将以JSON字符串转换为JS对象，它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">jsonStr</span> <span class="operator">=</span> <span class="string">&#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parse(jsonStr);</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/75043196321febfa7ff2044a01c36251.png" alt="img"></p><blockquote><p>注意 ：JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</p></blockquote><h3 id="6-2-5、JS对象转JSON字符串"><a href="#6-2-5、JS对象转JSON字符串" class="headerlink" title="6.2.5、JS对象转JSON字符串"></a>6.2.5、JS对象转JSON字符串</h3><p>JSON.stringify()：可以将一个JS对象转换为JSON字符串，需要一个js对象作为参数，会返回一个JSON字符串</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">obj</span> <span class="operator">=</span> &#123;</span><br><span class="line">   name: <span class="string">&quot;猪八戒&quot;</span>, age: <span class="number">28</span>, gender: <span class="string">&quot;男&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSON.stringify(obj);</span><br><span class="line">console.log(jsonStr);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f7dc872335de8f09109ea0c9b9f798b4.png" alt="img"></p><blockquote><p>注意 ：JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错</p></blockquote><h2 id="6-3、AJAX"><a href="#6-3、AJAX" class="headerlink" title="6.3、AJAX"></a>6.3、AJAX</h2><h3 id="6-3-1、AJAX概述"><a href="#6-3-1、AJAX概述" class="headerlink" title="6.3.1、AJAX概述"></a>6.3.1、AJAX概述</h3><p>传统的web交互是用户触发一个http请求服务器，然后服务器收到之后，在做出响应到用户，并且返回一个新的页面，每当服务器处理客户端提交的请求时，客户都只能空闲等待，并且哪怕只是一次很小的交互、只需从服务器端得到很简单的一个数据，都要返回一个完整的HTML页，而用户每次都要浪费时间和带宽去重新读取整个页面。这个做法浪费了许多带宽，由于每次应用的交互都需要向服务器发送请求，应用的响应时间就依赖于服务器的响应时间，这导致了用户界面的响应比本地应用慢得多。</p><p>AJAX 的出现,刚好解决了传统方法的缺陷，AJAX 是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新，这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><h3 id="6-3-2、AJAX的XMLHttpRequest对象"><a href="#6-3-2、AJAX的XMLHttpRequest对象" class="headerlink" title="6.3.2、AJAX的XMLHttpRequest对象"></a>6.3.2、AJAX的XMLHttpRequest对象</h3><p><strong>AJAX 的核心是 XMLHttpRequest 对象。</strong> 所有现代浏览器都支持 XMLHttpRequest 对象。</p><p>XMLHttpRequest 对象用于幕后同服务器交换数据，这意味着可以更新网页的部分，而不需要重新加载整个页面。</p><p>所有现代浏览器（Chrom、IE7+、Firefox、Safari 以及 Opera）都有内建的 XMLHttpRequest 对象。</p><p>创建 XMLHttpRequest 的语法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure><p>老版本的 Internet Explorer（IE5 和 IE6）使用 ActiveX 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br></pre></td></tr></table></figure><p>为了应对所有浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，创建 XMLHttpRequest 对象，如果不支持，则创建 ActiveX 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhttp;</span><br><span class="line"><span class="keyword">if</span> (window.XMLHttpRequest) &#123;</span><br><span class="line">   </span><br><span class="line">    xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// code for IE6, IE5</span></span><br><span class="line">    xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，出于安全原因，现代浏览器不允许跨域访问，这意味着尝试加载的网页和 XML 文件都必须位于相同服务器上。</p><h3 id="6-3-3、AJAX的XMLHttpRequest对象方法"><a href="#6-3-3、AJAX的XMLHttpRequest对象方法" class="headerlink" title="6.3.3、AJAX的XMLHttpRequest对象方法"></a>6.3.3、AJAX的XMLHttpRequest对象方法</h3><h3 id="6-3-4、AJAX的XMLHttpRequest对象属性"><a href="#6-3-4、AJAX的XMLHttpRequest对象属性" class="headerlink" title="6.3.4、AJAX的XMLHttpRequest对象属性"></a>6.3.4、AJAX的XMLHttpRequest对象属性</h3><h3 id="6-3-5、AJAX的GET请求"><a href="#6-3-5、AJAX的GET请求" class="headerlink" title="6.3.5、AJAX的GET请求"></a>6.3.5、AJAX的GET请求</h3><p>工程结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/369e3788b030c8f9aede3b3109f53da5.png" alt="img"></p><p>users.json</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;猪八戒&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;唐僧&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;沙和尚&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤一：创建异步对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">ajax</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">//步骤二：设置请求的url参数，参数一是请求的类型，参数二是请求的url</span></span><br><span class="line">ajax.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;users.json&quot;</span>);</span><br><span class="line"><span class="comment">//步骤三：发送请求</span></span><br><span class="line">ajax.send();</span><br><span class="line"><span class="comment">//步骤四：注册事件 onreadystatechange 状态改变就会调用</span></span><br><span class="line">ajax.onreadystatechange = function () &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (ajax.readyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//步骤五：如果能够进到这个判断，说明数据完美的回来了，并且请求的页面是存在的</span></span><br><span class="line">        console.log(ajax.responseText);<span class="comment">//输入响应的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>控制台：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d2fdee85bfbd29ccc214af02a2d17e62.png" alt="img"></p><h3 id="6-3-6、AJAX的POST请求"><a href="#6-3-6、AJAX的POST请求" class="headerlink" title="6.3.6、AJAX的POST请求"></a>6.3.6、AJAX的POST请求</h3><p>工程结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/369e3788b030c8f9aede3b3109f53da5.png" alt="img"></p><p>users.json</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;猪八戒&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;唐僧&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;沙和尚&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤一：创建异步对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">ajax</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">//步骤二：设置请求的类型及url，注意：post请求一定要添加请求头才行不然会报错</span></span><br><span class="line">ajax.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;users.json&quot;</span>);</span><br><span class="line">ajax.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"><span class="comment">//步骤三：发送请求</span></span><br><span class="line">ajax.send();</span><br><span class="line"><span class="comment">//步骤四：注册事件 onreadystatechange 状态改变就会调用</span></span><br><span class="line">ajax.onreadystatechange = function () &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//步骤五：如果能够进到这个判断，说明数据完美的回来了，并且请求的页面是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (ajax.readyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>) &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(ajax.responseText);<span class="comment">//输入响应的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>控制台：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d2fdee85bfbd29ccc214af02a2d17e62.png" alt="img"></p><h3 id="6-3-7、AJAX的请求整合"><a href="#6-3-7、AJAX的请求整合" class="headerlink" title="6.3.7、AJAX的请求整合"></a>6.3.7、AJAX的请求整合</h3><p>工程结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/369e3788b030c8f9aede3b3109f53da5.png" alt="img"></p><p>users.json</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;猪八戒&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">19</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;唐僧&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>:<span class="string">&quot;沙和尚&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">Ajax</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    get: function (url, fn) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">var</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">   </span><br><span class="line">                fn.call(<span class="built_in">this</span>, xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;,</span><br><span class="line">    post: function (url, data, fn) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">var</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.open(<span class="string">&quot;POST&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; (xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">                fn.call(<span class="built_in">this</span>, xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示GET请求</span></span><br><span class="line">Ajax.get(<span class="string">&quot;users.json&quot;</span>, function (response) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示POST请求</span></span><br><span class="line">Ajax.post(<span class="string">&quot;users.json&quot;</span>, <span class="string">&quot;&quot;</span>, function (response) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a785d39e7cd471f4a580cf2667357a8e.png" alt="img"></p><h2 id="6-4、Cookie"><a href="#6-4、Cookie" class="headerlink" title="6.4、Cookie"></a>6.4、Cookie</h2><h3 id="6-4-1、Cookie概述"><a href="#6-4-1、Cookie概述" class="headerlink" title="6.4.1、Cookie概述"></a>6.4.1、Cookie概述</h3><p>Cookie 是一些数据，存储于你电脑上的文本文件中，当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息，Cookie 的作用就是用于解决 “如何记录客户端的用户信息”：</p><ul><li>当用户访问 web 页面时，它的名字可以记录在 cookie 中。 </li><li>在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。</li></ul><p>Cookie 以名/值对形式存储，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=zhangsan</span><br></pre></td></tr></table></figure><p>当浏览器从服务器上请求 web 页面时， 属于该页面的 cookie 会被添加到该请求中，服务端通过这种方式来获取用户的信息。</p><p>JavaScript 可以使用 <strong>document.cookie</strong> 属性来创建 、读取、及删除 Cookie。</p><h3 id="6-4-2、Cookie创建"><a href="#6-4-2、Cookie创建" class="headerlink" title="6.4.2、Cookie创建"></a>6.4.2、Cookie创建</h3><p>JavaScript 中，创建 cookie 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">&quot;username=zhangsan&quot;</span>;</span><br></pre></td></tr></table></figure><p>您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">&quot;username=zhangsan; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;</span>;</span><br></pre></td></tr></table></figure><p>您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">&quot;username=zhangsan; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="6-4-3、Cookie读取"><a href="#6-4-3、Cookie读取" class="headerlink" title="6.4.3、Cookie读取"></a>6.4.3、Cookie读取</h3><p>JavaScript 中，读取 cookie 如下所示：</p><p>document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1=value; cookie2=value; cookie3=value;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">&quot;username=zhangsan&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">cookies</span> <span class="operator">=</span> document.cookie;</span><br><span class="line">console.log(cookies);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7f5f050ac3395ad2d8e04a83f52b9f17.png" alt="img"></p><h3 id="6-4-4、Cookie修改"><a href="#6-4-4、Cookie修改" class="headerlink" title="6.4.4、Cookie修改"></a>6.4.4、Cookie修改</h3><p>JavaScript 中，修改 cookie 如下所示：</p><p>使用 document.cookie 将旧的 cookie 将被覆盖就是修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">&quot;username=zhangsan&quot;</span>;</span><br><span class="line">document.cookie = <span class="string">&quot;username=lisi&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">cookies</span> <span class="operator">=</span> document.cookie;</span><br><span class="line">console.log(cookies);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/fe094b63b05824c69ed5147e180b298b.png" alt="img"></p><h3 id="6-4-5、Cookie删除"><a href="#6-4-5、Cookie删除" class="headerlink" title="6.4.5、Cookie删除"></a>6.4.5、Cookie删除</h3><p>JavaScript 中，删除 cookie 如下所示：</p><p>删除 cookie 非常简单，您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = <span class="string">&quot;username=zhangsan&quot;</span>;</span><br><span class="line">document.cookie = <span class="string">&quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>;</span><br><span class="line"><span class="type">var</span> <span class="variable">cookies</span> <span class="operator">=</span> document.cookie;</span><br><span class="line">console.log(cookies);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ed1e94b6c81dc809c2dd0a8436ed2c6f.png" alt="img"></p><h3 id="6-4-6、Cookie值设置函数"><a href="#6-4-6、Cookie值设置函数" class="headerlink" title="6.4.6、Cookie值设置函数"></a>6.4.6、Cookie值设置函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cookie值设置函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cname     cookie名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cvalue    cookie值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exdays    过期天数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">function <span class="title function_">setCookie</span><span class="params">(cname, cvalue, exdays)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    d.setTime(d.getTime() + (exdays * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="type">var</span> <span class="variable">expires</span> <span class="operator">=</span> <span class="string">&quot;expires=&quot;</span> + d.toGMTString();</span><br><span class="line">    document.cookie = cname + <span class="string">&quot;=&quot;</span> + cvalue + <span class="string">&quot;; &quot;</span> + expires;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-7、Cookie值获取函数"><a href="#6-4-7、Cookie值获取函数" class="headerlink" title="6.4.7、Cookie值获取函数"></a>6.4.7、Cookie值获取函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cookie值获取函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cname     cookie名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">function <span class="title function_">getCookie</span><span class="params">(cname)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> cname + <span class="string">&quot;=&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">ca</span> <span class="operator">=</span> document.cookie.split(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ca.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> ca[i].trim();</span><br><span class="line">        <span class="keyword">if</span> (c.indexOf(name) == <span class="number">0</span>) <span class="keyword">return</span> c.substring(name.length, c.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5、WebStorage"><a href="#6-5、WebStorage" class="headerlink" title="6.5、WebStorage"></a>6.5、WebStorage</h2><h3 id="6-5-1、WebStorage概述"><a href="#6-5-1、WebStorage概述" class="headerlink" title="6.5.1、WebStorage概述"></a>6.5.1、WebStorage概述</h3><p>WebStorage是HTML5中本地存储的解决方案之一，在HTML5的WebStorage概念引入之前除去IE User Data、Flash Cookie、Google Gears等看名字就不靠谱的解决方案，浏览器兼容的本地存储方案只有使用Cookie。有同学可能会问，既然有了Cookie本地存储，为什么还要引入WebStorage的概念？那就要说一说Cookie的缺陷了：</p><ol><li>数据大小：作为存储容器，Cookie的大小限制在4KB左右这是非常坑爹的，尤其对于现在复杂的业务逻辑需求，4KB的容量除了存储一些配置字段还简单单值信息，对于绝大部分开发者来说真的不知指望什么了。 </li><li>安全性问题：由于在HTTP请求中的Cookie是明文传递的（HTTPS不是），带来的安全性问题还是很大的。 </li><li>网络负担：我们知道Cookie会被附加在每个HTTP请求中，在HttpRequest和HttpResponse的header中都是要被传输的，所以无形中增加了一些不必要的流量损失。</li></ol><p>虽然WebStorage是HTML5新增的本地存储解决方案之一，但并不是为了取代Cookie而制定的标准，Cookie作为HTTP协议的一部分用来处理客户端和服务器通信是不可或缺的，session正是依赖于实现的客户端状态保持。WebStorage的意图在于解决本来不应该Cookie做，却不得不用Cookie的本地存储的应用场景。</p><h3 id="6-5-2、WebStorage分类"><a href="#6-5-2、WebStorage分类" class="headerlink" title="6.5.2、WebStorage分类"></a>6.5.2、WebStorage分类</h3><p>Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例。从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，浏览器关闭也就没了；而localStorage则一直将数据保存在客户端本地； 不管是sessionStorage，还是localStorage，使用的API都相同。</p><p>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理，低版本IE可以使用 <a href="https://github.com/douglascrockford/JSON-js/blob/master/json2.js">json2.js</a></p><h3 id="6-5-3、localStorage方法"><a href="#6-5-3、localStorage方法" class="headerlink" title="6.5.3、localStorage方法"></a>6.5.3、localStorage方法</h3><p><strong>对象介绍：</strong></p><p>localStorage在本地永久性存储数据，除非显式将其删除或清空。</p><p><strong>常见方法：</strong></p><ul><li>保存单个数据：localStorage.setItem(key,value); </li><li>读取单个数据：localStorage.getItem(key); </li><li>删除单个数据：localStorage.removeItem(key); </li><li>删除所有数据：localStorage.clear(); </li><li>获取某个索引的key：localStorage.key(index);</li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">localStorage.setItem(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取单个数据</span></span><br><span class="line">console.log(localStorage.getItem(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单个数据</span></span><br><span class="line">localStorage.removeItem(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">console.log(localStorage.getItem(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存两个数据</span></span><br><span class="line">localStorage.setItem(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">localStorage.setItem(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">console.log(<span class="string">&quot;age=&quot;</span> + localStorage.getItem(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;sex=&quot;</span> + localStorage.getItem(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for-in循环来迭代localStorage中的键值对、属性和方法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key in localStorage) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(key + <span class="string">&quot;=&quot;</span> + localStorage[key]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for循环来迭代localStorage中的键值对：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; localStorage.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">key</span> <span class="operator">=</span> localStorage.key(i);</span><br><span class="line">    <span class="type">var</span> <span class="variable">value</span> <span class="operator">=</span> localStorage.getItem(key);</span><br><span class="line">    console.log(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><p><strong>控制台：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/61686f1b890e4aed66a29ca7b99fb017.png" alt="img"></p><h3 id="6-5-4、sessionStorage方法"><a href="#6-5-4、sessionStorage方法" class="headerlink" title="6.5.4、sessionStorage方法"></a>6.5.4、sessionStorage方法</h3><p><strong>对象介绍：</strong></p><p>sessionStorage对象存储特定于某个对话的数据，也就是它的生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。存储在sessionStorage中的数据可以跨越页面刷新而存在，同时如果浏览器支持，浏览器崩溃并重启之后依然可以使用（注意：Firefox和Weblit都支持，IE则不行）。</p><p>因为sessionStorage对象绑定于某个服务器会话，所以当文件在本地运行的时候是不可用的。存储在sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。</p><p>不同浏览器写入数据方法略有不同。Firefox和Webkit实现了同步写入，所以添加到存储空间中的数据是立刻被提交的。而IE的实现则是异步写入数据，所以在设置数据和将数据实际写入磁盘之间可能有一些延迟。</p><p><strong>常见方法：</strong></p><ul><li>保存单个数据：sessionStorage.setItem(key,value); </li><li>读取单个数据：sessionStorage.getItem(key); </li><li>删除单个数据：sessionStorage.removeItem(key); </li><li>删除所有数据：sessionStorage.clear(); </li><li>获取某个索引的key：sessionStorage.key(index);</li></ul><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">sessionStorage.setItem(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取单个数据</span></span><br><span class="line">console.log(sessionStorage.getItem(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单个数据</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">console.log(sessionStorage.getItem(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存两个数据</span></span><br><span class="line">sessionStorage.setItem(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">sessionStorage.setItem(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">console.log(<span class="string">&quot;age=&quot;</span> + sessionStorage.getItem(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;sex=&quot;</span> + sessionStorage.getItem(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for-in循环来迭代sessionStorage中的键值对、属性和方法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key in sessionStorage) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(key + <span class="string">&quot;=&quot;</span> + sessionStorage[key]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for循环来迭代sessionStorage中的键值对：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sessionStorage.length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">key</span> <span class="operator">=</span> sessionStorage.key(i);</span><br><span class="line">    <span class="type">var</span> <span class="variable">value</span> <span class="operator">=</span> sessionStorage.getItem(key);</span><br><span class="line">    console.log(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有数据</span></span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure><p><strong>控制台：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1325a4d3c63e875d47b815eae84a29ac.png" alt="img"></p><h2 id="6-6、Closure"><a href="#6-6、Closure" class="headerlink" title="6.6、Closure"></a>6.6、Closure</h2><h3 id="6-6-1、闭包引入"><a href="#6-6-1、闭包引入" class="headerlink" title="6.6.1、闭包引入"></a>6.6.1、闭包引入</h3><p><strong>需求信息：点击某个按钮，提示”点击的是第n个按钮”</strong></p><p>第一种解决方法：将btn所对应的下标保存在btn上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">btns</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将btn所对应的下标保存在btn上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, length = btns.length; i &lt; length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> btns[i];</span><br><span class="line">    btn.index = i;</span><br><span class="line">    btn.onclick = function () &#123;</span><br><span class="line">   </span><br><span class="line">        alert(<span class="string">&#x27;第&#x27;</span> + (<span class="built_in">this</span>.index + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解决方法：利用闭包延长局部变量的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">btns</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用闭包延长局部变量的生命周期</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, length = btns.length; i &lt; length; i++) &#123;</span><br><span class="line">   </span><br><span class="line">    (function (j) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">var</span> <span class="variable">btn</span> <span class="operator">=</span> btns[j];</span><br><span class="line">        btn.onclick = function () &#123;</span><br><span class="line">   </span><br><span class="line">            alert(<span class="string">&#x27;第&#x27;</span> + (j + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-2、闭包概念"><a href="#6-6-2、闭包概念" class="headerlink" title="6.6.2、闭包概念"></a>6.6.2、闭包概念</h3><ul><li><p><strong>如何产生闭包?</strong> </p><ul> - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包 </ul>  </li><li><p><strong>什么才是闭包？</strong> </p><ul> - 理解一：闭包是嵌套的内部函数(绝大部分人认为) - 理解二：包含被引用变量(函数)的对象(极少部分人认为) </ul>  </li><li><p><strong>闭包的作用？</strong> </p><ul> - 它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中 </ul> </li></ul><h3 id="6-6-3、闭包演示"><a href="#6-6-3、闭包演示" class="headerlink" title="6.6.3、闭包演示"></a>6.6.3、闭包演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    function <span class="title function_">subFun</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        a++;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">f1</span> <span class="operator">=</span> fun1();</span><br><span class="line">f1();</span><br><span class="line">f1();</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">function <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    function <span class="title function_">subFun</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        a--;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subFun;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">f2</span> <span class="operator">=</span> fun2();</span><br><span class="line">f2();</span><br><span class="line">f2();</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9722bfe7789b49229b44fe31313dd6c0.png" alt="img"></p><h3 id="6-6-4、闭包生命周期"><a href="#6-6-4、闭包生命周期" class="headerlink" title="6.6.4、闭包生命周期"></a>6.6.4、闭包生命周期</h3><p>生命周期：</p><ol><li>产生：在嵌套内部函数定义执行完时就产生了(不是在调用) </li><li>死亡：在嵌套的内部函数成为垃圾对象时就死亡了</li></ol><p>演示说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">fn1</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//此时闭包就已经产生了(函数提升, 内部函数对象已经创建了)</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">fn2</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        a++;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">f</span> <span class="operator">=</span> fn1();</span><br><span class="line">f(); <span class="comment">// 3</span></span><br><span class="line">f(); <span class="comment">// 4</span></span><br><span class="line">f = <span class="literal">null</span>; <span class="comment">//闭包死亡(包含闭包的函数对象成为垃圾对象)</span></span><br></pre></td></tr></table></figure><h3 id="6-6-5、闭包应用"><a href="#6-6-5、闭包应用" class="headerlink" title="6.6.5、闭包应用"></a>6.6.5、闭包应用</h3><p><strong>闭包应用：</strong> 定义JS模块</p><ul><li>具有特定功能的js文件 </li><li>将所有的数据和功能都封装在一个函数内部(私有的) </li><li>只向外暴露一个包含n个方法的对象或函数 </li><li>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</li></ul><p><strong>案例演示：</strong></p><p>第一种格式：myModule.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">myModule</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&#x27;Hello, World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作数据的函数</span></span><br><span class="line">    function <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&#x27;doSomething() &#x27;</span> + msg.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">doOtherthing</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&#x27;doOtherthing() &#x27;</span> + msg.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">   </span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doOtherthing: doOtherthing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种使用：index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">module</span> <span class="operator">=</span> myModule();</span><br><span class="line"><span class="keyword">module</span>.doSomething();</span><br><span class="line"><span class="keyword">module</span>.doOtherthing();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/267a54ef948c4b363603dd4ebba92901.png" alt="img"></p><p>第二种格式：myModule.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(function (window) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&#x27;Hello, World&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作数据的函数</span></span><br><span class="line">    function <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&#x27;doSomething() &#x27;</span> + msg.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">doOtherthing</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&#x27;doOtherthing() &#x27;</span> + msg.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向外暴露对象(给外部使用的方法)</span></span><br><span class="line">    window.myModule = &#123;</span><br><span class="line">   </span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doOtherthing: doOtherthing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>第二种使用：index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myModule.doSomething();</span><br><span class="line">myModule.doOtherthing();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6ee4d72170ebfdf2e48d074c23f05543.png" alt="img"></p><h2 id="7-1、ECMAScript6新特性"><a href="#7-1、ECMAScript6新特性" class="headerlink" title="7.1、ECMAScript6新特性"></a>7.1、ECMAScript6新特性</h2><h3 id="7-1-1、let-关键字"><a href="#7-1-1、let-关键字" class="headerlink" title="7.1.1、let 关键字"></a>7.1.1、let 关键字</h3><p>let 关键字用来声明变量，使用 let 声明的变量有几个特点：</p><ul><li>不允许重复声明 </li><li>块儿级作用域 </li><li>不存在变量提升 </li><li>不影响作用域链</li></ul><blockquote><p>注意：以后声明变量使用 let 就对了</p></blockquote><p><strong>案例演示：创建四个div，单机每一个div让其变色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .item &#123;</span><br><span class="line">    </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            border: solid 1px <span class="title function_">rgb</span><span class="params">(<span class="number">42</span>, <span class="number">156</span>, <span class="number">156</span>)</span>;</span><br><span class="line">            <span class="type">float</span>: left;</span><br><span class="line">            margin-right: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;item&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;item&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;item&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;item&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 获取div元素对象</span></span><br><span class="line">    <span class="type">let</span> <span class="variable">items</span> <span class="operator">=</span> document.getElementsByClassName(<span class="string">&#x27;item&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并绑定事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        items[i].onclick = function () &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 以前的做法：this.style.background = &quot;pink&quot;;</span></span><br><span class="line">            items[i].style.background = <span class="string">&quot;pink&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/266f795976b338c4959954ce71032871.png" alt="img"></p><h3 id="7-1-2、const-关键字"><a href="#7-1-2、const-关键字" class="headerlink" title="7.1.2、const 关键字"></a>7.1.2、const 关键字</h3><p>const 关键字用来声明常量，const 声明有以下特点：</p><ul><li>不允许重复声明 </li><li>块儿级作用域 </li><li>声明必须赋初始值 </li><li>值不允许修改 </li><li>标识符一般为大写</li></ul><blockquote><p>注意：声明对象类型使用 const，非对象类型声明选择 let</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明常量</span></span><br><span class="line"><span class="type">const</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">console.log(MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数组和对象的元素修改, 不算做对常量的修改, 不会报错</span></span><br><span class="line"><span class="type">const</span> <span class="variable">TEAM1</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="type">const</span> <span class="variable">TEAM2</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 但是不能修改地址指向</span></span><br><span class="line"><span class="comment">// TEAM2 = TEAM1;</span></span><br></pre></td></tr></table></figure><h3 id="7-1-3、变量的解构赋值"><a href="#7-1-3、变量的解构赋值" class="headerlink" title="7.1.3、变量的解构赋值"></a>7.1.3、变量的解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><blockquote><p>注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式</p></blockquote><p><strong>数组的解构赋值：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的解构赋值</span></span><br><span class="line"><span class="type">const</span> <span class="variable">arr</span> <span class="operator">=</span> [<span class="string">&quot;张学友&quot;</span>, <span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;黎明&quot;</span>, <span class="string">&quot;郭富城&quot;</span>];</span><br><span class="line">let [zhang, liu, li, guo] = arr;</span><br><span class="line">console.log(zhang);</span><br><span class="line">console.log(liu);</span><br><span class="line">console.log(li);</span><br><span class="line">console.log(guo);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c9b63040612475be883d4fbe8493b672.png" alt="img"></p><p><strong>简单对象的解构赋值：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象的解构赋值</span></span><br><span class="line"><span class="type">const</span> <span class="variable">lin</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;林志颖&quot;</span>,</span><br><span class="line">    tags: [<span class="string">&quot;车手&quot;</span>, <span class="string">&quot;歌手&quot;</span>, <span class="string">&quot;小旋风&quot;</span>, <span class="string">&quot;演员&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;</span><br><span class="line">   name, tags&#125; = lin;</span><br><span class="line">console.log(name);</span><br><span class="line">console.log(tags);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9863e59feff49069c671819f794b2ae9.png" alt="img"></p><p><strong>复杂对象的解构赋值:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂对象的解构赋值</span></span><br><span class="line"><span class="type">let</span> <span class="variable">wangfei</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;王菲&quot;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    songs: [<span class="string">&quot;红豆&quot;</span>, <span class="string">&quot;流年&quot;</span>, <span class="string">&quot;暧昧&quot;</span>],</span><br><span class="line">    history: [</span><br><span class="line">        &#123;</span><br><span class="line">   name: <span class="string">&quot;窦唯&quot;</span>&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">   name: <span class="string">&quot;李亚鹏&quot;</span>&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">   name: <span class="string">&quot;谢霆锋&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;</span><br><span class="line">   name, age, songs: [one, two, three], history: [first, second, third]&#125; = wangfei;</span><br><span class="line">console.log(name);</span><br><span class="line">console.log(age);</span><br><span class="line">console.log(one);</span><br><span class="line">console.log(two);</span><br><span class="line">console.log(three);</span><br><span class="line">console.log(first);</span><br><span class="line">console.log(second);</span><br><span class="line">console.log(third);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/f46bd6a52d38e1030e264ec59062cc25.png" alt="img"></p><h3 id="7-1-4、模板字符串"><a href="#7-1-4、模板字符串" class="headerlink" title="7.1.4、模板字符串"></a>7.1.4、模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：</p><ul><li>字符串中可以出现换行符 </li><li>可以使用 ${xxx} 形式输出变量</li></ul><blockquote><p>注意：当遇到字符串与变量拼接的情况使用模板字符串</p></blockquote><p><strong>字符串中可以出现换行符：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义字符串</span></span><br><span class="line"><span class="type">let</span> <span class="variable">str</span> <span class="operator">=</span> `&lt;ul&gt;</span><br><span class="line">               &lt;li&gt;沈腾&lt;/li&gt;</span><br><span class="line">               &lt;li&gt;玛丽&lt;/li&gt;</span><br><span class="line">               &lt;li&gt;魏翔&lt;/li&gt;</span><br><span class="line">               &lt;li&gt;艾伦&lt;/li&gt;</span><br><span class="line">           &lt;/ul&gt;`;</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5ee196feafc0207eda53eac3e2b4aa3c.png" alt="img"></p><p><strong>变量拼接:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量拼接</span></span><br><span class="line"><span class="type">let</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;小可爱&#x27;</span>;</span><br><span class="line"><span class="type">let</span> <span class="variable">result</span> <span class="operator">=</span> `欢迎$&#123;</span><br><span class="line">     name&#125;访问我的文章`;</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9ae4c48b4dbdf2da942945c1de172b11.png" alt="img"></p><h3 id="7-1-5、简化对象写法"><a href="#7-1-5、简化对象写法" class="headerlink" title="7.1.5、简化对象写法"></a>7.1.5、简化对象写法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样的书写更加简洁。</p><blockquote><p>注意：对象简写形式简化了代码，所以以后用简写就对了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="type">let</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">let</span> <span class="variable">speak</span> <span class="operator">=</span> function () &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性和方法简写</span></span><br><span class="line"><span class="type">let</span> <span class="variable">person</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    speak</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.name);</span><br><span class="line">console.log(person.age);</span><br><span class="line">person.speak();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0107de45367b67a096cf71c2f8258c04.png" alt="img"></p><h3 id="7-1-6、箭头函数"><a href="#7-1-6、箭头函数" class="headerlink" title="7.1.6、箭头函数"></a>7.1.6、箭头函数</h3><p>ES6 允许使用「箭头」（=&gt;）定义函数，通用写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">fn</span> <span class="operator">=</span> (arg1, arg2, arg3) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2 + arg3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数的注意点：</p><ul><li>如果形参只有一个，则小括号可以省略 </li><li>函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的执行结果 </li><li>箭头函数 this 指向声明时所在作用域下 this 的值，箭头函数不会更改 this 指向，用来指定回调函数会非常合适 </li><li>箭头函数不能作为构造函数实例化 </li><li>不能使用 arguments 实参</li></ul><p><strong>省略小括号的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">fn</span> <span class="operator">=</span> num =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>省略花括号的情况：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">fn</span> <span class="operator">=</span> score =&gt; score * <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>this 指向声明时所在作用域中 this 的值：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this 指向声明时所在作用域中 this 的值</span></span><br><span class="line"><span class="type">let</span> <span class="variable">fn</span> <span class="operator">=</span> () =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="type">let</span> <span class="variable">school</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    getName() &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">let</span> <span class="variable">subFun</span> <span class="operator">=</span> () =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">            console.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        subFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">school.getName();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/362527ff0dbd1248e6dc65e4b2751491.png" alt="img"></p><h3 id="7-1-7、rest-参数"><a href="#7-1-7、rest-参数" class="headerlink" title="7.1.7、rest 参数"></a>7.1.7、rest 参数</h3><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments 参数。</p><blockquote><p>注意：rest 参数非常适合不定个数参数函数的场景</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用与 arguments 类似</span></span><br><span class="line">function <span class="title function_">add</span><span class="params">(...args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 参数必须是最后一个形参</span></span><br><span class="line">function <span class="title function_">minus</span><span class="params">(a, b, ...args)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(a, b, args);</span><br><span class="line">&#125;</span><br><span class="line">minus(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/223dc0964e7b11f7137b9ca6768e5583.png" alt="img"></p><h3 id="7-1-8、spread-扩展运算符"><a href="#7-1-8、spread-扩展运算符" class="headerlink" title="7.1.8、spread 扩展运算符"></a>7.1.8、spread 扩展运算符</h3><p>扩展运算符（spread）也是三个点（…），它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。</p><p><strong>展开数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展开数组</span></span><br><span class="line"><span class="type">let</span> <span class="variable">tfboys</span> <span class="operator">=</span> [<span class="string">&quot;德玛西亚之力&quot;</span>, <span class="string">&quot;德玛西亚之翼&quot;</span>, <span class="string">&quot;德玛西亚皇子&quot;</span>];</span><br><span class="line">function <span class="title function_">fn</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">fn(...tfboys);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/099d4a971374d3b90b62d225dff4fe8d.png" alt="img"></p><p><strong>展开对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展开对象</span></span><br><span class="line"><span class="type">let</span> <span class="variable">skillOne</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    q: <span class="string">&quot;致命打击&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">let</span> <span class="variable">skillTwo</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    w: <span class="string">&quot;勇气&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">let</span> <span class="variable">skillThree</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    e: <span class="string">&quot;审判&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">let</span> <span class="variable">skillFour</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    r: <span class="string">&quot;德玛西亚正义&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">let</span> <span class="variable">gailun</span> <span class="operator">=</span> &#123;</span><br><span class="line">   ...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;</span><br><span class="line">console.log(gailun);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/4ed8c6374e96866ca9d8f77a6f39778f.png" alt="img"></p><h3 id="7-1-9、Symbol类型"><a href="#7-1-9、Symbol类型" class="headerlink" title="7.1.9、Symbol类型"></a>7.1.9、Symbol类型</h3><h4 id="7-1-9-1、Symbol的使用"><a href="#7-1-9-1、Symbol的使用" class="headerlink" title="7.1.9.1、Symbol的使用"></a>7.1.9.1、Symbol的使用</h4><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型，Symbol 特点如下：</p><ul><li>Symbol 的值是唯一的，用来解决命名冲突的问题 </li><li>Symbol 值不能与其它数据进行运算 </li><li>Symbol 定义的对象属性不能使用 for…in 循环遍 历 ，但是可以使用 Reflect.ownKeys 来获取对象的所有键名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 Symbol</span></span><br><span class="line"><span class="type">let</span> <span class="variable">s1</span> <span class="operator">=</span> Symbol();</span><br><span class="line">console.log(s1);</span><br><span class="line">console.log(typeof s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加标识的 Symbol</span></span><br><span class="line"><span class="type">let</span> <span class="variable">s2</span> <span class="operator">=</span> Symbol(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="type">let</span> <span class="variable">s2_2</span> <span class="operator">=</span> Symbol(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">console.log(s2);</span><br><span class="line">console.log(s2_2);</span><br><span class="line">console.log(s2 === s2_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Symbol for 定义</span></span><br><span class="line"><span class="type">let</span> <span class="variable">s3</span> <span class="operator">=</span> Symbol.<span class="keyword">for</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="type">let</span> <span class="variable">s3_2</span> <span class="operator">=</span> Symbol.<span class="keyword">for</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">console.log(s3);</span><br><span class="line">console.log(s3_2);</span><br><span class="line">console.log(s3 === s3_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在方法中使用 Symbol</span></span><br><span class="line"><span class="type">let</span> <span class="variable">game</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;狼人杀&quot;</span>,</span><br><span class="line">    [Symbol(<span class="string">&#x27;say&#x27;</span>)]: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以发言&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    [Symbol(<span class="string">&#x27;zibao&#x27;</span>)]: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&#x27;我可以自爆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(game);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bf5414cb64e3cf9457972b10ce17fab6.png" alt="img"></p><blockquote><p>注意：遇到唯一性的场景时要想到 Symbol</p></blockquote><h4 id="7-1-9-2、Symbol内置值"><a href="#7-1-9-2、Symbol内置值" class="headerlink" title="7.1.9.2、Symbol内置值"></a>7.1.9.2、Symbol内置值</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p><p>可以称这些方法为魔术方法，因为它们会在特定的场景下自动执行。</p><p><strong>Symbol.hasInstance演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> [Symbol.hasInstance](param) &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我被用来检测类型了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">let</span> <span class="variable">o</span> <span class="operator">=</span> &#123;</span><br><span class="line">   &#125;;</span><br><span class="line">console.log(o <span class="keyword">instanceof</span> Person);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/74663d366b9a8261cc7c704896bca9c9.png" alt="img"></p><p><strong>Symbol.isConcatSpreadable演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">arr1</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="variable">arr2</span> <span class="operator">=</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr2[Symbol.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">console.log(arr1.concat(arr2));</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">arr3</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="variable">arr4</span> <span class="operator">=</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr4[Symbol.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line">console.log(arr3.concat(arr4));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/1072c432fee0970932bf37b846361d6d.png" alt="img"></p><h3 id="7-1-10、迭代器"><a href="#7-1-10、迭代器" class="headerlink" title="7.1.10、迭代器"></a>7.1.10、迭代器</h3><p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费，原生具备 iterator 接口的数据：</p><ul><li>Array </li><li>Arguments </li><li>Set </li><li>Map </li><li>String </li><li>TypedArray </li><li>NodeList</li></ul><blockquote><p>注意：需要自定义遍历数据的时候，要想到迭代器</p></blockquote><p>工作原理：</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置 </li><li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员 </li><li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员 </li><li>每调用 next 方法返回一个包含 value 和 done 属性的对象</li></ol><p><strong>案例演示：遍历数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个数组</span></span><br><span class="line"><span class="type">const</span> <span class="variable">xiyou</span> <span class="operator">=</span> [<span class="string">&quot;唐僧&quot;</span>, <span class="string">&quot;孙悟空&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>, <span class="string">&quot;沙僧&quot;</span>];</span><br><span class="line"><span class="comment">//使用 for...of 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (let v of xiyou) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取迭代器对象</span></span><br><span class="line"><span class="type">let</span> <span class="variable">iterator</span> <span class="operator">=</span> xiyou[Symbol.iterator]();</span><br><span class="line"><span class="comment">//调用对象的next方法</span></span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/7261b300de524e308b2f3d6fa2626003.png" alt="img"></p><p><strong>案例演示：自定义遍历数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">banji</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;五班&quot;</span>,</span><br><span class="line">    stus: [</span><br><span class="line">        <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">        <span class="string">&quot;王五&quot;</span>,</span><br><span class="line">        <span class="string">&quot;小六&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    [Symbol.iterator]() &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//索引变量</span></span><br><span class="line">        <span class="type">let</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">let</span> <span class="variable">_this</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">   </span><br><span class="line">            next: function () &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span> (index &lt; _this.stus.length) &#123;</span><br><span class="line">   </span><br><span class="line">                    <span class="type">const</span> <span class="variable">result</span> <span class="operator">=</span> &#123;</span><br><span class="line">   value: _this.stus[index], done: <span class="literal">false</span>&#125;;</span><br><span class="line">                    <span class="comment">//下标自增</span></span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="comment">//返回结果</span></span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">   value: undefined, done: <span class="literal">true</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历这个对象</span></span><br><span class="line"><span class="keyword">for</span> (let v of banji) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ee3984806f44ae602c00e2e135e681a4.png" alt="img"></p><h3 id="7-1-11、生成器"><a href="#7-1-11、生成器" class="headerlink" title="7.1.11、生成器"></a>7.1.11、生成器</h3><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><h4 id="7-1-11-1、生成器函数使用"><a href="#7-1-11-1、生成器函数使用" class="headerlink" title="7.1.11.1、生成器函数使用"></a>7.1.11.1、生成器函数使用</h4><p>代码说明：</p><ul><li><ul><li>的位置没有限制 </li></ul></li><li>生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到 yield 语句后的值 </li><li>yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next 方法，执行一段代码 </li><li>next 方法可以传递实参，作为 yield 语句的返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function * gen() &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*代码1开始执行*/</span></span><br><span class="line">    console.log(<span class="string">&quot;代码1执行了&quot;</span>);</span><br><span class="line">    yield <span class="string">&quot;一只没有耳朵&quot;</span>;</span><br><span class="line">    <span class="comment">/*代码2开始执行*/</span></span><br><span class="line">    console.log(<span class="string">&quot;代码2执行了&quot;</span>);</span><br><span class="line">    yield <span class="string">&quot;一只没有尾巴&quot;</span>;</span><br><span class="line">    <span class="comment">/*代码3开始执行*/</span></span><br><span class="line">    console.log(<span class="string">&quot;代码3执行了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;真奇怪&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">let</span> <span class="variable">iterator</span> <span class="operator">=</span> gen();</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(iterator.next());</span><br><span class="line">console.log(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (let v of <span class="title function_">gen</span><span class="params">()</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/df04133784427fb1f615e7d09c62cfc1.png" alt="img"></p><h4 id="7-1-11-2、生成器函数参数"><a href="#7-1-11-2、生成器函数参数" class="headerlink" title="7.1.11.2、生成器函数参数"></a>7.1.11.2、生成器函数参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function * gen(arg) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(arg);</span><br><span class="line">    <span class="type">let</span> <span class="variable">one</span> <span class="operator">=</span> yield <span class="number">111</span>;</span><br><span class="line">    console.log(one);</span><br><span class="line">    <span class="type">let</span> <span class="variable">two</span> <span class="operator">=</span> yield <span class="number">222</span>;</span><br><span class="line">    console.log(two);</span><br><span class="line">    <span class="type">let</span> <span class="variable">three</span> <span class="operator">=</span> yield <span class="number">333</span>;</span><br><span class="line">    console.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行获取迭代器对象</span></span><br><span class="line"><span class="type">let</span> <span class="variable">iterator</span> <span class="operator">=</span> gen(<span class="string">&#x27;AAA&#x27;</span>);</span><br><span class="line">console.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">//next方法可以传入实参</span></span><br><span class="line">console.log(iterator.next(<span class="string">&#x27;BBB&#x27;</span>));</span><br><span class="line">console.log(iterator.next(<span class="string">&#x27;CCC&#x27;</span>));</span><br><span class="line">console.log(iterator.next(<span class="string">&#x27;DDD&#x27;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/66be4bf19f8026b04b98cb516fb30b50.png" alt="img"></p><h4 id="7-1-11-3、生成器函数实例"><a href="#7-1-11-3、生成器函数实例" class="headerlink" title="7.1.11.3、生成器函数实例"></a>7.1.11.3、生成器函数实例</h4><p><strong>案例演示：1s后控制台输出 111，2s后输出 222，3s后输出 333</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">one</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="number">111</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">two</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="number">222</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">three</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="number">333</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * gen() &#123;</span><br><span class="line">   </span><br><span class="line">    yield <span class="title function_">one</span><span class="params">()</span>;</span><br><span class="line">    yield <span class="title function_">two</span><span class="params">()</span>;</span><br><span class="line">    yield <span class="title function_">three</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="type">let</span> <span class="variable">iterator</span> <span class="operator">=</span> gen();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/fa16362e71076bdfbe14a5f6974725e0.png" alt="img"></p><p><strong>案例演示：模拟获取 ，用户数据 ，订单数据 ，商品数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;用户数据&quot;</span>;</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">getOrders</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;订单数据&quot;</span>;</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">getGoods</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;商品数据&quot;</span>;</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * gen() &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">let</span> <span class="variable">users</span> <span class="operator">=</span> yield <span class="title function_">getUsers</span><span class="params">()</span>;</span><br><span class="line">    console.log(users);</span><br><span class="line">    <span class="type">let</span> <span class="variable">orders</span> <span class="operator">=</span> yield <span class="title function_">getOrders</span><span class="params">()</span>;</span><br><span class="line">    console.log(orders);</span><br><span class="line">    <span class="type">let</span> <span class="variable">goods</span> <span class="operator">=</span> yield <span class="title function_">getGoods</span><span class="params">()</span>;</span><br><span class="line">    console.log(goods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="type">let</span> <span class="variable">iterator</span> <span class="operator">=</span> gen();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6b1c6c66754846fe33f62c21276524a8.png" alt="img"></p><h3 id="7-1-12、Promise"><a href="#7-1-12、Promise" class="headerlink" title="7.1.12、Promise"></a>7.1.12、Promise</h3><p>Promise 是 ES6 引入的异步编程的新解决方案，语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><h4 id="7-1-12-1、Promise基本使用"><a href="#7-1-12-1、Promise基本使用" class="headerlink" title="7.1.12.1、Promise基本使用"></a>7.1.12.1、Promise基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化 Promise 对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(function (resolve, reject) &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功调用resolve()处理</span></span><br><span class="line">        <span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;数据读取成功&quot;</span>;</span><br><span class="line">        resolve(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败调用reject()处理</span></span><br><span class="line">        <span class="type">let</span> <span class="variable">err</span> <span class="operator">=</span> <span class="string">&quot;数据读取失败&quot;</span>;</span><br><span class="line">        reject(err);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 promise 对象的 then 方法</span></span><br><span class="line">p.then(function (value) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;, function (reason) &#123;</span><br><span class="line">   </span><br><span class="line">    console.error(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="7-1-12-2、Promise案例演示"><a href="#7-1-12-2、Promise案例演示" class="headerlink" title="7.1.12.2、Promise案例演示"></a>7.1.12.2、Promise案例演示</h4><p><strong>案例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口地址: https://api.apiopen.top/getJoke</span></span><br><span class="line"><span class="type">const</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//1. 创建对象</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">xhr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">//2. 初始化</span></span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>);</span><br><span class="line">    <span class="comment">//3. 发送</span></span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="comment">//4. 绑定事件, 处理响应结果</span></span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="comment">//判断响应状态码 200-299</span></span><br><span class="line">            <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="comment">//表示成功</span></span><br><span class="line">                resolve(xhr.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="comment">//如果失败</span></span><br><span class="line">                reject(xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调</span></span><br><span class="line">p.then(function (value) &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;, function (reason) &#123;</span><br><span class="line">   </span><br><span class="line">    console.error(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c66b93da4b145571f90fb2c0db0513c1.png" alt="img"></p><h4 id="7-1-12-3、Promise-then方法"><a href="#7-1-12-3、Promise-then方法" class="headerlink" title="7.1.12.3、Promise-then方法"></a>7.1.12.3、Promise-then方法</h4><p>调用 then 方法，then 方法的返回结果是 Promise 对象，对象状态由回调函数的执行结果决定，如果回调函数中返回的结果是 非 promise 类型的属性，状态为成功，返回值为对象的成功的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 promise 对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        resolve(<span class="string">&quot;用户数据&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式调用+箭头函数</span></span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b1e44a64bae470e31bec6b38243d4936.png" alt="img"></p><h4 id="7-1-12-4、Promise-catch方法"><a href="#7-1-12-4、Promise-catch方法" class="headerlink" title="7.1.12.4、Promise-catch方法"></a>7.1.12.4、Promise-catch方法</h4><p>如果只想处理错误状态，我们可以使用 catch 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//设置 p 对象的状态为失败, 并设置失败的值</span></span><br><span class="line">        reject(<span class="string">&quot;出错啦!&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="keyword">catch</span>(function (reason) &#123;</span><br><span class="line">   </span><br><span class="line">    console.error(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/13917a333fbbb46c3102bf8ccdcf4d9a.png" alt="img"></p><h3 id="7-1-13、Set"><a href="#7-1-13、Set" class="headerlink" title="7.1.13、Set"></a>7.1.13、Set</h3><p>ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：</p><ul><li>size：返回集合的元素个数 </li><li>add()：增加一个新元素，返回当前集合 </li><li>delete()：删除元素，返回 boolean 值 </li><li>has()：检测集合中是否包含某个元素，返回 boolean 值 </li><li>clear()：清空集合，返回 undefined</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空集合</span></span><br><span class="line"><span class="type">let</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">//创建一个非空集合</span></span><br><span class="line"><span class="type">let</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">//集合属性与方法</span></span><br><span class="line"><span class="comment">//返回集合的元素个数</span></span><br><span class="line">console.log(s1.size);</span><br><span class="line"><span class="comment">//添加新元素</span></span><br><span class="line">console.log(s1.add(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">console.log(s1.delete(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//检测是否存在某个值</span></span><br><span class="line">console.log(s1.has(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line">console.log(s1.clear());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/72e93e66fa960742b8f5f1f9121edc9a.png" alt="img"></p><h3 id="7-1-14、Map"><a href="#7-1-14、Map" class="headerlink" title="7.1.14、Map"></a>7.1.14、Map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属性和方法：</p><ul><li>size：返回 Map 的元素个数 </li><li>set()：增加一个新元素，返回当前 Map </li><li>get()：返回键名对象的键值 </li><li>has()：检测 Map 中是否包含某个元素，返回 boolean 值 </li><li>clear()：清空集合，返回 undefined</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空 map</span></span><br><span class="line"><span class="type">let</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//创建一个非空 map</span></span><br><span class="line"><span class="type">let</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;女&quot;</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">//属性和方法</span></span><br><span class="line"><span class="comment">//获取映射元素的个数</span></span><br><span class="line">console.log(m2.size);</span><br><span class="line"><span class="comment">//添加映射值</span></span><br><span class="line">console.log(m2.set(<span class="string">&quot;age&quot;</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">//获取映射值</span></span><br><span class="line">console.log(m2.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="comment">//检测是否有该映射</span></span><br><span class="line">console.log(m2.has(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"><span class="comment">//清除</span></span><br><span class="line">console.log(m2.clear());</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3bd894dd1c913370e03dcdddbdda27c2.png" alt="img"></p><h3 id="7-1-15、class-类"><a href="#7-1-15、class-类" class="headerlink" title="7.1.15、class 类"></a>7.1.15、class 类</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是 一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已，它的一些如下：</p><ul><li>class：声明类 </li><li>constructor：定义构造函数初始化 </li><li>extends：继承父类 </li><li>super：调用父级构造方法 </li><li>static：定义静态方法和属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    constructor(brand, color, price) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象方法</span></span><br><span class="line">    call() &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以打电话!!!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">   </span><br><span class="line">    constructor(brand, color, price, screen, pixel) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="built_in">super</span>(brand, color, price);</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.pixel = pixel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类方法</span></span><br><span class="line">    photo() &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以拍照!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    playGame() &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以玩游戏!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    call() &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以进行视频通话!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以运行程序&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我可以建立连接&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">Nokia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;诺基亚&quot;</span>, <span class="string">&quot;灰色&quot;</span>, <span class="number">230</span>);</span><br><span class="line"><span class="type">const</span> <span class="variable">iPhone6s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;白色&quot;</span>, <span class="number">6088</span>, <span class="string">&quot;4.7inch&quot;</span>, <span class="string">&quot;500w&quot;</span>);</span><br><span class="line"><span class="comment">//调用子类方法</span></span><br><span class="line">iPhone6s.playGame();</span><br><span class="line"><span class="comment">//调用重写方法</span></span><br><span class="line">iPhone6s.call();</span><br><span class="line"><span class="comment">//调用静态方法</span></span><br><span class="line">SmartPhone.run();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a32a01d82cb231f54f4981b69694fb9f.png" alt="img"></p><h3 id="7-1-16、数值扩展"><a href="#7-1-16、数值扩展" class="headerlink" title="7.1.16、数值扩展"></a>7.1.16、数值扩展</h3><h4 id="7-1-16-1、二进制和八进制"><a href="#7-1-16-1、二进制和八进制" class="headerlink" title="7.1.16.1、二进制和八进制"></a>7.1.16.1、二进制和八进制</h4><p>ES6 新增了二进制和八进制的表示方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0b1010</span><span class="comment">//二进制</span></span><br><span class="line"><span class="type">let</span> <span class="variable">o</span> <span class="operator">=</span> 0o777;<span class="comment">//八进制</span></span><br><span class="line"><span class="type">let</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//十进制</span></span><br><span class="line"><span class="type">let</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0xff</span>;<span class="comment">//十六进制</span></span><br><span class="line">console.log(b);</span><br><span class="line">console.log(o);</span><br><span class="line">console.log(d);</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c126e872714990e605fdcc1508cdc33c.png" alt="img"></p><h4 id="7-1-16-2、Number-EPSILON"><a href="#7-1-16-2、Number-EPSILON" class="headerlink" title="7.1.16.2、Number.EPSILON"></a>7.1.16.2、Number.EPSILON</h4><p>Number.EPSILON：它是 JavaScript 表示的最小精度，EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">equal</span><span class="params">(a, b)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (Math.abs(a - b) &lt; Number.EPSILON) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);</span><br><span class="line">console.log(equal(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d4a73aab41d2bc214326ff17ae97fb6f.png" alt="img"></p><h4 id="7-1-16-3、Number-isFinite"><a href="#7-1-16-3、Number-isFinite" class="headerlink" title="7.1.16.3、Number.isFinite"></a>7.1.16.3、Number.isFinite</h4><p>Number.isFinite：检测一个数值是否为有限数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.isFinite(<span class="number">100</span>));</span><br><span class="line">console.log(Number.isFinite(<span class="number">100</span> / <span class="number">0</span>));</span><br><span class="line">console.log(Number.isFinite(Infinity));</span><br><span class="line">console.log(Number.isFinite(-Infinity));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a8611da07c8890c5d55826eb7fe8f43b.png" alt="img"></p><h4 id="7-1-16-4、Number-isNaN"><a href="#7-1-16-4、Number-isNaN" class="headerlink" title="7.1.16.4、Number.isNaN"></a>7.1.16.4、Number.isNaN</h4><p>Number.isNaN：检测一个数值是否为 NaN</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.isNaN(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3bd2ba47d5441caac3c2585e75d76ad8.png" alt="img"></p><h4 id="7-1-16-5、Number-parseInt"><a href="#7-1-16-5、Number-parseInt" class="headerlink" title="7.1.16.5、Number.parseInt"></a>7.1.16.5、Number.parseInt</h4><p>Number.parseInt：将一个字符串转换为整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.parseInt(<span class="string">&quot;123abc&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/d7e850ad5d89ed46f543ff274724d89b.png" alt="img"></p><h4 id="7-1-16-6、Number-parseFloat"><a href="#7-1-16-6、Number-parseFloat" class="headerlink" title="7.1.16.6、Number.parseFloat"></a>7.1.16.6、Number.parseFloat</h4><p>Number.parseFloat：将一个字符串转换为浮点数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.parseFloat(<span class="string">&quot;3.1415926神奇&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bff9db6ac35e15c9c77e51937c7b50e6.png" alt="img"></p><h4 id="7-1-16-7、Number-isInteger"><a href="#7-1-16-7、Number-isInteger" class="headerlink" title="7.1.16.7、Number.isInteger"></a>7.1.16.7、Number.isInteger</h4><p>Number.isInteger：判断一个数是否为整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.isInteger(<span class="number">5</span>));</span><br><span class="line">console.log(Number.isInteger(<span class="number">2.5</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a38c6b96578d9f18c63d4d35b62b1a0a.png" alt="img"></p><h4 id="7-1-16-8、Math-trunc"><a href="#7-1-16-8、Math-trunc" class="headerlink" title="7.1.16.8、Math.trunc"></a>7.1.16.8、Math.trunc</h4><p>Math.trunc：将数字的小数部分抹掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.trunc(<span class="number">3.5</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a4652a02e7a1b4bc4cf8cfc62aa5f405.png" alt="img"></p><h4 id="7-1-16-9、Math-sign"><a href="#7-1-16-9、Math-sign" class="headerlink" title="7.1.16.9、Math.sign"></a>7.1.16.9、Math.sign</h4><p>Math.sign：判断一个数到底为正数、负数、还是零</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.sign(<span class="number">100</span>));</span><br><span class="line">console.log(Math.sign(<span class="number">0</span>));</span><br><span class="line">console.log(Math.sign(-<span class="number">20000</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3a39d8535927bdcf4e2d81e05cca7fd5.png" alt="img"></p><h3 id="7-1-17、对象扩展"><a href="#7-1-17、对象扩展" class="headerlink" title="7.1.17、对象扩展"></a>7.1.17、对象扩展</h3><p>ES6 新增了一些 Object 对象的方法，例如：</p><ul><li>Object.is：比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN） </li><li>Object.assign：对象的合并，将源对象的所有可枚举属性，复制到目标对象 </li><li><strong>proto</strong>、setPrototypeOf、 setPrototypeOf可以直接设置对象的原型</li></ul><h4 id="7-1-17-1、Object-is"><a href="#7-1-17-1、Object-is" class="headerlink" title="7.1.17.1、Object.is"></a>7.1.17.1、Object.is</h4><p>Object.is：判断两个值是否完全相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.is(<span class="number">120</span>, <span class="number">120</span>));<span class="comment">// ===</span></span><br><span class="line">console.log(Object.is(NaN, NaN));<span class="comment">// ===</span></span><br><span class="line">console.log(NaN === NaN);<span class="comment">// ===</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/bdec47a5a4af766fef6a766cf3a2156d.png" alt="img"></p><h4 id="7-1-17-2、Object-assign"><a href="#7-1-17-2、Object-assign" class="headerlink" title="7.1.17.2、Object.assign"></a>7.1.17.2、Object.assign</h4><p>Object.assign：对象的合并，后边的对象会把前边对象的相同属性和方法覆盖，没有的属性和方法会合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">config1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    host: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    name: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    pass: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    test1: <span class="string">&quot;test1&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="variable">config2</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    host: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    port: <span class="number">3309</span>,</span><br><span class="line">    name: <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">    pass: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    test2: <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.assign(config1, config2));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/98a9827537b0f61618056cda4826dbc8.png" alt="img"></p><h4 id="7-1-17-3、设置原型对象"><a href="#7-1-17-3、设置原型对象" class="headerlink" title="7.1.17.3、设置原型对象"></a>7.1.17.3、设置原型对象</h4><ul><li>Object.setPrototypeOf：设置原型对象 </li><li>Object.getPrototypeof：获取原型对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">school</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;MySchool&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="variable">cities</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    xiaoqu: [<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">Object.setPrototypeOf(school, cities);</span><br><span class="line">console.log(Object.getPrototypeOf(school));</span><br><span class="line">console.log(school);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/2692986b738e4ec760eff2a59ee9daef.png" alt="img"></p><h3 id="7-1-18、模块化"><a href="#7-1-18、模块化" class="headerlink" title="7.1.18、模块化"></a>7.1.18、模块化</h3><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p><h4 id="7-1-18-1、模块化的好处"><a href="#7-1-18-1、模块化的好处" class="headerlink" title="7.1.18.1、模块化的好处"></a>7.1.18.1、模块化的好处</h4><ul><li>防止命名冲突 </li><li>代码复用 </li><li>高维护性</li></ul><h4 id="7-1-18-2、模块化的产品"><a href="#7-1-18-2、模块化的产品" class="headerlink" title="7.1.18.2、模块化的产品"></a>7.1.18.2、模块化的产品</h4><p>CommonJS =&gt; NodeJS、Browserify</p><p>AMD =&gt; requireJS</p><p>CMD =&gt; seaJS</p><h4 id="7-1-18-3、模块化的语法"><a href="#7-1-18-3、模块化的语法" class="headerlink" title="7.1.18.3、模块化的语法"></a>7.1.18.3、模块化的语法</h4><p>模块功能主要由两个命令构成：export 和 import。</p><ul><li>export 命令用于规定模块的对外接口 </li><li>import 命令用于输入其它模块提供的功能</li></ul><h4 id="7-1-18-4、模块化的暴露"><a href="#7-1-18-4、模块化的暴露" class="headerlink" title="7.1.18.4、模块化的暴露"></a>7.1.18.4、模块化的暴露</h4><p>m1.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：分别暴露</span></span><br><span class="line">export <span class="type">let</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;华北理工大学&quot;</span>;</span><br><span class="line"></span><br><span class="line">export function <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="string">&quot;我们要学习！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m2.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式二：统一暴露</span></span><br><span class="line"><span class="type">let</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;华北理工大学&quot;</span>;</span><br><span class="line"></span><br><span class="line">function <span class="title function_">findJob</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(<span class="string">&quot;我们要找工作！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">   school, findJob&#125;;</span><br></pre></td></tr></table></figure><p>m3.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式三：默认暴露</span></span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">   </span><br><span class="line">    school: <span class="string">&quot;华北理工大学&quot;</span>,</span><br><span class="line">    change: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我们要改变自己！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-18-5、模块化的导入"><a href="#7-1-18-5、模块化的导入" class="headerlink" title="7.1.18.5、模块化的导入"></a>7.1.18.5、模块化的导入</h4><p>index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 引入 m1.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * as m1 from <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line">    <span class="comment">// 引入 m2.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * as m2 from <span class="string">&quot;./m2.js&quot;</span>;</span><br><span class="line">    <span class="comment">// 引入 m3.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * as m3 from <span class="string">&quot;./m3.js&quot;</span>;</span><br><span class="line">     </span><br><span class="line">    m1.study();</span><br><span class="line">    m2.findJob();</span><br><span class="line">    m3.<span class="keyword">default</span>.change();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/4566c9c669277441f6f717a83b758da7.png" alt="img"></p><h4 id="7-1-18-6、解构赋值形式"><a href="#7-1-18-6、解构赋值形式" class="headerlink" title="7.1.18.6、解构赋值形式"></a>7.1.18.6、解构赋值形式</h4><p>index.html</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在这里写JavaScript代码，因为JavaScript是由上到下执行的 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 引入 m1.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> &#123;</span><br><span class="line">    school, study&#125; from <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line">    <span class="comment">// 引入 m2.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> &#123;</span><br><span class="line">    school as s, findJob&#125; from <span class="string">&quot;./m2.js&quot;</span>;</span><br><span class="line">    <span class="comment">// 引入 m3.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> as m3&#125; from <span class="string">&quot;./m3.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">    console.log(school);</span><br><span class="line">    study();</span><br><span class="line"></span><br><span class="line">    console.log(s);</span><br><span class="line">    findJob();</span><br><span class="line"></span><br><span class="line">    console.log(m3);</span><br><span class="line">    m3.change();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/914ec8bc96c157e1d2e870930fb2590a.png" alt="img"></p><blockquote><p>注意：针对默认暴露还可以直接 <code>import m3 from “./m3.js”</code></p></blockquote><h3 id="7-1-19、浅拷贝和深拷贝"><a href="#7-1-19、浅拷贝和深拷贝" class="headerlink" title="7.1.19、浅拷贝和深拷贝"></a>7.1.19、浅拷贝和深拷贝</h3><p>如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝；如果B没变，那就是深拷贝，深拷贝与浅拷贝的概念只存在于引用数据类型。</p><h4 id="7-1-19-1、浅拷贝"><a href="#7-1-19-1、浅拷贝" class="headerlink" title="7.1.19.1、浅拷贝"></a>7.1.19.1、浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">obj1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    speak: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我是&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj2</span> <span class="operator">=</span> obj1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改obj2的属性和方法的时候，obj1相应的属性和方法也会改变</span></span><br><span class="line">obj2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6c91cba15c8b2bae18d6f69b842bacae.png" alt="img"></p><h4 id="7-1-19-2、深拷贝"><a href="#7-1-19-2、深拷贝" class="headerlink" title="7.1.19.2、深拷贝"></a>7.1.19.2、深拷贝</h4><h5 id="7-1-19-2-1、自带的"><a href="#7-1-19-2-1、自带的" class="headerlink" title="7.1.19.2.1、自带的"></a>7.1.19.2.1、自带的</h5><p><strong>Array：slice()、concat()、Array.from()、… 操作符：只能实现一维数组的深拷贝</strong></p><p>slice()方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr1</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">arr2</span> <span class="operator">=</span> arr1.slice();</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">console.log(arr1);</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9210eb6cb1f8ce51db545f32388a0a19.png" alt="img"></p><p>concat()方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr1</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">arr2</span> <span class="operator">=</span> arr1.concat();</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">console.log(arr1);</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/10f0bfe1e754957fb947804b201b90a9.png" alt="img"></p><p>Array.from()方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr1</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">arr2</span> <span class="operator">=</span> Array.from(arr1);</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">console.log(arr1);</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/565589822317ef0caf40c97b41f5dedc.png" alt="img"></p><p>… 操作符演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">arr1</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="type">var</span> <span class="variable">arr2</span> <span class="operator">=</span> [...arr1];</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">console.log(arr1);</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/2d90b07bfdc114450b7fef097772dd18.png" alt="img"></p><p><strong>Object：Object.assign()、… 操作符：只能实现一维对象的深拷贝</strong></p><p>Object.assign()方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">obj1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    speak: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我是&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj2</span> <span class="operator">=</span> Object.assign(&#123;</span><br><span class="line">   &#125;, obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变</span></span><br><span class="line">obj2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/a79b8cbcb59725bd43f406f3b407e5a5.png" alt="img"></p><p>… 操作符演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">obj1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    speak: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我是&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj2</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    ...obj1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变</span></span><br><span class="line">obj2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5b7f4e62a810da3cba10f4e9de868604.png" alt="img"></p><p><strong>JSON.parse(JSON.stringify(obj))：可实现多维对象的深拷贝，但会忽略 undefined 、 任意的函数 、Symbol 值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">obj1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    birthday: &#123;</span><br><span class="line">   </span><br><span class="line">        year: <span class="number">1997</span>,</span><br><span class="line">        month: <span class="number">12</span>,</span><br><span class="line">        day: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    speak: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我是&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj2</span> <span class="operator">=</span> JSON.parse(JSON.stringify(obj1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变</span></span><br><span class="line">obj2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/02aa09c5c1b8b563ffb115cfc9f4a1f0.png" alt="img"></p><blockquote><p>注意：进行<code>JSON.stringify()</code>序列化的过程中，<code>undefined、任意的函数以及 symbol 值</code>，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时），由上面可知，JS 提供的自有方法并不能彻底解决Array、Object的深拷贝问题，因此我们应该自己实现。</p></blockquote><h5 id="7-1-19-2-2、通用版"><a href="#7-1-19-2-2、通用版" class="headerlink" title="7.1.19.2.2、通用版"></a>7.1.19.2.2、通用版</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">obj1</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    birthday: &#123;</span><br><span class="line">   </span><br><span class="line">        year: <span class="number">1997</span>,</span><br><span class="line">        month: <span class="number">12</span>,</span><br><span class="line">        day: <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    speak: function () &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(<span class="string">&quot;我是&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">obj2</span> <span class="operator">=</span> deepClone(obj1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当修改obj2的属性和方法的时候，obj1相应的属性和方法不会改变</span></span><br><span class="line">obj2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">console.log(obj1);</span><br><span class="line">console.log(obj2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝通用方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj   需要拷贝的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> has</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;any|RegExp|Date&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">function <span class="title function_">deepClone</span><span class="params">(obj, has = new WeakMap()</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Date) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> RegExp) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!(typeof obj == <span class="string">&quot;object&quot;</span>)) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="type">const</span> <span class="variable">newObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">obj</span>.constructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止自引用导致的死循环</span></span><br><span class="line">    <span class="keyword">if</span> (has.get(obj)) <span class="keyword">return</span> has.get(obj);</span><br><span class="line">    has.set(obj, newObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历属性及方法</span></span><br><span class="line">    <span class="keyword">for</span> (let key in obj) &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">   </span><br><span class="line">            newObj[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3f4db7e1675de043429df5bf2ecc3b5d.png" alt="img"></p><h2 id="7-2、ECMAScript7新特性"><a href="#7-2、ECMAScript7新特性" class="headerlink" title="7.2、ECMAScript7新特性"></a>7.2、ECMAScript7新特性</h2><h3 id="7-2-1、数组方法扩展"><a href="#7-2-1、数组方法扩展" class="headerlink" title="7.2.1、数组方法扩展"></a>7.2.1、数组方法扩展</h3><p>Array.prototype.includes：此方法用来检测数组中是否包含某个元素，返回布尔类型值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">mingzhu</span> <span class="operator">=</span> [<span class="string">&quot;西游记&quot;</span>, <span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;水浒传&quot;</span>];</span><br><span class="line">console.log(mingzhu.includes(<span class="string">&quot;西游记&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c9aa858f337ad639378bdda002e62617.png" alt="img"></p><h3 id="7-2-2、幂运算"><a href="#7-2-2、幂运算" class="headerlink" title="7.2.2、幂运算"></a>7.2.2、幂运算</h3><p>** 操作符的作用和 Math.pow 的作用是一样，请看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="number">2</span> ** <span class="number">10</span>);</span><br><span class="line">console.log(Math.pow(<span class="number">2</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9920bbd0845ad8ccbe0b89c5ccdb8d6e.png" alt="img"></p><h2 id="7-3、ECMAScript8新特性"><a href="#7-3、ECMAScript8新特性" class="headerlink" title="7.3、ECMAScript8新特性"></a>7.3、ECMAScript8新特性</h2><h3 id="7-3-1、async-函数"><a href="#7-3-1、async-函数" class="headerlink" title="7.3.1、async 函数"></a>7.3.1、async 函数</h3><p>async 函数的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function <span class="title function_">fn</span><span class="params">()</span>&#123;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async 函数的返回值：</p><ol><li>返回的结果不是一个 Promise 类型的对象，返回的结果就是成功 Promise 对象 </li><li>返回的结果如果是一个 Promise 对象，具体需要看执行resolve方法还是reject方法 </li><li>抛出错误，返回的结果是一个失败的 Promise</li></ol><p>async 函数的演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//async 函数</span></span><br><span class="line">async function <span class="title function_">fn</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        resolve(<span class="string">&#x27;成功的数据&#x27;</span>);</span><br><span class="line">        <span class="comment">// reject(&quot;失败的错误&quot;);</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">result</span> <span class="operator">=</span> fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 then 方法</span></span><br><span class="line">result.then(value =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    console.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/74f290d199ade307d151a755ab01e17b.png" alt="img"></p><h3 id="7-3-2、await-表达式"><a href="#7-3-2、await-表达式" class="headerlink" title="7.3.2、await 表达式"></a>7.3.2、await 表达式</h3><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p><p>await 表达式的注意事项：</p><ol><li>await 必须写在 async 函数中 </li><li>await 右侧的表达式一般为 promise 对象 </li><li>await 返回的是 promise 成功的值 </li><li>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li></ol><p>await 表达式的语法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 promise 对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">    resolve(<span class="string">&quot;用户数据&quot;</span>);</span><br><span class="line">    <span class="comment">//reject(&quot;失败啦!&quot;);</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//await 要放在 async 函数中.</span></span><br><span class="line">async function <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="type">let</span> <span class="variable">result</span> <span class="operator">=</span> await p;</span><br><span class="line">        console.log(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   </span><br><span class="line">        console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">fun();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/665370c4fba5aaf2f16aa9be2888a375.png" alt="img"></p><p>await 表达式的案例演示：async与await封装AJAX请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 AJAX 请求, 返回的结果是 Promise 对象</span></span><br><span class="line">function <span class="title function_">sendAJAX</span><span class="params">(url)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//1. 创建对象</span></span><br><span class="line">        <span class="type">const</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="comment">//2. 初始化</span></span><br><span class="line">        x.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">        <span class="comment">//3. 发送</span></span><br><span class="line">        x.send();</span><br><span class="line">        <span class="comment">//4. 事件绑定</span></span><br><span class="line">        x.onreadystatechange = function () &#123;</span><br><span class="line">   </span><br><span class="line">            <span class="keyword">if</span> (x.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">   </span><br><span class="line">                <span class="keyword">if</span> (x.status &gt;= <span class="number">200</span> &amp;&amp; x.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">   </span><br><span class="line">                    resolve(x.response);<span class="comment">//成功</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">                    reject(x.status);<span class="comment">//失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// async 与 await 测试</span></span><br><span class="line">async function <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//发送 AJAX 请求 1</span></span><br><span class="line">    <span class="type">let</span> <span class="variable">joke</span> <span class="operator">=</span> await <span class="title function_">sendAJAX</span><span class="params">(<span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//发送 AJAX 请求 2</span></span><br><span class="line">    <span class="type">let</span> <span class="variable">tianqi</span> <span class="operator">=</span> await <span class="title function_">sendAJAX</span><span class="params">(<span class="string">&#x27;https://www.tianqiapi.com/api/?version=v1&amp;city=%E5%8C%97%E4%BA%AC&amp;appid=23941491&amp;appsecret=TXoD5e8P&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">    console.log(joke);</span><br><span class="line">    console.error(tianqi);<span class="comment">//为了区别数据，我这里用红色的error输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">fun();</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/9c96ad3b47b55f33fa84825ad4f7e477.png" alt="img"></p><h3 id="7-3-3、对象方法拓展"><a href="#7-3-3、对象方法拓展" class="headerlink" title="7.3.3、对象方法拓展"></a>7.3.3、对象方法拓展</h3><ul><li>Object.keys()方法返回一个给定对象的所有可枚举键值的数组 </li><li>Object.values()方法返回一个给定对象的所有可枚举属性值的数组 </li><li>Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">person</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象所有的键</span></span><br><span class="line">console.log(Object.keys(person));</span><br><span class="line"><span class="comment">//获取对象所有的值</span></span><br><span class="line">console.log(Object.values(person));</span><br><span class="line"><span class="comment">//获取对象所有的键值对数组</span></span><br><span class="line">console.log(Object.entries(person));</span><br><span class="line"><span class="comment">//创建 Map</span></span><br><span class="line"><span class="type">const</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Map</span>(Object.entries(person));</span><br><span class="line">console.log(m.get(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/c20a17fc761ee98ec76ce034011a45e1.png" alt="img"></p><p>Object.getOwnPropertyDescriptors方法返回指定对象所有自身属性的描述对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">person</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对象属性的描述对象</span></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明对象</span></span><br><span class="line"><span class="type">const</span> <span class="variable">obj</span> <span class="operator">=</span> Object.create(<span class="literal">null</span>, &#123;</span><br><span class="line">   </span><br><span class="line">    name: &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        value: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">        <span class="comment">//属性特性</span></span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//设置值</span></span><br><span class="line">        value: <span class="number">21</span>,</span><br><span class="line">        <span class="comment">//属性特性</span></span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//对象属性的描述对象</span></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(obj));</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ac3d28ba3178fa5429d4c5813e8f793c.png" alt="img"></p><h2 id="7-4、ECMAScript9新特性"><a href="#7-4、ECMAScript9新特性" class="headerlink" title="7.4、ECMAScript9新特性"></a>7.4、ECMAScript9新特性</h2><h3 id="7-4-1、对象拓展"><a href="#7-4-1、对象拓展" class="headerlink" title="7.4.1、对象拓展"></a>7.4.1、对象拓展</h3><p>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组，在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p><h4 id="7-4-1-1、对象展开"><a href="#7-4-1-1、对象展开" class="headerlink" title="7.4.1.1、对象展开"></a>7.4.1.1、对象展开</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">connect</span><span class="params">(&#123;</span></span><br><span class="line"><span class="params">   host, port, ...user&#125;)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    console.log(host);</span><br><span class="line">    console.log(port);</span><br><span class="line">    console.log(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect(&#123;</span><br><span class="line">   </span><br><span class="line">    host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    username: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;master&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6bb0e75ed9882ee4a65240839ac2c0e9.png" alt="img"></p><h4 id="7-4-1-2、对象合并"><a href="#7-4-1-2、对象合并" class="headerlink" title="7.4.1.2、对象合并"></a>7.4.1.2、对象合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="variable">skillOne</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    q: <span class="string">&#x27;天音波&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">skillTwo</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    w: <span class="string">&#x27;金钟罩&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">skillThree</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    e: <span class="string">&#x27;天雷破&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">skillFour</span> <span class="operator">=</span> &#123;</span><br><span class="line">   </span><br><span class="line">    r: <span class="string">&#x27;猛龙摆尾&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">mangseng</span> <span class="operator">=</span> &#123;</span><br><span class="line">   ...skillOne, ...skillTwo, ...skillThree, ...skillFour&#125;;</span><br><span class="line">console.log(mangseng);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0ad0c01503b55ce2c6f32b3f0a957f56.png" alt="img"></p><h3 id="7-4-2、正则表达式拓展"><a href="#7-4-2、正则表达式拓展" class="headerlink" title="7.4.2、正则表达式拓展"></a>7.4.2、正则表达式拓展</h3><h4 id="7-4-2-1、命名捕获分组"><a href="#7-4-2-1、命名捕获分组" class="headerlink" title="7.4.2.1、命名捕获分组"></a>7.4.2.1、命名捕获分组</h4><p>ES9 允许命名捕获组使用符号 ?<name> ，这样获取捕获结果可读性更强。使用数组下标不好吗？的确不好，因为如果一旦你想要获取的元素一旦增加，数组下标就改变了，所以建议使用命名捕获分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;打开百度，你就知道！&lt;/a&gt;&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="variable">reg</span> <span class="operator">=</span> /&lt;a href=<span class="string">&quot;(?&lt;url&gt;.*)&quot;</span>&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/;</span><br><span class="line"><span class="type">const</span> <span class="variable">result</span> <span class="operator">=</span> reg.exec(str);</span><br><span class="line">console.log(result.groups.url);</span><br><span class="line">console.log(result.groups.text);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8528a032da7517daba43b4ab38b9b2fd.png" alt="img"></p><h4 id="7-4-2-2、正向断言"><a href="#7-4-2-2、正向断言" class="headerlink" title="7.4.2.2、正向断言"></a>7.4.2.2、正向断言</h4><p>ES9 支持正向断言，通过对匹配结果后面的内容进行判断，对匹配进行筛选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明字符串</span></span><br><span class="line"><span class="type">let</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;订单编号开始123456789订单编号结束&quot;</span>;</span><br><span class="line"><span class="comment">//正向断言</span></span><br><span class="line"><span class="type">const</span> <span class="variable">reg</span> <span class="operator">=</span> /\d+(?=订单编号结束)/;<span class="comment">//也就是说数字的后边一定要跟着 订单编号结束</span></span><br><span class="line"><span class="type">const</span> <span class="variable">result</span> <span class="operator">=</span> reg.exec(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/8d7a1264a838ce36f9a422c549e50426.png" alt="img"></p><h4 id="7-4-2-3、反向断言"><a href="#7-4-2-3、反向断言" class="headerlink" title="7.4.2.3、反向断言"></a>7.4.2.3、反向断言</h4><p>ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明字符串</span></span><br><span class="line"><span class="type">let</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;订单编号开始123456789订单编号结束&quot;</span>;</span><br><span class="line"><span class="comment">//正向断言</span></span><br><span class="line"><span class="type">const</span> <span class="variable">reg</span> <span class="operator">=</span> /(?&lt;=订单编号开始)\d+/;<span class="comment">//也就是说数字的前边一定要跟着 订单编号开始</span></span><br><span class="line"><span class="type">const</span> <span class="variable">result</span> <span class="operator">=</span> reg.exec(str);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0ed065b20d34aa358c6632f1fb8e72dc.png" alt="img"></p><h4 id="7-4-2-4、dotAll模式"><a href="#7-4-2-4、dotAll模式" class="headerlink" title="7.4.2.4、dotAll模式"></a>7.4.2.4、dotAll模式</h4><p>正则表达式中点 . 匹配除回车外的任何单字符，标记 s 改变这种行为，允许行终止符出现，也就是dotAll模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">let</span> <span class="variable">str</span> <span class="operator">=</span> `</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">     &lt;li&gt;</span><br><span class="line">         &lt;a&gt;肖生克的救赎&lt;/a&gt;</span><br><span class="line">         &lt;p&gt;上映日期: <span class="number">1994</span>-09-<span class="number">10</span>&lt;/p&gt;</span><br><span class="line">         &lt;/li&gt;</span><br><span class="line">     &lt;li&gt;</span><br><span class="line">         &lt;a&gt;阿甘正传&lt;/a&gt;</span><br><span class="line">         &lt;p&gt;上映日期: <span class="number">1994</span>-<span class="number">07</span>-<span class="number">06</span>&lt;/p&gt;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;`;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明正则</span></span><br><span class="line"><span class="type">const</span> <span class="variable">reg</span> <span class="operator">=</span> /&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/gs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行匹配</span></span><br><span class="line">let result</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1、JavaScript的起源&quot;&gt;&lt;a href=&quot;#1-1、JavaScript的起源&quot; class=&quot;headerlink&quot; title=&quot;1.1、JavaScript的起源&quot;&gt;&lt;/a&gt;1.1、JavaScript的起源&lt;/h2&gt;&lt;p&gt;JavaScript</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://manamn.space/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://manamn.space/tags/JavaScript/"/>
    
    <category term="前端技术" scheme="https://manamn.space/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>代理模式你了解多少</title>
    <link href="https://manamn.space/2022/10/17/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/"/>
    <id>https://manamn.space/2022/10/17/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/</id>
    <published>2022-10-17T04:46:09.000Z</published>
    <updated>2022-12-13T13:04:38.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt=""></p><h2 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="代理模式：目标对象不可访问，通过代理对象增强功能访问。"><a href="#代理模式：目标对象不可访问，通过代理对象增强功能访问。" class="headerlink" title="代理模式：目标对象不可访问，通过代理对象增强功能访问。"></a>代理模式：目标对象不可访问，通过代理对象增强功能访问。</h3><blockquote><p>生活中：</p><p>房东                                  ====&gt;      目标对象</p><p>房屋中介                           ====&gt;      代理对象    </p><p>我们大家                           ====&gt;      客户端对象</p><p>服务生产商                        ====&gt;     目标对象</p><p>门店（旗舰店）                 ====&gt;     目标对象</p></blockquote><h3 id="什么是代理模式-？"><a href="#什么是代理模式-？" class="headerlink" title="什么是代理模式 ？"></a>什么是代理模式 ？</h3><p>​        代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下， 一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户和目标对象之间起到中介的作用。</p><p>​        换句话说，使用代理对象，是为了在不修改目标对象的基础上，增强主业务逻辑。客户类真正的想要访问的对象是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。</p><blockquote><p>例如： 有 A，B，C 三个类， A 原来可以调用 C 类的方法， 现在因为某种原因 C 类不允许A 类调用其方法，但 B 类可以调用 C 类的方法。A 类通过 B 类调用 C 类的方法。这里 B 是 C的代理。 A 通过代理 B 访问 C。</p></blockquote><p><strong>原来的访问关系</strong>：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210608597.png" alt="image-20220710210608597"></p><blockquote><p>Window 系统的快捷方式也是一种代理模式。快捷方式代理的是真实的程序，双击快捷方式是启动它代表的程序。</p></blockquote><h3 id="代理模式的作用"><a href="#代理模式的作用" class="headerlink" title="代理模式的作用"></a>代理模式的作用</h3><ul><li>控制目标对象的访问</li><li>增强功能</li></ul><h3 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h3><ul><li><code>静态代理</code></li><li><code>动态代理又分为JDK动态代理和CGlib动态代理</code></li></ul><h3 id="代理模式的实现方式"><a href="#代理模式的实现方式" class="headerlink" title="代理模式的实现方式"></a>代理模式的实现方式</h3><ul><li>静态代理实现</li><li>动态代理的实现又分为JDK代理和CGlib动态代理。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h3 id="静态代理的特点"><a href="#静态代理的特点" class="headerlink" title="静态代理的特点"></a>静态代理的特点</h3><blockquote><p> 静态代理要求目标对象和代理对象实现同一个业务接口。代理对象中的核心功能是由目标对象来完成，代理对象负责增强功能。</p></blockquote><h3 id="静态代理的实现"><a href="#静态代理的实现" class="headerlink" title="静态代理的实现"></a>静态代理的实现</h3><blockquote><p><strong>需求：</strong><br>有个明星(目标对象)很大腕，档期很满，我们想约这个明星来学校表演。我们只能通过他的助理来约他，助理就是（代理对象）。具体的时间、地点、场合、费用都只能跟助理来谈。助理完全负责明星的所有行程。并且安排明星来表演。</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210723708.png" alt="image-20220710210723708"></p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><h4 id="1-定义业务接口"><a href="#1-定义业务接口" class="headerlink" title="1. 定义业务接口"></a>1. 定义业务接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义业务接口 Service（目标对象和代理对象都要实现的业务接口）。</span><br><span class="line">    <span class="keyword">package</span> com.manman.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/18 21:46</span></span><br><span class="line"><span class="comment"> * description : 测试绑定业务功能的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个唱歌的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-定义目标实现类对象"><a href="#2-定义目标实现类对象" class="headerlink" title="2. 定义目标实现类对象"></a>2. 定义目标实现类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.manman.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/18 21:45</span></span><br><span class="line"><span class="comment"> * description :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperStarLiu</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是刘德华,我正在唱歌........ &quot;</span>  );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-定义代理实现类功能"><a href="#3-定义代理实现类功能" class="headerlink" title="3. 定义代理实现类功能"></a>3. 定义代理实现类功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.manman.service.Service;</span><br><span class="line"><span class="keyword">import</span> com.manman.service.impl.SuperStarLiu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/18 21:46</span></span><br><span class="line"><span class="comment"> * description :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是华仔的助理,正在预定时间.....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;我是华仔的助理,正在预定场地.....&quot;</span>);</span><br><span class="line"><span class="comment">//        创建刘德华对象</span></span><br><span class="line">        <span class="type">SuperStarLiu</span> <span class="variable">liu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperStarLiu</span>();</span><br><span class="line">        liu.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是华仔的助理,正在结算费用......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-测试类"><a href="#4-测试类" class="headerlink" title="4. 测试类"></a>4. 测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.manman.Agent;</span><br><span class="line"><span class="keyword">import</span> com.manman.service.Service;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/18 21:44</span></span><br><span class="line"><span class="comment"> * description :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于测试 : 静态代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Service</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">        agent.sing();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5. 运行结果"></a>5. 运行结果</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210702986.png" alt="image-20220710210702986"></p><h4 id="6-代理功能改造"><a href="#6-代理功能改造" class="headerlink" title="6. 代理功能改造"></a>6. 代理功能改造</h4><p>现在的代理类只能代理一个目标对象,不够灵活.如果需要代理多个目标对象,是可以使用面向接口编程.</p><p>  <strong>面向接口编程的要点:</strong></p><blockquote><p>A. 类中的成员变量设计为接口</p><p>B. 方法的参数设计为接口</p><p>C. 方法的返回值设计为接口</p><p>D. 调用时接口指向实现类</p></blockquote><p>  <strong>切记:上了接口就是上灵活.</strong></p><p><strong>改造后Agent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.manman.service.Service;</span><br><span class="line"><span class="keyword">import</span> com.manman.service.impl.SuperStarLiu;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/18 21:46</span></span><br><span class="line"><span class="comment"> * description :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"><span class="comment">//    将成员设置为接口类型</span></span><br><span class="line">    <span class="keyword">public</span> Service target;</span><br><span class="line"><span class="comment">//  提供有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(Service target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在预定时间.....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在预定场地.....&quot;</span>);</span><br><span class="line"><span class="comment">/*        创建刘德华对象</span></span><br><span class="line"><span class="comment">        SuperStarLiu liu = new SuperStarLiu();</span></span><br><span class="line"><span class="comment">        liu.sing();*/</span></span><br><span class="line">        target.sing();</span><br><span class="line">        System.out.println(<span class="string">&quot;正在结算费用......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><h4 id="代理复杂，难于管理"><a href="#代理复杂，难于管理" class="headerlink" title="代理复杂，难于管理"></a>代理复杂，难于管理</h4><blockquote><p>代理类和目标类实现了相同的接口，每个代理都需要实现目标的方法，这样就出现了大量的代码重复。如果接口增加了一个新的业务方法，除了所有目标类要实现这个方法以外，所有的代理类也需要实现这个方法。增加了代码维护的复杂度。</p></blockquote><h3 id="代理类依赖于目标类，代理类过多"><a href="#代理类依赖于目标类，代理类过多" class="headerlink" title="代理类依赖于目标类，代理类过多"></a>代理类依赖于目标类，代理类过多</h3><blockquote><p>代理类只服务于一种类型的目标类，如果要服务多个类型。势必要为每一种目标类都进行代理， 静态代理在程序规模稍大时就无法胜任了，代理类数量过多</p></blockquote><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote><p>动态代理是指代理类对象在程序运行时由 JVM 根据反射机制动态生成的。动态代理不需要定义代理类的.java 源文件。动态代理其实就是 jdk 运行期间，动态创建 class 字节码并加载到 JVM。动态代理的实现方式常用的有两种：使用 <code>JDK 动态代理</code>和 <code>CGLIB 动态代理</code>。</p></blockquote><p><strong>代理运行对象在程序运行的过程中动态的在内存进行构建，可以灵活的进行业务功能的切换。</strong></p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><blockquote><p>JDK动态代理是基于 Java 的反射机制实现的。使用 JDK中接口和类实现代理对象的动态创建。JDK的动态代理要求目标对象必须实现接口，而代理对象不必实现业务接口，这是 java 设计上的要求。从 jdk1.3 以来，java 语言通过 java.lang.reflect 包提供三个类和接口支持代理模式，它们分别Proxy, Method和 InvocationHandler。</p></blockquote><ul><li>目标对象必须实现业务接口</li><li>JDK代理代理对象不需要实现业务接口</li><li>动态代理的对象在程序运行中不存在</li><li>动态代理灵活的进行业务功能的切换</li></ul><h4 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h4><blockquote><p>通过JDK的java.lang.reflect.Proxy类实现动态代理，会使用其静态方法newProxyInstance()，依据目标对象、业务接口及调用处理器三者，自动生成一个动态代理对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">newProxyInstance</span> <span class="params">( ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">InvocationHandler handler)</span></span><br><span class="line">loader：目标类的类加载器，通过目标对象的反射可获取</span><br><span class="line">interfaces：目标类实现的接口数组，通过目标对象的反射可获取</span><br><span class="line">handler：调用处理器。</span><br></pre></td></tr></table></figure><h4 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h4><blockquote><p>invoke()方法的第二个参数为 Method 类对象，该类有一个方法也叫 invoke()，可以调用目标方法。这两个 invoke()方法，虽然同名，但无关。</p></blockquote><ul><li>反射用的类，用来进行目标的对象的方法的反射调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span> <span class="params">( Object obj, Object... args)</span></span><br><span class="line">obj：表示目标对象</span><br><span class="line">args：表示目标方法参数，就是其上一层 invoke 方法的第三个参数</span><br><span class="line">该方法的作用是：调用执行 obj 对象所属类的方法，这个方法由其调用者 Method 对象确定。在代码中，一般的写法为</span><br><span class="line">method.invoke(target, args);</span><br><span class="line">其中，method 为上一层 invoke 方法的第二个参数。这样，即可调用了目标类的目标方法。</span><br></pre></td></tr></table></figure><h4 id="IocationHandler接口"><a href="#IocationHandler接口" class="headerlink" title="IocationHandler接口"></a>IocationHandler接口</h4><blockquote><p>InvocationHandler 接口叫做调用处理器，负责完成调用目标方法，并增强功能。通过代理对象执行目标接口中的方法 ， 会把方法的调用分派给调用处理器(InvocationHandler)的实现类，执行实现类中的 invoke()方法，我们需要把功能代理写在 invoke（）方法中 。此接口中只有一个方法。</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210804260.png" alt="image-20220710210804260"></p><blockquote><p>在 invoke 方法中可以截取对目标方法的调用。在这里进行功能增强。Java 的动态代理是建立在反射机制之上的。实现了 InvocationHandler 接口的类用于加强目标类的主业务逻辑。这个接口中有一个方法 invoke()，具体加强的代码逻辑就是定义在该方法中的。通过代理对象执行接口中的方法时，会自动调用 invoke()方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">invoke()方法的介绍如下：</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span> <span class="params">( Object proxy, Method method, Object[] args)</span></span><br><span class="line">proxy：代表生成的代理对象</span><br><span class="line">method：代表目标方法</span><br><span class="line">args：代表目标方法的参数</span><br><span class="line">第一个参数 proxy 是 jdk 在运行时赋值的，在方法中直接使用，第二个参数后面介绍，</span><br><span class="line">第三个参数是方法执行的参数， 这三个参数都是 jdk 运行时赋值的，无需程序员给出。</span><br></pre></td></tr></table></figure><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>代理对象不需要实现接口。</li><li>代理对象的生成是利用JDK中的proxy类，动态的在内存中构建代理对象。</li></ol><ol><li><p>代码实现接口</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210817906.png" alt="image-20220710210817906"></p></li><li><p>ProxyFactory.java代理实例生成工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.manman.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/19 11:34</span></span><br><span class="line"><span class="comment"> * description : 代理工厂演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任何的代理对象，都要清楚目标对象，在此得设置一个目标对象，</span></span><br><span class="line">        <span class="keyword">private</span> Service superStar;</span><br><span class="line">        <span class="comment">//传入目标对象</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Service superStar)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.superStar=superStar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//给目标对象生成代理实例</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Proxy.newProxyInstance(</span><br><span class="line">                    <span class="comment">//指定当前目标对象，使用类加载器获得</span></span><br><span class="line">                    superStar.getClass().getClassLoader(),</span><br><span class="line">                    <span class="comment">//获得目标对象实现的所有接口</span></span><br><span class="line">                    superStar.getClass().getInterfaces(),</span><br><span class="line">                    <span class="comment">//处理代理实例上的方法并返回调用结果</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(</span></span><br><span class="line"><span class="params">                                //代理对象的实例</span></span><br><span class="line"><span class="params">                                Object proxy,</span></span><br><span class="line"><span class="params">                                //代理的目标对象的实现方法</span></span><br><span class="line"><span class="params">                                Method method,</span></span><br><span class="line"><span class="params">                                //代理的目标对象实现方法的参数</span></span><br><span class="line"><span class="params">                                Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;预定场地..........&quot;</span>);</span><br><span class="line">                            System.out.println(<span class="string">&quot;预定时间..........&quot;</span>);</span><br><span class="line">                            <span class="comment">//目标对象执行自己的方法</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(superStar, args);</span><br><span class="line">                            System.out.println(<span class="string">&quot;结帐走人.........&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> returnValue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                        <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.manman.proxy.ProxyFactory;</span><br><span class="line"><span class="keyword">import</span> com.manman.service.Service;</span><br><span class="line"><span class="keyword">import</span> com.manman.service.impl.SuperStarZhou;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 满满</span></span><br><span class="line"><span class="comment"> * createDate 2022/6/19 11:33</span></span><br><span class="line"><span class="comment"> * description : JDK动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用于测试 : JDK动态代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">SuperStarZhou</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Service</span> <span class="variable">agent</span> <span class="operator">=</span> (Service) factory.getProxyInstance();</span><br><span class="line">        agent.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li>结果截图</li></ol><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210828899.png" alt="image-20220710210828899"></p><blockquote><p>注意：JDK动态代理中，代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用JDK动态代理。</p></blockquote><h3 id="CGlib（Code-Generation-Library）动态代理"><a href="#CGlib（Code-Generation-Library）动态代理" class="headerlink" title="CGlib（Code Generation Library）动态代理"></a>CGlib（Code Generation Library）动态代理</h3><ul><li>又称为子类通过动态的的在内存中构建子类对象，重写父类方法进行代理功能的增强。</li></ul><blockquote><p>想要功能扩展，但目标对象没有实现接口，怎样功能扩展？</p><p>解决方案：<strong>子类的方式</strong></p><p>​    Class subclass  extends  UserDao{}</p><p>以子类的方式实现(cglib代理)，在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p></blockquote><h3 id="CGlib动态代理的特点"><a href="#CGlib动态代理的特点" class="headerlink" title="CGlib动态代理的特点"></a>CGlib动态代理的特点</h3><ol><li>JDK动态代理有一个限制，就是使用动态代理的目标对象必须实现一个或多个接口。如果想代理没有实现类的接口，就可以使用CGLIB进行代理。</li><li>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception。 </li><li><code>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类</code>。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</li></ol><h3 id="CGLIB的实现步骤"><a href="#CGLIB的实现步骤" class="headerlink" title="CGLIB的实现步骤"></a>CGLIB的实现步骤</h3><ol><li>需要spring-core-5.2.5.jar依赖即可。</li><li>引入功能包后，就可以在内存中动态构建子类</li><li>被代理的类不能为final， 否则报错。</li><li>目标对象的方法如果为final/static, 那么就不会被拦截，即不会执行目标对象额外的业务方法。</li><li>代码实现结构</li></ol><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210840937.png" alt="image-20220710210840937"></p><p>​    <strong>ProxyFactory.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"><span class="comment">//传入目标对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.target=target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cglib采用底层的字节码技术，在子类中采用方法拦截的技术，拦截父类指定方法的调用，并顺势植入代理功能的代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] arg2, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//代理对象的功能</span></span><br><span class="line">System.out.println(<span class="string">&quot;预定场地............&quot;</span>);</span><br><span class="line"><span class="comment">//调用目标对象的方法</span></span><br><span class="line">Object returnValue=method.invoke(target, arg2);</span><br><span class="line"><span class="comment">//代理对象的功能</span></span><br><span class="line">System.out.println(<span class="string">&quot;结帐走人............&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//1.使用工具类</span></span><br><span class="line">Enhancer en=<span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"><span class="comment">//2.设置父类</span></span><br><span class="line">en.setSuperclass(target.getClass());</span><br><span class="line"><span class="comment">//3.设置回调函数</span></span><br><span class="line">en.setCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//4.创建子类（代理）对象</span></span><br><span class="line"><span class="keyword">return</span> en.create();</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCglibProxy</span><span class="params">()</span>&#123;</span><br><span class="line">SuperStar superStar=<span class="keyword">new</span> <span class="title class_">SuperStar</span>();</span><br><span class="line">System.out.println(superStar.getClass());</span><br><span class="line">SuperStar proxy=(SuperStar) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(superStar).getProxyInstance();</span><br><span class="line">System.out.println(proxy.getClass());</span><br><span class="line">proxy.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p><strong>面向接口编程的四大注意事项：</strong></p><ul><li>类中的成员方法设置为接口</li><li>方法的参数设置为接口</li><li>方法的返回值设置为接口</li><li>使用时接口指向实现类</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220710210957447.png" alt="image-20220710210957447" style="zoom:200%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https://blog.csdn.net/qq_58608526</summary>
      
    
    
    
    <category term="开发必备框架" scheme="https://manamn.space/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="开发必备框架" scheme="https://manamn.space/tags/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Maven学习笔记</title>
    <link href="https://manamn.space/2022/10/17/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://manamn.space/2022/10/17/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-10-17T04:45:25.000Z</published>
    <updated>2022-12-13T12:59:43.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven学习笔记"><a href="#Maven学习笔记" class="headerlink" title="Maven学习笔记"></a>Maven学习笔记</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.png" alt=""></p><h1 id="第1章-为什么要使用Maven"><a href="#第1章-为什么要使用Maven" class="headerlink" title="第1章 为什么要使用Maven"></a>第1章 为什么要使用Maven</h1><p>之所以会提出这个问题，是因为即使不使用Maven我们仍然可以进行B/S结构项目的开发。</p><p>从表述层、业务逻辑层到持久化层再到数据库都有成熟的解决方案——不使用Maven我们一样可以开发项目啊？</p><p>所以我们有必要通过企业开发中的实际需求来看一看哪些方面是我们现有技术的不足。</p><h2 id="1-1-获取第三方jar包"><a href="#1-1-获取第三方jar包" class="headerlink" title="1.1 获取第三方jar包"></a>1.1 获取第三方jar包</h2><p>开发中需要使用到的jar包种类繁多，获取jar包的方式都不尽相同。为了查找一个jar包找遍互联网，身心俱疲。不仅如此，费劲心血找到的jar包里有的时候并没有你需要的那个类，又或者有同名的类没有你要的方法——以不规范的方式获取的jar包也往往是不规范的。</p><p>使用Maven我们可以享受到一个完全规范的jar包管理系统。你只需要在你的项目中以坐标的形式依赖一个jar包，Maven就会自动去中央仓库进行下载，并同时下载这个jar包所依赖的其他jar包—-规范、完整、准确！一次性解决所有问题！这也就是我们选择Maven的原因之一吧。</p><p>​    </p><h2 id="1-2-添加第三方jar包"><a href="#1-2-添加第三方jar包" class="headerlink" title="1.2 添加第三方jar包"></a>1.2 添加第三方jar包</h2><p>在今天开发领域，有大量的第三方框架和工具可以供我们使用。要使用这些jar包最简单的方法就是复制粘贴到WEB-INF目录下的lib目录下。但是这会导致每次创建一个新的工程就需要将jar包重复复制到lib目录下，从而造成工作区中存在大量重复的文件。</p><blockquote><p>而使用Maven后每个jar包都会在Maven本地仓库中保存一份，需要jar包的工程只需要维护一个文本形式的jar包的引用—-我们称之为 <code>坐标</code>。不仅极大的节约了我们电脑的存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</p></blockquote><h2 id="1-3-jar包之间的依赖关系"><a href="#1-3-jar包之间的依赖关系" class="headerlink" title="1.3 jar包之间的依赖关系"></a>1.3 jar包之间的依赖关系</h2><p>jar包往往不是孤立存在的，很多jar包都需要在其他jar包的支持下才能够正常工作，我们称之为jar包之间的依赖关系。最典型的例子是：commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar，如果没有IO包，FileUpload包就不能正常工作。</p><p>那么问题来了，你知道你所使用的所有jar包的依赖关系吗？当你拿到一个新的从未使用过的jar包，你如何得知他需要哪些jar包的支持呢？如果不了解这个情况，导入的jar包不够，那么现有的程序将不能正常工作。再进一步，当你的项目中需要用到上百个jar包时，你还会人为的，手工的逐一确认它们依赖的其他jar包吗？这简直是不可想象的</p><blockquote><p>而引入Maven后，Maven就可以替代我们自动将当前的jar包所依赖的其他所有jar包全部导进来，不需要我们自己再导了，节约了我们大量的时间和精力。用实际例子来说明就是：通过Maven导入commons-fileupload-1.3.jar后，commons-io-2.0.1.jar会被自动导入，程序员不必了解这个依赖关系。</p></blockquote><h2 id="1-4-处理jar包之间的冲突"><a href="#1-4-处理jar包之间的冲突" class="headerlink" title="1.4 处理jar包之间的冲突"></a>1.4 处理jar包之间的冲突</h2><p>上一点说的是jar包不足项目无法正常工作，但其实有的时候jar包多了项目仍然无法正常工作，这就是jar包之间的冲突。</p><p>举个例子：我们现在有三个工程MakeFriend、HelloFriend、和Hello。MakeFriend依赖HelloFriend，HelloFriend依赖Hello。而Hello依赖log4j.1.2.17.jar，HelloFriend依赖log4j.1.2.14.jar。如下图所示：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220917154032704.png" alt="image-20220917154032704"></p><p>那么MakeFriend工程的运行时环境中该导入log4j.1.2.14.jar呢还是log4j.1.2.17.jar呢？</p><p>这样的问题一个两个还可以手工解决，但如果系统中存在几十上百的jar包，他们之间的依赖关系会非常复杂，几乎不可能手工实现依赖关系的梳理。</p><p><strong>使用Maven就可以自动的处理jar包的冲突问题。</strong>因为Maven中内置了两条依赖原则：</p><blockquote><p>最短路径者优先和先声明者优先，上述问题MakeFriend工程会自动使用log4j.1.2.14.jar。</p></blockquote><h2 id="1-5-将项目拆分为多个工程模块"><a href="#1-5-将项目拆分为多个工程模块" class="headerlink" title="1.5 将项目拆分为多个工程模块"></a>1.5 将项目拆分为多个工程模块</h2><p>随着JavaEE项目的规模越来越庞大，开发团队的规模也与日俱增。一个项目上千人的团队持续开发很多年对于JavaEE项目来说再正常不过。那么我们想象一下：几百上千的人开发的项目是同一个Web工程。那么架构师、项目经理该如何划分项目的模块、如何分工呢？这么大的项目已经不可能通过package结构来划分模块，必须将项目拆分成多个工程协同开发。多个模块工程中有的是Java工程，有的是Web工程。</p><p>那么工程拆分后又如何进行互相调用和访问呢？这就需要用到Maven的依赖管理机制。大家请看调查项目拆分的情况：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220917154313569.png" alt="image-20220917154313569"></p><p>下层模块依赖上层，所以上层模块中定义的API都可以为下层所调用和访问。</p><h2 id="1-6-实现项目的分布式部署"><a href="#1-6-实现项目的分布式部署" class="headerlink" title="1.6 实现项目的分布式部署"></a>1.6 实现项目的分布式部署</h2><p>在实际生产环境中，项目规模增加到一定程度后，可能每个模块都需要运行在独立的服务器上，我们称之为分布式部署，这里同样需要用到Maven。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps49.jpg" alt="img"></p><h1 id="第2章-Maven是什么-？"><a href="#第2章-Maven是什么-？" class="headerlink" title="第2章 Maven是什么 ？"></a>第2章 Maven是什么 ？</h1><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps50.jpg" alt="img"></p><p>如果上面的描述能够使你认识到使用Maven是多么的重要，我们下面就来介绍一下Maven是什么</p><h2 id="2-1-自动化构建"><a href="#2-1-自动化构建" class="headerlink" title="2.1 自动化构建"></a>2.1 自动化构建</h2><p>1) Maven这个单词的本意是：专家，内行。读音是[‘meɪv(ə)n]或[‘mevn]，不要读作“妈文”。</p><p>2) Maven是一款自动化构建工具，专注服务于Java平台的项目构建和依赖管理。在JavaEE开发的历史上构建工具的发展也经历了一系列的演化和变迁：</p><p>Make→Ant→Maven→Gradle→其他……</p><h2 id="2-2-构建的概念"><a href="#2-2-构建的概念" class="headerlink" title="2.2 构建的概念"></a>2.2 构建的概念</h2><p>1) 构建并不是创建，创建一个工程并不等于构建一个项目。<strong>构建是一个过程，</strong> 就是以我们编写的Java代码、框架配置文件、国际化等其他资源文件、JSP页面和图片等静态资源作为“<strong>原材料</strong>，去生产<strong>出一个可以运行的</strong>项目的过程。</p><p>那么项目构建的全过程中都包含哪些环节呢？</p><h2 id="2-3-构建环节"><a href="#2-3-构建环节" class="headerlink" title="2.3 构建环节"></a>2.3 构建环节</h2><p>1) 清理：删除以前的编译结果，为重新编译做好准备。</p><p>2) 编译：将Java源程序编译为字节码文件。</p><p>3) 测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。</p><p>4) 报告：在每一次测试后以标准的格式记录和展示测试结果。</p><p>5) 打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对应war包。</p><p>6) 安装：在Maven环境下特指将打包的结果——jar包或war包安装到本地仓库中。</p><p>7) 部署：将打包的结果部署到远程仓库或将war包部署到服务器上运行。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps51.jpg" alt="img"> </p><h1 id="第3章-Maven如何使用-？"><a href="#第3章-Maven如何使用-？" class="headerlink" title="第3章  Maven如何使用 ？"></a>第3章  Maven如何使用 ？</h1><p>在这一节中，我们来看看Maven核心程序的安装和本地仓库的必要设置。然后我们就可以编写第一个Maven程序了。</p><h2 id="3-1-安装Maven核心程序"><a href="#3-1-安装Maven核心程序" class="headerlink" title="3.1 安装Maven核心程序"></a>3.1 安装Maven核心程序</h2><p>1) 下载地址：<a href="http://maven.apache.org/">http://maven.apache.org/</a></p><p>2) 检查JAVA_HOME环境变量。Maven是使用Java开发的，所以必须知道当前系统环境中JDK的安装目录。</p><p>C:\Users\lemon&gt;echo %JAVA_HOME%D:\Java\jdk1.8.0_111</p><p>1) 解压Maven的核心程序。</p><p>将apache-maven-3.8.4-bin.zip解压到一个<strong>非中文无空格</strong>的目录下。例如：</p><p>D:\apache-maven-3.6.4</p><p>2) 配置环境变量。</p><div class="table-container"><table><thead><tr><th>MAVEN_HOME</th></tr></thead><tbody><tr><td>D:\apache-maven-3.6.4</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>path</th></tr></thead><tbody><tr><td>%MAVEN_HOME%\bin</td></tr></tbody></table></div><p>3) ④查看Maven版本信息验证安装是否正确</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220917154952892.png" alt="image-20220917154952892"></p><h2 id="3-2-第一个Maven程序"><a href="#3-2-第一个Maven程序" class="headerlink" title="3.2 第一个Maven程序"></a>3.2 第一个Maven程序</h2><h3 id="3-2-1-Maven约定的目录结构以及说明"><a href="#3-2-1-Maven约定的目录结构以及说明" class="headerlink" title="3.2.1 Maven约定的目录结构以及说明"></a>3.2.1 Maven约定的目录结构以及说明</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220917155152890.png" alt="image-20220917155152890"></p><blockquote><p>main目录用于存放主程序。</p><p>test目录用于存放测试程序。</p><p>java目录用于存放源代码文件。</p><p>resources目录用于存放配置文件和资源文件。</p></blockquote><h3 id="3-2-3-通过命令行的方式运行Maven程序"><a href="#3-2-3-通过命令行的方式运行Maven程序" class="headerlink" title="3.2.3 通过命令行的方式运行Maven程序"></a>3.2.3 通过命令行的方式运行Maven程序</h3><p>1) 在电脑的任意位置创建Hello目录（文件夹）</p><p>2) 在Hello目录中创建src目录和pom.xml文件</p><p>3) 在src目录中创建main和test目录</p><p>4) 在main和test目录中分别创建java和resources目录</p><p>5) 将以下内容复制到pom.xml文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.manman.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6) 编写主程序</p><p>在src/main/java目录下新建文件Hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name+<span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7) 编写测试程序</p><p>在/src/test/java目录下新建测试文件HelloTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">maven</span> <span class="operator">=</span> hello.sayHello(<span class="string">&quot;Maven&quot;</span>);</span><br><span class="line">        System.out.println(maven);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8) 运行以下常用的Maven命令</p><p>打开cmd命令行，进入Hello项目根目录(pom.xml文件所在目录)执行mvn compile命令，查看根目录变化cmd 中继续录入mvn clean命令，然后再次查看根目录变化cmd 中录入 mvn  compile命令, 查看根目录变化cmd 中录入 mvn  test-compile命令， 查看target目录的变化cmd 中录入 mvn  test命令，查看target目录变化cmd 中录入 mvn  package命令,查看target目录变化cmd 中录入 mvn  install命令， 查看本地仓库的目录变化</p><blockquote><p>注意：运行Maven命令时一定要进入pom.xml文件所在的目录！</p></blockquote><h2 id="3-3-在IDEA中使用Maven"><a href="#3-3-在IDEA中使用Maven" class="headerlink" title="3.3 在IDEA中使用Maven"></a>3.3 在IDEA中使用Maven</h2><h3 id="3-3-1-在IDEA中配置Maven"><a href="#3-3-1-在IDEA中配置Maven" class="headerlink" title="3.3.1 在IDEA中配置Maven"></a>3.3.1 在IDEA中配置Maven</h3><p>dea中也自带Maven插件，而且我们也可以给自带的Maven插件进行配置，所以我们可以使用自带的Maven，也可以使用我们安装的Maven核心程序</p><p>1) 配置自带的Maven插件</p><p>1) Idea自带的Maven在Idea的安装目录的plugins目录中</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps52.jpg" alt="img"> </p><p>2) 在自带的Maven里配置了本地仓库之后打开Idea之后会发现本地仓库自动变成了我们设置的仓库</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps53.jpg" alt="img"> </p><p>3) 设置Maven自动导包</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps54.jpg" alt="img"> </p><p>2) 配置我们自己安装的Maven</p><p>1) 点击工具栏中的Settings</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps55.jpg" alt="img"> </p><p>2) 点击OK保存即可</p><h4 id="3-4-2在Idea中创建Maven项目"><a href="#3-4-2在Idea中创建Maven项目" class="headerlink" title="3.4.2在Idea中创建Maven项目"></a>3.4.2在Idea中创建Maven项目</h4><p>1) 点击File→New→Module…（如果之前没有Project选Project）→Maven</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps56.jpg" alt="img"> </p><p>2) 点击Next，配置要继承的模块（如果直接创建的是Project不存在这一项）、坐标（GAV）、路径。不同的Idea版本可能有所差别，我使用的是2019.3.3的版本</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps57.jpg" alt="img"> </p><p>3) 点击Finish即可创建成功</p><p>4) 创建完工程之后在settings→Build，Execusion，Development→Compiler→Java Compiler中发现默认的JDK的编译版本是1.5，在Maven的核心配置文件settings.xml文件中添加以下配置将编译版本改为1.8，重启Idea即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>5) 配置Maven的核心配置文件pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6) 编写主代码</p><p>在src/<strong>main</strong>/java目录下新建文件Hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atmanman.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name+<span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7) 编写测试代码</p><p>​    在/src/<strong>test</strong>/java目录下新建测试文件HelloTest.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.atmanman.maven;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class HelloTest &#123;</span><br></pre></td></tr></table></figure><p>8) 使用Maven的方式运行Maven工程</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps58.jpg" alt="img"> </p><h4 id="3-4-3在Idea中导入Maven项目"><a href="#3-4-3在Idea中导入Maven项目" class="headerlink" title="3.4.3在Idea中导入Maven项目"></a>3.4.3在Idea中导入Maven项目</h4><p>1) 点击Project Structure</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps59.jpg" alt="img"> </p><p>2) 点击Modules→➕→Import Module</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps60.jpg" alt="img"> </p><p>3) 找到项目所在的位置</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps61.jpg" alt="img"> </p><p>4) 选择Import module from external model（从外部模型导入模块）→Maven→Finish</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps62.jpg" alt="img"></p><h2 id="3-4-Maven的联网问题"><a href="#3-4-Maven的联网问题" class="headerlink" title="3.4 Maven的联网问题"></a>3.4 Maven的联网问题</h2><p>1) 配置本地仓库</p><p>1) Maven的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插件来完成。Maven核心程序会到本地仓库中查找插件。如果本地仓库中没有就会从远程中央仓库下载。此时如果不能上网则无法执行Maven的具体功能。为了解决这个问题，我们可以将Maven的本地仓库指向一个在联网情况下下载好的目录。</p><p>2) Maven默认的本地仓库：~.m2\repository目录。</p><p>Tips：~表示当前用户的家目录。</p><p>3) Maven的核心配置文件位置：</p><p>解压目录D:\apache-maven-3.6.3\conf\settings.xml</p><p>4) 设置方式</p><div class="table-container"><table><thead><tr><th><localRepository>以及准备好的仓库位置</localRepository></th></tr></thead><tbody><tr><td><localRepository>D:\LocalRepository</localRepository></td></tr></tbody></table></div><p>5) 为了以后下载jar包方便，配置阿里云镜像</p><p>将以下标签配置到<mirrors></mirrors>标签里面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="第4章-Maven的核心概念"><a href="#第4章-Maven的核心概念" class="headerlink" title="第4章 Maven的核心概念"></a>第4章 Maven的核心概念</h1><h2 id="4-1-核心概念"><a href="#4-1-核心概念" class="headerlink" title="4.1 核心概念"></a>4.1 核心概念</h2><p>1) POM</p><p>2) 约定的目录结构</p><p>3) 插件和目标</p><p>4) 生命周期</p><p>5) 仓库</p><p>6) 坐标</p><p>7) 依赖</p><p>8) 继承</p><p>9) 聚合</p><h2 id="4-2-POM"><a href="#4-2-POM" class="headerlink" title="4.2 POM"></a>4.2 POM</h2><p>Project Object Model：项目对象模型。将Java工程的相关信息封装为对象作为便于操作和管理的模型。Maven工程的核心配置。可以说学习Maven就是学习pom.xml文件中的配置。</p><h2 id="4-3-约定的目录结构"><a href="#4-3-约定的目录结构" class="headerlink" title="4.3 约定的目录结构"></a>4.3 约定的目录结构</h2><p>现在JavaEE开发领域普遍认同一个观点：约定&gt;配置&gt;编码。意思就是能用配置解决的问题就不编码，能基于约定的就不进行配置。而Maven正是因为指定了特定文件保存的目录才能够对我们的Java工程进行自动化构建。</p><h2 id="4-4-插件和目标"><a href="#4-4-插件和目标" class="headerlink" title="4.4 插件和目标"></a>4.4 插件和目标</h2><p>1) Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。</p><p>2) 每个插件都能实现多个功能，每个功能就是一个插件目标。</p><p>3) Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。</p><p>例如：compile就是插件maven-compiler-plugin的一个功能；pre-clean是插件maven-clean-plugin的一个目标。</p><h2 id="4-5-生命周期"><a href="#4-5-生命周期" class="headerlink" title="4.5 生命周期"></a>4.5 生命周期</h2><p>1) 什么是Maven的生命周期？</p><p>Maven生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven就可以自动化的执行构建命令了。</p><p>Maven有三套相互独立的生命周期，分别是： </p><p>Clean Lifecycle在进行真正的构建之前进行一些清理工作。</p><p>Default Lifecycle构建的核心部分，编译，测试，打包，安装，部署等等。</p><p>Site Lifecycle生成项目报告，站点，发布站点。</p><p>再次强调一下它们是<strong>相互独立的</strong>，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 <strong>mvn clean install site</strong> 运行所有这三套生命周期。</p><p>每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean，这个clean是Clean生命周期的一个阶段。有Clean生命周期，也有clean阶段。</p><p>2) clean生命周期</p><p>Clean生命周期一共包含了三个阶段：</p><p>pre-clean 执行一些需要在clean之前完成的工作 </p><p>clean 移除所有上一次构建生成的文件 </p><p>post-clean 执行一些需要在clean之后立刻完成的工作 </p><p>3) Site生命周期</p><p>​    pre-site 执行一些需要在生成站点文档之前完成的工作</p><p>​    site 生成项目的站点文档</p><p>​    post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</p><p>​    site-deploy 将生成的站点文档部署到特定的服务器上</p><p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。</p><p>4) Default生命周期</p><p>Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：</p><p>validate</p><p>generate-sources</p><p>process-sources</p><p>generate-resources</p><p>process-resources 复制并处理资源文件，至目标目录，准备打包。</p><p><strong>compile</strong> 编译项目的源代码。</p><p>process-classes</p><p>generate-test-sources</p><p>process-test-sources</p><p>generate-test-resources</p><p>process-test-resources 复制并处理资源文件，至目标测试目录。</p><p><strong>test-compile</strong> 编译测试源代码。</p><p>process-test-classes</p><p><strong>test</strong> 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</p><p>prepare-package</p><p><strong>package</strong> 接受编译好的代码，打包成可发布的格式，如JAR。</p><p>pre-integration-test</p><p>integration-test</p><p>post-integration-test</p><p>verify</p><p><strong>install</strong>将包安装至本地仓库，以让其它项目依赖。</p><p>deploy将最终的包复制到远程的仓库，以让其它开发人员与项目共享或部署到服务器上运行。</p><p>5) 生命周期与自动化构建</p><p><strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，例如我们运行mvn install 的时候，代码会被编译，测试，打包。这就是Maven为什么能够自动执行构建过程的各个环节的原因。此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。</p><h2 id="4-6-仓库"><a href="#4-6-仓库" class="headerlink" title="4.6 仓库"></a>4.6 仓库</h2><p>1) 分类</p><p>① 本地仓库：为当前本机电脑上的所有Maven工程服务。</p><p>② 远程仓库</p><p>[1] 私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220917160305967.png" alt="image-20220917160305967"></p><p>[2]中央仓库：架设在Internet上，为全世界所有Maven工程服务。</p><p>[3]中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。</p><p>1) 仓库中的文件</p><p>① Maven的插件</p><p>② 我们自己开发的项目的模块</p><p>③ 第三方框架或工具的jar包</p><p>​    ※不管是什么样的jar包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。</p><h2 id="4-7-坐标"><a href="#4-7-坐标" class="headerlink" title="4.7 坐标"></a>4.7 坐标</h2><p>1) 几何中的坐标</p><p>[1]在一个平面中使用x、y两个向量可以唯一的确定平面中的一个点。</p><p>[2]在空间中使用x、y、z三个向量可以唯一的确定空间中的一个点。</p><p>2) Maven的坐标</p><p>使用如下三个向量在Maven的仓库中唯一的确定一个Maven工程。</p><p>[1]groupId：公司或组织的域名倒序+当前项目名称</p><p>[2]artifactId：当前项目的模块名称</p><p>[3]version：当前模块的版本</p><p>​    &lt;<strong>g</strong>roupId&gt;com.atguigu.maven&lt;/groupId&gt;    &lt;<strong>a</strong>rtifactId&gt;Hello&lt;/artifactId&gt;    &lt;<strong>v</strong>ersion&gt;1.0-SNAPSHOT&lt;/version&gt;</p><p>3) 如何通过坐标到仓库中查找jar包？</p><p>[1]将gav三个向量连起来</p><p>com.atmanman.maven+Hello+1.0-SNAPSHOT</p><p>[2]以连起来的字符串作为目录结构到仓库中查找</p><p>com/atmanman/maven/Hello/1.0-SNAPSHOT/Hello<strong>-</strong>1.0-SNAPSHOT.jar</p><blockquote><p>※注意：我们自己的Maven工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</p></blockquote><h2 id="4-8-第二个Maven程序"><a href="#4-8-第二个Maven程序" class="headerlink" title="4.8 第二个Maven程序"></a>4.8 第二个Maven程序</h2><h2 id="4-9-依赖管理"><a href="#4-9-依赖管理" class="headerlink" title="4.9 依赖管理"></a>4.9 依赖管理</h2><p>1) 基本概念</p><p>当A jar包需要用到B jar包中的类时，我们就说A对B有依赖。例如：commons-fileupload-1.3.jar依赖于commons-io-2.0.1.jar。</p><p>通过第二个Maven工程我们已经看到，当前工程会到本地仓库中根据坐标查找它所依赖的jar包。</p><p>配置的基本形式是使用dependency标签指定目标jar包的坐标。例如：</p><p>2) 直接依赖和间接依赖</p><p>如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。</p><h3 id="4-9-1-依赖的范围"><a href="#4-9-1-依赖的范围" class="headerlink" title="4.9.1 依赖的范围"></a>4.9.1 依赖的范围</h3><p>1) compile（默认就是这个范围）</p><blockquote><p>[1]main目录下的Java代码<strong>可以</strong>访问这个范围的依赖</p><p>[2]test目录下的Java代码<strong>可以</strong>访问这个范围的依赖</p><p>[3]部署到Tomcat服务器上运行时<strong>要</strong>放在WEB-INF的lib目录下</p></blockquote><p>例如：对Hello的依赖。主程序、测试程序和服务器运行时都需要用到。</p><p>2) test</p><blockquote><p>[1]main目录下的Java代码<strong>不能</strong>访问这个范围的依赖</p><p>[2]test目录下的Java代码<strong>可以</strong>访问这个范围的依赖</p><p>[3]部署到Tomcat服务器上运行时<strong>不会</strong>放在WEB-INF的lib目录下</p></blockquote><p>例如：对junit的依赖。仅仅是测试程序部分需要。</p><p>3) provided</p><blockquote><p>[1]main目录下的Java代码<strong>可以</strong>访问这个范围的依赖</p><p>[2]test目录下的Java代码<strong>可以</strong>访问这个范围的依赖</p><p>[3]部署到Tomcat服务器上运行时<strong>不会</strong>放在WEB-INF的lib目录下</p></blockquote><p>例如：servlet-api在服务器上运行时，Servlet容器会提供相关API，所以部署的时候不需要。</p><p>4) 其他：runtime、import、system等。</p><p>各个依赖范围的作用可以概括为下图：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps63.jpg" alt="img"></p><h3 id="4-9-2"><a href="#4-9-2" class="headerlink" title="4.9.2"></a>4.9.2</h3><p>当存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这要看间接依赖的jar包引入时的依赖范围——只有依赖范围为compile时可以访问，即依赖范围是compile时才具有传递性。例如：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Maven工程</th><th>依赖范围</th><th>对A的可见性</th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">A</td><td>B</td><td>C</td><td>compile</td><td>√</td></tr><tr><td style="text-align:left"></td><td></td><td>D</td><td>test</td><td>×</td></tr><tr><td style="text-align:left"></td><td></td><td>E</td><td>provided</td><td>×</td></tr></tbody></table></div><h3 id="4-9-3-结局依赖的原则-：结局jar包冲突"><a href="#4-9-3-结局依赖的原则-：结局jar包冲突" class="headerlink" title="4.9.3 结局依赖的原则 ：结局jar包冲突"></a>4.9.3 结局依赖的原则 ：结局jar包冲突</h3><h4 id="1-路径最短者优先"><a href="#1-路径最短者优先" class="headerlink" title="1. 路径最短者优先"></a>1. 路径最短者优先</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220925111139067.png" alt="image-20220925111139067"></p><h4 id="2-路径相同时先声明者优先"><a href="#2-路径相同时先声明者优先" class="headerlink" title="2. 路径相同时先声明者优先"></a>2. 路径相同时先声明者优先</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220925111212347.png" alt="image-20220925111212347"></p><h3 id="4-9-4-依赖的排除"><a href="#4-9-4-依赖的排除" class="headerlink" title="4.9.4 依赖的排除"></a>4.9.4 依赖的排除</h3><p>1) 有的时候为了确保程序正确可以将有可能重复的间接依赖排除。请看如下的例子：</p><p>假设当前工程为MakeFriend，直接依赖OurFriends。</p><p>OurFriends依赖commons-logging的1.1.1对于MakeFriend来说是间接依赖。</p><p>当前工程MakeFriend直接依赖commons-logging的1.1.2</p><p>加入exclusions配置后可以在依赖OurFriends的时候排除版本为1.1.1的commons-logging的间 接依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>OurFriends<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--依赖排除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-9-5-统一管理目标jar包的管理"><a href="#4-9-5-统一管理目标jar包的管理" class="headerlink" title="4.9.5 统一管理目标jar包的管理"></a>4.9.5 统一管理目标jar包的管理</h3><p>以对Spring的jar包依赖为例：Spring的每一个版本中都包含spring-context，springmvc等jar包。我们应该导入版本一致的Spring jar包，而不是使用5.3.1的spring-context的同时使用5.3.2的springmvc。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>问题是如果我们想要将这些jar包的版本统一升级为5.3.2，是不是要手动一个个修改呢？显然，我们有统一配置的方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一管理当前模块的jar包的版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这样一来，进行版本调整的时候只改一改地方就行了。</p></blockquote><h1 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h1><h2 id="5-1-为什么要使用继承机制-？"><a href="#5-1-为什么要使用继承机制-？" class="headerlink" title="5.1 为什么要使用继承机制 ？"></a>5.1 为什么要使用继承机制 ？</h2><p>由于非compile范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。例如：</p><div class="table-container"><table><thead><tr><th>Hello</th><th><dependency>     <groupId>junit</groupId>     <artifactId>junit</artifactId>     <version>4.13.2</version>     <scope>test</scope> </dependency></th></tr></thead><tbody><tr><td>HelloFriend</td><td><dependency>     <groupId>junit</groupId>     <artifactId>junit</artifactId>     <version>4.13.2</version>     <scope>test</scope> </dependency></td></tr><tr><td>MakeFriend</td><td><dependency>     <groupId>junit</groupId>     <artifactId>junit</artifactId>     <version>4.13.2</version>     <scope>test</scope> </dependency></td></tr></tbody></table></div><p>此时如果项目需要将各个模块的junit版本统一为4.9，那么到各个工程中手动修改无疑是非常不可取的。使用继承机制就可以将这样的依赖信息统一提取到父工程模块中进行统一管理。</p><h2 id="5-2-创建父工程"><a href="#5-2-创建父工程" class="headerlink" title="5.2 创建父工程"></a>5.2 创建父工程</h2><blockquote><p>  父工程的打包方式为pom</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-3-在子工程中引入父工程"><a href="#5-3-在子工程中引入父工程" class="headerlink" title="5.3 在子工程中引入父工程"></a>5.3 在子工程中引入父工程</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父工程坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定从当前pom.xml文件出发寻找父工程的pom.xml文件的相对路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>..<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--继承--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.manman.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定从当前pom.xml文件出发寻找父工程的pom.xml文件的相对路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><font color='red'>此时如果子工程的groupId和version如果和父工程重复则可以删除。</font><h2 id="5-4-在父工程中管理依赖"><a href="#5-4-在父工程中管理依赖" class="headerlink" title="5.4 在父工程中管理依赖"></a>5.4 在父工程中管理依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子项目中重新指定需要的依赖，<font color='red'>删除范围和版本号</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="第6章-聚合"><a href="#第6章-聚合" class="headerlink" title="第6章 聚合"></a>第6章 聚合</h1><h3 id="6-1-为什么要使用聚合？"><a href="#6-1-为什么要使用聚合？" class="headerlink" title="6.1 为什么要使用聚合？"></a>6.1 为什么要使用聚合？</h3><p>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行clean操作。而使用了聚合之后就可以批量进行Maven工程的安装、清理工作。</p><h3 id="6-2-如何配置聚合-？"><a href="#6-2-如何配置聚合-？" class="headerlink" title="6.2 如何配置聚合 ？"></a>6.2 如何配置聚合 ？</h3><p>在总的聚合工程中使用modules/module标签组合，指定模块工程的相对路径即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--聚合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../MakeFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../OurFriends<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../HelloFriend<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Hello<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Maven可以根据各个模块的继承和依赖关系自动选择安装的顺序</p><h1 id="第7章-通过Maven创建Web工程"><a href="#第7章-通过Maven创建Web工程" class="headerlink" title="第7章  通过Maven创建Web工程"></a>第7章  通过Maven创建Web工程</h1><p>1) 创建简单的Maven工程，打包方式为war包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.manman.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MavenWeb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2) 点击Project Structure</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps1.jpg" alt="img"> </p><p>3) 选择对应的Module，添加web目录</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps2.jpg" alt="img"> </p><p>4) 设置目录名称</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps3.jpg" alt="img"> </p><p>5) 在web目录下创建index.jsp页面</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps4.jpg" alt="img"> </p><p>6) 部署到Tomcat上运行</p><h1 id="第8章-Maven酷站"><a href="#第8章-Maven酷站" class="headerlink" title="第8章 Maven酷站"></a>第8章 Maven酷站</h1><p>我们可以到<a href="http://mvnrepository.com或http://search.maven.org">http://mvnrepository.com或http://search.maven.org</a></p><p>搜索需要的jar包的依赖信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Maven学习笔记&quot;&gt;&lt;a href=&quot;#Maven学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Maven学习笔记&quot;&gt;&lt;/a&gt;Maven学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https://blog.</summary>
      
    
    
    
    <category term="开发必备框架" scheme="https://manamn.space/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="开发必备框架" scheme="https://manamn.space/tags/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="https://manamn.space/2022/10/17/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://manamn.space/2022/10/17/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-10-17T04:37:06.000Z</published>
    <updated>2022-10-17T14:08:32.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux笔记"><a href="#Linux笔记" class="headerlink" title="Linux笔记"></a>Linux笔记</h1><h1 id="虚拟的克隆和快照及迁移和删除"><a href="#虚拟的克隆和快照及迁移和删除" class="headerlink" title="虚拟的克隆和快照及迁移和删除"></a>虚拟的克隆和快照及迁移和删除</h1><ul><li><p>克隆</p><p>​        1.方式一：直接拷贝一份安装好的虚拟机文件</p><p>​        2.方式二：使用VMware的克隆操作，<strong>注意</strong>  克隆时需要关闭linux系统</p></li><li><p>虚拟机快照</p><p>​                        <strong>使用场景：避免出现误操作，可以先保留之前的状态，然后使用快照功能回到原来的状态</strong></p></li><li><p>虚拟机的迁移和删除</p><p>​        1.<strong>迁移和删除：</strong>把安装虚拟系统的文件夹整体拷贝或者剪切到其他位置，删除直接把文件夹删除即可</p><p>​        2.<strong>移除：</strong>使用VMware进行移除</p></li></ul><h1 id="设置共享文件夹"><a href="#设置共享文件夹" class="headerlink" title="设置共享文件夹"></a>设置共享文件夹</h1><ul><li><strong>第一步安装vmtools</strong><ul><li>进入centos<ul><li>点击vm菜单的-&gt;install vmware tools</li><li>centos会出现一个vm的安装包，xx.tar.gz</li><li>拷贝到/opt</li><li>使用解压命令tar，得到一个安装文件 cd /opt[进入到    opt目录]   tar -zxvf  xx.tar.gz</li><li>进入该vm解压的目录，<code>/opt</code> 目录下 <code>cd vmware...</code></li><li>安装<code>/vmware-install.pl</code></li><li>全部使用默认的设置即可，就可以安装成功</li></ul></li></ul></li><li><strong>第二步，设置共享文件夹(如果安装过vmtools，第一步可直接跳过)</strong><ul><li>菜单-&gt;vm-&gt;setting,设置选项为always enable</li><li>windows和centos可以共享 xx 目录</li><li>共享文件在centos的<strong>/mnt/hgfs</strong>目录下</li><li>查看ip地址：<code>ifconfig -a</code></li></ul></li></ul><h1 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux    目录结构"></a>Linux    目录结构</h1><p>1.linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录<code>/</code>，然后在次目录下创建其他目录。</p><p>2.<code>/bin</code>    [常用] (<code>/usr/bin</code> <code>/usr/local/bin</code>)    是Binary的缩写，这个目录存放着最经常使用的命令</p><p>3.<code>/sbin</code>    (<code>/usr/sbin</code>      <code>/usr/local/sbin</code>)    s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p><p>4.<code>/home</code>    [常用] 存放普通用户的主目录，在Linux中每一个用户都有自己的目录，一般该目录是以用户的账户名命名。</p><p>5.<code>/root</code>    [常用] 该目录为系统管理员，也称作超级权限者的用户主目录</p><p>6.<code>/lib</code>    系统开机所需要的最基本的动态连接共享库，其作用类似于Windows里面的DLL文件,几乎所有的用户程序都需要用到这些共享库。</p><p>7.<code>/lost+found</code>    这个目录一般是空的，当系统非法关机后，这里面就存放了一些文件</p><p>8.<code>/etc</code>    [常用]    所有的系统管理所需要的配置文件和子目录，比如安装Mysql数据库 my.conf</p><p>9.<code>/usr</code>    [常用]    用户的很多应用程序和文件都放在这个目录下，类似于windows下的program.file目录</p><p>10.<code>/boot</code>    [常用]    存放的是启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件</p><p>11.<code>/proc</code>    [不能动]    这个目录是一个虚拟的目录，他是系统内存的映射，访问这个目录来获取系统信息</p><p>12.<code>/srv</code>    [不能动]    service的缩写，该目录存放一些服务器启动之后需要提取的数据</p><p>13.<code>/sys</code>    [不能动]    这是一个linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs =&gt;[不能动]</p><p>14.<code>/tmp</code>    这个目录是用来存放一些临时文件的</p><p>15.<code>/dev</code>    类似于windows的设备管理器，把所有的硬件用文件的形似储存</p><p>16.<code>media</code>    [常用]    linux系统会自动识别一些设备，例如u盘，光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</p><p>17.<code>/mnt</code>    [常用]    系统提供该目录是为了让用户临时挂载别的文件系统，我们可以将外部的存储挂载在<strong>/mnt</strong>上，然后进入该目录就可以查看里面的内容。</p><p>18.<code>/opt</code>    这是给主机额外安装软件所存放的目录。</p><p>19.<code>/usr/local</code>    [常用]    这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p><p>20.<code>/var</code>    [常用]    这个目录中存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p><p>21.<code>/selinux[security-enhanced linux]</code>    SElinux 是一种安全子系统，他能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p><h1 id="Vi和Vim编辑器"><a href="#Vi和Vim编辑器" class="headerlink" title="Vi和Vim编辑器"></a>Vi和Vim编辑器</h1><p><strong>介绍vi和vim：</strong></p><p>​                <strong>vi:</strong>    vi是Linux内置的文本编辑器</p><p>​                <strong>vim：</strong>    vim可以看作是vi的增强版，可以主动的以字体颜色辨别的语法的正确性，方便程序设计。代码补全，编辑错误等等功能。</p><p><strong>vi和vim的三种模式：</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220929085717.png" alt="三种模式的相互切换"></p><p><strong>1.正常模式：</strong></p><p>​                以vim或者vi打开一个档案就直接进入了(这是<strong>默认的模式</strong>)。在这个模式中，你可以使用 <strong>[上下左右]</strong>按键来移动光标，可以使用    [删除字符] 或者 [删除整行] 来处理档案内容，也可以使用 [复制、粘贴] 来处理你的文件数据。</p><p><strong>2.插入模式：</strong></p><p>​                按下<code>i,I,o,O,a,A,r,R</code> 等任何一个字母后才会进入编辑模式，一般来说按i即可。</p><p><strong>3.命令行模式：</strong></p><p>​                输入<code>esc</code> 键再输入 <code>：</code> 在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作是在次模式中完成的。</p><p><strong>4.vi和vim基本使用：</strong></p><p>​                使用    vim 开发一个Hello.java程序，保存步骤说明演示</p><p>在主页面输入<code>vim hello.java</code>  然后回车，进入正常模式</p><p>按下<code>i</code> 进入编辑模式</p><p>然后输入一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;hello,shell&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后按下<code>:wq</code> (保存并退出)</p><p><strong>5.vim常用快捷键</strong></p><p>1.拷贝当行<code>yy</code> , 拷贝当行向下的5行<code>5yy</code> , 并粘贴 <code>p</code>。</p><p>2.删除当行 <code>dd</code> , 删除当前行向下的5行 <code>5dd</code> 。</p><p>3.在文件中查找某个单词 [命令行下， <code>/ + 关键字</code> ，回车 查找，输入<code>n</code> 就是查找下一个]</p><p>4.设置文件的行号，取消文件的行号[命令行下，<code>:set nu</code>  和 <code>:set nonu</code>] </p><p>5.文件的跳转,在一般模式下，使用快捷键到该文档的最末行 <code>G</code> 和最首行 <code>gg</code> ,在一般模式下，并将光标移动到，输入 <code>20</code> 再输入<code>shift 键 + g</code> 。</p><p>6.在一个文件中输入’’Hello’’,在一般模式下，然后又撤销这个动作 <code>u</code> 。</p><p>7.快捷键的键盘对应图</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720220929101349.png" alt=""></p><h1 id="开机、重启和用户登录注销"><a href="#开机、重启和用户登录注销" class="headerlink" title="开机、重启和用户登录注销"></a>开机、重启和用户登录注销</h1><ul><li><p><strong>关机&amp;重启命令</strong></p><ul><li><p>基本介绍            </p><ol><li><p><code>shutdown -h now</code> 立刻进行关机</p></li><li><p><code>shutdown  -h 1</code>  1分钟后关机</p></li><li><code>shutdown -r now</code> 现在重启计算机</li><li><code>halt</code> 立刻关机</li><li><code>reboot</code> 现在重启计算机</li><li><code>sync</code>  把内存的数据同步到磁盘 </li></ol></li><li><p><strong>注意细节</strong></p><ul><li>1.不管是重启系统还是关闭系统，首先要运行<code>sync</code> 命令，把内存中的数据写入磁盘中。</li><li>2.目前的 <code>shutdown/reboot/halt</code> 等命令均在关机前进行了<code>sync</code> ，但是避免失误，最好在工作中进行手动<code>sync</code>。</li></ul></li></ul></li><li><p><strong>用户登录和注销</strong></p><ul><li>基本介绍<ul><li>1.登录时尽量别用root用户登录，因为它是系统管理员，最大的权限，避免失误操作。可以利用普通用户登录，登录后再用<code>su - +用户名</code>    命令来切换成系统管理员身份。</li><li>2.在提示符下输入<code>logout</code> 即可注销用户。</li></ul></li><li><strong>使用细节</strong><ul><li>1.<code>logout</code> 注销指令在图形运行级别无效，在运行级别 3 下有效。</li></ul></li></ul></li></ul><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><ul><li><strong>一.基本介绍</strong><ul><li>linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</li></ul></li><li><strong>二.添加用户</strong><ul><li>1.基本语法：<code>useradd</code> + 用户名。</li><li>2.细节说明：当创建用户成功后，会自动的创建和用户相同的家目录,也可以通过<code>useradd -d + 指定的目录名 + 新的用户名</code> 给新的用户创建指定的家目录。</li></ul></li><li><strong>三.指定修改密码</strong><ul><li>基本语法：<code>passwd + 用户名</code>     </li></ul></li><li><strong>四.删除用户</strong><ul><li>1.基本语法：<code>userdel + 用户名</code></li><li>2.删除用户及用户主目录<code>userdel -r + 用户名</code></li></ul></li><li><strong>五.查询用户信息指令</strong><ul><li>基本语法：<code>id + 用户名</code></li></ul></li><li><strong>六.切换用户</strong><ul><li><code>su - 用户名</code><ul><li>细节说明：从权限高的用户切换到权限低的用户，不需要用户密码，反之需要,当需要返回到原来用户时，使用<code>exit\logout</code> 指令。</li></ul></li></ul></li><li><strong>七.查看当前用户/登录用户</strong><ul><li>基本语法<code>who am i</code> </li></ul></li><li><strong>八.用户组</strong><ul><li>介绍：系统可以对有共同性/权限的多个用户进行统一管理</li><li>新增组：<ul><li>指令<code>groupadd + 组名</code></li></ul></li><li>删除组：<ul><li>指令<code>groupdel + 组名</code></li></ul></li><li>增加用户时直接给加上组<ul><li>指令 : <code>useradd -g 用户组 用户名</code> </li><li>例如：增加一个用户 zwj  ，直接将他指定到 wudang 组<ul><li>第一步先创建组：<code>groupadd wudang</code>            </li><li>第二步创建用户并将用户放置到改组：<code>useradd -g wudang zwj</code></li></ul></li></ul></li><li>修改用户的组 : <ul><li>指令 ：<code>usermod -g 用户组 用户名</code></li><li>案例演示：<ul><li>第一步创建一个组：mojiao  <code>groupadd mojiap</code></li><li>第二步把 zwj 放入到 mojiao ：<code>usermod -g mojiao zwj</code></li></ul></li></ul></li></ul></li><li><strong>九.用户和组相关文件</strong><ul><li><code>/etc/passwd</code> 文件<ul><li>用户 <strong>user</strong> 的配置文件，记录用户的各种信息</li><li>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</li></ul></li><li><code>/etc/shadow</code> 文件<ul><li>口令的配置文件</li><li>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li></ul></li><li><code>/etc/group</code> 文件<ul><li>组 <strong>(group)</strong> 的配置文件，记录 <strong>Linux</strong> 包含的组的信息</li><li>每行的含义：组名：口令：组标识号：组内用户列表</li></ul></li></ul></li></ul><h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h5 id="一-指定Linux运行级别"><a href="#一-指定Linux运行级别" class="headerlink" title="一.指定Linux运行级别"></a>一.指定Linux运行级别</h5><ul><li><p>基本介绍：</p><ul><li><p>运行级别说明：</p><p><strong>0 ：关机</strong></p><p><strong>1 ：单用户[找回丢失密码]</strong></p><p><strong>2 :  多用户状态没有网络</strong></p><p><strong>3 ： 多用户状态有网络服务</strong></p><p><strong>4 :  系统未使用保留给用户</strong></p><p><strong>5 ： 图形界面</strong></p><p><strong>6 ： 系统重启</strong></p></li><li><p><strong>常用运行级别是 3 和 5 ，也可以默认运行级别。</strong></p></li></ul></li><li><p>应用实例：</p><ul><li>命令：<code>init [0123456]</code> : 通过 <code>init</code> 来切换不同的运行级别，比如 <code>init 3</code> ,就是传统的dos界面。</li><li>第二种方式：<code>systemctl set-default TARGET.target</code></li></ul></li></ul><h5 id="二-帮助指令"><a href="#二-帮助指令" class="headerlink" title="二.帮助指令"></a>二.帮助指令</h5><ul><li><code>1. man</code> <strong>获得帮助信息</strong><ul><li>基本语法：<code>man[命令或者配置文件]</code> (功能描述：获取帮助信息)</li><li>案例：查看<code>ls</code> 命令的帮助信息，<code>man ls</code> </li><li>在Linux下，隐藏文件是以 . 开头，选项可以组合使用，比如 <code>ls -al</code> ,比如 <code>ls -al/root</code>  </li></ul></li><li><code>2. help</code> 指令<ul><li>基本语法 ：<code>help + 命令</code> ，(功能描述：获取shell内置命令的帮助信息)</li><li>应用实例：查看 <code>cd</code> 命令的帮助信息 ：<code>help cd</code></li></ul></li></ul><h5 id="三-文件目录类"><a href="#三-文件目录类" class="headerlink" title="三.文件目录类"></a>三.文件目录类</h5><ul><li><p><strong><code>1. pwd</code> 命令</strong></p><ul><li>基本语法：<code>pwd</code> (功能描述 ： 显示当前工作目录的绝对路径)</li><li>应用实例：案例：显示当前工作目录的绝对路径</li></ul></li><li><p><strong><code>2. ls</code> 指令</strong></p><ul><li>基本语法：<code>ls [选项] [目录或者文件]</code></li><li>常用选项：<ul><li><strong>-a</strong>  : 显示当前目录所有的文件和目录，包括隐藏的</li><li><strong>-l</strong>  : 以列的方式显示信息</li></ul></li></ul></li><li><p><strong><code>3. cd</code> 指令</strong></p><ul><li><p>基本语法：<code>cd [参数]</code> (功能描述：切换到指定的目录)</p></li><li><p>理解：绝对路径和相对路径</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720221002190815.png" alt=""></p></li><li><p><code>cd ~ 或者 cd</code> : 回到自己的家目录，比如 你是’root’ , cd~ 到 /root</p></li><li><p><code>cd ..</code> 回到当前目录的上一级目录</p></li><li><p>应用实例：</p><ul><li>案例1：使用绝对路径切换到 root 目录， <code>cd /root</code></li><li>案例2：使用相对路径到 root 目录，比如在 /home/tem, <code>cd ../../root</code></li><li>案例3：表示回到当前目录的上一级，<code>cd ..</code> </li><li>案例4：回到家目录，<code>cd ~</code></li></ul></li></ul></li><li><p><strong><code>4. mkdir</code> 指令</strong></p><ul><li><code>mkdir</code> 指令用于创建目录：<ul><li>基本语法：<code>mkdir [选项] 要创建的目录名称</code></li></ul></li><li>常用选项<ul><li><code>-p</code> : 创建多级目录</li></ul></li><li>应用实例：<ul><li>案例1：<strong>创建一个目录 /home/dong</strong><ul><li>指令：<code>mkdir /home/dong</code></li></ul></li><li>案例2：<strong>创建多级目录 /home/animal/taiger</strong><ul><li>指令 <code>mkdir  -p /home/animal/taiger</code></li></ul></li></ul></li></ul></li><li><p><strong><code>5. rmdir</code> 指令</strong></p><ul><li>基本语法：<code>rmdir [选项] 要删除的目录</code></li><li>应用实例：<ul><li>案例：删除一个目录 /home/dog <ul><li>指令：<code>rmdir /home/dog</code></li></ul></li></ul></li><li>使用细节：<ul><li><code>rmdir</code> 删除的是空目录，如果目录下有内容时无法删除</li><li>提示：<strong>如果需要删除非空目录，需要使用<code>rm -rf 要删除的目录</code> </strong></li><li>比如：<code>rm -rf /home/animal</code></li></ul></li></ul></li><li><p><strong><code>6. touch</code> 指令</strong></p><ul><li><code>touch</code> 指令创建空文件</li><li>基本语法：<code>touch 文件名称</code></li><li>应用案例：在/home 目录下，创建一个空文件 hello.txt<ul><li>指令 <code>touch hello.txt</code></li></ul></li></ul></li><li><p><strong><code>7.cp</code> 指令</strong></p><ul><li><code>cp</code> 指令拷贝文件到指定目录</li><li>基本语法：<code>cp [选项] source  dest</code></li><li>常用选项：<ul><li><code>-r</code> :递归复制整个文件</li></ul></li><li>应用实例：<ul><li>案例1：将 /home/hello.txt  拷贝到  /home/bbb 目录下<ul><li>指令：<code>cp /home/hello.txt /home/bbb</code></li></ul></li><li>案例2：递归复制整个文件夹，举例，比如将 /home/bbb 整个目录，拷贝到 /opt<ul><li>指令：<code>cp -r /home/bbb /opt</code></li></ul></li></ul></li><li>使用细节：如果目标目录下已存在该文件名，那么该操作会覆盖该文件<ul><li>强制覆盖不提示的方法：<code>\cp</code> 在cp 前加上\</li><li>比如：<code>\cp -r /home/bbb /opt</code></li></ul></li></ul></li><li><p><strong><code>8. rm</code> 指令</strong></p><ul><li>说明：<code>rm</code> 指令移除文件或者目录</li><li>基本语法：<code>rm [选项] 要删除的文件或者目录</code></li><li>常用选项：<ul><li><code>-r</code> ：递归删除整个文件夹</li><li><code>-f</code> ：强制删除，不在提示</li></ul></li><li>应用实例：<ul><li>案例1：将/home/hello.txt 删除，<code>rm /home/hello.txt</code></li><li>案例2：递归删除整个文件夹 /home/bbb, <code>rm -rf /home/bbb</code></li></ul></li><li>使用细节：强制删除不提示的方法：带上 <code>-f</code> 参数即可</li></ul></li><li><p><strong><code>9. mv</code> 指令</strong></p><ul><li><code>mv</code> <strong>移动文件与目录或者重命名</strong></li><li>基本语法：<ul><li><code>mv oldNameFile newNameFile</code> (功能描述：重命名)</li><li><code>mv /temp/movefile /targetFolder</code> (功能描述：移动文件)</li></ul></li><li>应用实例：<ul><li>案例1：将 /home/cat.txt  文件  重新命名为  pig.txt    <code>mv /home/cat.txt pig.txt</code></li><li>案例2：将 /home/pig.txt  文件移动到  /root   目录下 <code>mv /home/pig.txt  /root</code></li><li>案例3：将 /opt/bbb 整个目录，移动到/home下 <code>mv /opt/bbb /home</code></li></ul></li></ul></li><li><p><strong><code>10. cat</code> 指令</strong></p><ul><li><code>cat</code> 查看文件内容</li><li>基本语法：<code>cat [选项] 要查看的文件</code></li><li>常用选项：<ul><li><code>-n</code> 显示行号</li></ul></li><li>应用实例：<code>cat -n /ect/profile</code>  查看文件内容，并显示行号 </li><li>使用细节：<ul><li>1.<code>cat</code> 指令只能浏览文件，而不能修改文件，为了浏览方便，一般会带上，管道命令  <code>|more</code></li><li>2.<code>cat -n /ect/profile | more</code></li></ul></li></ul></li><li><p><strong><code>11. more</code> 指令</strong></p><ul><li><p>基本语法：如图</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003150512.png" alt=""></p></li><li><p>应用实例：案例：采用 more 查看文件 <code>cat -n /ect/profile | more</code></p></li></ul></li><li><p><strong><code>12. less</code> 指令</strong></p><ul><li><p><strong>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</strong></p></li><li><p>基本语法：<code>less 要查看的文件</code></p></li><li><p>操作说明：如图</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003151722.png" alt=""></p></li><li><p>应用实例：采用<code>less</code> 查看一个大文件 <code>/opt/杂文.txt</code>  指令<code>less /opt/杂文.txt</code> </p></li></ul></li><li><p><strong><code>13. echo</code> 指令</strong></p><ul><li><code>echo</code> 输出内容到控制台</li><li>基本语法：<code>echo [选项] [输出的内容]</code></li><li>类似 Java 中的 <code>println(&quot;输出的内容&quot;)</code></li></ul></li><li><p><strong><code>14. head</code> 指令</strong></p><ul><li><code>head</code> 用于显示文件的开头部分内容，默认情况下<code>head</code> 指令显示文件的前10行内容</li><li>基本语法<ul><li><ol><li><code>head 文件</code> (功能描述：查看文件前10行内容)</li><li><code>head -n 5 文件</code> (功能描述：查看文件头5行内容，5 如果是20，则标识前20行内容)</li></ol></li></ul></li></ul></li><li><p><strong><code>15. tail</code> 指令</strong></p><ul><li><code>tail</code> 用于输出文件中尾部的内容，默认情况下tail显示文件后10行内容</li><li>基本语法：<ul><li><code>tail 文件</code> (功能描述：查看文件尾行10行内容)</li><li><code>tail -n 5 文件</code> (功能描述 ：查看文件尾行5行内容) </li><li><code>tail -f  文件</code> (功能描述：实时追踪该文档的所有更新)</li></ul></li></ul></li><li><p><strong><code>16. &gt; 和 &gt;&gt;</code> 指令</strong></p><ul><li><code>&gt;</code> 输出重定向和：<code>文件内容 &gt; 文件名</code> <strong>后者中的文件内容将会被新的文件内容覆盖</strong></li><li><code>&gt;&gt;</code> 追加：<code>文件内容 &gt; 文件名</code> <strong>后者中的文件内容将不会被新的文件内容覆盖，只是追加在原来的内容后面</strong></li><li>基本语法：<ul><li><code>ls -l &gt; 文件</code> (功能描述：显示的列表内容写入文件中 <strong>（覆盖写）</strong>)</li><li><code>ls -al &gt;&gt; 文件</code> (功能描述：列表显示的内容追加到文件中末尾)</li><li><code>cat 文件1 &gt; 文件2</code> (功能描述：将文件1中的内容 <strong>覆盖</strong>  文件2的内容)</li></ul></li></ul></li><li><p><strong><code>17. ln</code> 指令</strong></p><ul><li><strong>软链接也称为符号链接，类似window里的快捷键，主要存放了链接其他文件的路径</strong></li><li>基本语法：<code>ln -s [原文件或者目录][软链接名]</code> (功能描述：给原文件创建一个软链接)</li><li>应用案例：<ul><li>在 /home  目录下创建一个软链接 myroot ，连接到 /root 目录</li><li>指令：<code>ln -s /root /home/myroot</code> </li></ul></li><li>删除软链接：<code>rm -f /home/myroot</code></li><li>细节说明：当我们使用 <code>pwd</code> 查看目录时，仍然看到的是软链接所在目录</li></ul></li><li><p><strong><code>18. history</code> 指令</strong></p><ul><li>查看已经执行过的历史命令，也可以执行历史命令</li><li>基本语法：<code>history</code> (功能描述：查看已经执行过的历史命令)</li><li>实用案例：<ul><li>显示所有的历史命令：<code>history</code></li><li>显示最近使用的是个历史命令：<code>history 10</code></li><li>执行历史编号为5的指令：<code>history</code> <code>!5</code></li></ul></li></ul></li></ul><h5 id="四-时间日期类"><a href="#四-时间日期类" class="headerlink" title="四.时间日期类"></a><strong>四.时间日期类</strong></h5><ul><li><strong><code>1. date</code> 指令-显示当前日期</strong><ul><li>基本语法：<ul><li><code>date</code> (功能描述：显示当前时间)</li><li><code>date + %Y</code> (功能描述：显示当前年份)</li><li><code>date + %m</code>  (功能描述：显示当前月份)</li><li><code>date + %d</code> (功能描述：显示当前是那一天)</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> (功能描述：显示：年-月-日 时：分：秒) </li></ul></li><li>应用案例：<ul><li>案例1：显示当前时间信息  —- 指令 <code>date</code></li><li>案例2：显示当前时间年月日——指令 <code>date &quot;+%Y-%m-%d&quot;</code></li><li>案例3：显示当前时间年月日时分秒——-指令 <code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></li></ul></li></ul></li><li><strong><code>2. date 指令设置时间</code></strong><ul><li>基本语法：<code>date -s [需要设置的字符串时间]</code></li><li>应用案例：设置系统当前时间，比如设置成  2020-11-03 20：02：10 —- 指令 <code>date -s &quot;2020-11-03 20：02：10&quot;</code></li></ul></li><li><strong><code>3. cal</code> 指令</strong><ul><li>查看日历指令：<code>cal</code></li><li>基本语法：<ul><li><code>cal [选项]</code> (功能描述：不加选项，显示本月日历)</li></ul></li><li>应用实例：<ul><li>案例1：显示当前日历 —-指令 <code>cal</code></li><li>案例2：显示2020年日历 —— 指令 <code>:cal 2020</code></li></ul></li></ul></li></ul><h5 id="五-搜索查找类"><a href="#五-搜索查找类" class="headerlink" title="五.搜索查找类"></a>五.搜索查找类</h5><ul><li><p><strong><code>1. find</code> 指令</strong> </p><ul><li><p><code>find</code> 指令将从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端</p></li><li><p>基本语法：<code>find [搜索范围] [选项]</code></p></li><li><p>选项说明：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003222620.png" alt=""></p></li><li><p>应用实例：</p><ul><li>案例1：按照文件名：根据名称查找/home 目录下的 hello.txt<ul><li>指令：<code>find /home -name hello.txt</code></li></ul></li><li>案例2：按照拥有者：查找 /opt 目录下的，用户名称为 nobody 的文件<ul><li>指令：<code>find /opt -user nobody</code></li></ul></li><li>案例3：查找整个文件大于200M的文件，(+n  大于n  ，n 等于n  ，-n  小于n， 单位有k,M,G)<ul><li>指令：<code>find -size +200M</code></li></ul></li></ul></li></ul></li><li><p><strong><code>2. locate</code> 指令</strong></p><ul><li>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</li><li>基本语法：<code>locate [搜索的文件]</code></li><li>特别说明：由于locate指令基于数据库进行查询，所以第一次运行前， 必须使用updatedb指令创建locate数据库。</li><li>应用实例：<ul><li>案例1:请使用locate指令快速定位hello.txt 文件所在目录</li><li>指令：<code>updatedb</code> <code>locate hello.txt</code> (如果是第一次使用则需要第一条指令，否则不需要)</li></ul></li></ul></li><li><p><strong><code>3. which 指令</code></strong></p><ul><li>which指令，可以查看某个指令在哪个目录下，比如ls 指令在哪个目录 —— 指令：<code>which ls</code></li></ul></li><li><p><strong><code>4. grep</code></strong>  过滤查找，管道符：<code>|</code>  ,表示将前一个命令的处理结果输出传递给后面的命令处理</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003224631.png" alt=""></p><ul><li><p>基本语法：<code>grep [选项] 查找内容 源文件</code></p></li><li><p>常用选项：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003225410.png" alt=""></p></li><li><p>应用实例：</p><ul><li>案例1:请在hello.txt 文件中，查找”yes”所在行， 并且显示行号<ul><li>写法1: cat /home/hello.txt| grep “yes”</li><li>写法2: grep -n “yes” /home/hello.txt</li></ul></li></ul></li></ul></li></ul><h5 id="六-压缩和解压类"><a href="#六-压缩和解压类" class="headerlink" title="六.压缩和解压类"></a>六.压缩和解压类</h5><ul><li><p><strong><code>1. gzip/gunzip</code> 指令</strong></p><ul><li><code>gzip</code> 用于压缩文件，<code>gunzip</code>  用于解压文件</li><li>基本语法：<ul><li><code>gzip 文件</code> (功能描述：压缩文件，只能将文件压缩为*.gz 文件) </li><li><code>gunzip 文件.gz</code>  (功能描述：解压缩文件命令)</li></ul></li><li>应用实例：<ul><li>案例1：gzip 压缩， 将 /home 下的 hello.txt 文件进行压缩——- 指令 <code>gzip /home/hello.txt</code></li><li>案例2：gunzip 解压,  将 /home 下的 hello.txt.gz 文件解压缩——-指令 <code>gunzip /home/hello.txt.gz</code></li></ul></li></ul></li><li><p><strong><code>2. zip/unzip</code> 指令</strong></p><ul><li><p>zip 用于压缩文件，unzip 用于解压文件， <strong>这个在项目打包发布中很有用</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003230923.png" alt=""></p></li><li><p>基本语法：</p><ul><li><code>zip [选项] XXX.zip  将要压缩的内容</code> (功能描述：压缩文件和目录的命令)</li><li><code>unzip [选项] XXX.zip</code> (功能描述：解压缩文件)</li></ul></li><li><p>zip 常用选项</p><ul><li><code>-r</code> 递归压缩：即压缩目录</li></ul></li><li><p>unzip 常用选项</p><ul><li><code>-d 目录</code> ：指定解压后文件的存放目录</li></ul></li><li><p>应用实例</p><ul><li>案例1: 将 /home 下的所有文件/文件夹进行压缩成myhome .zip <ul><li>指令: <code>zip -r myhome.zip /home/[将home日录及其包含的文件和子文件夹都压缩]</code></li></ul></li><li>案例2: 将myhome.zip 解压到 /opt/tmp 目录下<ul><li>指令：<code>mkdir /opt/tmp</code>  <code>unzip -d /opt/tmp /home/myhome.zip</code></li></ul></li></ul></li></ul></li><li><p><strong><code>3. tar</code> 指令</strong></p><ul><li><p>tar指令是打包指令，最后打包后的文件是.tar.gz 的文件。</p></li><li><p>基本语法：<code>tar [选项] XXX.tar.gz  打包的内容</code> (功能描述：打包目录，压缩后的文件格式.tar.gz)</p></li><li><p>选项说明</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221003232435.png" alt=""></p></li><li><p>应用实例</p><ul><li>案例1:  压缩多个文件，将 /home/pig.txt 和 /home/cat.txt  压缩成pc.tar.gz<ul><li>指令：<code>tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</code></li></ul></li><li>案例2:  将 /home 的文件夹压缩成 myhome.tar.gz<ul><li>指令：<code>tar -zcvf myhome.tar.gz /home/</code></li></ul></li><li>案例3:  将 pc.tar.gz 解压到当前目录<ul><li>指令：<code>tar -zxvf pc.tar.gz</code></li></ul></li><li>案例4:  将  myhome.tar.gz 解压到  /opt/tmp2 目录下<ul><li>指令：<code>mkdir /opt/tmp2</code> <code>tar -zxvf /home/myhome.tar.gz -C /opt/tmp2</code></li></ul></li></ul></li></ul></li></ul><h1 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h1><h5 id="一-linux-组的基本介绍"><a href="#一-linux-组的基本介绍" class="headerlink" title="一.linux 组的基本介绍"></a>一.linux 组的基本介绍</h5><ul><li>在 Linux 中的每一个用户必须属于一个组，不能独立于组外。在 Linux 中每个文件，所有者、所在组、其他组的概念。</li><li><ol><li>所有者</li><li>所在组</li><li>其他组</li><li>改变用户所在的组</li></ol></li><li><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221008083106.png" alt=""></li></ul><h5 id="二-文件-目录-所有者"><a href="#二-文件-目录-所有者" class="headerlink" title="二.文件/目录 所有者"></a>二.文件/目录 所有者</h5><ul><li><p>一般为文件的所创建者，谁创建了该文件，就自然的成为该文件的所创建者</p></li><li><p><strong><code>1. ls -ahl</code> 查看文件的所有者</strong></p><ul><li><p>指令： <code>ls -ahl</code></p></li><li><p>应用实例：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221008083707.png" alt=""></p></li></ul></li><li><p><strong><code>2. chown [用户名] [文件名]</code> 修改文件的所有者</strong></p><ul><li>指令：<code>chown [用户名] [文件名]</code> </li><li>应用实例：要求：使用 root 创建一个 apple.txt 文件，然后将其所有者改为 tom </li><li><code>chown tom apple.txt</code></li></ul></li><li><p><strong><code>3. groupadd [组名]</code> 组的创建</strong></p><ul><li>指令：<code>groupadd [组名]</code></li><li>应用实例：<ul><li>创建一个组：monster</li><li><code>groupadd monster</code></li><li>创建一个用户 fox ，并放入到 monster 组中</li><li><code>useradd -g monster fox</code></li></ul></li></ul></li></ul><h5 id="三-文件-目录所在组"><a href="#三-文件-目录所在组" class="headerlink" title="三.文件/目录所在组"></a>三.文件/目录所在组</h5><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户的组(默认)</p><ul><li><strong><code>1. ls -ahl</code> 查看目录/文件所在组</strong><ul><li>基本指令：<code>ls -ahl</code></li><li>应用实例：<ul><li>使用 fox 来创建一个文件，看看改文件属于那个组</li><li><code>touch ok.txt</code> <code>ls -ahl</code></li><li><code>-rw-r--r--.1 fox monster 0 11月 5 12：50 0k.txt</code></li></ul></li></ul></li><li><strong><code>2. chgrp [组名][文件名]</code> 修改文件/目录所在组</strong><ul><li>基本指令：<code>chgrp [组名][文件名]</code></li><li>应用实例：使用 root 用户来创建文件 orange.txt ,看看当前文件属于那个组，然后将这个文件所在组，修改到 fruit 组</li><li>指令：<ul><li><code>groupadd fruit</code></li><li><code>touch orange.txt</code></li><li><code>chgrp fruit orange.txt</code></li></ul></li></ul></li><li><strong>其他组</strong><ul><li>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组</li></ul></li><li><strong>改变用户所在组</strong><ul><li>在添加用户时，可以指定将用户添加到那个组中，同样的使用 root 的管理权限可以改变某个用户的所在的组。</li><li><strong>改变用户的所在组</strong><ul><li><code>usermod -g [新组名][用户名]</code></li><li><code>usermod -d [目录名][用户名]</code> 改变该用户登录的初始目录。</li></ul></li><li>应用实例：<ul><li>将 zwj  这个用户从原来的所在组，修改到 wudang 组</li><li><code>usermod -g wudang zwj</code></li></ul></li></ul></li></ul><h5 id="四-权限的基本介绍"><a href="#四-权限的基本介绍" class="headerlink" title="四.权限的基本介绍"></a>四.权限的基本介绍</h5><ul><li><p>基本介绍：</p><ul><li><p><code>ls -l</code> 或者 <code>ll</code>     显示所在目录的所有文件及目录的权限  <code>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</code></p></li><li><p><strong>0~9位说明</strong></p></li><li><p>第 0 位说明文件类型(d, -, l, c, b)</p><ul><li>l 是链接，Linux中的软链接类似于Windows中的快捷键</li><li>d 是目录，相当于windows中的文件夹</li><li>c 是字符设备文件，鼠标，键盘</li><li>b 是块设备，比如硬盘</li><li><code>-</code> 是普通文件，如 .txt</li></ul></li><li><p>第 1~3 位确定 <strong>所有者</strong> (该文件的所有者) 拥有改文件的权限 —-User</p></li><li><p>第 4~6 位确定 <strong>所属组</strong> (同用户组的) 拥有改文件的权限—-Group</p></li><li><p>第 7~9 位确定 <strong>其它用户</strong> 拥有该文件的权限—-Other</p></li><li><p>可以使用数字表示为：r = 4, w = 2, x = 1,所有 rwx = 4 + 2 + 1 = 7,数字可以进行组合</p></li><li><p><strong>其他说明</strong></p><p>| ———————- | —————————————————————————————————- |<br>| ———————- | —————————————————————————————— |<br>| 1               | 文件：硬链接数或目录：子目录数                               |<br>| root            | 用户                                                         |<br>| root            | 组                                                           |<br>| 1213            | 文件大小(字节），如果是文件夹，显示 4096 字节                |<br>| Feb 2 09:39     | 最后修改的时间                                               |<br>| abc             | 文件名                                                       |</p></li></ul></li><li><p><strong>rwx 权限详解</strong></p><ul><li><strong><code>rwx</code> 作用到文件</strong><ul><li>[r] ：代表可以读 read : 可以读取，查看</li><li>[w] : 代表可写 write : 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在目录有写的权限，才能删除该文件</li><li><code>x</code> : 代表可执行 execute : 可以被执行</li></ul></li><li><strong><code>rwx</code> 作用到目录</strong><ul><li>[r] ：代表可以读 read : 可以读取，<code>ls</code> 查看目录内容</li><li>[w] : 代表可以写 write : 可以修改，对目录内 创建+删除+目录重命名</li><li><code>x</code> : 代表可执行 execute : 可以进入该目录</li></ul></li></ul></li></ul><h5 id="五-文件-目录权限操作"><a href="#五-文件-目录权限操作" class="headerlink" title="五.文件/目录权限操作"></a>五.文件/目录权限操作</h5><ul><li><strong><code>1. chmod</code> 修改权限</strong><ul><li>通过 <code>chmod</code> 指令，可以修改 <strong>文件或者目录</strong> 的权限</li></ul></li><li><strong><code>2. + 、- 、=</code> 第一种方式变更权限</strong><ul><li>u: 所有者    g: 所在组    o: 其他人    a: 所有人(u、g、o 的总合)<ul><li><ol><li><code>chmod u=rxw,g=rx,o=x [文件/目录名]</code>  </li><li><code>chmod o+w [文件/目录名]</code>  </li><li><code>chmod a-x [文件/目录名]</code>  </li></ol></li></ul></li><li>案例演示：<ul><li><ol><li>给 abc 文件 的所有者读写执行的权限(rwx) ,给所在组读执行的权限(rx),给其他组读执行的权限(rx)   指令：<code>chmod u=rwx,g=rx,o=rx abc</code></li><li>给 abc 文件的所有者除去执行的权限，组增加写的权限   指令：<code>chmod u-x,g+w abc</code></li><li>给文件 abc 的所有用户添加读的权限    指令：<code>chmod o+r abc</code></li></ol></li></ul></li></ul></li><li><code>3. 第二种方式：通过数字变更权限</code><ul><li>r = 4;    w = 2;    x = 1;    rwx = 4+2+1</li><li><code>chmod u=rwx,g=rx,o=x [文件目录名]</code>  == <code>chmod 751 [文件目录名]</code></li><li><strong>案例演示：</strong><ul><li>要求：将 /home/abc.txt 文件的权限修改成  rwx r-x r-x 使用数字方式实现<ul><li>指令：<code>chmod 755 /home/abc.txt</code></li></ul></li></ul></li></ul></li><li><strong><code>chown</code> 修改文件所有者</strong><ul><li>指令：<code>chown [用户名] [文件/目录名]</code>                            <strong>改变所有者</strong></li><li>指令：<code>chown  [用户名] [文件/目录名]</code>  -R  如果是目录，则递归           <strong>改变所有者和所在组</strong></li><li>应用实例：要求：使用 root 创建一个 apple.txt 文件，然后将其所有者改为 tom <ul><li>指令：<code>chown tom apple.txt</code></li></ul></li><li>应用实例：请将 /home/test 目录下的所有文件和目录的所有者和所在组 tom<ul><li>指令：<code>chown -R tom /home/test</code></li></ul></li></ul></li><li><strong><code>chgup</code> 修改文件/目录所在组</strong><ul><li>基本指令：<code>chgrp [组名][文件名]</code>                         <strong>改变所在组</strong></li><li>案例演示：<ul><li>请将 /home/abc.txt 文件的所在组修改成 shaolin<ul><li>指令：<code>groupadd shaolin</code>      <code>chgrp shaolin /home/acb.txt</code></li></ul></li><li>请将 /home/test 目录下的所有文件和目录的所在组都修改成 shaolin<ul><li>指令：<code>chgrp -R shaolin /home/test</code></li></ul></li></ul></li></ul></li></ul><h1 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h1><h5 id="1-crond-任务调度"><a href="#1-crond-任务调度" class="headerlink" title="1. crond 任务调度"></a>1. crond 任务调度</h5><ul><li><p><strong>概述：</strong></p><ul><li><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p></li><li><p>任务调度分类：1.系统工作：有些重要的工作必须周而复始地执行，比如病毒扫描等</p></li><li><p>个别用户工作：个别用可能希望执行某些程序，比如对 mysql 数据库的备份</p></li><li><p>示意图：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009225759.png" alt=""></p></li></ul></li><li><p><strong>基本语法</strong></p><ul><li><p><code>crontab [选项]</code></p></li><li><p>常用选项：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009230026.png" alt=""></p></li><li><p>快速入门：</p><ul><li><p>设置任务调度文件：/etc/crontab</p></li><li><p>设置个人任务调度，执行一次 <code>crontab -e</code> 命令</p></li><li><p>接着输入任务到调度文件</p></li><li><p>如：<code>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt</code>  : 意思是说每分钟都执行一次 <code>ls -l /etc/ &gt; /tmp/to.txt</code></p></li><li><p>参数细节说明:  五个占位符说明</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009230657.png" alt=""></p></li><li><p>特殊符号说明</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009230805.png" alt=""></p></li><li><p>特殊时间执行案例</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009230925.png" alt=""></p></li></ul></li><li><p>应用实例</p><ul><li>案例1：每隔一分钟，将当前时间的日期信息，追加到 /tmp/mydate 文件中<ul><li>指令：<code>*/1 * * * * date &gt;&gt; /tmp/mydate</code></li></ul></li><li>案例2：每隔一分钟。将当前日历和日期都追加到 /home/mycal 文件中<ul><li>步骤：</li><li><ol><li><code>vim /home/my.sh</code>  写入内容：<code>date &gt;&gt; /home/mycal 和 cal &gt;&gt; /home/mycal</code></li><li>给 my.sh 增加执行的权限：<code>chmod u+x /home/my.sh</code></li><li><code>crontab -e</code> 然后回车，进入编辑 增加 <code>*/1 * * * * /home/my.sh</code></li></ol></li></ul></li><li>案例3：每天凌晨2点 将 mysql 数据库 testbd,备份到文件夹中<ul><li>步骤<ul><li><ol><li><code>crontab -e</code></li><li><code>0 2 * * * mysqldump -uroot -p1578 testbd &gt; /home/db.bak</code></li></ol></li></ul></li></ul></li></ul></li></ul></li></ul><h5 id="2-at-一次性定时计划任务"><a href="#2-at-一次性定时计划任务" class="headerlink" title="2.at 一次性定时计划任务"></a>2.at 一次性定时计划任务</h5><ul><li><p>基本介绍：</p><ul><li><p>at命令是一次性定时计划任务，at 的守护进程atd 会以后台模式运行，检查作业队列来运行。</p></li><li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</p></li><li><p>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</p></li><li><p>在使用at命令的时候，一定要保证 atd进程的启动﹐可以使用相关指令来查看<code>ps -ef | grep atd</code>可以检测atd是否在运行</p></li><li><p>示意图：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009233055.png" alt=""></p></li></ul></li><li><p>at 命令格式</p><ul><li>指令：<code>at [选项][时间]</code>  <strong>Ctrl + D  结束 at 命令输入后，输入两次</strong>   </li></ul></li><li><p>at 命令选项</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221009233325.png" alt=""></p></li><li><p>at 时间定义</p><ul><li>接受在当天的 h:mm(小时:分钟)式的时间指定。假如该时间已过去，那么就放在第二天执行。例如:04:002)</li><li>使用midnight(深夜)，noon(中午) ，teatime(饮茶时间，一般是下午4点〉等比较模糊的词语来指定时间。</li><li>采用12小时计时制，即在时间后面加上AM (上午)或PM(下午）来说明是上午还是下午。例如： 12pm</li><li>指定命令执行的具体日期，指定格式为month day(月日)或mm/dd/yy (月/日/年)或dd.mm.yy(日.月.年），指定的日期必须跟在指定时间的后面。例如:04:002021-03-1</li><li>使用相对计时法.指定格式为: now + count time-units ,now就是当前时间, time-units是时间单位,这里能够是minutes(分钟)、hours (小时)、days(天)、weeks (星期)。count是时间的数量，几天，几小时。例如: now + 5 minutes</li><li>直接使用today(今天)、tomorrow(明天）来指定完成命令的时间。</li></ul></li><li><p>应用实例</p><ul><li>案例1：2天后的下午 5 点 执行 /bin/ls /home<ul><li>指令：<code>at 5pm + 2 days</code> <strong>回车</strong>  <code>/bin/ls /home</code></li></ul></li><li>案例2：<code>atq</code> 命令查看系统中有没有执行的工作任务</li><li>案例3：每天17点钟，输出时间到指定文件夹内，比如 /root/date100.log<ul><li>指令：<code>at 5pm tomorrow</code>  <strong>回车</strong>  date &gt;  /root/date100.log</li></ul></li><li>案例4：2分钟后，输出时间到指定文件夹，比如：/root/date200.log<ul><li>指令：<code>at now + 2 minutes</code> <strong>回车</strong>  /root/date200.log</li></ul></li><li>案例5：删除已经设置的任务 <code>atrm [编号]</code><ul><li><code>atrm 4</code>  表示将job队列，编号为4的job删除</li></ul></li></ul></li></ul><h1 id="磁盘分区和挂载"><a href="#磁盘分区和挂载" class="headerlink" title="磁盘分区和挂载"></a>磁盘分区和挂载</h1><h5 id="一-Linux-分区"><a href="#一-Linux-分区" class="headerlink" title="一.Linux 分区"></a>一.Linux 分区</h5><ul><li><p>原理介绍</p><ul><li><ol><li><p>Linux 来说无论有几个分区，分给哪一个目录使用，它归根到底就只有一个根目录，一个独立且唯一的文件结构，Linux 中每一个分区都是用来组成整个文件系统的一部分。</p></li><li><p>Linux 采用了一种叫 ”挂载“ 的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的储存空间在一个目录下获得。</p></li><li><p>示意图</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221010230403.png" alt=""></p></li></ol></li></ul></li><li><p>硬盘说明</p><ul><li><ol><li>Linux 硬盘分为两种 ：IDE 硬盘    SCSI硬盘，目前基本上使用的都是：SCSI硬盘。</li><li>对于 IDE硬盘 ，驱动器标识符为 <strong>hdx~</strong> ,其中 hd 表明分区所在设备的类型，这里是指 IDE硬盘，x 表示为盘号(a 为基本盘， b为基本从属盘，c为辅助主盘，d为辅助从属盘)， ~ 代表分区，前四个分区分别是用数字 1~4 表示，它们是主分区或扩展分区，从5开始就是逻辑分区。 例如： <strong>hda3</strong> 表示 ：是一个 IDE硬盘上的基本盘上的第三主分区或扩展分区</li><li>对于 SCSI硬盘 驱动器标识符则为 <strong>sdx~</strong> ,SCSI硬盘是用  ”sd“ 表示分区所在设备的类型，其余的则是和IDE硬盘的表示方法一样</li></ol></li></ul></li><li><p>查看所有设备挂载情况</p><ul><li>指令：<code>lsblk</code>  或者 <code>lsblk -f</code><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221010232137.png" alt=""></li></ul></li></ul><h5 id="二-挂载案例及步骤"><a href="#二-挂载案例及步骤" class="headerlink" title="二.挂载案例及步骤"></a>二.挂载案例及步骤</h5><ul><li><p>说明：下面我们以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念</p></li><li><p>如何增加一块硬盘</p><ul><li>虚拟机添加硬盘</li><li>分区</li><li>格式化</li><li>挂载</li><li>设置可以自动挂载</li></ul></li><li><p><strong>虚拟机添加硬盘步骤1</strong></p><ul><li><p>在 虚拟机 菜单中，选择 设置 ，然后设备列表里添加硬盘，然后一路 下一步 ，中间只有选择磁盘大小的地方需要修改，直至完成。然后重启系统(系统需要扫描，才能识别)</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012073710.png" alt=""></p></li></ul></li><li><p><strong>虚拟机增加硬盘步骤2</strong></p><ul><li><p><code>fdisk /dev/sdb</code> 分区命令，开始对 /sdb 分区</p><ul><li><p><code>m</code> 显示命令列表</p></li><li><p><code>p</code> 显示磁盘分区，同 <code>fdisk -l</code> 作用一样</p></li><li><p><code>n</code> 新增分区</p></li><li><p><code>d</code> 删除分布</p></li><li><p><code>w</code> 写入并退出</p></li><li><p>说明：开始分区后输入 n ，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入并退出，若不保存退出输入 q。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012114356.png" alt=""></p></li></ul></li></ul></li><li><p><strong>虚拟机增加硬盘步骤3</strong></p><ul><li>格式化磁盘<ul><li>指令：<code>mkfs -t ext4 /dev/sdb1</code>  其中 ext4 是文件类型</li><li>注意： <strong>用命令进行挂载，重启后挂载会失效</strong></li></ul></li></ul></li><li><p><strong>虚拟机增加硬盘步骤4</strong></p><ul><li>挂载：将一个分区与一个目录进行联系起来<ul><li>指令：<code>mount [设备名称] [挂载目录]</code>  </li><li>比如：<code>mount /dev/sdb1  /newdisk</code></li></ul></li><li>取消挂载<ul><li>指令：<code>umount [设备名称] 或者 [挂载目录]</code>、</li><li>比如：<code>umount /dev/sdb1</code>  或者 <code>umount /newdisk</code></li></ul></li></ul></li><li><p><strong>虚拟机增加硬盘步骤5</strong></p><ul><li><p>永久挂载：通过修改 /etc/fstab/ 实现挂载</p></li><li><p>使用：<code>vim /etc/fatab</code> 指令进入该文件进行修改</p></li><li><p>添加后 执行 <code>mount -a</code> 即刻生效</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012115543.png" alt=""></p></li></ul></li></ul><h5 id="三-磁盘情况查询"><a href="#三-磁盘情况查询" class="headerlink" title="三.磁盘情况查询"></a>三.磁盘情况查询</h5><ul><li><p>查询系统整体磁盘使用情况</p><ul><li><p>基本语法：<code>df -h</code></p></li><li><p>应用实例：查询系统整体磁盘使用情况</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012115927.png" alt=""></p></li></ul></li><li><p>查询指定目录的磁盘占用情况</p><ul><li><p>基本语法：<code>du - h</code></p></li><li><p>查询指定目录的磁盘占用情况，默认从当前目录</p><ul><li><code>-s</code>     指定目录占用大小汇总</li><li><code>-h</code>      带计量单位</li><li><code>-a</code>      含文件</li><li><code>--max-depth=1</code>   子目录深度</li><li><code>-c</code>       列出明细的同时，增加汇总值</li></ul></li><li><p>应用实例：</p><ul><li><p>查询 /opt 目录占用磁盘的情况，深度为1</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012120609.png" alt=""></p></li></ul></li></ul></li></ul><h5 id="四-磁盘情况-工作实用指令"><a href="#四-磁盘情况-工作实用指令" class="headerlink" title="四.磁盘情况-工作实用指令"></a>四.磁盘情况-工作实用指令</h5><ul><li><p>统计 /opt  文件夹下文件个数</p><ul><li>指令：<code>ls -l /opt | grep &quot;^-&quot; | wc -l</code></li></ul></li><li><p>统计 /opt  文件夹下目录个数</p><ul><li>指令：<code>ls -l /opt | grep &quot;^d&quot; | wc -l</code></li></ul></li><li><p>统计 /opt  文件夹下文件个数，包括子文件里面的</p><ul><li>指令：<code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code></li></ul></li><li><p>统计 /opt  文件夹下目录个数,包括子文件里面的</p><ul><li>指令：<code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code></li></ul></li><li><p>以树结构显示目录结构 tree 目录，注意，如果没有 tree，则使用 <code>yum install tree</code> 安装</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012121351.png" alt=""></p></li></ul><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h5 id="一-网络配置原理图"><a href="#一-网络配置原理图" class="headerlink" title="一.网络配置原理图"></a>一.网络配置原理图</h5><ul><li><p>Linux 网络配置原理图</p><p><img src="D:\图片\资料\QQ截图20221012154456.png" alt=""></p></li></ul><h5 id="二-查看虚拟网络编辑器和修改-IP-地址"><a href="#二-查看虚拟网络编辑器和修改-IP-地址" class="headerlink" title="二.查看虚拟网络编辑器和修改 IP 地址"></a>二.查看虚拟网络编辑器和修改 IP 地址</h5><ul><li><p>修改IP：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012155528.png" alt=""></p></li><li><p>查看网关：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012160453.png" alt=""></p></li></ul><h5 id="三-查看-windows-环境中-VMnet8-网络配置-ipconfig-指令"><a href="#三-查看-windows-环境中-VMnet8-网络配置-ipconfig-指令" class="headerlink" title="三.查看 windows 环境中 VMnet8 网络配置(ipconfig 指令)"></a>三.查看 windows 环境中 VMnet8 网络配置(ipconfig 指令)</h5><ul><li><p>指令：在 windows 的 dos 命令窗口 输入 <code>ipconfig</code></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012161245.png" alt=""></p></li><li><p>查看 Linux 的网络配置 (ifconfig)</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012161507.png" alt=""></p></li><li><p>ping 测试主机之间网络连通性</p><ul><li>基本语法：<code>ping [ip] 或者[dns]</code> (功能描述：测试当前服务器是否可以连接目的主机)</li><li>应用实例：测试当前服务器是否可以连接百度 <code>ping www.baidu.com</code></li></ul></li></ul><h5 id="四-Linux-网络环境配置"><a href="#四-Linux-网络环境配置" class="headerlink" title="四.Linux 网络环境配置"></a>四.Linux 网络环境配置</h5><ul><li>第一种方式(自动获取 DHCP)<ul><li>说明：登录后，通过界面的设置来自动获取ip，特点：Linux 启动后会自动获取ip，缺点是每次自动获取的ip地址可能会不一样(当该ip被其他主机占用时，会重新分配一个新的ip)</li></ul></li><li>第二种方式(指定ip)<ul><li>说明：直接修改配置文件夹来指定ip，并可以连接到外网</li><li>编辑：<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></li><li>要求：将 ip 地址配置为静态，比如：ip地址为：192.168.200.130</li><li>ifcfg-ens33 文件说明<ul><li><img src="D:\图片\资料\QQ截图20221012164508.png" alt=""></li><li><img src="D:\图片\资料\QQ截图20221012164542.png" alt=""></li></ul></li><li>重启网络服务或者重启系统生效<ul><li>指令：<code>service network restart</code> (重启网络服务)  或者 <code>reboot</code></li></ul></li></ul></li></ul><h5 id="五-设置主机名和hosts映射"><a href="#五-设置主机名和hosts映射" class="headerlink" title="五.设置主机名和hosts映射"></a>五.设置主机名和hosts映射</h5><ul><li><p>设置主机别名</p><ul><li><ol><li>为了方便记忆，可以给Linux系统设置主机别名，也可以根据需要修改主机别名</li><li>指令：<code>hostname</code> : 查看主机名</li><li>修改文件在 /etc/hostname  指定</li><li>修改后，重启生效</li></ol></li></ul></li><li><p>设置hosts映射</p><ul><li>windows<ul><li>在 C:\Windows\System32\drivers\etc\hosts  文件指定即可</li></ul></li><li>linux<ul><li>在 /etc/hosts  文件指定</li></ul></li></ul></li><li><p>主机域名解析 过程分析(DNS、Hosts) </p><ul><li><p>Hosts 是什么 ：一个文本文件，用来记录 IP 和 Hostname(主机名) 的映射关系</p></li><li><p>DNS：DNS 就是 Domain Name System 的缩写，翻译过来就是域名系统，是互联网上作为域名和 IP 地址相互映射的一个分布式数据库</p></li><li><p>应用实例：用户在浏览器上输入一个 <code>www.baidu.com</code></p><ul><li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存，如果有就直接返回IP完成解析。这两个缓存，可以理解为，本地解析器缓存</p></li><li><p>如果本地解析器缓存没有找到对应的映射，检查系统中 hosts 文件中有没有配置对应的域名IP映射，如果有，则完成解析返回</p></li><li><p>如果本地DNS解析器 和hosts文件中 没有找到对应映射，则到域名服务器 DNS 进行解析域</p><p>示意图：</p><p>​    <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012213541.png" alt=""></p></li><li><p>一般来说，当电脑第一次成功访问某一个网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址(DNS解析记录)。如在 cmd 窗口输入</p><ul><li><code>ipconfig /displaydns</code>  //DNS 域名解析缓存</li><li><code>ipconfig /flushdns</code>   //手动清理 dns 缓存</li></ul></li></ul></li></ul></li></ul><h1 id="进程管理-重点"><a href="#进程管理-重点" class="headerlink" title="进程管理(重点)"></a>进程管理(重点)</h1><ul><li><p>基本介绍：</p><ul><li><p>在 Linux 中，每一个执行的程序都称为一个进程。每一个进程都分配了一个 ID号(端口port) pid</p></li><li><p>每一个进程都可以以两种方式存在。前台和后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。(服务器类似后台)</p></li><li><p>一般系统的服务器都是以后台进程进行存在，而且都会常驻在系统中，直至关机才结束</p><p>示意图：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012214321.png" alt=""></p></li></ul></li></ul><h5 id="一-显示系统执行的进程"><a href="#一-显示系统执行的进程" class="headerlink" title="一.显示系统执行的进程"></a>一.显示系统执行的进程</h5><ul><li><p>基本介绍：<code>ps</code>  命令是用来查看目前系统中，有哪些正在执行的进程，以及它们执行的状况。可以不加参数</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221012215033.png" alt=""></p></li><li><p><code>ps</code> 详解</p><ul><li>指令：<code>ps-aux | grep xxx</code>  比如查看有没有sshd 服务</li><li>指令说明<ul><li><code>System V</code> ： 展示风格</li><li><code>User</code> ：用户名称</li><li><code>PID</code> ：进程号</li><li><code>%CPU</code> ：进程占用CPU的百分比</li><li><code>%MEM</code> ：进程占用物理内存的百分比</li><li><code>VSZ</code> ：进程占用虚拟内存大小(单位：kb)</li><li><code>RSS</code> ：进程占用的物理内存大小(单位：kb)</li><li><code>TT</code> ：终端名称，缩写</li><li><code>STAT</code> : 进程状态，其中 S- 睡眠，s- 表示改进程是会话的先导进程，N- 表示进程拥有比普通优先级更低的优先级，R- 正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li><li><code>STARTED</code> : 进程启动时间</li><li><code>TIME</code> : CPU 时间，即进程使用CPU的总时间</li><li><code>COMMAND</code> : 启动进程所用的命令和参数，如果过长会被截断显示</li></ul></li><li>应用实例：<ul><li>要求：以全格式显示当前所有的进程，查看进程的父进程。查看 sshd 的父进程信息</li><li><code>ps -ef</code> 是以全格式显示当前所有的进程</li><li><code>-e</code> 是显示所有进程，<code>-f</code> 是全格式</li><li><code>ps -ef | grep sshd</code></li><li><strong>是BSD风格</strong></li><li><code>UID</code> : 用户ID</li><li><code>PID</code> : 进程ID</li><li><code>PPID</code> ：父进程ID</li><li><code>C</code>  ：CPU 用于计算执行优先级的因子。数值越大，表示进程是CPU密集型运算，执行优先级会降低；数值越小，表示进程是 I/O 密集型运算，执行优先级会提高</li><li><code>STIME</code> ：进程启动时间</li><li><code>TTY</code> ：完整的终端名称</li><li><code>TIEM</code> ：CPU 时间</li><li><code>CMD</code> ：启动进程所用的命令和参数</li></ul></li></ul></li></ul><h5 id="二-终止进程-kill-和-killall"><a href="#二-终止进程-kill-和-killall" class="headerlink" title="二.终止进程 kill 和 killall"></a>二.终止进程 kill 和 killall</h5><ul><li>介绍：若是某个进程执行到一半需要停止时，或是已消费了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务</li><li>基本选项：<ul><li><code>kill [选项] [进程号]</code> (功能描述：通过进程号杀死/终止进程)</li><li><code>killall [进程名称]</code>  (功能描述：通过进程名称杀死进程，也支持通配符，这在系统负载过大而变得很慢时很有用)</li></ul></li><li>常用选项<ul><li><code>-9</code> : 表示强迫进程执行，立即停止</li></ul></li><li>应用实例：<ul><li>案例1：踢掉某个非法登录用户<ul><li>指令：<code>kill [进程号]</code>  <code>kill 11111</code></li></ul></li><li>案例2：终止远程登录服务 sshd,在适当的时候再次重启 sshd 服务<ul><li><code>kill sshd 11111</code>  11111 进程号 对应的是 /bin/system start sshd.service</li></ul></li><li>案例3：终止多个 gedit，演示<code>killall gedit</code></li><li>案例4：强制终止一个终端<ul><li>指令：<code>kill -9 bash [进程号]</code></li></ul></li></ul></li></ul><h5 id="三-查看进程树pstree"><a href="#三-查看进程树pstree" class="headerlink" title="三.查看进程树pstree"></a>三.查看进程树pstree</h5><ul><li>基本语法<ul><li><code>pstree [选项]</code> 可以更加直观的查看进程信息</li></ul></li><li>常用选项<ul><li><code>-p</code> : 显示进程的 PID</li><li><code>-u</code> ：显示进程的所属用户</li></ul></li><li>应用实例：<ul><li>案例1：请你以树状的形式显示进程的PID<ul><li>指令：<code>pstree -p</code></li></ul></li><li>案例2：请你以树状的形式显示进程的用户<ul><li>指令：<code>pstree -u</code></li></ul></li></ul></li></ul><h5 id="四-服务管理"><a href="#四-服务管理" class="headerlink" title="四.服务管理"></a>四.服务管理</h5><ul><li><p>介绍：服务(service)本质就是进程，但是是运行再后台的进程，通常都会监听某个端口，等待其他程序的请求，比如(mysqld,sshd,firewalld)等，因此我们又称为守护进程，是Linux中非常重要的知识。</p></li><li><p><strong><code>service</code> 管理指令</strong></p><ul><li><p><code>service [服务名] [ start | stop | restart | reload | status]</code> ：(服务器的开启与关闭)</p></li><li><p>在CentOS7.0后，很多服务不在使用 service ，而是 systemctl</p></li><li><p>service 指令管理的服务在 /etc/init.d 查看</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221014110742.png" alt=""></p></li></ul></li><li><p><strong>service 管理指令案例</strong></p><ul><li>请使用 service 指令，查看，关闭，启动， network [注意：在虚拟系统演示，因为网络连接会关闭]<ul><li>指令：<ul><li><code>service network status</code> ：network 服务的状态</li><li><code>service network stop</code> ：关闭，network 服务</li><li><code>service network start</code> : 开启，network 服务</li></ul></li></ul></li></ul></li><li><p><strong>查看服务名</strong></p><ul><li><p>方式1：使用 <code>setup</code> ——-&gt;系统服务 ，就能看到所有的服务</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221014111419.png" alt=""></p></li><li><p>方式2： /etc/init.d 查看 service 指令管理的服务</p><ul><li>指令：<code>ls -l /etc/init.d/</code></li></ul></li></ul></li><li><p><strong>服务的运行级别</strong></p><ul><li><p>运行级别0:系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</p></li><li><p>运行级别1:单用户工作状态，root 权限，用于系统维护，禁止远程登陆</p></li><li><p>运行级别2:多用户状态(没有NFS),不支持网络</p></li><li><p>运行级别3:完全的多用户状态(有NFS)，无界面，登陆后进入控制台命令行模式</p></li><li><p>运行级别4:系统未使用，保留</p></li><li><p>运行级别5: X11控制台，登陆后进入图形GUI模式</p></li><li><p>运行级别6:系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</p></li><li><p><strong>开机的流程说明：</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221014112148.png" alt=""></p></li></ul></li><li><p><strong><code>chkconfig</code> 指令</strong></p><ul><li><p>介绍：</p><ul><li>通过chkconfig命令可以给服务的各个运行级别设置自启动/关闭</li><li><strong>chkconfig指令管理的服务在/etc/init.d 查看</strong>；注意：(只能管理里面列出的服务)</li><li>注意: Centos7.0后，很多服务使用systemctl管理(后 面马上讲)</li></ul></li><li><p><strong><code>chkconfig</code> 基本语法</strong></p><ul><li><ol><li><p>查看服务 ：<code>chkconfig --list | grep xxx</code></p><p>​    <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221014141555.png" alt=""></p></li><li><p>修改服务的运行级别：<code>chkconfig --level [级别] [服务名] on/off</code></p></li></ol></li><li><p>案例演示：对 network 服务，进行各种操作，把 network 在3运行级别，关闭自动启</p><ul><li><code>chkconfig --level 3 network off</code>  自启动：关闭</li><li><code>chkconfig --level 3 network on</code>   自启动：开启</li></ul></li><li><p>使用细节：chkconfig 重新设置服务后自启动或关闭，需要重新启动机器 reboot 生效</p></li></ul></li></ul></li><li><p><strong><code>systemctl</code> 管理指令</strong></p><ul><li>基本语法：<code>systemctl [ start | stop | restart | status] [服务名]</code> ：(服务器的开启与关闭)</li><li><strong>systemctl  指令管理的服务在  /use/bin/systemd/system  查看</strong></li><li>systemctl 设置服务的自启动状态<ul><li><code>systemctl list-unit-files | grep [服务名]</code>  ：查看服务开机启动状态</li><li><code>systemctl enable [服务名]</code> ：设置服务开机启动 <strong>(默认是3和5的运行级别)</strong></li><li><code>systemctl disable [服务名]</code> ：设置关闭服务开机启动 <strong>(默认是3和5的运行级别)</strong></li><li><code>systemctl is-enabled [服务名]</code> ：查看某个服务是否开机启动</li></ul></li><li>应用案例：<ul><li>查看当前防火墙的状况，关闭防火墙和重启防火墙。(firewalld.service)</li><li><code>systemctl status firewalld</code> ：查看防火墙的状态</li><li><code>systemctl stop firewalld</code> ：关闭防火墙</li><li><code>systemctl start firewalld</code> ：开启防火墙</li><li>关闭或者启用防火墙后，立即生效。[telnet 测试某 个端口即可]；这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。<strong>如果希望设置某个服务自启动或关闭永久生效，要使用systemctl [enable | disable] 服务名</strong></li></ul></li></ul></li><li><p><strong>打开或者关闭指定端口</strong></p><ul><li><p>在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如80、22、 8080等，这个又怎么做呢?老韩给给大家讲一讲。[示意图]</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221014145941.png" alt=""></p></li><li><p><code>firewall</code> 指令</p><ul><li>打开端口：<code>firewall-cmd --permanent --add-port=端口号/协议</code></li><li>关闭端口：<code>firewall-cmd --permanent --remove-port=端口号/协议</code></li><li>重新载入，才能生效：<code>firewall-cmd --reload</code></li><li>查询端口是否开放：<code>firewall-cmd --query-port=端口号/协议</code></li></ul></li><li><p>应用案例</p><ul><li>启用防火墙，测试 111 端口是否能 telnet (不能)  指令：<code>systemctl start firewalld</code></li><li>开放 111 端口<ul><li>指令：<code>firewall-cmd --permanent --add-port=111/tcp</code></li><li>需要重新加载，才能生效：<code>firewall-cmd --reload</code></li></ul></li><li>再次关闭端口<ul><li>指令：<code>firewall-cmd --permanent --remove-port=111/tcp</code></li><li>需要重新加载，才能生效：<code>firewall-cmd --reload</code></li></ul></li></ul></li></ul></li><li><p><strong>动态监控进程</strong></p><ul><li><p>介绍：<code>top</code> 与 <code>ps</code> 指令很相似，他们都是用来显示正在执行的进程。<code>top</code> 与 <code>ps</code> 最大的不同之处，在于 <strong>top 在执行一段时间后可以更新正在执行的进程</strong></p></li><li><p>基本语法：</p><ul><li><p>指令：<code>top [选项]</code></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221015113013.png" alt=""></p></li><li><p>选项说明：</p><p>| ————————- | —————————————————————————— |<br>| ————————- | —————————————————————————— |<br>| 选项              | 功能                                                 |<br>| -d （秒数）       | 指定top命令每隔几秒更新，默认是3秒                   |<br>| -i                | 使top不显示任何闲置或者僵死的进程                    |<br>| -p                | 通过指定监控进程PID来仅仅监控某个进程的状态          |</p></li><li><p>交互操作说明</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221015113745.png" alt=""></p></li><li><p>应用实例：</p><ul><li>案例1：监视特定用户，比如我们监控 tom 用户<ul><li><code>top</code>: 输入此命令，按回车，查看执行的进程</li><li><code>u</code> : 然后，再输入用 <strong>tom</strong>，回车即可</li></ul></li><li>案例2：终止特定的进程，比如我们要结束 tom 登录<ul><li><code>top</code>: 输入此命令，按回车，查看执行的进程</li><li><code>u</code> : 然后，再输入用户名，回车即可</li><li><code>k</code> ：然后回车，输入要结束进程的PID 回车，最后输入 9 表示强制执行</li></ul></li><li>案例3：指定系统状态更新的时间（每隔10秒自动更新），默认三秒<ul><li><code>top -d 10</code></li></ul></li></ul></li></ul></li></ul></li><li><p><strong>监控网络状况</strong></p><ul><li><p>查看系统网络情况：<code>netstat</code></p></li><li><p>基本语法：<code>netstat [选项]</code></p></li><li><p>选项说明：</p><ul><li><code>-an</code> 按照一定顺序排列</li><li><code>-p</code> 显示哪个进程再调用</li></ul></li><li><p>应用案例：</p><ul><li><p>请查看服务名 为 sshd 的服务信息</p></li><li><p>指令：<code>netstat -anp | grep sshd</code></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221015140951.png" alt=""></p></li></ul></li></ul></li><li><p><strong>检测主机连接命令 ping </strong></p><ul><li>是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机的网线或网卡故障</li><li>指令：<code>ping [对方的IP]</code></li></ul></li></ul><h1 id="RPM-与-YUM"><a href="#RPM-与-YUM" class="headerlink" title="RPM 与 YUM"></a>RPM 与 YUM</h1><h5 id="rpm-包的管理"><a href="#rpm-包的管理" class="headerlink" title="rpm 包的管理"></a><strong>rpm 包的管理</strong></h5><ul><li>介绍：rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager ( RedHat软件包管理工具)的缩写，类似windows的setupexe,这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。Linux的分发版本都有采用(suse,redhat, centos等等)，可以算是公认的行业标准了。</li><li><strong>rpm 包名基本格式</strong><ul><li>一个 rpm 包名：firefox-60.2.2-1.e17.centos.x86_64</li><li>名称：firefox</li><li>版本号：60.2.2-1</li><li>适用操作系统：e17.centos.x86_64 ，表示 centos7.x 的64位操作系统，如果是 i686、i386 表示 32 位操作系统， noarch 表示通用</li></ul></li><li><strong>rmp 包的其他查询指令</strong><ul><li><code>rpm -qa</code>：查询所安装的所有 rpm 软件包</li><li><code>rpm -qa | more</code> </li><li><code>rpm -qa | grep xxx</code> ：查询已安装的 rpm 列表</li><li><code>rpm -q [软件包名]</code>  ：查询软件包，是否安装  <ul><li>举例：看看当前系统，是否安装了 firefox </li><li>指令：<code>rpm -q firefox</code>  或者 <code>rpm -qa | grep firefox</code></li></ul></li><li><code>rpm -qi [软件包名]</code> ：查询软件包名信息<ul><li>案例：<code>rpm -qi firefox</code></li></ul></li><li><code>rpm -qf [文件全路径名]</code> ：查询文件所属的软件包<ul><li>案例：查询 /etc/passwd 文件所属的软件包是什么</li><li><code>rpm -qf /etc/passwd</code></li></ul></li></ul></li><li><strong>卸载 rpm 包</strong><ul><li>基本语法：<code>rpm -e [RPM包的名称]</code> <ul><li>应用案例：删除 firefox 软件包</li><li>指令：<code>rpm -e firefox</code></li></ul></li><li>细节讨论<ul><li>如果其他软件包依赖于你要卸载的软件包，卸载时则会产生错误信息<ul><li>指令：<code>rpm -e foo</code></li><li>removing these packages would break dependencies:foo is needed by bar-1.0-1</li></ul></li><li>如果我们就是要删除foo这个rpm包，可以增加参数 —nodeps ,就可以强制删除，但是一.般不推荐这样做，因为依赖于该软件包的程序可能无法运行<ul><li>指令：<code>rpm -e --nodeps foo</code></li></ul></li></ul></li></ul></li><li><strong>安装 rpm 包</strong><ul><li>基本语法：<code>rpm -ivh [RPM包全路径名称]</code></li><li>参数说明：<ul><li><code>i</code> = install 安装</li><li><code>v</code> = verbose 提示</li><li><code>h</code> = hash 进度条</li></ul></li><li>应用案例 ：演示卸载和安装 firefox 浏览器<ul><li>卸载：<code>rpm -e firefox</code></li><li>安装：<code>rpm -ivh firefox</code></li></ul></li></ul></li></ul><h5 id="yum"><a href="#yum" class="headerlink" title="yum"></a><strong>yum</strong></h5><ul><li><p>介绍：Yum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且- -次安装所有依赖的软件包。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221015160020.png" alt=""></p></li><li><p><strong>yum 的基本指令</strong></p><ul><li>查询 yum 服务器是否有需要安装的软件</li><li>指令：<code>yum list | grep [软件包名]</code><ul><li>案例：查看 yum 服务器是否有 firefox</li><li>指令：<code>yum list | grep firefox</code></li></ul></li></ul></li><li><p><strong>安装指定的 yum 包</strong></p><ul><li>指令：<code>yum install [软件包名]</code> ：下载安装</li></ul></li><li><p>yum 应用实例：</p><ul><li>案例：请使用 yum 的方式，来安装 firefox</li><li>指令：<ul><li><code>rpm -e firefox</code>：删除firefox</li><li><code>yum list | grep firefox</code> ：查询 yum 服务器是否有firefox软件包</li><li><code>yum install firefox</code> ：从yum服务器上下载firefox</li></ul></li></ul></li></ul><h1 id="搭建javaSE环境"><a href="#搭建javaSE环境" class="headerlink" title="搭建javaSE环境"></a>搭建javaSE环境</h1><ul><li><p>概述：如果需要在Linux 下进行javaEE的开发，我们需要安装如下软件</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221017101750.png" alt=""></p></li></ul><h5 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h5><ul><li><p>安装步骤：</p><ul><li><ol><li><code>mkdir /opt/jdk</code>  ：创建新目录</li><li>通过 xftp6 上传到 /opt/jdk 下；将jdk 传至新目录下</li><li><code>cd /opt/jdk</code>：去已经有 jdk 的安装包下</li><li>解压 <code>tar -zxvf jdk-8u261-linux-x64.tar.gz</code>：对安装包进行解压</li><li><code>mkdir /usr/local/java</code> ：创建新目录</li><li><code>mv /opt/jdk/jdk.8.0_261 /usr/local/java</code> 将解压后的 jdk 放置在新目录下</li><li><code>vim /etc/profile</code> ：配置java环境变量的配置文件<ol><li>在配置文件下加入：<ol><li><code>export JAVA_HOME=/usr/local/java/jdk1.8.0_261</code> </li><li><code>export PATH=$JAVA_HOME/bin:$PATH</code></li></ol></li><li>保存并退出：<code>:wq</code></li></ol></li><li><code>source /etc/porfile</code> ：让新的环境变量生效</li></ol></li><li><p>测试是否安装成功</p><ul><li><p>编写一个简单的 Hello.java ;输出“hello,world”</p></li><li><p><code>vim Hello.java</code> 然后输入以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="安装-tomcat"><a href="#安装-tomcat" class="headerlink" title="安装 tomcat"></a>安装 tomcat</h5><ul><li><p>安装步骤：</p><ul><li><ol><li><code>mkdir /opt/tomcat</code>  ：创建新目录</li><li>通过 xftp6 将tomcat 传至新目录—-&gt;上传到 /opt/tomcat 下；</li><li><code>cd /opt/tomcat</code>：去已经有 tomcat 的安装包下</li><li>解压 <code>tar -zxvf [tomcat 的安装包]</code>：对安装包进行解压</li><li>进入 解压后的 /bin 目录；启动 tomcat<ol><li><code>cd /bin</code>      <code>./startup.sh</code></li></ol></li><li>开放端口 8080 <ol><li><code>firewall-cmd --permanent --add-port=8080/tcp</code></li><li>重新载入，才能生效：<code>firewall-cmd --reload</code></li></ol></li></ol></li></ul></li><li><p>测试是否安装成功</p><ul><li><p>在windows 的浏览器下的 URL 下输入：<a href="http://linuxip:8080">http://linuxip:8080</a> ;linuxip 为自己Linux的ip地址</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221017105827.png" alt=""></p><p>如果有此图表示成功</p></li></ul></li></ul><h5 id="idea2020的安装"><a href="#idea2020的安装" class="headerlink" title="idea2020的安装"></a>idea2020的安装</h5><ul><li>安装步骤：<ul><li><ol><li><code>mkdir /opt/idea</code>  ：创建新目录</li><li>通过 xftp6将idea 传至新目录—-&gt;上传到 /opt/idea 下；</li><li><code>cd /opt/idea</code>：去已经有 idea 的安装包下</li><li>解压 <code>tar -zxvf [idea 的安装包]</code>：对安装包进行解压</li><li>在 图形界面上进行操作：（不能远程操作及指令操作）<ol><li>通过指令进入 idea 的 bin 目录下：<code>cd /opt/idea</code>     <code>cd idea-IU-202.7660.26/</code>      <code>cd bin/</code></li><li>启动 idea bin目录下的 <code>./idea.sh</code>  就打开idea了</li></ol></li></ol></li></ul></li></ul><h5 id="mysql5-7的安装"><a href="#mysql5-7的安装" class="headerlink" title="mysql5.7的安装"></a>mysql5.7的安装</h5><ul><li><p>安装步骤：</p><ul><li><ol><li><p><code>mkdir /opt/mysql</code> : 新建文件夹/opt/mysql，并cd进去</p></li><li><p>通过 xftp6 将mysql传至新目录—-&gt;上传到 /opt/mysql 下 </p></li><li><p><code>cd /opt/mysql</code>：去已经有 mysql 的安装包下</p></li><li><p>运行 <code>tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar</code> ：对安装包进行解压</p></li><li><p>centos7.6自带的类mysql数据库是mariadb，会跟mysql冲突，要先删除。</p><ol><li>运行 <code>rpm -qa|grep mari</code>，查询mariadb相关安装包</li><li>运行 <code>rpm -e --nodeps mariadb-libs</code>，卸载</li><li>运行 <code>rpm -e --nodeps marlisa</code>，卸载</li></ol></li><li><p>然后开始真正安装mysql，依次运行以下几条  </p><ol><li><code>rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm</code></li><li><code>rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm</code></li><li><code>rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm</code></li><li><code>rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm</code></li></ol></li><li><p>运行 <code>systemctl start mysqld.service</code>，启动mysql</p></li><li><p>然后开始设置root用户密码</p><ol><li><p>Mysql自动给root用户设置随机密码，运行 <code>grep &quot;password&quot; /var/log/mysqld.log</code> 可看到当前密码  </p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221017112313.png" alt=""></p></li><li><p>运行 <code>mysql -u root -p</code>，用root用户登录，提示输入密码可用上述的，可以成功登陆进入mysql命令行</p></li><li><p>设置root密码，对于个人开发环境，如果要设比较简单的密码（<strong>生产环境服务器要设复杂密码</strong>），可以运行</p><p><code>set global validate_password_policy=0</code>  提示密码设置策略;（validate_password_policy默认值1，）</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20221017112515.png" alt=""></p></li><li><p><code>set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;hspedu100&#39;);</code> ：hspedu100 为新密码</p></li><li><p>运行 <code>flush privileges;</code> 使密码设置生效  （注意里面有 ; ）</p></li></ol></li></ol></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux笔记&quot;&gt;&lt;a href=&quot;#Linux笔记&quot; class=&quot;headerlink&quot; title=&quot;Linux笔记&quot;&gt;&lt;/a&gt;Linux笔记&lt;/h1&gt;&lt;h1 id=&quot;虚拟的克隆和快照及迁移和删除&quot;&gt;&lt;a href=&quot;#虚拟的克隆和快照及迁移和删除&quot; cla</summary>
      
    
    
    
    <category term="开发必备框架" scheme="https://manamn.space/categories/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="开发必备框架" scheme="https://manamn.space/tags/%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Web环境搭建以及Servlet入门</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-16T15:01:07.000Z</published>
    <updated>2022-12-13T12:57:32.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web环境搭建以及Servlet入门"><a href="#Web环境搭建以及Servlet入门" class="headerlink" title="Web环境搭建以及Servlet入门"></a>Web环境搭建以及Servlet入门</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>理解WEB相关概念和WEB服务器概念</li><li>会安装、卸载、启动和关闭tomcat</li><li>掌握使用tomcat部署项目</li><li>能够使用Eclipse开发Web应用程序</li><li>了解Servlet概念</li><li>掌握Servlet的执行原理和生命周期</li><li>掌握Servlet的体系结构，了解其他Servlet配置</li><li>掌握Servlet3.0注解配置</li><li>理解HTTP协议及HTTP请求和响应</li><li>熟练掌握Request和Response核心API</li><li>熟练掌握登陆案例</li></ul><h1 id="一-、Web相关概念"><a href="#一-、Web相关概念" class="headerlink" title="一 、Web相关概念"></a>一 、Web相关概念</h1><h3 id="1-1-软件架构"><a href="#1-1-软件架构" class="headerlink" title="1.1 软件架构"></a>1.1 软件架构</h3><p>WEB：在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。<br>JavaWeb：使用Java语言开发基于互联网的项目</p><h4 id="1-1-1-软件架构："><a href="#1-1-1-软件架构：" class="headerlink" title="1.1.1 软件架构："></a>1.1.1 软件架构：</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%9B%BE%E7%89%871.png" style="zoom:48%;" /></p><h4 id="1-1-2-软件架构详解："><a href="#1-1-2-软件架构详解：" class="headerlink" title="1.1.2 软件架构详解："></a>1.1.2 软件架构详解：</h4><ul><li><strong>C/S</strong>: Client/Server 客户端/服务器端<ul><li>在用户本地有一个客户端程序，在远程有一个服务器端程序<ul><li>如：QQ，迅雷…</li></ul></li><li>特点：<ul><li>充分发挥客户端PC的处理能力，很多数据可以通过客户端的处理后再发给服务器，降低了服务器的负荷，提高了速度。但维护和升级比较复杂，维护和升级是针对成千上万的客户机的。</li><li>必须安装专用的客户端软件。客户端是成千上万的，要安装专用软件，是多么大的工作量，如果一台客户机出现了问题，如：感染病毒、计算机故障等等原因，都需要进行安装或维护。系统软件需要升级的时候，每一台客户机都需要重新安装系统软件，维护和升级成本相当的高。</li><li>对客户机的操作系统有限制，对一些操作系统和新开发的操作系统不兼容。目前产品更新换代十分的快，要针对不同的操作系统系统版本开发不同的客户机软件，对成本而言是相当大。</li></ul></li></ul></li><li><strong>B/S</strong>: Browser/Server 浏览器/服务器端<ul><li>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序<ul><li>如：淘宝，京东…</li></ul></li><li>特点：<ul><li>维护和升级简单，我们只要对服务器端进行维护和升级即可，不需要对成千上万的客服端进行维护和升级，减少了人力资源成本。</li><li>随时随地都可以访问，只要有一台连接互联网和安装了浏览器的计算机就可以访问。</li><li>减轻了客户端电脑载荷，客户端电脑只要运行少部分程序就能实现。因此对客服端电脑要求不高，对服务器端负荷较重，由于主要的功能都集中到了服务器端，因此对服务器要求高，但总体而言，还是大大降低了成本。</li></ul></li></ul></li><li><strong>总结</strong>：B/S对C/S而言，B/S具有的优势。<ul><li>分布性：可以随时随地进行查询和浏览等业务；</li><li>功能业务扩展比较方便：增加服务器的功能，就能增加浏览器端的功能；</li><li>维护简单方便：改变服务器端数据即可以实现所有用户同步更新；</li><li>开发简单，共享性强，成本低，数据可以持久存储在服务器端而不必担心数据的丢失。</li></ul></li></ul><h3 id="1-2-Web资源分类"><a href="#1-2-Web资源分类" class="headerlink" title="1.2 Web资源分类"></a>1.2 Web资源分类</h3><ul><li><strong>静态资源：</strong><ul><li>使用静态网页开发技术发布的资源</li><li>特点：<ul><li>所有用户访问，得到的结果是一样的<ul><li>如：文本，图片，音频、视频, <code>HTML,CSS,JavaScript</code></li></ul></li><li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li></ul></li></ul></li><li><strong>动态资源：</strong><ul><li>使用动态网页技术发布的资源</li><li>特点：<ul><li>所有用户访问，得到的结果可能不一样<ul><li>如：<code>jsp/servlet,php,asp...</code></li></ul></li><li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器            </li></ul></li></ul></li></ul><h3 id="1-3-网络通信三要素"><a href="#1-3-网络通信三要素" class="headerlink" title="1.3 网络通信三要素"></a>1.3 网络通信三要素</h3><p><strong>IP</strong>：电子设备(计算机)在网络中的唯一标识</p><p><strong>端口</strong>：应用程序在计算机中的唯一标识。 0~65536</p><p><strong>传输协议</strong>：规定了数据传输的规则</p><ul><li><p>基础协议：</p><ul><li>tcp:安全协议，三次握手。 速度稍慢</li><li>udp：不安全协议。 速度快</li></ul></li><li><p>高级协议</p><ul><li>http协议<ul><li>基于TCP/IP的高级协议</li><li>基于请求/响应模型的:一次请求对应一次响应</li></ul></li></ul></li></ul><h3 id="1-4-Web资源请求响应过程"><a href="#1-4-Web资源请求响应过程" class="headerlink" title="1.4 Web资源请求响应过程"></a>1.4 Web资源请求响应过程</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt=""></p><h1 id="二、Web服务器软件"><a href="#二、Web服务器软件" class="headerlink" title="二、Web服务器软件"></a>二、Web服务器软件</h1><h3 id="2-1-web服务器软件概念"><a href="#2-1-web服务器软件概念" class="headerlink" title="2.1 web服务器软件概念"></a>2.1 web服务器软件概念</h3><p>服务器：安装了服务器软件的计算机。</p><p>服务器软件：接收用户的请求，处理请求，做出响应。</p><p>web服务器软件：接收用户的请求，处理请求，做出响应。</p><p>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目。</p><blockquote><p>疑问：学习web开发，为什么必须要先装一个WEB服务器 ?</p></blockquote><h3 id="2-2-常见的web服务器软件："><a href="#2-2-常见的web服务器软件：" class="headerlink" title="2.2 常见的web服务器软件："></a>2.2 常见的web服务器软件：</h3><ul><li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>webSphere：IBM公司， 大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</li></ul><h3 id="2-3-Tomcat：web服务器软件"><a href="#2-3-Tomcat：web服务器软件" class="headerlink" title="2.3 Tomcat：web服务器软件"></a>2.3 Tomcat：web服务器软件</h3><p>Tomcat免费的Web服务器，该服务器支持全部JSP以及Servlet规范，也是我们学习javaweb所使用的服务器，所以我们有必要深入了解;</p><h4 id="2-3-1-下载"><a href="#2-3-1-下载" class="headerlink" title="2.3.1 下载"></a>2.3.1 下载</h4><p>可以直接在官网下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><h4 id="2-3-2-安装"><a href="#2-3-2-安装" class="headerlink" title="2.3.2 安装"></a>2.3.2 安装</h4><p>解压压缩包即可。 </p><p>注意：安装目录建议不要有中文和空格,解压的目录结构如下图<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/tomcat.png" style="zoom:75%;" /></p><h4 id="2-3-3-卸载"><a href="#2-3-3-卸载" class="headerlink" title="2.3.3 卸载"></a>2.3.3 卸载</h4><p>删除目录就行了</p><h4 id="2-3-4-启动"><a href="#2-3-4-启动" class="headerlink" title="2.3.4 启动"></a>2.3.4 启动</h4><p><code>bin/startup.bat</code> ,双击运行该文件即可</p><p>访问：浏览器输入：<a href="http://localhost:8080">http://localhost:8080</a> 回车访问自己</p><p>​                                   <a href="http://别人的ip:8080">http://别人的ip:8080</a> 访问别人</p><p>显示如下界面表示成功</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/sss.png" alt=""></p><p><strong>启动时可能遇到的问题</strong>：</p><ol><li><p>黑窗口一闪而过：</p><ol><li>原因： 没有正确配置JAVA_HOME环境变量</li><li>解决方案：正确配置JAVA_HOME环境变量</li></ol></li><li><p>端口号被占用：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%8D%A0%E7%94%A8.png" style="zoom:67%;" /></p></li><li><p>暴力解决：找到占用的端口号，并且找到对应的进程，杀死该进程</p><ol><li><p>使用命令<code>netstat –ano|findstr [指定端口号]</code>找到占用端口的进程 </p></li><li><p>打开任务管理器-&gt;查看-&gt;选择列-&gt;然后勾选PID选项，回到任务管理器上可以查看到对应的pid，然后结束进程</p></li><li><p>温柔解决：修改自身的端口号</p></li></ol><p>在conf/server.xml 配置文件中修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">redirectPort</span>=<span class="string">&quot;8445&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</p><p>好处：在访问时，就不用输入端口号</p></blockquote></li></ol><h4 id="2-3-5-关闭"><a href="#2-3-5-关闭" class="headerlink" title="2.3.5 关闭"></a>2.3.5 关闭</h4><ul><li>正常关闭：<ul><li><code>bin/shutdown.bat</code></li><li><code>ctrl+c</code></li></ul></li><li>强制关闭：<ul><li>点击启动窗口的 <code>×</code></li></ul></li></ul><h4 id="2-3-6-Tomcat项目部署-（虚拟目录映射）"><a href="#2-3-6-Tomcat项目部署-（虚拟目录映射）" class="headerlink" title="2.3.6 Tomcat项目部署 （虚拟目录映射）"></a>2.3.6 Tomcat项目部署 （虚拟目录映射）</h4><p>Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为项目部署（虚拟目录的映射）。</p><ul><li><p>配置<code>conf/server.xml</code>文件, 在<code>&lt;Host&gt;</code>标签体中加入子标签配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;Context  path=&quot;虚拟路径&quot;   docBase =&quot;物理路径&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\hello&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/xixi&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><ul><li><p><code>docBase</code>:项目存放的路径</p></li><li><p><code>path</code>：虚拟目录</p></li></ul></li><li><p>直接将项目放到webapps目录下即可</p><ul><li><code>/hello</code>：项目的访问路径—&gt;虚拟目录</li><li>简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩。</li></ul></li></ul><h1 id="三、使用IDEA开发Web应用程序"><a href="#三、使用IDEA开发Web应用程序" class="headerlink" title="三、使用IDEA开发Web应用程序"></a>三、使用IDEA开发Web应用程序</h1><h2 id="3-1-创建Web项目"><a href="#3-1-创建Web项目" class="headerlink" title="3.1 创建Web项目"></a>3.1 创建Web项目</h2><p><strong>File  ——-&gt;  New  ——-&gt;   Project ——-&gt;</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172013846.png" alt="image-20220819172013846"></p><p><strong>开始创建Web项目</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172350009.png" alt="image-20220819172350009" style="zoom: 80%;" /></p><p><strong>右键添加Web框架依赖 </strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172544437.png" alt="image-20220819172544437" style="zoom:67%;" /></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172629012.png" alt="image-20220819172629012" style="zoom:80%;" /></p><h2 id="3-2-IDEA配置Tomcat"><a href="#3-2-IDEA配置Tomcat" class="headerlink" title="3.2 IDEA配置Tomcat"></a>3.2 IDEA配置Tomcat</h2><p><strong>tomcat详细配置</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819220432972.png" alt="image-20220819220432972" style="zoom:80%;" /></p><h2 id="3-3-JavaWeb应用目录结构"><a href="#3-3-JavaWeb应用目录结构" class="headerlink" title="3.3 JavaWeb应用目录结构"></a>3.3 JavaWeb应用目录结构</h2><p>开发web应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/javaweb%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"  /></p><blockquote><p>web应用中，web.xml文件是其中最重要的一个文件，它用于对web应用中的web资源进行配置。</p><p>但是在servlet3.0以后支持使用@Webservlet编程，进一步简化了JavaWeb开发。</p></blockquote><h1 id="四、Servlet"><a href="#四、Servlet" class="headerlink" title="四、Servlet"></a>四、Servlet</h1><h2 id="4-1-什么是Servlet？"><a href="#4-1-什么是Servlet？" class="headerlink" title="4.1 什么是Servlet？"></a>4.1 什么是Servlet？</h2><p>Servlet是一门用于开发动态web资源的技术，它是运行在服务器端的小程序。</p><p>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p><p>作用：Servlet主要用于处理客户端传来的HTTP请求，并返回一个响应，它能够处理的请求有doGet()和doPost()等方法。</p><p>用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：</p><ol><li>编写一个Java类，实现Servlet接口。</li><li>把开发好的Java类部署到web服务器中。</li></ol><h3 id="4-2什么是Servlet对象的生命周期"><a href="#4-2什么是Servlet对象的生命周期" class="headerlink" title="4.2什么是Servlet对象的生命周期"></a>4.2什么是Servlet对象的生命周期</h3><ul><li>Servlet对象什么时候被创建。</li><li>Servlet对象什么时候被销毁。</li><li>Servlet对象创建了几个？</li><li>Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li></ul><p>我们不需要在程序创建Servlet的对象，也没有去调用对象上的方法。Servlet对象的生命周期由web服务器负责</p><h3 id="Servlet对象是由谁来维护的？"><a href="#Servlet对象是由谁来维护的？" class="headerlink" title="Servlet对象是由谁来维护的？"></a>Servlet对象是由谁来维护的？</h3><ul><li>Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</li><li>Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。</li><li>Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】）</li><li>WEB容器来管理Servlet对象的死活。</li></ul><h3 id="思考：我们自己new的Servlet对象受WEB容器的管理吗？"><a href="#思考：我们自己new的Servlet对象受WEB容器的管理吗？" class="headerlink" title="思考：我们自己new的Servlet对象受WEB容器的管理吗？"></a>思考：我们自己new的Servlet对象受WEB容器的管理吗？</h3><ul><li>我们自己new的Servlet对象是不受WEB容器管理的。</li><li>WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中）</li><li>web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系</li><li><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819233802399.png" alt="image-20220819233802399" style="zoom:80%;" /><br>key对应请求路径，value对应我们写的servlet程序</li></ul><h3 id="研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？"><a href="#研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？" class="headerlink" title="研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？"></a>研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？</h3><ul><li>在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。</li><li><strong>经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。</strong></li><li>这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。</li><li>怎么让服务器启动的时候创建Servlet对象呢？</li><li>在servlet标签中添加子标签，在该子标签中填写整数，越小的整数优先级越高。我写负数时，测试出来也不会创建对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>aservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.AServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>aservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819233342293.png" alt="image-20220819233342293"></p><h3 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h3><ul><li>默认情况下服务器启动的时候AServlet对象并没有被实例化</li><li>下面这个是我用来测试Servlet生命周期写的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet无参数构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet&#x27;s init method execute!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet&#x27;s service method execute!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet&#x27;s destroy method execute!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>用户发送第一次请求的时候，控制台输出了以下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AServlet无参数构造方法执行了</span><br><span class="line">AServlet<span class="string">&#x27;s init method execute!</span></span><br><span class="line"><span class="string">AServlet&#x27;</span>s service method execute!</span><br></pre></td></tr></table></figure><ul><li>根据以上输出内容得出结论：<ul><li>用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。）<br>- AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。）</li><li>用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。</li></ul></li><li>用户继续发送第二次请求，控制台输出了以下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AServlet<span class="string">&#x27;s service method execute!</span></span><br></pre></td></tr></table></figure><ul><li>根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明：<ul><li>第一：Servlet对象是单例的（单实例的。)(但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。）</li><li>第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</li><li>第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</li></ul></li><li>关闭服务器的时候，控制台输出了以下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AServlet<span class="string">&#x27;s destroy method execute</span></span><br></pre></td></tr></table></figure><ul><li>通过以上输出内容，可以得出以下结论：<ul><li>Servlet的destroy方法只被Tomcat服务器调用一次。</li><li>destroy方法是在什么时候被调用的？<ul><li>在服务器关闭的时候。</li><li>因为服务器关闭的时候要销毁AServlet对象的内存。</li><li>服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。</li></ul></li></ul></li><li>请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？<ul><li>destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。因为destroy方法不是静态方法，它是实例方法，需要有对象才能调用。</li></ul></li><li>Servlet对象更像一个人的一生：<ul><li>Servlet的无参数构造方法执行：标志着你出生了。</li><li>Servlet对象的init方法的执行：标志着你正在接受教育。</li><li>Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。</li><li>Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。</li></ul></li><li>关于Servlet类中方法的调用次数？<ul><li>构造方法只执行一次。</li><li>init方法只执行一次。</li><li>service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。</li><li>destroy方法只执行一次。</li></ul></li><li><strong>当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？</strong><ul><li>报错了：500错误。</li><li>注意：500是一个HTTP协议的错误状态码。</li><li>500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。）</li><li>如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</li><li>所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</li></ul></li><li><strong>思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？</strong><ul><li>不能。</li><li>Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</li></ul></li><li>init、service、destroy方法中使用最多的是哪个方法？<ul><li>使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</li></ul></li></ul><h3 id="什么时候使用init方法呢？"><a href="#什么时候使用init方法呢？" class="headerlink" title="什么时候使用init方法呢？"></a>什么时候使用init方法呢？</h3><ul><li>init方法很少用。</li><li>通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池… 我们就想想什么样的代码只执行一次，并且在对象创建后执行</li><li>什么时候使用destroy方法呢？<ul><li>destroy方法也很少用。</li><li>通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。</li></ul></li></ul><p>看完后，再来复习一下</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="在这里插入图片描述"></p><h2 id="4-2-Servlet快速入门"><a href="#4-2-Servlet快速入门" class="headerlink" title="4.2 Servlet快速入门"></a>4.2 Servlet快速入门</h2><h4 id="案例2："><a href="#案例2：" class="headerlink" title="案例2："></a>案例2：</h4><p>快速入门，用Servlet向浏览器输出“hello servlet”。</p><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类，实现Servlet接口</p><ul><li>public class Demo1Servlet implements Servlet</li></ul></li><li><p>实现接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bailiban.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Servlet快速入门</span></span><br><span class="line"><span class="comment"> * 定义一个类实现Servlet接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Servlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供服务的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//向控制台输出一句话</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello Servlet&quot;</span>);</span><br><span class="line"><span class="comment">//得到输出对象</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> res.getWriter();</span><br><span class="line"><span class="comment">//向浏览器输出信息</span></span><br><span class="line">out.write(<span class="string">&quot;Hello Servlet&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.hp.servlet.Demo1Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/r1111.png" alt=""></p><p>6.Servlet执行原理</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/servlet%E5%8E%9F%E7%90%86.png" alt=""></p></li></ol><h2 id="4-3-Servlet3-0-注解配置"><a href="#4-3-Servlet3-0-注解配置" class="headerlink" title="4.3 Servlet3.0 注解配置"></a>4.3 Servlet3.0 注解配置</h2><p>Servlet3.0开始支持注解配置，通过WebServlet注解来实现映射，web.xml不再是必需的组件。</p><p><strong>步骤：</strong></p><ol><li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li><li>定义一个类，实现Servlet接口</li><li>复写方法</li><li>在类上使用<code>@WebServlet</code>注解，进行配置<ul><li><code>@WebServlet(&quot;资源路径&quot;)</code></li></ul></li></ol><p>下面是<code>@WebServlet</code>的源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    </span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//相当于&lt;Servlet-name&gt;</span></span><br><span class="line"></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//代表urlPatterns()属性配置</span></span><br><span class="line"></span><br><span class="line">String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//相当于&lt;url-pattern&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//相当于&lt;load-on-startup&gt;</span></span><br><span class="line"></span><br><span class="line"> WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-Servlet体系结构"><a href="#4-3-Servlet体系结构" class="headerlink" title="4.3 Servlet体系结构"></a>4.3 Servlet体系结构</h2><p> <code>Servlet</code>— 接口<br>        |</p><p><code>GenericServlet</code> — 抽象类<br>        |</p><p><code>HttpServlet</code>  — 抽象类</p><ul><li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><ul><li>定义Servlet类时，可以继承GenericServlet，实现service()方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bailiban.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.GenericServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 继承 GenericServlet 方式 创建Servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Servlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;继承 GenericServlet 方式 创建Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HttpServlet：对http协议的一种封装，简化操作 （我们一般使用这个）</p><ol><li>定义类继承HttpServlet</li><li>复写doGet/doPost方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bailiban.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 HttpServlet方式创建servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果请求方式为get执行该方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;get方式~~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果请求方式为post执行该方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;post方式~~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="案例4："><a href="#案例4：" class="headerlink" title="案例4："></a>案例4：</h4><p>分别以继承GenericServlet和HttpServlet方式 创建Servlet。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web环境搭建以及Servlet入门&quot;&gt;&lt;a href=&quot;#Web环境搭建以及Servlet入门&quot; class=&quot;headerlink&quot; title=&quot;Web环境搭建以及Servlet入门&quot;&gt;&lt;/a&gt;Web环境搭建以及Servlet入门&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
