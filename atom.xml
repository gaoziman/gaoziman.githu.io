<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>爱笑的Gao的个人博客</title>
  
  <subtitle>生活明朗 万物可爱</subtitle>
  <link href="https://manamn.space/atom.xml" rel="self"/>
  
  <link href="https://manamn.space/"/>
  <updated>2022-10-16T15:05:02.579Z</updated>
  <id>https://manamn.space/</id>
  
  <author>
    <name>Gao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web环境搭建以及Servlet入门</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Web%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8AServlet%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-16T15:01:07.000Z</published>
    <updated>2022-10-16T15:05:02.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web环境搭建以及Servlet入门"><a href="#Web环境搭建以及Servlet入门" class="headerlink" title="Web环境搭建以及Servlet入门"></a>Web环境搭建以及Servlet入门</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>理解WEB相关概念和WEB服务器概念</li><li>会安装、卸载、启动和关闭tomcat</li><li>掌握使用tomcat部署项目</li><li>能够使用Eclipse开发Web应用程序</li><li>了解Servlet概念</li><li>掌握Servlet的执行原理和生命周期</li><li>掌握Servlet的体系结构，了解其他Servlet配置</li><li>掌握Servlet3.0注解配置</li><li>理解HTTP协议及HTTP请求和响应</li><li>熟练掌握Request和Response核心API</li><li>熟练掌握登陆案例</li></ul><h1 id="一-、Web相关概念"><a href="#一-、Web相关概念" class="headerlink" title="一 、Web相关概念"></a>一 、Web相关概念</h1><h3 id="1-1-软件架构"><a href="#1-1-软件架构" class="headerlink" title="1.1 软件架构"></a>1.1 软件架构</h3><p>WEB：在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。<br>JavaWeb：使用Java语言开发基于互联网的项目</p><h4 id="1-1-1-软件架构："><a href="#1-1-1-软件架构：" class="headerlink" title="1.1.1 软件架构："></a>1.1.1 软件架构：</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%9B%BE%E7%89%871.png" style="zoom:48%;" /></p><h4 id="1-1-2-软件架构详解："><a href="#1-1-2-软件架构详解：" class="headerlink" title="1.1.2 软件架构详解："></a>1.1.2 软件架构详解：</h4><ul><li><strong>C/S</strong>: Client/Server 客户端/服务器端<ul><li>在用户本地有一个客户端程序，在远程有一个服务器端程序<ul><li>如：QQ，迅雷…</li></ul></li><li>特点：<ul><li>充分发挥客户端PC的处理能力，很多数据可以通过客户端的处理后再发给服务器，降低了服务器的负荷，提高了速度。但维护和升级比较复杂，维护和升级是针对成千上万的客户机的。</li><li>必须安装专用的客户端软件。客户端是成千上万的，要安装专用软件，是多么大的工作量，如果一台客户机出现了问题，如：感染病毒、计算机故障等等原因，都需要进行安装或维护。系统软件需要升级的时候，每一台客户机都需要重新安装系统软件，维护和升级成本相当的高。</li><li>对客户机的操作系统有限制，对一些操作系统和新开发的操作系统不兼容。目前产品更新换代十分的快，要针对不同的操作系统系统版本开发不同的客户机软件，对成本而言是相当大。</li></ul></li></ul></li><li><strong>B/S</strong>: Browser/Server 浏览器/服务器端<ul><li>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序<ul><li>如：淘宝，京东…</li></ul></li><li>特点：<ul><li>维护和升级简单，我们只要对服务器端进行维护和升级即可，不需要对成千上万的客服端进行维护和升级，减少了人力资源成本。</li><li>随时随地都可以访问，只要有一台连接互联网和安装了浏览器的计算机就可以访问。</li><li>减轻了客户端电脑载荷，客户端电脑只要运行少部分程序就能实现。因此对客服端电脑要求不高，对服务器端负荷较重，由于主要的功能都集中到了服务器端，因此对服务器要求高，但总体而言，还是大大降低了成本。</li></ul></li></ul></li><li><strong>总结</strong>：B/S对C/S而言，B/S具有的优势。<ul><li>分布性：可以随时随地进行查询和浏览等业务；</li><li>功能业务扩展比较方便：增加服务器的功能，就能增加浏览器端的功能；</li><li>维护简单方便：改变服务器端数据即可以实现所有用户同步更新；</li><li>开发简单，共享性强，成本低，数据可以持久存储在服务器端而不必担心数据的丢失。</li></ul></li></ul><h3 id="1-2-Web资源分类"><a href="#1-2-Web资源分类" class="headerlink" title="1.2 Web资源分类"></a>1.2 Web资源分类</h3><ul><li><strong>静态资源：</strong><ul><li>使用静态网页开发技术发布的资源</li><li>特点：<ul><li>所有用户访问，得到的结果是一样的<ul><li>如：文本，图片，音频、视频, <code>HTML,CSS,JavaScript</code></li></ul></li><li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li></ul></li></ul></li><li><strong>动态资源：</strong><ul><li>使用动态网页技术发布的资源</li><li>特点：<ul><li>所有用户访问，得到的结果可能不一样<ul><li>如：<code>jsp/servlet,php,asp...</code></li></ul></li><li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器            </li></ul></li></ul></li></ul><h3 id="1-3-网络通信三要素"><a href="#1-3-网络通信三要素" class="headerlink" title="1.3 网络通信三要素"></a>1.3 网络通信三要素</h3><p><strong>IP</strong>：电子设备(计算机)在网络中的唯一标识</p><p><strong>端口</strong>：应用程序在计算机中的唯一标识。 0~65536</p><p><strong>传输协议</strong>：规定了数据传输的规则</p><ul><li><p>基础协议：</p><ul><li>tcp:安全协议，三次握手。 速度稍慢</li><li>udp：不安全协议。 速度快</li></ul></li><li><p>高级协议</p><ul><li>http协议<ul><li>基于TCP/IP的高级协议</li><li>基于请求/响应模型的:一次请求对应一次响应</li></ul></li></ul></li></ul><h3 id="1-4-Web资源请求响应过程"><a href="#1-4-Web资源请求响应过程" class="headerlink" title="1.4 Web资源请求响应过程"></a>1.4 Web资源请求响应过程</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt=""></p><h1 id="二、Web服务器软件"><a href="#二、Web服务器软件" class="headerlink" title="二、Web服务器软件"></a>二、Web服务器软件</h1><h3 id="2-1-web服务器软件概念"><a href="#2-1-web服务器软件概念" class="headerlink" title="2.1 web服务器软件概念"></a>2.1 web服务器软件概念</h3><p>服务器：安装了服务器软件的计算机。</p><p>服务器软件：接收用户的请求，处理请求，做出响应。</p><p>web服务器软件：接收用户的请求，处理请求，做出响应。</p><p>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目。</p><blockquote><p>疑问：学习web开发，为什么必须要先装一个WEB服务器 ?</p></blockquote><h3 id="2-2-常见的web服务器软件："><a href="#2-2-常见的web服务器软件：" class="headerlink" title="2.2 常见的web服务器软件："></a>2.2 常见的web服务器软件：</h3><ul><li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>webSphere：IBM公司， 大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</li></ul><h3 id="2-3-Tomcat：web服务器软件"><a href="#2-3-Tomcat：web服务器软件" class="headerlink" title="2.3 Tomcat：web服务器软件"></a>2.3 Tomcat：web服务器软件</h3><p>Tomcat免费的Web服务器，该服务器支持全部JSP以及Servlet规范，也是我们学习javaweb所使用的服务器，所以我们有必要深入了解;</p><h4 id="2-3-1-下载"><a href="#2-3-1-下载" class="headerlink" title="2.3.1 下载"></a>2.3.1 下载</h4><p>可以直接在官网下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><h4 id="2-3-2-安装"><a href="#2-3-2-安装" class="headerlink" title="2.3.2 安装"></a>2.3.2 安装</h4><p>解压压缩包即可。 </p><p>注意：安装目录建议不要有中文和空格,解压的目录结构如下图<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/tomcat.png" style="zoom:75%;" /></p><h4 id="2-3-3-卸载"><a href="#2-3-3-卸载" class="headerlink" title="2.3.3 卸载"></a>2.3.3 卸载</h4><p>删除目录就行了</p><h4 id="2-3-4-启动"><a href="#2-3-4-启动" class="headerlink" title="2.3.4 启动"></a>2.3.4 启动</h4><p><code>bin/startup.bat</code> ,双击运行该文件即可</p><p>访问：浏览器输入：<a href="http://localhost:8080">http://localhost:8080</a> 回车访问自己</p><p>​                                   <a href="http://别人的ip:8080">http://别人的ip:8080</a> 访问别人</p><p>显示如下界面表示成功</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/sss.png" alt=""></p><p><strong>启动时可能遇到的问题</strong>：</p><ol><li><p>黑窗口一闪而过：</p><ol><li>原因： 没有正确配置JAVA_HOME环境变量</li><li>解决方案：正确配置JAVA_HOME环境变量</li></ol></li><li><p>端口号被占用：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%8D%A0%E7%94%A8.png" style="zoom:67%;" /></p></li><li><p>暴力解决：找到占用的端口号，并且找到对应的进程，杀死该进程</p><ol><li><p>使用命令<code>netstat –ano|findstr [指定端口号]</code>找到占用端口的进程 </p></li><li><p>打开任务管理器-&gt;查看-&gt;选择列-&gt;然后勾选PID选项，回到任务管理器上可以查看到对应的pid，然后结束进程</p></li><li><p>温柔解决：修改自身的端口号</p></li></ol><p>在conf/server.xml 配置文件中修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">redirectPort</span>=<span class="string">&quot;8445&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</p><p>好处：在访问时，就不用输入端口号</p></blockquote></li></ol><h4 id="2-3-5-关闭"><a href="#2-3-5-关闭" class="headerlink" title="2.3.5 关闭"></a>2.3.5 关闭</h4><ul><li>正常关闭：<ul><li><code>bin/shutdown.bat</code></li><li><code>ctrl+c</code></li></ul></li><li>强制关闭：<ul><li>点击启动窗口的 <code>×</code></li></ul></li></ul><h4 id="2-3-6-Tomcat项目部署-（虚拟目录映射）"><a href="#2-3-6-Tomcat项目部署-（虚拟目录映射）" class="headerlink" title="2.3.6 Tomcat项目部署 （虚拟目录映射）"></a>2.3.6 Tomcat项目部署 （虚拟目录映射）</h4><p>Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为项目部署（虚拟目录的映射）。</p><ul><li><p>配置<code>conf/server.xml</code>文件, 在<code>&lt;Host&gt;</code>标签体中加入子标签配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;Context  path=&quot;虚拟路径&quot;   docBase =&quot;物理路径&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\hello&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/xixi&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><ul><li><p><code>docBase</code>:项目存放的路径</p></li><li><p><code>path</code>：虚拟目录</p></li></ul></li><li><p>直接将项目放到webapps目录下即可</p><ul><li><code>/hello</code>：项目的访问路径—&gt;虚拟目录</li><li>简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩。</li></ul></li></ul><h1 id="三、使用IDEA开发Web应用程序"><a href="#三、使用IDEA开发Web应用程序" class="headerlink" title="三、使用IDEA开发Web应用程序"></a>三、使用IDEA开发Web应用程序</h1><h2 id="3-1-创建Web项目"><a href="#3-1-创建Web项目" class="headerlink" title="3.1 创建Web项目"></a>3.1 创建Web项目</h2><p><strong>File  ——-&gt;  New  ——-&gt;   Project ——-&gt;</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172013846.png" alt="image-20220819172013846"></p><p><strong>开始创建Web项目</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172350009.png" alt="image-20220819172350009" style="zoom: 80%;" /></p><p><strong>右键添加Web框架依赖 </strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172544437.png" alt="image-20220819172544437" style="zoom:67%;" /></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819172629012.png" alt="image-20220819172629012" style="zoom:80%;" /></p><h2 id="3-2-IDEA配置Tomcat"><a href="#3-2-IDEA配置Tomcat" class="headerlink" title="3.2 IDEA配置Tomcat"></a>3.2 IDEA配置Tomcat</h2><p><strong>tomcat详细配置</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819220432972.png" alt="image-20220819220432972" style="zoom:80%;" /></p><h2 id="3-3-JavaWeb应用目录结构"><a href="#3-3-JavaWeb应用目录结构" class="headerlink" title="3.3 JavaWeb应用目录结构"></a>3.3 JavaWeb应用目录结构</h2><p>开发web应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/javaweb%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png"  /></p><blockquote><p>web应用中，web.xml文件是其中最重要的一个文件，它用于对web应用中的web资源进行配置。</p><p>但是在servlet3.0以后支持使用@Webservlet编程，进一步简化了JavaWeb开发。</p></blockquote><h1 id="四、Servlet"><a href="#四、Servlet" class="headerlink" title="四、Servlet"></a>四、Servlet</h1><h2 id="4-1-什么是Servlet？"><a href="#4-1-什么是Servlet？" class="headerlink" title="4.1 什么是Servlet？"></a>4.1 什么是Servlet？</h2><p>Servlet是一门用于开发动态web资源的技术，它是运行在服务器端的小程序。</p><p>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p><p>作用：Servlet主要用于处理客户端传来的HTTP请求，并返回一个响应，它能够处理的请求有doGet()和doPost()等方法。</p><p>用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：</p><ol><li>编写一个Java类，实现Servlet接口。</li><li>把开发好的Java类部署到web服务器中。</li></ol><h3 id="4-2什么是Servlet对象的生命周期"><a href="#4-2什么是Servlet对象的生命周期" class="headerlink" title="4.2什么是Servlet对象的生命周期"></a>4.2什么是Servlet对象的生命周期</h3><ul><li>Servlet对象什么时候被创建。</li><li>Servlet对象什么时候被销毁。</li><li>Servlet对象创建了几个？</li><li>Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li></ul><p>我们不需要在程序创建Servlet的对象，也没有去调用对象上的方法。Servlet对象的生命周期由web服务器负责</p><h3 id="Servlet对象是由谁来维护的？"><a href="#Servlet对象是由谁来维护的？" class="headerlink" title="Servlet对象是由谁来维护的？"></a>Servlet对象是由谁来维护的？</h3><ul><li>Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</li><li>Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。</li><li>Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】）</li><li>WEB容器来管理Servlet对象的死活。</li></ul><h3 id="思考：我们自己new的Servlet对象受WEB容器的管理吗？"><a href="#思考：我们自己new的Servlet对象受WEB容器的管理吗？" class="headerlink" title="思考：我们自己new的Servlet对象受WEB容器的管理吗？"></a>思考：我们自己new的Servlet对象受WEB容器的管理吗？</h3><ul><li>我们自己new的Servlet对象是不受WEB容器管理的。</li><li>WEB容器创建的Servlet对象，这些Servlet对象都会被放到一个集合当中（HashMap），只有放到这个HashMap集合中的Servlet才能够被WEB容器管理，自己new的Servlet对象不会被WEB容器管理。（自己new的Servlet对象不在容器当中）</li><li>web容器底层应该有一个HashMap这样的集合，在这个集合当中存储了Servlet对象和请求路径之间的关系</li><li><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819233802399.png" alt="image-20220819233802399" style="zoom:80%;" /><br>key对应请求路径，value对应我们写的servlet程序</li></ul><h3 id="研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？"><a href="#研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？" class="headerlink" title="研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？"></a>研究：服务器在启动的Servlet对象有没有被创建出来（默认情况下）？</h3><ul><li>在Servlet中提供一个无参数的构造方法，启动服务器的时候看看构造方法是否执行。</li><li><strong>经过测试得出结论：默认情况下，服务器在启动的时候Servlet对象并不会被实例化。</strong></li><li>这个设计是合理的。用户没有发送请求之前，如果提前创建出来所有的Servlet对象，必然是耗费内存的，并且创建出来的Servlet如果一直没有用户访问，显然这个Servlet对象是一个废物，没必要先创建。</li><li>怎么让服务器启动的时候创建Servlet对象呢？</li><li>在servlet标签中添加子标签，在该子标签中填写整数，越小的整数优先级越高。我写负数时，测试出来也不会创建对象</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>aservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.bjpowernode.javaweb.servlet.AServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>aservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220819233342293.png" alt="image-20220819233342293"></p><h3 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h3><ul><li>默认情况下服务器启动的时候AServlet对象并没有被实例化</li><li>下面这个是我用来测试Servlet生命周期写的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet无参数构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet&#x27;s init method execute!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet&#x27;s service method execute!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AServlet&#x27;s destroy method execute!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>用户发送第一次请求的时候，控制台输出了以下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AServlet无参数构造方法执行了</span><br><span class="line">AServlet<span class="string">&#x27;s init method execute!</span></span><br><span class="line"><span class="string">AServlet&#x27;</span>s service method execute!</span><br></pre></td></tr></table></figure><ul><li>根据以上输出内容得出结论：<ul><li>用户在发送第一次请求的时候Servlet对象被实例化（AServlet的构造方法被执行了。并且执行的是无参数构造方法。）<br>- AServlet对象被创建出来之后，Tomcat服务器马上调用了AServlet对象的init方法。（init方法在执行的时候，AServlet对象已经存在了。已经被创建出来了。）</li><li>用户发送第一次请求的时候，init方法执行之后，Tomcat服务器马上调用AServlet对象的service方法。</li></ul></li><li>用户继续发送第二次请求，控制台输出了以下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AServlet<span class="string">&#x27;s service method execute!</span></span><br></pre></td></tr></table></figure><ul><li>根据以上输出结果得知，用户在发送第二次，或者第三次，或者第四次请求的时候，Servlet对象并没有新建，还是使用之前创建好的Servlet对象，直接调用该Servlet对象的service方法，这说明：<ul><li>第一：Servlet对象是单例的（单实例的。)(但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。）</li><li>第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</li><li>第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</li></ul></li><li>关闭服务器的时候，控制台输出了以下内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AServlet<span class="string">&#x27;s destroy method execute</span></span><br></pre></td></tr></table></figure><ul><li>通过以上输出内容，可以得出以下结论：<ul><li>Servlet的destroy方法只被Tomcat服务器调用一次。</li><li>destroy方法是在什么时候被调用的？<ul><li>在服务器关闭的时候。</li><li>因为服务器关闭的时候要销毁AServlet对象的内存。</li><li>服务器在销毁AServlet对象内存之前，Tomcat服务器会自动调用AServlet对象的destroy方法。</li></ul></li></ul></li><li>请问：destroy方法调用的时候，对象销毁了还是没有销毁呢？<ul><li>destroy方法执行的时候AServlet对象还在，没有被销毁。destroy方法执行结束之后，AServlet对象的内存才会被Tomcat释放。因为destroy方法不是静态方法，它是实例方法，需要有对象才能调用。</li></ul></li><li>Servlet对象更像一个人的一生：<ul><li>Servlet的无参数构造方法执行：标志着你出生了。</li><li>Servlet对象的init方法的执行：标志着你正在接受教育。</li><li>Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。</li><li>Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。</li></ul></li><li>关于Servlet类中方法的调用次数？<ul><li>构造方法只执行一次。</li><li>init方法只执行一次。</li><li>service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。</li><li>destroy方法只执行一次。</li></ul></li><li><strong>当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？</strong><ul><li>报错了：500错误。</li><li>注意：500是一个HTTP协议的错误状态码。</li><li>500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。）</li><li>如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</li><li>所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</li></ul></li><li><strong>思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？</strong><ul><li>不能。</li><li>Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</li></ul></li><li>init、service、destroy方法中使用最多的是哪个方法？<ul><li>使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</li></ul></li></ul><h3 id="什么时候使用init方法呢？"><a href="#什么时候使用init方法呢？" class="headerlink" title="什么时候使用init方法呢？"></a>什么时候使用init方法呢？</h3><ul><li>init方法很少用。</li><li>通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池… 我们就想想什么样的代码只执行一次，并且在对象创建后执行</li><li>什么时候使用destroy方法呢？<ul><li>destroy方法也很少用。</li><li>通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。</li></ul></li></ul><p>看完后，再来复习一下</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="在这里插入图片描述"></p><h2 id="4-2-Servlet快速入门"><a href="#4-2-Servlet快速入门" class="headerlink" title="4.2 Servlet快速入门"></a>4.2 Servlet快速入门</h2><h4 id="案例2："><a href="#案例2：" class="headerlink" title="案例2："></a>案例2：</h4><p>快速入门，用Servlet向浏览器输出“hello servlet”。</p><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类，实现Servlet接口</p><ul><li>public class Demo1Servlet implements Servlet</li></ul></li><li><p>实现接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bailiban.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Servlet快速入门</span></span><br><span class="line"><span class="comment"> * 定义一个类实现Servlet接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Servlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提供服务的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//向控制台输出一句话</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello Servlet&quot;</span>);</span><br><span class="line"><span class="comment">//得到输出对象</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> res.getWriter();</span><br><span class="line"><span class="comment">//向浏览器输出信息</span></span><br><span class="line">out.write(<span class="string">&quot;Hello Servlet&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.hp.servlet.Demo1Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>运行效果</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/r1111.png" alt=""></p><p>6.Servlet执行原理</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/servlet%E5%8E%9F%E7%90%86.png" alt=""></p></li></ol><h2 id="4-3-Servlet3-0-注解配置"><a href="#4-3-Servlet3-0-注解配置" class="headerlink" title="4.3 Servlet3.0 注解配置"></a>4.3 Servlet3.0 注解配置</h2><p>Servlet3.0开始支持注解配置，通过WebServlet注解来实现映射，web.xml不再是必需的组件。</p><p><strong>步骤：</strong></p><ol><li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li><li>定义一个类，实现Servlet接口</li><li>复写方法</li><li>在类上使用<code>@WebServlet</code>注解，进行配置<ul><li><code>@WebServlet(&quot;资源路径&quot;)</code></li></ul></li></ol><p>下面是<code>@WebServlet</code>的源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    </span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//相当于&lt;Servlet-name&gt;</span></span><br><span class="line"></span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//代表urlPatterns()属性配置</span></span><br><span class="line"></span><br><span class="line">String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//相当于&lt;url-pattern&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//相当于&lt;load-on-startup&gt;</span></span><br><span class="line"></span><br><span class="line"> WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-Servlet体系结构"><a href="#4-3-Servlet体系结构" class="headerlink" title="4.3 Servlet体系结构"></a>4.3 Servlet体系结构</h2><p> <code>Servlet</code>— 接口<br>        |</p><p><code>GenericServlet</code> — 抽象类<br>        |</p><p><code>HttpServlet</code>  — 抽象类</p><ul><li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><ul><li>定义Servlet类时，可以继承GenericServlet，实现service()方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bailiban.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.GenericServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 继承 GenericServlet 方式 创建Servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1Servlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;继承 GenericServlet 方式 创建Servlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HttpServlet：对http协议的一种封装，简化操作 （我们一般使用这个）</p><ol><li>定义类继承HttpServlet</li><li>复写doGet/doPost方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bailiban.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 HttpServlet方式创建servlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Servlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果请求方式为get执行该方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;get方式~~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//如果请求方式为post执行该方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;post方式~~~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="案例4："><a href="#案例4：" class="headerlink" title="案例4："></a>案例4：</h4><p>分别以继承GenericServlet和HttpServlet方式 创建Servlet。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Web环境搭建以及Servlet入门&quot;&gt;&lt;a href=&quot;#Web环境搭建以及Servlet入门&quot; class=&quot;headerlink&quot; title=&quot;Web环境搭建以及Servlet入门&quot;&gt;&lt;/a&gt;Web环境搭建以及Servlet入门&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一文学懂JSP</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82JSP/</id>
    <published>2022-10-16T15:00:49.000Z</published>
    <updated>2022-10-16T15:05:02.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文学懂JSP"><a href="#一文学懂JSP" class="headerlink" title="一文学懂JSP"></a>一文学懂JSP</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><h1 id="第1章-为什么要学习JSP"><a href="#第1章-为什么要学习JSP" class="headerlink" title="第1章 为什么要学习JSP"></a>第1章 为什么要学习JSP</h1><h2 id="1-1-现有技术不足"><a href="#1-1-现有技术不足" class="headerlink" title="1.1 现有技术不足"></a>1.1 现有技术不足</h2><p>Servlet可以通过转发或重定向跳转到某个HTML文档。但HTML文档中的内容不受Servlet的控制。比如登录失败时，跳转回登录表单页面无法显示诸如“用户名或密码不正确”的错误消息，所以我们目前采用的办法是跳转到一个错误信息页面。如果通过Servlet逐行输出响应信息则会非常繁琐。</p><p><strong>Servlet输入html页面的程序代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gaoziman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/23 19:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置返回的数据内容的数据类型和编码</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html; charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取字符输出流</span></span><br><span class="line">        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="comment">//输出页面内容！</span></span><br><span class="line">        writer.write(<span class="string">&quot;&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot; \&quot;http://www.w3.org/TR/html4/loose.dtd\&quot;&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;head&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=UTF-8\&quot;&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;title&gt;Insert title here&lt;/title&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;这是由Servlet程序输出的html页面内容！&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接着，在浏览器中输入访问Servlet的访问路径得到以下结果：</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823193538516.png" alt="image-20220823193538516"></p><p>上面的代码我们不难发现。通过Servlet输出简单的html页面信息都非常不方便。那我们要输出一个复杂页面的时候，就更加的困难，而且不利于页面的维护和调试。</p><h2 id="1-2-Servlet与HTML"><a href="#1-2-Servlet与HTML" class="headerlink" title="1.2 Servlet与HTML"></a>1.2 Servlet与HTML</h2><div class="table-container"><table><thead><tr><th></th><th>Servlet</th><th>HTML</th></tr></thead><tbody><tr><td>长处</td><td>接收请求参数，访问域对象，转发页面</td><td>以友好方式显示数据</td></tr><tr><td>短处</td><td>以友好方式显示数据</td><td>动态显示数据</td></tr></tbody></table></div><h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p>那能否将Servlet和HTML二者的长处结合起来呢？</p><p>能！sun公司推出一种叫做JSP的动态页面技术帮助我们实现对页面输出繁锁工作。</p><h1 id="第2章-JSP简介"><a href="#第2章-JSP简介" class="headerlink" title="第2章 JSP简介"></a>第2章 JSP简介</h1><h2 id="2-1-JSP全称"><a href="#2-1-JSP全称" class="headerlink" title="2.1 JSP全称"></a>2.1 JSP全称</h2><ul><li>JSP全称Java Server Pages，顾名思义就是运行在java服务器中的页面。由Sun 公司专门为了解决动态生成HTML文档的技术，也就是在我们JavaWeb中的动态页面。</li><li>JSP能够以HTML页面的方式呈现数据，是一个可以嵌入Java代码的HTML。</li><li>JSP其本质就是一个<code>Servlet</code>。Servlet能做的事情 <code>JSP</code> 都能做。</li><li>JSP必须运行在服务器中，不能直接使用浏览器打开。</li><li>JSP是Web网页的技术标准,主要语法组成包括：指令，html模板元素，脚本片段（小脚本），表达式，声明，注释，后缀是*.JSP。</li><li>JSP的主要作用是代替Servlet程序回传HTML页面的数据</li><li>web目录(或其他)右击 —&gt; new —&gt; JSP/JSPX —&gt; 输入文件名 —&gt; 选择JSP file创建</li></ul><h2 id="2-2-JSP与HTML的区别"><a href="#2-2-JSP与HTML的区别" class="headerlink" title="2.2 JSP与HTML的区别"></a>2.2 JSP与HTML的区别</h2><ul><li><p>JSP是动态页面，html是静态页面。</p><p>|          | 动态页面                                     | 静态页面                           |<br>| ———— | —————————————————————— | ————————————————— |<br>| 运行原理 | 通过服务器解析后，将数据在浏览器中显示       | 直接在浏览器中解析运行             |<br>| 维护成本 | 较低，可以修改后台数据，进而影响页面中的数据 | 较高，必须将修改后的页面覆盖原页面 |<br>| 数据库   | 可以连接数据库                               | 不可连接数据库                     |<br>| 访问速度 | 较慢                                         | 较快                               |<br>| 书写代码 | 可以书写java代码                             | 不能书写java代码                   |</p></li></ul><h2 id="2-3-JSP与Servlet分工"><a href="#2-3-JSP与Servlet分工" class="headerlink" title="2.3 JSP与Servlet分工"></a>2.3 JSP与Servlet分工</h2><ul><li>JSP本质是一个Servlet ，翻译后的文件结构为：class helloworld_JSP : HttpJSPBase : HttpServlet。</li><li>JSP主要负责显示及获取数据，从表面上看，JSP 相对于在html中嵌入java代码：JSP=html+java。</li><li>Servlet主要负责处理业务，从表面上看，Servlet相当于在java中嵌入html代码：Servlet=java+html。</li><li>总结：相比于Servlet，JSP更加善于处理显示页面，而Servlet更善于处理业务逻辑，两种技术各有专长，所以一般我们会将Servlet和 JSP 结合使用，Servlet负责业务，JSP 负责显示。</li></ul><h2 id="2-4-JSP基本格式"><a href="#2-4-JSP基本格式" class="headerlink" title="2.4 JSP基本格式"></a>2.4 JSP基本格式</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;JSP页面&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">这是我的第一个JSP页面。</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="2-5-JSP的本质"><a href="#2-5-JSP的本质" class="headerlink" title="2.5 JSP的本质"></a>2.5 JSP的本质</h2><blockquote><p>JSP页面本质上是一个Servlet程序，第一次访问JSP页面时(运行Tomcat服务器后在浏览器地址栏输入路径)，Tomcat服务器会将此JSP页面翻译成为一个Java源文件，并对其进行编译成为.class字节码文件(一个.java，一个.class)，当打开.java文件时发现其中的内容是：</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20200811124521945.png" alt=""></p><blockquote><p>而HttpJspBase类直接继承于HttpServlet类，即JSP翻译出来的Java类间接继承于HttpServlet类，证明JSP页面是一个Servlet程序</p></blockquote><h1 id="第3章-JSP初体验"><a href="#第3章-JSP初体验" class="headerlink" title="第3章 JSP初体验"></a>第3章 JSP初体验</h1><h2 id="3-1-创建一个JSP动态页面程序：HelloWorld"><a href="#3-1-创建一个JSP动态页面程序：HelloWorld" class="headerlink" title="3.1 创建一个JSP动态页面程序：HelloWorld"></a>3.1 创建一个JSP动态页面程序：HelloWorld</h2><p><strong>① 选中Web目录，右键创建一个jsp文件</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823194648212.png" alt="image-20220823194648212"></p><p><strong>②在body标签中添加你想要显示的文本内容</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823195139844.png" alt="image-20220823195139844" style="zoom:80%;" /></p><p><strong>③然后在浏览器中输入jsp页面的访问地址</strong></p><ul><li>jsp页面的访问地址和html页面的访问路径一样<a href="http://ip:端口号/工程名/文件名。也就是https://localhost:8080/day07/demo.jsp">http://ip:端口号/工程名/文件名。也就是https://localhost:8080/day07/demo.jsp</a></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823193538516.png" alt="image-20220823193538516"></p><p><strong>注意事项：</strong></p><p>1、jsp 页面是一个类似于 <code>html</code> 的一个页面。 jsp直接存放到 <code>web</code>目录下，和html一样访问 jsp 的时候，也和访问html一样</p><p>2、jsp 的默认编码集是 <code>ISO-8859-1</code>，修改 jsp 的默认编码为<code>UTF-8</code></p><h2 id="3-2-JSP运行原理"><a href="#3-2-JSP运行原理" class="headerlink" title="3.2 JSP运行原理"></a>3.2 JSP运行原理</h2><ul><li><p>jsp的本质其实是一个Servlet程序。</p><ul><li>实际上Tomcat在运行JSP时，并不是直接显示的我们所编写的JSP页面，而是将JSP页面转换成了一个Java类，这个Java类是什么，我想大家也能猜到了，它实际上就是一个Servlet。</li></ul></li><li><p>这个Servlet在哪呢？在Tomcat目录中work目录中，在那个目录下保存着 Tomcat自动生成的一些内容，下面让我们来找到那个目录。</p></li><li><p>在work目录下的…work\Catalina\localhost\day07_jsp\org\apache\jsp文件夹中我们可以发现两个文件index_jsp.java和index_jsp.class，前者就是Tomcat自动生成的Servlet的源码，后者是编译后的.class文件。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558366745836.png" alt="1558366745836"></p></li></ul><p>打开index_jsp.java文件部分内容如下：</p><ul><li><p>图一：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823200206048.png" alt="image-20220823200206048"></p><p>我们打开index_jsp.java文件查看里面的内容：发现，生成的类继承于HttpJspBase类。这是一个jsp文件生成Servlet程序要继承的基类！于是，我们关联源代码。去查看一下HttpJspBase类的内容。从源码的类注释说明中，我们发现。HttpJspBase这个类就是所有JSP文件生成Servlet程序需要去继承的基类。并且这个HttpJspBase类继承于HttpServlet类。我们访问JSP时服务器就是调用了该Servlet来响应请求。所以JSP也是一个Servlet小程序。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558367072400.png" alt="1558367072400"></p><p>我们分别在工程的WebContent目录下创建多个jsp文件。然后依次访问。它们都被翻译为.java文件并编译成为.class字节码文件。</p></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/JSP%E5%8E%9F%E7%90%86.png" alt=""></p><ul><li><p>我们顺着代码向下看，会发现_jspService()方法。会发现有九个对象（实际上默认会看到八个），这是后面要讲到的重点。</p><ul><li><p>图二：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jsp%E7%BF%BB%E8%AF%91servlet%E5%90%8E%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%812.png" alt="jsp翻译servlet后部分源码2"></p></li></ul></li></ul><p><strong>小结：</strong>            </p><p>从生成的文件我们不难发现一个规则：</p><p>a.jsp 翻译成 java文件后的全名是    a_jsp.java文件</p><p>b.jsp 翻译成 java文件后的全名是    b_jsp.java文件</p><p><strong>那么当我们访问 一个xxx.jsp文件后翻译成java文件的全名是  xxx_jsp.java文件。</strong></p><p><strong>xxx_jsp.java文件是一个Servlet程序。原来jsp中的html内容都被翻译到Servlet类的service方法中原样输出。</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558023396492.png" alt="1558023396492"></p><p><strong>Servlet是需要在web.xml中配置的</strong>，而我们并没有配置JSP的serlvet映射，那他是如何访问的呢？实际在tomcat下的conf目录中的<strong>web.xm</strong>l早已配置好了JSP的映射信息，具体内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.jasper.servlet.JspServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>fork<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>xpoweredBy<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>jsp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jspx<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="总结Jsp运行原理"><a href="#总结Jsp运行原理" class="headerlink" title="总结Jsp运行原理"></a>总结Jsp运行原理</h4><ol><li><strong>第一次访问jsp页面时，服务器会将xxx.jsp文件翻译成xxx_jsp.java文件，再编译成xxx_jsp.class文件。</strong> </li><li><strong>以后在访问同一个jsp文件</strong><ul><li><strong>如果文件未改变，不会被翻译和编译</strong></li><li><strong>如果文件改变，会翻译和编译</strong></li></ul></li></ol><h1 id="第4章-JSP基本语法"><a href="#第4章-JSP基本语法" class="headerlink" title="第4章 JSP基本语法"></a>第4章 JSP基本语法</h1><p>JSP头部的page指令：</p><p>JSP头部的page指令可以修改JSP页面中的一些重要属性或行为<br>(以下属性均写在page指令中，默认page指令中没有出现的属性都采用默认值)：</p><blockquote><p>(1) contentType属性：表示JSP返回的数据类型是什么，即response.setContentType()的参数值<br>(2) language属性：表示JSP翻译之后是什么语言文件(目前只支持Java)<br>(3) pageEncoding属性：表示当前JSP文件本身的字符集(可在IDEA右下角看到)<br>(4) import属性：表示导包(导类)，与Java一致<br>(5) autoFlush属性：设置当out输出流缓冲区满了之后是否自动刷新缓冲区，默认值是true<br>(6) buffer属性：设置out缓冲区的大小，默认是8kb<br>注意：out缓冲区满了之后不能自动刷新的话会报错<br>(7) errorPage属性：设置当JSP页面运行出错时自动跳转到的页面(错误信息页面)的路径，这个 路径一般都是以斜杠打头，表示请求的地址是<a href="http://ip:port/工程路径/，对应代码web目录">http://ip:port/工程路径/，对应代码web目录</a><br>(8) isErrorPage属性：设置当前JSP页面是否是错误信息页面，默认是false，如果是true可以 获取错误信息<br>(9) session属性：设置访问当前JSP页面时是否会创建HttpSession对象，默认值是true<br>(10) extends属性：设置JSP页面翻译出来的Java类默认继承谁</p></blockquote><p><strong>注意：以上默认值除非有特殊需要，否则不建议修改</strong></p><h2 id="4-1指令"><a href="#4-1指令" class="headerlink" title="4.1指令"></a>4.1指令</h2><ul><li><p>语法格式：&lt;%@ %&gt;  </p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br></pre></td></tr></table></figure></li><li><p>三大指令：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page %&gt; ，&lt;%@ include %&gt; ，| &lt;%@ taglib %&gt; </span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2模板元素"><a href="#4-2模板元素" class="headerlink" title="4.2模板元素"></a>4.2模板元素</h2><ul><li>html&amp;css&amp; js &amp;jQuery 等…</li></ul><h2 id="4-3代码脚本片段（重点）"><a href="#4-3代码脚本片段（重点）" class="headerlink" title="4.3代码脚本片段（重点）"></a>4.3代码脚本片段（重点）</h2><ul><li><p>格式 ：&lt;%%&gt;</p></li><li><p>作用：在_jspService()方法中，书写java代码。</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;%&gt;</span><br><span class="line">&lt;%-- &lt;% 第一种方式声明%&gt; --%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-4表达式（重点）"><a href="#4-4表达式（重点）" class="headerlink" title="4.4表达式（重点）"></a>4.4表达式（重点）</h2><ul><li>格式：&lt;%=表达式 %&gt;</li><li>作用：在浏览器的JSP页面上输出数据(只有此脚本可以在浏览器的页面上输出数据)</li><li>特点：<br>(1) 所有的表达式脚本都会被翻译到对应的Java类的 <code>_ jspService()</code>方法中，故表达式脚本可以 直接使用 <code>_jspService()</code> 方法参数中的对象<br>(2) 表达式脚本都会被编译后的Java类中的 <code>out.print()</code> 方法输出到浏览器页面上<br>(3) 表达式脚本中的表达式不能以分号结束</li></ul><p>代码演示：表达式脚本的使用(此JSP文件在web目录下，名为First.jsp)</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%=<span class="number">22</span> %&gt; &lt;br/&gt;</span><br><span class="line">&lt;%=<span class="string">&quot;可以输出字符串&quot;</span> %&gt; &lt;br/&gt;</span><br><span class="line">&lt;%=map %&gt; &lt;br/&gt;</span><br><span class="line">&lt;%--使用_jspService方法中的对象--%&gt;</span><br><span class="line">&lt;%=request.getParameter(<span class="string">&quot;username&quot;</span>) %&gt;</span><br></pre></td></tr></table></figure><h2 id="4-5声明（了解）"><a href="#4-5声明（了解）" class="headerlink" title="4.5声明（了解）"></a>4.5声明（了解）</h2><ul><li><p>格式：&lt;%! 声明Java代码 %&gt;</p></li><li><p>作用：可以给JSP翻译出来的Java类定义属性、方法、静态代码块、内部类等</p></li><li><p>特点：不会在浏览器的页面上显示出来，仅存在于翻译后的Java类中</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.HashMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%--<span class="number">1.</span>声明类属性--%&gt;</span><br><span class="line">    &lt;%!</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; map;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%--<span class="number">2.</span>声明类方法--%&gt;</span><br><span class="line">    &lt;%!</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%--<span class="number">3.</span>声明静态代码块--%&gt;</span><br><span class="line">    &lt;%!</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-6注释：Jsp支持三种注释"><a href="#4-6注释：Jsp支持三种注释" class="headerlink" title="4.6注释：Jsp支持三种注释"></a>4.6注释：Jsp支持三种注释</h2><ul><li>java：单行注释：//，多行注释：/**/ </li><li>html：<!-- --></li><li>jsp：&lt;%— —%&gt;</li><li>jsp中三种注释的比较，如下所示：</li></ul><div class="table-container"><table><thead><tr><th></th><th>JSP注释</th><th>Java注释</th><th>HTML注释</th></tr></thead><tbody><tr><td>JSP页面</td><td>可见</td><td>可见</td><td>可见</td></tr><tr><td>Java代码</td><td>不可见</td><td>可见</td><td>可见</td></tr><tr><td>浏览器</td><td>不可见</td><td>不可见</td><td>可见</td></tr></tbody></table></div><h1 id="第5章-JSP常用指令"><a href="#第5章-JSP常用指令" class="headerlink" title="第5章 JSP常用指令"></a>第5章 JSP常用指令</h1><h2 id="5-1-语法格式"><a href="#5-1-语法格式" class="headerlink" title="5.1 语法格式"></a>5.1 语法格式</h2><blockquote><p>&lt;%@ 指令名   属性=属性值    属性2=属性值2  … %&gt; </p></blockquote><h2 id="5-2-Jsp常用指令"><a href="#5-2-Jsp常用指令" class="headerlink" title="5.2 Jsp常用指令"></a>5.2 Jsp常用指令</h2><h4 id="5-2-1-page指令"><a href="#5-2-1-page指令" class="headerlink" title="5.2.1 page指令"></a>5.2.1 page指令</h4><ul><li><p>语法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br></pre></td></tr></table></figure></li><li><p>属性</p><ul><li>language：语言，值为 <code>java</code> 且仅 <code>java</code>。</li><li>contentType：与response.setContentType()作用一致，设置浏览器字符集。</li><li>pageEncoding：设置Jsp页面的编码字符集。</li><li>import：导包</li><li>isErrorPage：设置当前页面是否为错误页面，默认值”false”。<ul><li>​    true：设置当前页面为错误页面，可以使用exception内置对象，捕获异常 。</li><li>​    false：设置当前页面不是错误页面，不可以使用exception内置对象，捕获异常 。</li></ul></li><li>errorPage：设置当前页面错误时的跳转目标页面。错误需要在_jspService()中才可以捕获。</li></ul></li></ul><h3 id="5-2-2-include指令-静态包含"><a href="#5-2-2-include指令-静态包含" class="headerlink" title="5.2.2 include指令:静态包含"></a>5.2.2 include指令:静态包含</h3><ul><li><p>语法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;被包含文件的路径&quot;</span> %&gt; </span><br></pre></td></tr></table></figure></li><li><p>作用：将目标文件包含到当前文件中。</p></li><li><p>特点：被包含的文件不会被翻译&amp;编译。（先包含，再翻译)</p></li></ul><h3 id="5-2-3-静态包含和动态包含"><a href="#5-2-3-静态包含和动态包含" class="headerlink" title="5.2.3 静态包含和动态包含"></a>5.2.3 静态包含和动态包含</h3><h4 id="静态包含"><a href="#静态包含" class="headerlink" title="静态包含"></a>静态包含</h4><p>(1)使用场景：</p><p>(2)使用方法：<br>&lt;%@include file=“”%&gt;<br>其中file属性设置要包含的JSP页面，以/打头，代表<a href="http://ip:port/工程路径/，对应web目录">http://ip:port/工程路径/，对应web目录</a></p><p>代码演示1：在web目录下创建body.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    头部信息 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    主体信息 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &lt;%@include file=&quot;/foot.jsp&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码演示2：在web目录下创建foot.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    页脚信息 &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>(3)静态包含的特点：</p><blockquote><p>① 静态包含不会将被包含的JSP页面翻译成.java.class文件<br>② 静态包含是把被包含的页面的代码拷贝到body.jsp对应的Java文件的对应位置执行输出</p></blockquote><h4 id="动态包含"><a href="#动态包含" class="headerlink" title="动态包含"></a>动态包含</h4><p>(1)使用方法：</p><blockquote><p><jsp:include page=””>&lt;/jsp:include&gt;<br>其中page属性设置要包含的JSP页面，与静态包含一致</p></blockquote><p>(2)动态包含的特点：<br>①动态包含将被包含的JSP页面翻译成.java.class文件<br>②动态包含还可以传递参数<br>③动态包含底层使用如下代码调用被包含的JSP页面执行输出：<br>org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, “/foot.jsp”, out, false);</p><p>代码演示1：在web目录下创建body.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    头部信息 &lt;br&gt;</span><br><span class="line">    主体信息 &lt;br&gt;</span><br><span class="line">    &lt;jsp:include page=<span class="string">&quot;/foot.jsp&quot;</span>&gt;</span><br><span class="line">        &lt;jsp:param name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;Jaychou&quot;</span>/&gt;</span><br><span class="line">        &lt;jsp:param name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">    &lt;/jsp:include&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>设置参数的标签要写在动态包含之中<br>出现Expecting “jsp:param” standard action with “name” and “value” attributes异常，两个原因：<br>①动态包含中未设置参数但没有把<jsp:include page=””>&lt;/jsp:include&gt;放在一行上<br>②动态包含中加了注释</p></blockquote><p>代码演示2：在web目录下创建 foot.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    页脚信息 &lt;br&gt;</span><br><span class="line">    &lt;%=request.getParameter(<span class="string">&quot;username&quot;</span>)%&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823203947439.png" alt="image-20220823203947439"></p><p>(3)动态包含的底层原理：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823204008104.png" alt="image-20220823204008104"></p><h3 id="5-2-4-taglib指令（略）"><a href="#5-2-4-taglib指令（略）" class="headerlink" title="5.2.4 taglib指令（略）"></a>5.2.4 taglib指令（略）</h3><ul><li><p>语法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt; </span><br></pre></td></tr></table></figure></li><li><p>属性</p><ul><li>prefix用来指定前缀名，我们通过该名来使用JSTL。</li><li>uri相当于库的唯一标识，因为JSTL由多个不同的库组成，使用该属性指定要导入哪个库。</li></ul></li><li><p>作用：引入标签库。</p></li></ul><h2 id="第六章-Jsp常用动作标签"><a href="#第六章-Jsp常用动作标签" class="headerlink" title="第六章 Jsp常用动作标签"></a>第六章 Jsp常用动作标签</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><ul><li>JSP动作标签与HTML标签不同，HTML标签由浏览器来解析，而JSP动作标签需要服务器（Tomcat）来运行。</li></ul><h3 id="6-2-常用的JSP动作标签"><a href="#6-2-常用的JSP动作标签" class="headerlink" title="6.2 常用的JSP动作标签"></a>6.2 常用的JSP动作标签</h3><h4 id="6-2-1-转发动作标签"><a href="#6-2-1-转发动作标签" class="headerlink" title="6.2.1  转发动作标签"></a>6.2.1  转发动作标签</h4><ul><li><p>语法：\<jsp:forward>\&lt;/jsp:forward&gt;</p></li><li><p>作用：在页面中用于转发操作</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;target.jsp&quot;</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure></li><li><p>转发子标签</p><ul><li><p>语法：<jsp:param value="paramValue" name="paramName"/></p></li><li><p>作用：在转发时设置请求参数，通过request.getParameter()在目标页面获取请求参数。</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;target.jsp&quot;</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">&quot;paramValue&quot;</span> name=<span class="string">&quot;paramName&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure></li><li><p>注意：如果转发动作标签不需要设置请求参数，该标签开始与结束标签内部，不允许书写任何内容，（包括空格）</p></li></ul></li></ul><h4 id="6-2-2-动态包含动作标签"><a href="#6-2-2-动态包含动作标签" class="headerlink" title="6.2.2 动态包含动作标签"></a>6.2.2 动态包含动作标签</h4><ul><li><p>语法：<jsp:include page=*"target.jsp"*></p></li><li><p>作用：动态包含，将其他页面包含到当前页面中。</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;target.jsp&quot;</span>&gt;&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure></li><li><p>特点：被包含的文件同时会被翻译&amp;编译。（先翻译，再包含）</p><ul><li><p>本质原理：当使用动态包含时，Tomcat会在生成的Servlet中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, <span class="string">&quot;target.jsp&quot;</span>, out, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-3-动态包含与静态包含的区别"><a href="#6-3-动态包含与静态包含的区别" class="headerlink" title="6.3 动态包含与静态包含的区别"></a>6.3 动态包含与静态包含的区别</h3><div class="table-container"><table><thead><tr><th></th><th>@include指令</th><th><jsp:include>标签</th></tr></thead><tbody><tr><td>特点</td><td>静态包含</td><td>动态包含</td></tr><tr><td>语法的基本形式</td><td>&lt;%@ include   file=”…”%&gt;</td><td><jsp:include   page=”…”/></td></tr><tr><td>包含动作发生的时机</td><td>翻译期间</td><td>请求期间</td></tr><tr><td>是否生成java文件</td><td>不生成</td><td>生成</td></tr><tr><td>合并方式</td><td>代码复制</td><td>合并运行结果</td></tr><tr><td>包含的内容</td><td>文件实际内容</td><td>页面输出结果</td></tr><tr><td>代码冲突</td><td>有可能</td><td>不可能</td></tr><tr><td>编译次数</td><td>1</td><td>包含的文件 + 1</td></tr><tr><td>适用范围</td><td>适用包含纯静态内容(CSS,HTML,JS)，或没有非常耗时操作。或少量java代码的jsp</td><td>包含需要传递参数。含有大量java代码，运算，耗时很长的操作。</td></tr></tbody></table></div><h1 id="第6章-JSP常用动作标签"><a href="#第6章-JSP常用动作标签" class="headerlink" title="第6章 JSP常用动作标签"></a>第6章 JSP常用动作标签</h1><h3 id="6-1-概述-1"><a href="#6-1-概述-1" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><ul><li>JSP动作标签与HTML标签不同，HTML标签由浏览器来解析，而JSP动作标签需要服务器（Tomcat）来运行。</li></ul><h3 id="6-2-常用的JSP动作标签-1"><a href="#6-2-常用的JSP动作标签-1" class="headerlink" title="6.2 常用的JSP动作标签"></a>6.2 常用的JSP动作标签</h3><h4 id="6-2-1-转发动作标签-1"><a href="#6-2-1-转发动作标签-1" class="headerlink" title="6.2.1  转发动作标签"></a>6.2.1  转发动作标签</h4><ul><li><p>语法：\<jsp:forward>\&lt;/jsp:forward&gt;</p></li><li><p>作用：在页面中用于转发操作</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;target.jsp&quot;</span>&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure></li><li><p>转发子标签</p><ul><li><p>语法：<jsp:param value="paramValue" name="paramName"/></p></li><li><p>作用：在转发时设置请求参数，通过request.getParameter()在目标页面获取请求参数。</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;target.jsp&quot;</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">&quot;paramValue&quot;</span> name=<span class="string">&quot;paramName&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure></li><li><p>注意：如果转发动作标签不需要设置请求参数，该标签开始与结束标签内部，不允许书写任何内容，（包括空格）</p></li></ul></li></ul><h4 id="6-2-2-动态包含动作标签-1"><a href="#6-2-2-动态包含动作标签-1" class="headerlink" title="6.2.2 动态包含动作标签"></a>6.2.2 动态包含动作标签</h4><ul><li><p>语法：<jsp:include page=*"target.jsp"*></p></li><li><p>作用：动态包含，将其他页面包含到当前页面中。</p></li><li><p>实例</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;target.jsp&quot;</span>&gt;&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure></li><li><p>特点：被包含的文件同时会被翻译&amp;编译。（先翻译，再包含）</p><ul><li><p>本质原理：当使用动态包含时，Tomcat会在生成的Servlet中加入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.jasper.runtime.JspRuntimeLibrary.include(request, response, <span class="string">&quot;target.jsp&quot;</span>, out, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-3-动态包含与静态包含的区别-1"><a href="#6-3-动态包含与静态包含的区别-1" class="headerlink" title="6.3 动态包含与静态包含的区别"></a>6.3 动态包含与静态包含的区别</h3><div class="table-container"><table><thead><tr><th></th><th>@include指令</th><th><jsp:include>标签</th></tr></thead><tbody><tr><td>特点</td><td>静态包含</td><td>动态包含</td></tr><tr><td>语法的基本形式</td><td>&lt;%@ include   file=”…”%&gt;</td><td><jsp:include   page=”…”/></td></tr><tr><td>包含动作发生的时机</td><td>翻译期间</td><td>请求期间</td></tr><tr><td>是否生成java文件</td><td>不生成</td><td>生成</td></tr><tr><td>合并方式</td><td>代码复制</td><td>合并运行结果</td></tr><tr><td>包含的内容</td><td>文件实际内容</td><td>页面输出结果</td></tr><tr><td>代码冲突</td><td>有可能</td><td>不可能</td></tr><tr><td>编译次数</td><td>1</td><td>包含的文件 + 1</td></tr><tr><td>适用范围</td><td>适用包含纯静态内容(CSS,HTML,JS)，或没有非常耗时操作。或少量java代码的jsp</td><td>包含需要传递参数。含有大量java代码，运算，耗时很长的操作。</td></tr></tbody></table></div><h1 id="第7章-JSP九大隐式对象"><a href="#第7章-JSP九大隐式对象" class="headerlink" title="第7章 JSP九大隐式对象"></a>第7章 JSP九大隐式对象</h1><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><blockquote><p>Jsp共有九大隐式对象，也叫隐含对象或内置对象。JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。</p></blockquote><h3 id="7-2-对象详情"><a href="#7-2-对象详情" class="headerlink" title="7.2 对象详情"></a>7.2 对象详情</h3><h4 id="7-2-1-pageContext"><a href="#7-2-1-pageContext" class="headerlink" title="7.2.1 pageContext"></a>7.2.1 pageContext</h4><ul><li>类型：PageContext</li><li>定义：代表页面域对象，用来代表整个JSP页面。</li><li>作用：<ol><li>页面域对象，具体详见：下方四大域对象。</li><li>九大隐式对象的“大哥”，可以直接调用其他八大隐式对象。</li></ol></li><li>在Servlet中获取方式：无。</li></ul><h4 id="7-2-2-request"><a href="#7-2-2-request" class="headerlink" title="7.2.2 request"></a>7.2.2 request</h4><ul><li><p>类型：HttpServletRequest</p></li><li><p>定义：代表浏览器向服务器发送的请求报文，该对象由服务器创建，最终以参数的形式发送到doGet()和doPost()方法中。</p><blockquote><p>每当客户端请求一个JSP页面时，JSP引擎就会制造一个新的request对象来代表这个请求。request对象提供了一系列方法来获取HTTP头信息，cookies，HTTP方法等等。</p></blockquote></li><li><p>作用（详见Servlet中request对象）</p><ol><li>获取请求参数</li><li>获取url地址参数</li><li>请求转发</li><li>向请求域中保存数据（获取数据&amp;移除数据）</li><li>获取请求头信息</li></ol></li><li><p>在Servlet中获取方式：doGet()或doPost()中直接使用。</p></li></ul><h4 id="7-2-3-session"><a href="#7-2-3-session" class="headerlink" title="7.2.3 session"></a>7.2.3 session</h4><ul><li><p>类型：HttpSession</p></li><li><p>定义：代表浏览器与服务器之间的会话。</p></li><li><p>作用</p><ul><li>会话域对象，具体详见：下方四大域对象。</li></ul><blockquote><p>session对象用来跟踪在各个客户端请求间的会话。</p></blockquote></li><li><p>在Servlet中获取方式 ：request.getSession();</p></li></ul><h4 id="7-2-4-application"><a href="#7-2-4-application" class="headerlink" title="7.2.4 application"></a>7.2.4 application</h4><ul><li><p>类型：ServletContext</p></li><li><p>定义：Servlet上下文，代表当前web应用。</p><blockquote><p>Web容器在启动时，它会为<strong>每个Web应用程序都创建一个唯一对应的ServletContext对象</strong>，意思是Servlet上下文，<strong>代表当前Web应用。</strong></p></blockquote></li><li><p>作用</p><ol><li><p>获取项目的上下文路径(带/的项目名)：<strong>getContextPath()</strong></p></li><li><p>获取虚拟路径所映射的本地真实路径：<strong>getRealPath(String path)</strong></p></li><li><p>获取WEB应用程序的全局初始化参数（基本不用）</p><ul><li><p>设置Web应用初始化参数的方式是在web.xml的根标签下加入如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Web应用初始化参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>ParamName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>ParamValue<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><pre><code> - 获取Web应用初始化参数   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">//1.获取ServletContext对象</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> config.getServletContext();</span><br><span class="line"><span class="comment">//2.获取Web应用初始化参数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> application.getInitParameter(<span class="string">&quot;ParamName&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;全局初始化参数paramValue=&quot;</span>+paramValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol><li>作为域对象共享数据:具体详见：下方四大域对象。</li></ol><ul><li>在Servlet中获取方式：使用this.getServletContext()方法获取。</li></ul><h4 id="7-2-5-page"><a href="#7-2-5-page" class="headerlink" title="7.2.5 page"></a>7.2.5 page</h4><ul><li>类型：Object</li><li>作用：this，当前类对象。</li></ul><h4 id="7-2-6-response"><a href="#7-2-6-response" class="headerlink" title="7.2.6 response"></a>7.2.6 response</h4><ul><li>类型：HttpServletResponse</li><li>定义：代表服务器向浏览器发送的响应报文，该对象由服务器创建，最终以参数的形式发送到doGet()和doPost()方法中。</li><li>作用：<ol><li>向页面（响应体）中响应数据，数据包括文本、Html等。</li><li>重定向</li><li>设置响应头信息</li></ol></li><li>在Servlet中获取方式：doGet()或doPost()中直接使用</li></ul><h4 id="7-2-7-config"><a href="#7-2-7-config" class="headerlink" title="7.2.7 config"></a>7.2.7 config</h4><ul><li>类型：ServletConfig</li><li>定义：代表当前Servlet的配置信息，每一个Servlet都有一个唯一对应的ServletConfig对象。</li><li>作用：<ol><li>获取Servlet名称：getServletName()</li><li>获取全局上下文ServletContext对象：getServletContext()</li><li>获取Servlet初始化参数：getInitParameter(String) / getInitParameterNames()。</li></ol></li><li>在Servlet中获取方式：this.getServletConfig()</li></ul><h4 id="7-2-8-out"><a href="#7-2-8-out" class="headerlink" title="7.2.8 out"></a>7.2.8 out</h4><ul><li>类型：JspWriter</li><li>定义：代表当前页面的输出流。</li><li>作用：与Servlet中的PrintWriter功能类似，将数据响应到页面，响应的数据可以是页面、页面片段、字符串等。</li><li>在Servlet中获取方式：无</li></ul><h4 id="7-2-9-exception"><a href="#7-2-9-exception" class="headerlink" title="7.2.9 exception"></a>7.2.9 exception</h4><ul><li>类型：Throwable</li><li>定义：代表当前页面的异常对象。</li><li>作用：代表当前页面的异常对象。</li><li>在Servlet中获取方式：new Throwable()</li></ul><p><strong>九大内置对象，都是我们可以在【代码脚本】中或【表达式脚本】中直接使用的对象。</strong></p><blockquote><p>request：请求对象<br>response：响应对象<br>pageContext：JSP的上下文对象<br>session：会话对象<br>application：ServletContext对象<br>config：ServletConfig对象<br>out：JSP输出流对象<br>page：指向当前JSP的对象<br>exception：异常对象</p></blockquote><h1 id="第8章-JSP四大域对象"><a href="#第8章-JSP四大域对象" class="headerlink" title="第8章 JSP四大域对象"></a>第8章 JSP四大域对象</h1><h2 id="8-1-域对象概述"><a href="#8-1-域对象概述" class="headerlink" title="8.1 域对象概述"></a>8.1 域对象概述</h2><blockquote><p>​    生活中使用“域对象”比较经典的行业，是快递行业。现如今快递行业大体分为，全球快递，全国快递，同城快递和同区快递。需求不同，使用不同“域对象”。</p><p>​    如：外卖一般使用同区快递，给北京朝阳区的朋友邮寄贺卡，一般使用同城快递。在某宝某东上购买外地商品，一般使用全国快递或全球快递。</p></blockquote><h2 id="8-2-程序中的域对象"><a href="#8-2-程序中的域对象" class="headerlink" title="8.2 程序中的域对象"></a>8.2 程序中的域对象</h2><h3 id="8-2-1-域对象概述"><a href="#8-2-1-域对象概述" class="headerlink" title="8.2.1 域对象概述"></a>8.2.1 域对象概述</h3><blockquote><p>程序中的域对象，主要负责在不同web资源之间进行数据交换，（如:servlet和jsp之间的数据交换）。由于不同的web资源之间需要共享数据，所以就有了域对象。</p><p>在Jsp中一共有四个域对象，分别是pageContext 、request、session、application。主要作用是能够在一定范围内共享数据。</p></blockquote><h3 id="8-2-2-域对象分析"><a href="#8-2-2-域对象分析" class="headerlink" title="8.2.2 域对象分析"></a>8.2.2 域对象分析</h3><p><strong>每个域对象内部都维护了一个Map<String , Object>，域对象的共同方法。</strong></p><ul><li>设置属性到域中：void setAttribute(String key , Object value);</li><li>从域中获取指定的属性：Object  getAttribute(String key);</li><li>移除域中指定属性：void removeAttribute(String key);</li></ul><h3 id="8-2-3-域对象有效性"><a href="#8-2-3-域对象有效性" class="headerlink" title="8.2.3 域对象有效性"></a>8.2.3 域对象有效性</h3><ul><li>pageContext: 当前页面中共享数据有效，离开当前页面失效。<ul><li>每个页面都有自己唯一的一个pageContext对象。</li><li>注意servlet中没有该对象。</li></ul></li><li>request： 当前请求中共享数据有效。<ul><li>当前请求：转发、直接访问一个页面为当前请求。</li><li>不在当前请求：重定向、 打开页面再点击页面中的超链接不在当前请求 。</li></ul></li><li>session： 一次会话范围中共享数据有效。<ul><li>当前会话：当前浏览器不关闭&amp;不更换浏览器即为当前会话。</li><li>只关心浏览器是否关闭，不关心服务器关闭重启。</li><li>不同浏览器不共享会话。</li></ul></li><li>application： 在服务器运行的一次过程中共享数据有效。<ul><li>服务器关闭销毁</li></ul></li></ul><p><strong>小结</strong>：</p><div class="table-container"><table><thead><tr><th>域对象</th><th>作用范围</th><th>起始时间</th><th>结束时间</th></tr></thead><tbody><tr><td>pageContext</td><td>当前JSP页面</td><td>页面加载</td><td>离开页面</td></tr><tr><td>request</td><td>同一个请求</td><td>收到请求</td><td>响应</td></tr><tr><td>session</td><td>同一个会话</td><td>开始会话</td><td>结束会话</td></tr><tr><td>application</td><td>当前Web应用</td><td>Web应用加载</td><td>Web应用卸载</td></tr></tbody></table></div><h3 id="8-2-4-四个作用域的测试代码："><a href="#8-2-4-四个作用域的测试代码：" class="headerlink" title="8.2.4 四个作用域的测试代码："></a>8.2.4 四个作用域的测试代码：</h3><ul><li><p>新建两个jsp页面。分别取名叫：context1.jsp，context2.jsp</p><ul><li><p>context1.jsp的页面代码如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">这是context1页面&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">//设置page域的数据</span></span><br><span class="line">pageContext.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;pageContext-value&quot;</span>);</span><br><span class="line"><span class="comment">//设置request域的数据</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;request-value&quot;</span>);</span><br><span class="line"><span class="comment">//设置session域的数据</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;session-value&quot;</span>);</span><br><span class="line"><span class="comment">//设置application域的数据</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;application-value&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%-- 测试当前页面作用域 --%&gt;</span><br><span class="line">&lt;%=pageContext.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%=request.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%=session.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%=application.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="comment">// 测试request作用域</span></span><br><span class="line"><span class="comment">// request.getRequestDispatcher(&quot;/context2.jsp&quot;).forward(request, response);</span></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>context2.jsp的页面代码如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span></span><br><span class="line">    pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">这是context2页面 &lt;br/&gt;</span><br><span class="line">&lt;%=pageContext.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%=request.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%=session.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;%=application.getAttribute(<span class="string">&quot;key&quot;</span>) %&gt;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">测试pageContext作用域步骤：</span><br><span class="line">直接访问context1.jsp文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试request作用域步骤：</span><br><span class="line">1.在context1.jsp文件中添加转发到context2.jsp（有数据）</span><br><span class="line">2.直接访问context2.jsp文件 （没有数据）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试session作用域步骤：</span><br><span class="line">1.访问完context1.jsp文件</span><br><span class="line">2.关闭浏览器。但是要保持服务器一直开着</span><br><span class="line">3.打开浏览器，直接访问context2.jsp文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">测试application作用域步骤：</span><br><span class="line">1.访问完context1.jsp文件，然后关闭浏览器</span><br><span class="line">2.停止服务器。再启动服务器。</span><br><span class="line">3.打开浏览器访问context2.jsp文件</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文学懂JSP&quot;&gt;&lt;a href=&quot;#一文学懂JSP&quot; class=&quot;headerlink&quot; title=&quot;一文学懂JSP&quot;&gt;&lt;/a&gt;一文学懂JSP&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https://blog.csdn.net</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一文学懂Cookie与Session的区别</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-10-16T15:00:28.000Z</published>
    <updated>2022-10-16T15:05:02.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文学懂Cookie与Session的区别"><a href="#一文学懂Cookie与Session的区别" class="headerlink" title="一文学懂Cookie与Session的区别"></a>一文学懂Cookie与Session的区别</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p><strong>一张思维导图了解</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt=""></p><blockquote><p>Session用来实现用户会话<br>Session对应类名:HttpSession（javax.servlet.http.HttpSession）<br>Session是JSP内置的对象</p></blockquote><h1 id="会话的理解"><a href="#会话的理解" class="headerlink" title="会话的理解"></a>会话的理解</h1><ul><li>什么是会话？<ul><li>用户打开浏览器，对浏览器进行一系列操作，最终关闭浏览器的过程中，这个整个过程叫做 ： <font color='red'>会话</font>。会话在服务器端也对应一个Java对象，这个Java对象叫做 ：  <font color='red'>session</font>。</li><li>什么是一次请求：用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的Java对象是：request。</li><li>一个会话当中包含多次请求。（ <font color='red'>一次会话对应N次请求。</font>）</li></ul></li><li>在Java的servlet规范当中，session对应的类名：HttpSession。</li><li>Session机制实际上是一个规范。然后不同的语言对这种会话机制都有实现。</li></ul><blockquote><p>对于会话有了基本的理解以后，我们来看一下，它的作用是什么</p></blockquote><h1 id="Seesion的作用"><a href="#Seesion的作用" class="headerlink" title="Seesion的作用"></a>Seesion的作用</h1><ul><li><p>Session对象最主要的作用是：保存会话状态。（<code>用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用session对象可以保留会话状态。</code>）</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220828193623047.png" alt="image-20220828193623047" style="zoom:80%;" /></p></li></ul><blockquote><p>既然Session是用来保存会话状态的，那么我们就会有一个疑惑，为什么要用它来保存会话状态。因为客户端发送请求以后，它和服务器的连接就断开了。</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220828193742715.png" alt="image-20220828193742715" style="zoom:80%;" /></p><ul><li>为什么需要Session对象来保存会话状态呢 ？<ul><li>因为HTTP是无状态的</li><li>什么是无状态：请求的时候，B和S是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。</li><li>只要B/S断开了，也就是关闭浏览器这个动作，服务器是不知道的。</li></ul></li><li><p>张三打开一个浏览器A，李四打开一个浏览器B，访问服务器之后，在服务器端会生成：</p></li><li><ul><li>张三专属的 <code>Session</code> 对象</li><li>李四专属的 <code>Session</code> 对象</li></ul></li><li><p>为什么不使用request对象保存会话状态？为什么不使用ServletContext对象保存会话状态？</p></li><li><ul><li>request.setAttribute()存，request.getAttribute()取，ServletContext也有这个方法。request是请求域。ServletContext是应用域。</li><li>request 是一次请求一个对象。</li><li>ServletContext 对象是服务器启动的时候创建，服务器关闭的时候销毁，这个ServletContext对象只有一个。</li><li>ServletContext对象的域太大。</li><li>request请求域（HttpServletRequest）、session会话域（HttpSession）、application域（ServletContext）</li><li><code>request &lt; session &lt; application</code></li></ul></li></ul><h1 id="HTTP协议的无状态特点"><a href="#HTTP协议的无状态特点" class="headerlink" title="HTTP协议的无状态特点"></a>HTTP协议的无状态特点</h1><blockquote><p>服务器没有办法识别每一次请求是从哪一台电脑访问的，它能接收请求，但是它不知道这个请求是从哪里来的，不知道要响应给谁。比如说我们买东西，添加购物车，由于它无法识别是来自哪一个客户端的请求，它就可能把我们的请求发送给其他人，所以必须要有一种技术来让服务器知道请求来自哪里，这就是会话技术</p></blockquote><p><strong>下面这一张图很清晰的概述了我们为什么需要会话技术 </strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220828193924749.png" alt="image-20220828193924749" style="zoom:80%;" /></p><h1 id="Seesion的实现原理（重点）"><a href="#Seesion的实现原理（重点）" class="headerlink" title="Seesion的实现原理（重点）"></a>Seesion的实现原理（重点）</h1><ul><li>Session的实现原理 ：<ul><li>JSESSIONID = xxx 这个是以Cookie的形式保存在浏览器的内存中的。浏览器只要关闭。这个cookie就没有了。</li><li>Session列表是一个Map，Map的 key可以 <code>SeesionId</code> ，Map的 value 是 <code>Session</code> 对象。</li><li>用户发送第一次请求时，服务器生成Session对象，同时生成SeesionId，然后将这个id以cookie的形式发送给浏览器。</li><li>用户发送第二次 ，自动将浏览器内存中的SeesionId发送给服务器，服务器根据SeesionId来查找Seesion对象。</li><li>关闭浏览器，内存消失，cookie消失，sessionid消失，会话等同于结束。</li></ul></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220828191330094.png" alt="image-20220828191330094"></p><ul><li><p>总结一下到目前位置我们所了解的域对象：</p><ul><li>request（对应的类名：HttpServletRequest）<ul><li>请求域（请求级别的）</li></ul></li><li>session（对应的类名：HttpSession）<ul><li>会话域（用户级别的）</li></ul></li><li>application（对应的类名：ServletContext）<ul><li>应用域（项目级别的，所有用户共享的。）</li></ul></li><li><p>这三个域对象的大小关系</p></li><li><p>request &lt; session &lt; application</p></li><li><p>他们三个域对象都有以下三个公共的方法：</p><ul><li>setAttribute（向域当中绑定数据）</li><li>getAttribute（从域当中获取数据）</li><li>removeAttribute（删除域当中的数据）</li></ul></li></ul></li><li><p>使用原则：尽量使用小的域。</p></li></ul><h1 id="Session的常用方法"><a href="#Session的常用方法" class="headerlink" title="Session的常用方法"></a>Session的常用方法</h1><blockquote><p>Session在实际开发中是用来记录我们的用户信息的，我们不需要每一次访问都输入用户名和密码，如果登录过一次，后面可以不用再输入，但是这是有一个周期的，不可能一直存着的，默认失效时间为1800秒(也就是30分钟)</p></blockquote><h2 id="Session数据的存取"><a href="#Session数据的存取" class="headerlink" title="Session数据的存取"></a>Session数据的存取</h2><ul><li><p>Session域对象数据的存取和其他三个域对象PageContext、Request、ServletContext是一样的。只需要调用下面两个方法：</p><ul><li><code>setAttribute 设置属性</code></li><li><code>getAttribute 获取属性</code></li></ul></li><li><p>编写下面的java代码去访问，就可以在Session域中设置属性，和获取属性。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc value&quot;</span>);</span><br><span class="line">response.getWriter().write(<span class="string">&quot;设置属性值成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">getAttribute</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">response.getWriter().write(<span class="string">&quot;获取abc的属性值：&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改session.html 中访问的连接地址，然后点击访问。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sessionServlet?action=setAttribute&quot;</span> &gt;</span>Session域数据的存储<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sessionServlet?action=getAttribute&quot;</span> &gt;</span>Session域数据的获取<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问后效果图：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558628097144.png" alt="1558628097144"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558628140230.png" alt="1558628140230"></p><h2 id="Session-的有效时间"><a href="#Session-的有效时间" class="headerlink" title="Session 的有效时间"></a>Session 的有效时间</h2><ul><li><p><strong>基本原则</strong></p><ul><li>Session对象在服务器端不能长期保存，它是有时间限制的，超过一定时间没有被访问过的Session对象就应该释放掉，以节约内存。所以Session的有效时间并不是从创建对象开始计时，到指定时间后释放。而是<strong>从最后一次被访问开始计时，统计其“空闲”的时间。</strong></li></ul></li><li><p><strong>默认时效</strong></p><ul><li><p>在tomcat的conf 目录下web.xml配置文件中能够找到如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ==================== Default Session Configuration ================= --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- You can set the default session timeout (in minutes) for all newly   --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- created sessions by modifying the value below.                       --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：Session对象默认的最长有效时间为30分钟。</p></blockquote></li></ul></li><li><p><strong>手动设置1：全局</strong></p><ul><li><p>我们也可以在自己工程的web.xml文件中配置Session会话的超时时间为10分钟。</p></li><li><p>记住一点，我们在web.xml文件中配置的Session会话超时时间是对所有Session都生效的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置Session默认的过期时间  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以分钟为单位。10分钟超时  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>10<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>手动设置2：局部</strong></p><ul><li><code>int getMaxInactiveInterval()    获取超时时间。以秒为单位。</code></li><li><code>setMaxInactiveInterval (int seconds)  设置用户多长时间没有操作之后就会Session过期。以秒为单位。</code><ul><li><code>如果是正数。表示用户在给定的时间内没有任意操作，Session会话就会过期。</code></li><li><code>如果是非正数（零&amp;负数）。表示Session永不过期。</code></li></ul></li></ul></li><li><p><strong>强制失效</strong></p><ul><li><code>invalidate()</code></li></ul></li><li><p><strong>示例代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Session在<span class="number">3</span>秒之后超时</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置过期时间为3秒 </span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Session在<span class="number">1</span>分钟之后超时</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。 </span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置过期时间为1分钟</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">Session在<span class="number">1</span>小时之后超时</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置过期时间为1小时</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">Session在<span class="number">1</span>天之后超时</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置过期时间为1天</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">Session在<span class="number">1</span>周之后超时</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置过期时间为1周</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Session永远不超时</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 设置永远不超时</span></span><br><span class="line">session.setMaxInactiveInterval(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Session马上超时（失效）</span><br><span class="line"><span class="comment">// 第一个调用就是获取一个新的Session。如果Session已经创建过。就获取原来的会话。</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">// 让Session对象立即过期</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure><h2 id="Session对象的释放"><a href="#Session对象的释放" class="headerlink" title="Session对象的释放"></a>Session对象的释放</h2><ul><li><p>Session对象空闲时间达到了目标设置的最大值，自动释放</p></li><li><p>Session对象被强制失效</p></li><li><p>Web应用卸载</p></li><li><p>服务器进程停止</p></li></ul><h2 id="Session的活化和钝化"><a href="#Session的活化和钝化" class="headerlink" title="Session的活化和钝化"></a>Session的活化和钝化</h2><ul><li><p>Session机制很好的解决了Cookie的不足，但是当访问应用的用户很多时，服务器上就会创建非常多的Session对象，如果不对这些Session对象进行处理，那么在Session失效之前，这些Session一直都会在服务器的内存中存在。那么，就出现了Session活化和钝化的机制。</p></li><li><p><strong>Session钝化：</strong>Session在一段时间内没有被使用或关闭服务器时，会将当前存在的Session对象及Session对象中的数据从内存序列化到磁盘的过程，称之为钝化。</p></li><li><p><strong>Session活化：</strong>Session被钝化后，服务器再次调用Session对象或重启服务器时，将Session对象及Session对象中的数据从磁盘反序列化到内存的过程，称之为活化。</p></li><li><p>如果希望Session域中的对象也能够随Session钝化过程一起序列化到磁盘上，则对象的实现类也必须实现java.io.Serializable接口。不仅如此，如果对象中还包含其他对象的引用，则被关联的对象也必须支持序列化，否则会抛出异常：java.io.NotSerializableException</p></li></ul><h2 id="浏览器和Session关联的技术内幕"><a href="#浏览器和Session关联的技术内幕" class="headerlink" title="浏览器和Session关联的技术内幕"></a>浏览器和Session关联的技术内幕</h2><p>一旦浏览器关闭之后，我们再去获取Session对象就会创建一个新的Session对象。这是怎么回事呢。现在让我们来看一下。这一系列操作过程中的内幕细节。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558628349795.png" alt="1558628349795"></p><blockquote><p>通过上图的分析，我们不难发现。当浏览器关闭之后。只是因为浏览器无法再通知服务器，之前创建的Session的会话id是多少了。所以服务器没办法找到对应的Session对象之后，就以为这是第一次访问服务器。就创建了新的Session对象返回。</p></blockquote><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><ul><li><p>Session的实现原理中 ： 每一个Seesion对象都会关联一个sessionid，例如  ：</p><ul><li><p>JSESSIONID=41C481F0224664BDB28E95081D23D5B8</p></li><li><p>以上的这个键值对数据其实就是cookie对象。</p></li><li><p>对于session关联的cookie来说，这个cookie是被保存在浏览器的 <code>运行内存</code> 当中。</p></li><li><p>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存的cookie发送给服务器。</p></li><li><p>例如  ， 这个cookie ： </p><p><code>JSESSIONID=41C481F0224664BDB28E95081D23D5B8</code>就会再次发送给服务器。</p></li><li><p>服务器就是根据<code>41C481F0224664BDB28E95081D23D5B8</code>这个值来找到对应的session对象的。</p></li></ul></li><li><p>cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？？？？？？？</p></li><li><p>cookie最终是保存在浏览器客户端上面的。</p><ul><li>可以保存在运行内存中。（浏览器只要关闭cookie就会立即消失。）</li><li>也可以保存在硬盘文件中。（永久保存）</li></ul></li><li><p>cookie有什么用呢 ？</p><ul><li>cookie和session的机制其实都为了保存绘画的状态。</li><li>cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。）</li><li>session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。）</li><li>为什么要有cookie和session机制呢？因为HTTP协议是无状态 无连接协议。</li></ul></li></ul><h1 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h1><ul><li><p>cookie的经典案例</p></li><li><ul><li>京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？</li></ul></li><li><p>将购物车中的商品编号放到cookie当中，cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。</p></li><li><p>京东存储购物车中商品的cookie可能是这样的：productIds=xxxxx,yyyy,zzz,kkkk</p><ul><li>注意：cookie如果清除掉，购物车中的商品就消失了。</li></ul></li></ul><ul><li>cookie机制和session机制其实都不属于Java中的机制，其实cookie机制和session机制都是HTTP协议的一部分。不论是什么编程语言，cookie和session机制都时必不可少的。</li><li>HTTP协议中规定 ： 任何一个cookie都是由name和value组成的。name和value都是字符串类型。</li><li>在 <code>java</code>的servlet中，对cookie提供了哪些支持呢？<ul><li>提供了一个Cookie类来专门表示cookie数据。<code>javax.servlet.http.Cookie;</code></li><li>java程序怎么把cookie数据发送给浏览器呢？<code>response.addCookie(cookie);</code></li></ul></li><li>在HTTP协议中是这样规定的：当浏览器发送请求的时候，会自动携带该path下的cookie数据给服务器。（URL。）</li><li>关于cookie的有效时间<ul><li>怎么用Java设置cookie的有效时间<ul><li>cookie.setMaxAge（60*60）；设置保存在一小时之后失效。</li></ul></li><li>没有设置有效时间 ： 默认保存在浏览器的运行内存中，浏览器关闭则cookie消失。</li></ul></li><li>只要设置cookie的有效时间 &gt; 0，这个cookie一定会存储到硬盘文件当中。</li><li><p>设置cookie的有效时间 = 0 呢？</p><ul><li>cookie被删除，同名cookie被删除。</li><li>设置cookie的有效时间 &lt; 0 呢？</li><li>保存在运行内存中。和不设置一样。</li></ul></li><li><p>浏览器发送cookie给服务器了，服务器中的java程序怎么接收？</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Cookie[] cookies = request.getCookies(); <span class="comment">// 这个方法可能返回null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">        <span class="comment">// 获取cookie的name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">        <span class="comment">// 获取cookie的value</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Cookie的常用方法"><a href="#Cookie的常用方法" class="headerlink" title="Cookie的常用方法"></a>Cookie的常用方法</h1><div class="table-container"><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>void setMaxAge(int age)</td><td>设置Cookie的有效时间，单位为秒</td></tr><tr><td>int getMaxAge()</td><td>获取Cookie的有效时间</td></tr><tr><td>String getName/()</td><td>获取Cookie的name</td></tr><tr><td>String getValue()</td><td>获取Cookie的value</td></tr></tbody></table></div><h1 id="Seesion与Cookie的区别"><a href="#Seesion与Cookie的区别" class="headerlink" title="Seesion与Cookie的区别"></a>Seesion与Cookie的区别</h1><p>Session: <strong>保存在服务器，Session是一个对象保存在Java虚拟机中</strong><br>保存的数据是Object<br>随着会话的结束而销毁<br>保存重要信息</p><p>Cookie: <strong>保存在浏览器</strong><br>只能保存String类型，类似于文本文件，存放的都是数据，而不是对象<br>可以长期保存在浏览器，与会话无关<br>保存不重要信息</p><blockquote><p>存储用户信息：<br>Session:setAttribute(name,“admin”) 存<br>getAttribute(name) 取<br>生命周期：服务端:只要WEB应用重启或者销毁<br>客户端:只要浏览器关闭就销毁<br>退出登录:session.invalidate();<br>Cookie:<br>Cookie cookie=new Cookie(name,“admin”);<br>response.addCookie(cookie); 存</p></blockquote><p>取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies=request.getCookie();</span><br><span class="line"> <span class="keyword">for</span>(Cookie cookie:cookies)&#123;</span><br><span class="line"><span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;name&quot;</span>)&#123;</span><br><span class="line">out.write(<span class="string">&quot;欢迎回来&quot;</span>+cookie.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期：不会随着服务端的重启而销毁，客户端：默认是只要关闭浏览器就会销毁，我们通过setMaxAge()方法来设置有效期，一旦设置了有效期，就不会随着浏览器的关闭而销毁，而是由设置的时间来决定<br>退出登录:setMaxAge(0)</p><p>Cookie是浏览器提供的一种技术，通过服务器的程序能把一些只须保存在客户端，或者在客户端进行处理的数据放在本地计算机上，不需要通过网络传送，因此提高网页处理效率，并且可以减少服务器的负载，但是因为Cookie是服务器端保存在客户端的信息，所以它的安全性也是很差的，例如：常见的记住密码就可以通过Cookie来实现</p><p>如果想要把Cookie随着响应发送到客户端，需要先添加到response对象中</p><p>cookie默认是关闭浏览器失效</p><h1 id="Cookie的有效时间值"><a href="#Cookie的有效时间值" class="headerlink" title="Cookie的有效时间值"></a>Cookie的有效时间值</h1><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220828202948622.png" alt="image-20220828202948622" style="zoom:80%;" /></p><h1 id="Cookie的注意点"><a href="#Cookie的注意点" class="headerlink" title="Cookie的注意点"></a>Cookie的注意点</h1><blockquote><p>1.cookie保存在当前浏览器，不能跨浏览器，更不用说换电脑了<br>2.cookie存中文问题<br>cookie不能存中文，如果有中文，则通过URLEncoder.encode()来进行编码<br>通过URLDecoder.decode()进行解码</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220828203015097.png" alt="image-20220828203015097"></p><blockquote><p>3.同名cookie问题<br>如果服务器发送重复的cookie，那么会覆盖原来的cookie<br>4.cookie的数量<br>不同浏览器对cookie有限定，cookie的存储是有上限的，cookie存储在客户端(浏览器)的，而且一般是由服务器创建和指定，后期结合Session来实现会话追踪</p></blockquote><h1 id="Cookie路径的问题"><a href="#Cookie路径的问题" class="headerlink" title="Cookie路径的问题"></a>Cookie路径的问题</h1><p>Cookie的setPath（可以设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些cookie</p><p>情景一：当前服务器下的任何项目的任意资源都可以获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前项目路径s</span></span><br><span class="line">Cookie cookie=<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//设置路径为&quot;/&quot;,表示在当前项目下的任何项目都可以访问到cookie对象</span></span><br><span class="line"></span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>情景二：当前项目下的资源都可获取Cookie对象(默认不设置Cookie的path)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前项目路径s</span><br><span class="line">Cookie cookie=<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//设置路径为&quot;/s&quot;,表示在当前项目下的任何项目都可以访问到cookie对象</span></span><br><span class="line"><span class="comment">//默认情况下可以不设置path的值</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/s&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>情景三：指定项目下的资源可获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前项目路径s</span><br><span class="line">Cookie cookie=<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//设置路径为&quot;/s2&quot;,表示在s2项目下才可以访问到</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/s2&quot;</span>);</span><br><span class="line"><span class="comment">//只能在s2项目下获取cookie，就算cookie是s产生的，s也不能获取它</span></span><br><span class="line"> response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>情景四：指定目录下的资源可获取Cookie对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前项目路径s</span></span><br><span class="line">Cookie cookie=<span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"><span class="comment">//设置路径为/s/cook,表示在s1/cook目录下面才可以访问到cookie对象</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/s/cook&quot;</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><h1 id="Cookie的禁用问题"><a href="#Cookie的禁用问题" class="headerlink" title="Cookie的禁用问题"></a>Cookie的禁用问题</h1><p>Cookie禁用了，session还能找到吗？</p><blockquote><p>cookie禁用就是说服务器正常发送cookie给浏览器，但是浏览器不要了。拒收了。并不是服务器不发了。<br>找不到了。每一次请求都会获取到新的session对象。<br>cookie禁用了，session机制还能实现吗？<br>可以。需要使用URL重写机制。<br><a href="http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16">http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16</a><br>URL重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：如果禁用cookie，就别用了。</p></blockquote><h1 id="URL重写（了解）"><a href="#URL重写（了解）" class="headerlink" title="URL重写（了解）"></a>URL重写（了解）</h1><ul><li><p>在整个会话控制技术体系中，保持JSESSIONID的值主要通过Cookie实现。但Cookie在浏览器端可能会被禁用，所以我们还需要一些备用的技术手段，例如：URL重写。</p></li><li><p>URL重写其实就是将JSESSIONID的值以固定格式附着在URL地址后面，以实现保持JSESSIONID，进而保持会话状态。这个固定格式是：URL;jsessionid=xxxxxxxxx</p></li><li><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetServlet;jsessionid=97120112D5538009334F1C6DEADB1BE7</span><br></pre></td></tr></table></figure></li><li><p>实现方式：</p><ul><li><p>response.encodeURL(String)</p></li><li><p>response.encodeRedirectURL(String)</p></li></ul></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取Session对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建目标URL地址字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;targetServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.在目标URL地址字符串后面附加JSESSIONID的值</span></span><br><span class="line">url = response.encodeURL(url+<span class="string">&quot;;jsessionid=97120112D5538009334F1C6DEADB1BE7&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.重定向到目标资源</span></span><br><span class="line">response.sendRedirect(url);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="处理表单重复提交问题"><a href="#处理表单重复提交问题" class="headerlink" title="处理表单重复提交问题"></a>处理表单重复提交问题</h1><ul><li>表单重复提交的危害<ul><li>可重复注册，对数据库进行批处理攻击。（验证码已解决该问题）</li><li>可重复提交已付款表单，用户支付一次订单费用，下了多个订单</li><li>等待…</li></ul></li><li>解决表单重复提交的步骤<ul><li>生成一个不可重复（全球唯一）的随机数(uuid)</li><li>在提交表单前，将随机数(uuid)分别存放到表单内的隐藏域，和session域对象中</li><li>发送“提交表单”请求</li><li>判断是否提交表单，具体操作如下：<ul><li>分别获取隐藏域和session域中的uuid</li><li>判断两个域中的数据是否相等<ul><li>相等：提交表单，并将session域中的uuid移除</li><li>不等：不提交表单</li></ul></li></ul></li></ul></li><li>UUID<ul><li>定义：是一个32位16进制的随机数</li><li>特点：全球唯一</li><li>使用：java.util.UUID.randomUUID()</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文学懂Cookie与Session的区别&quot;&gt;&lt;a href=&quot;#一文学懂Cookie与Session的区别&quot; class=&quot;headerlink&quot; title=&quot;一文学懂Cookie与Session的区别&quot;&gt;&lt;/a&gt;一文学懂Cookie与Session的区别&lt;/</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一文学懂过滤器和监听器</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E5%AD%A6%E6%87%82%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</id>
    <published>2022-10-16T15:00:12.000Z</published>
    <updated>2022-10-16T15:05:02.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文学懂过滤器和监听器"><a href="#一文学懂过滤器和监听器" class="headerlink" title="一文学懂过滤器和监听器"></a>一文学懂过滤器和监听器</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/Filter&amp;Listener.png" alt=""></p><h1 id="第一章-什么是Filter"><a href="#第一章-什么是Filter" class="headerlink" title="第一章  什么是Filter"></a>第一章  什么是Filter</h1><h2 id="1-1-Filter简介"><a href="#1-1-Filter简介" class="headerlink" title="1.1 Filter简介"></a>1.1 Filter简介</h2><blockquote><p>Filter的中文意思是过滤器。顾名思义，过滤器就是在浏览器和目标资源之间起到一个过滤与资源拦截的作用。例如：水净化器，可以看成是生活中的一个过滤器，他可以将污水中的杂质过滤，从而使进入的污水变成净水。</p></blockquote><ul><li>对于WEB应用来说，过滤器是一个驻留在服务器中的WEB组件，他可以截取客户端和WEB资源之间的请求和响应信息。<ul><li>WEB资源可能包括 Servlet、JSP、HTML页面等。</li></ul></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558767049205.png" alt="1558767049205"></p><ul><li><p>当服务器收到资源请求之后，会首先将请求给顾虑器处理，程序员可以在过滤器中对请求信息进行读取修改等操作，然后将请求信息再发送给目标资源。目标资源作出响应后，服务器会再次将响应转交给过滤器，在过滤器中同样可以对响应信息做一些操作，<code>然后再将响应发送给服务器</code>。</p></li><li><p>在一个WEB应用中可以部署多个过滤器，多个过滤器就组成了一个过滤器链，请求和响应必须在经过多个过滤器后才能到达目标；</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558774993622.png" alt="1558774993622"></p></li><li><p>过滤器不是必须将请求传送到下一个过滤器（或WEB资源），也可以自己来处理请求，发送响应。</p></li><li><p>当配置<code>多个Filter</code> 的时候就有一个执行顺序的问题，实际执行顺序是按照在web.xml文件中servlet-mapping的顺序决定的，如果顺序越靠前越先被调用。</p></li></ul><h2 id="1-2-总结"><a href="#1-2-总结" class="headerlink" title="1.2 总结"></a>1.2 总结</h2><ul><li>Filter是一个接口。</li><li>Filter是Java Web三大组件之一。（JavaWeb三大组件分别是：Servlet小程序、Filter过滤器、Listener监听器）</li><li>Filter是服务器专门用来过滤请求，拦截请求的。</li><li>Filter的常见作用 ： <ul><li>检查用的的访问权限。</li><li>设置响应编码，解决乱码问题。</li></ul></li></ul><h2 id="1-3-主要API"><a href="#1-3-主要API" class="headerlink" title="1.3 主要API"></a>1.3 主要API</h2><h4 id="1-3-1-Filter接口"><a href="#1-3-1-Filter接口" class="headerlink" title="1.3.1 Filter接口"></a>1.3.1 Filter接口</h4><ul><li><p>编写Filter 需要实现Filter接口，我们来看一下Filter接口的主要方法：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558775226983.png" alt="1558775226983"></p><ul><li><code>init()方法用于初始化Filter</code></li><li><code>doFilter()作用和service()方法类似，是过滤请求和响应的主要方法。</code></li><li><code>destroy()用于在Filter对象被销毁前做一些收尾工作。如：释放资源等。</code></li></ul></li></ul><h4 id="1-3-2-FilterConfig接口"><a href="#1-3-2-FilterConfig接口" class="headerlink" title="1.3.2 FilterConfig接口"></a>1.3.2 FilterConfig接口</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558775582961.png" alt="1558775582961"></p><ul><li>FilterConfig对象在服务器调用init()方法时传递进来。<ul><li><code>getFilterName() 获取Filter的名字</code></li><li><code>getServletContext() 获取ServletContext对象（即application）</code></li><li><code>getInitParameter() 获取Filter的初始化参数</code></li><li><code>getInitParameterNames() 获取所有初始化参数的名字</code></li></ul></li></ul><h4 id="1-3-3-FilterChain接口"><a href="#1-3-3-FilterChain接口" class="headerlink" title="1.3.3 FilterChain接口"></a>1.3.3 FilterChain接口</h4><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558775624400.png" alt="1558775624400"></p><ul><li>FilterChain对象是在doFilter()方法被调用时作为参数传递进来的。<ul><li>doFilter()方法用于调用Filter链上的下一个过滤器，如果当前过滤器为最后一个过滤器则将请求发送到目标资源。</li></ul></li></ul><h1 id="第二章-Filter初体验"><a href="#第二章-Filter初体验" class="headerlink" title="第二章  Filter初体验"></a>第二章  Filter初体验</h1><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>现在在Web目录下有一个目录admin。这个目录是管理员操作的目录。这个目录里有 jsp文件，有html文件，还有图片资源文件。现在我们要让这些资源都在用户登录才能被访问。那么我们要怎么实现这样的需求。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>前面我们讲过Session。有同学可能会想，我们可以在用户登录之后把用户的信息保存在Session域对象中。然后在 jsp页面里通过Session域对象获取用户的信息。如果用户信息存在，说明用户已登录。否则就重定向到登录页面。这个方案可行。可是html页面呢? html页面是没有Session域对象的。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>这就需要我们使用Filter过滤器来进行请求的拦截。然后判断Session域对象中是否包含用户的信息。</p><p>现在我们以admin目录下user.jsp为例进行讲解。</p><p>1、首先，我们需要创建一个类来实现Filter接口，用来检查Session中是否包含用户信息。</p><p>2、实现Filter中的doFilter方法</p><p>3、然后到web.xml文件中去配置Filter的过滤信息。</p><p>4、然后重启服务器访问测试</p><p><strong>操作步骤1：Filter1的类代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter的过滤方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"><span class="comment">// 强转</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line"><span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line"><span class="comment">// 获取用户登录信息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) httpRequest.getSession().getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 过滤器中，只要允许用户访问资源，一定要调用chain.doFilter方法，否则用户永远访问不到资源</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果用户未登录。返回登录页面</span></span><br><span class="line">httpResponse.sendRedirect(httpRequest.getContextPath() + <span class="string">&quot;/login.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter销毁的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作步骤2：web.xml文件中的Filter配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Filter1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给Filter1起一个名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是哪一个Filter类，即全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atmanman.filter.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Filter的名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Filter1的过滤地址</span></span><br><span class="line"><span class="comment">表示过滤http://127.0.0.1:8080/day17/admin/user.jsp</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/user.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>除此之外在filter-mapping还有一个子标签dispatcher，该标签用来指定需要Filter处理的请求类型，该标签可以配置四个值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户直接访问资源时，会调用Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过转发访问时，会调用Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过动态包含获取时，会调用Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>INCLUDE<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当通过异常处理访问页面时，会调用Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这四种情况可以设置一个，也可以同时设置多个，如果不设置那么默认为REQUEST。</li></ul></li></ul><h1 id="第三章-Filter的生命周期"><a href="#第三章-Filter的生命周期" class="headerlink" title="第三章  Filter的生命周期"></a>第三章  Filter的生命周期</h1><p><strong>Servlet的生命周期</strong></p><ol><li>先执行构造方法</li><li>执行init方法做初始化操作</li><li>执行service方法</li><li>销毁的时候调用destory方法</li></ol><p><strong>Filter生命周期：</strong></p><ol><li>先执行Filter的构造方法</li><li>然后执行Filter的init()方法，对象创建后，马上就被调用，对Filter做一些初始化操作</li><li>执行Filter的doFilter()方法，每次访问目标资源，只要匹配过滤的地址，就会调用。</li><li>执行Filter的destroy()方法，服务器停止时调用，用来释放资源。</li></ol><p><strong>Filter的生命周期和生命周期方法</strong></p><div class="table-container"><table><thead><tr><th>生命周期阶段</th><th>执行时机</th><th>生命周期方法</th></tr></thead><tbody><tr><td>创建对象</td><td>Web应用启动时</td><td>init方法，通常在该方法中做初始化工作</td></tr><tr><td>拦截请求</td><td>接收到匹配的请求</td><td>doFilter方法，通常在该方法中执行拦截过滤</td></tr><tr><td>销毁</td><td>Web应用卸载前</td><td>destroy方法，通常在该方法中执行资源释放</td></tr></tbody></table></div><h1 id="第四章-FilterConfig类"><a href="#第四章-FilterConfig类" class="headerlink" title="第四章 FilterConfig类"></a>第四章 FilterConfig类</h1><ul><li><p>作用：FilterConfig类和ServletConfig类是一样的。可以获取Filter在web.xml文件中的配置信息，做初始化之用。</p></li><li><p>我们可以在web.xml文件中给Filter添加初始化参数。然后在init初始化方法中使用FilterConfig类获取到初始化的参数。</p></li><li><p>FilterConfig类，一般有三个作用：</p><ul><li>获取Filter在web.xml文件中配置的名称</li></ul></li><li>获取Filter在web.xml文件中配置的初始化参数<ul><li>通过FilterConfig类获取ServletContext对象实例</li></ul></li></ul><p><strong>第一步：修改Filter2在web.xml中的配置信息</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Filter2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给Filter2起一个名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是哪一个Filter类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.manman.filter.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置初始化参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 初始化参数的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 初始化参数的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二步：修改Filter2中init方法的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Filter2 init 方法被调用。初始化……&quot;</span>);</span><br><span class="line"><span class="comment">// 获取Filter的名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">System.out.println(<span class="string">&quot;Filter name ==&gt;&gt;&gt; &quot;</span> + filterName);</span><br><span class="line"><span class="comment">// 获取初始化参数。username的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;username ==&gt;&gt; &quot;</span> + username);</span><br><span class="line"><span class="comment">// 获取ServletContext的对象实例 </span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">ctx</span> <span class="operator">=</span> filterConfig.getServletContext();</span><br><span class="line">System.out.println(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步：重启Tomcat服务器，控制台打印如下：</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558764469028.png" alt="1558764469028"></p><h1 id="第5章-FilterChain过滤器链（重点）"><a href="#第5章-FilterChain过滤器链（重点）" class="headerlink" title="第5章 FilterChain过滤器链（重点）"></a>第5章 FilterChain过滤器链（重点）</h1><ul><li><p>FilterChain是整个Filter过滤器的调用者。Filter与Filter之间的传递，或者Filter与请求资源之间的传递都靠FilterChain.doFilter方法。</p></li><li><p>一般Filter.doFilter中的代码分为三段：</p><ul><li>第一段是FilterChain.doFilter之前的代码。一般用来做请求的拦截，检查用户访问的权限，访问日记的记录。参数编码的设置等等操作。</li></ul></li><li><p>第二段是FilterChain.doFilter方法。此方法可以将代码的执行传递到下一个Filter中。或者是传递到用户最终访问的资源中。</p><ul><li>第三段是FilterChain.doFilter之后的代码。主要用过做一些日志操作。我们很少会在第三段中做太多复杂的操作。</li></ul></li><li><p>在每一个Filter类的doFilter方法中，一定要调用chain.doFilter方法，除非你想要阻止用户继续往下面访问。否则一定要调用FilterChain的doFilter方法。</p></li></ul><p><strong>5.1 图解：多个Filter过滤器的代码流转</strong></p><p> <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558764647060.png" alt="1558764647060"></p><p><strong>5.2 现在我们添加两个Filter类，对同一个资源进行过滤</strong></p><p>第一个Filter类ChainFilter1 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainFilter1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;资源访问前---ChainFilter1 -- 开始执行&quot;</span>);</span><br><span class="line"><span class="comment">// 转发下一个Filter或者请求的资源</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">System.out.println(<span class="string">&quot;资源访问后---ChainFilter1 -- 执行结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个Filter类ChainFilter2 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainFilter2</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;资源访问前---ChainFilter2 -- 开始执行&quot;</span>);</span><br><span class="line"><span class="comment">// 转发下一个Filter或者请求的资源</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">System.out.println(<span class="string">&quot;资源访问后---ChainFilter2 -- 执行结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.3 在web.xml文件中的配置如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ChainFilter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.manman.filter.ChainFilter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ChainFilter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/chainFilter.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ChainFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.manman.filter.ChainFilter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ChainFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/chainFilter.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5.4 WebContent/chainFilter.jsp文件的内容如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;cache-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(&quot;这是请求资源的代码&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">这是ChainFilter.jsp</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5.5 打开浏览器输入<a href="http://127.0.0.1:8080/day17/chainFilter.jsp回车访问：">http://127.0.0.1:8080/day17/chainFilter.jsp回车访问：</a></strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558764839164.png" alt="1558764839164"></p><blockquote><p><strong>千万要注意：</strong>在Filter类的doFilter方法中，除非你要拦截请求的资源，否则一定要调用FilterChain参数的doFilter方法让代码的执行传递到下一个Filter或访问的资源中。</p></blockquote><h1 id="第6章-Filter的拦截路径（目标资源的配置）"><a href="#第6章-Filter的拦截路径（目标资源的配置）" class="headerlink" title="第6章 Filter的拦截路径（目标资源的配置）"></a>第6章 Filter的拦截路径（目标资源的配置）</h1><ul><li><p>Filter的目标资源指的是需要调用Filter来进行过滤处理的资源，例如上文我们配置的/index.html就是我们的目标资源，当我们访问项目根目录下的index.html时就会调用HelloFilter来进行过滤。</p></li><li><p>目标资源的配置方式主要有以下两大种：</p><ul><li><p>第一种：通过filter-mapping的url-pattern来配置（与Servlet的url-pattern的规则相同）</p><ul><li><p><strong>精确匹配：/路径/资源名</strong></p><p>比如：/index.html、/hello/index.jsp 、 /client/LoginServlet 等，只要在请求地址完全一样时才会调用Filter</p></li><li><p><strong>目录匹配：/路径名/*</strong></p><p>比如1：/abc/ <strong>表示可以拦截abc目录下的所有资源，甚至是abc目录下的其他目录</strong>。其中：/* 表示访问 当前工程下所有资源</p><p>比如2：/* 表示只要访问项目根目录下的资源就会调用Filter</p></li><li><p><strong>后缀名匹配：*.后缀名</strong></p><p>比如：*.jsp 表示拦截所有后缀为jsp文件资源</p></li></ul></li><li><p>第二种：通过 <strong>filter-mapping</strong> 中的 <strong>servlet-name</strong> 来指定要过滤的Servlet</p></li><li><p>如：以下是一个项目中的web.xml配置文件，在项目中有一个Filter加做HelloFilter，一个Servlet叫做HelloServlet。在Filter的filter-mapping中增加了一个servlet-name标签，将该标签的值设置成Servlet的名字，在访问Servlet时就会调用该过滤器过滤请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HelloFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.manman.web.filter.HelloFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HelloFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.manman.web.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>针对于第一种情况：</p><p>精确匹配前面 ，我们已经演示过了。</p><p>下面我们以目录匹配为示例展示代码。大家可以在此基础上修改web.xml文件中的<url-pattern>标签来测试自己想要的路径。</p><p><strong>1. Filter的代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterPath</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;filter path 执行了&quot;</span>);</span><br><span class="line"><span class="comment">// 将代码执行传递到下一个Filter或者是请求资源</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. web.xml文件中的配置内容：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterPath<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.manman.filter.FilterPath<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterPath<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="第7章-HttpFilter"><a href="#第7章-HttpFilter" class="headerlink" title="第7章 HttpFilter"></a>第7章 HttpFilter</h1><ul><li><p>回想Servlet中学习，我们发现：实现Servlet接口，不如继承HttpServlet应用方便。所以，我们想到需要继承HttpFilter。</p></li><li><p>如果tomcat类库没有提供HttpFilter,就需要我们自己设计一个HttpFilter。</p><ul><li><p>类比最终创建Servlet的方式，我们发现设计HttpFilter大体分为以下几个步骤：</p><ol><li><p>提供 getFilterConfig() 和 getServletContext()</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558775624401.png" alt="1558764839164"></p></li><li><p>将doFilter()重载并抽象化处理</p></li><li><p>原有doFilter()方法需要将参数转换类型后，调用重载doFilter()方法</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558775624402.png" alt="1558764839164"></p></li></ol></li></ul></li></ul><h1 id="第八章-监听器（了解即可）"><a href="#第八章-监听器（了解即可）" class="headerlink" title="第八章 监听器（了解即可）"></a>第八章 监听器（了解即可）</h1><h2 id="2-1-监听器的简介"><a href="#2-1-监听器的简介" class="headerlink" title="2.1 监听器的简介"></a>2.1 监听器的简介</h2><h3 id="2-1-1-监听器的概念"><a href="#2-1-1-监听器的概念" class="headerlink" title="2.1.1 监听器的概念"></a>2.1.1 监听器的概念</h3><p>监听器：专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。<br><span style="color:blue;font-weight:bold;">Servlet监听器</span>：Servlet规范中定义的一种特殊类，它用于监听Web应用程序中的ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。</p><h3 id="2-1-2-Servlet监听器的分类-了解"><a href="#2-1-2-Servlet监听器的分类-了解" class="headerlink" title="2.1.2 Servlet监听器的分类(了解)"></a>2.1.2 Servlet监听器的分类(了解)</h3><h4 id="①-ServletContextListener"><a href="#①-ServletContextListener" class="headerlink" title="① ServletContextListener"></a>① ServletContextListener</h4><p>作用：监听ServletContext对象的创建与销毁</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>contextInitialized(ServletContextEvent sce)</td><td>ServletContext创建时调用</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>ServletContext销毁时调用</td></tr></tbody></table></div><p>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</p><h6 id="②-HttpSessionListener"><a href="#②-HttpSessionListener" class="headerlink" title="② HttpSessionListener"></a>② HttpSessionListener</h6><p>作用：监听HttpSession对象的创建与销毁</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionCreated(HttpSessionEvent hse)</td><td>HttpSession对象创建时调用</td></tr><tr><td>sessionDestroyed(HttpSessionEvent hse)</td><td>HttpSession对象销毁时调用</td></tr></tbody></table></div><p>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</p><h6 id="③-ServletRequestListener"><a href="#③-ServletRequestListener" class="headerlink" title="③ ServletRequestListener"></a>③ ServletRequestListener</h6><p>作用：监听ServletRequest对象的创建与销毁</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>requestInitialized(ServletRequestEvent sre)</td><td>ServletRequest对象创建时调用</td></tr><tr><td>requestDestroyed(ServletRequestEvent sre)</td><td>ServletRequest对象销毁时调用</td></tr></tbody></table></div><p>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</p><h6 id="④-ServletContextAttributeListener"><a href="#④-ServletContextAttributeListener" class="headerlink" title="④ ServletContextAttributeListener"></a>④ ServletContextAttributeListener</h6><p>作用：监听ServletContext中属性的添加、移除和修改</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletContextAttributeEvent scab)</td><td>向ServletContext中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletContextAttributeEvent scab)</td><td>从ServletContext中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletContextAttributeEvent scab)</td><td>当ServletContext中的属性被修改时调用</td></tr></tbody></table></div><p>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table></div><h6 id="⑤-HttpSessionAttributeListener"><a href="#⑤-HttpSessionAttributeListener" class="headerlink" title="⑤ HttpSessionAttributeListener"></a>⑤ HttpSessionAttributeListener</h6><p>作用：监听HttpSession中属性的添加、移除和修改</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(HttpSessionBindingEvent se)</td><td>向HttpSession中添加属性时调用</td></tr><tr><td>attributeRemoved(HttpSessionBindingEvent se)</td><td>从HttpSession中移除属性时调用</td></tr><tr><td>attributeReplaced(HttpSessionBindingEvent se)</td><td>当HttpSession中的属性被修改时调用</td></tr></tbody></table></div><p>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table></div><h6 id="⑥-ServletRequestAttributeListener"><a href="#⑥-ServletRequestAttributeListener" class="headerlink" title="⑥ ServletRequestAttributeListener"></a>⑥ ServletRequestAttributeListener</h6><p>作用：监听ServletRequest中属性的添加、移除和修改</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>向ServletRequest中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>从ServletRequest中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>当ServletRequest中的属性被修改时调用</td></tr></tbody></table></div><p>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletRequest ()</td><td>获取触发事件的ServletRequest对象</td></tr></tbody></table></div><h6 id="⑦-HttpSessionBindingListener"><a href="#⑦-HttpSessionBindingListener" class="headerlink" title="⑦ HttpSessionBindingListener"></a>⑦ HttpSessionBindingListener</h6><p>作用：监听某个对象在Session域中的创建与移除</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>valueBound(HttpSessionBindingEvent event)</td><td>该类的实例被放到Session域中时调用</td></tr><tr><td>valueUnbound(HttpSessionBindingEvent event)</td><td>该类的实例从Session中移除时调用</td></tr></tbody></table></div><p>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</p><div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取当前事件涉及的属性名</td></tr><tr><td>getValue()</td><td>获取当前事件涉及的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table></div><h4 id="2-2-ServletContextListener的使用"><a href="#2-2-ServletContextListener的使用" class="headerlink" title="2.2 ServletContextListener的使用"></a>2.2 ServletContextListener的使用</h4><h5 id="2-2-1-作用"><a href="#2-2-1-作用" class="headerlink" title="2.2.1 作用"></a>2.2.1 作用</h5><p>ServletContextListener是监听ServletContext对象的创建和销毁的，因为ServletContext对象是在服务器启动的时候创建、在服务器关闭的时候销毁，所以ServletContextListener也可以监听服务器的启动和关闭</p><h5 id="2-2-2-使用场景"><a href="#2-2-2-使用场景" class="headerlink" title="2.2.2 使用场景"></a>2.2.2 使用场景</h5><p>将来学习SpringMVC的时候，会用到一个ContextLoaderListener，这个监听器就实现了ServletContextListener接口，表示对ServletContext对象本身的生命周期进行监控。</p><h5 id="2-2-3-代码实现"><a href="#2-2-3-代码实现" class="headerlink" title="2.2.3 代码实现"></a>2.2.3 代码实现</h5><h6 id="①-创建监听器类"><a href="#①-创建监听器类" class="headerlink" title="① 创建监听器类"></a>① 创建监听器类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包名:com.manman.listener</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenxin</span></span><br><span class="line"><span class="comment"> * 日期2021-06-19  10:26</span></span><br><span class="line"><span class="comment"> * 编写监听器的步骤:</span></span><br><span class="line"><span class="comment"> * 1. 写一个类实现对应的：Listener的接口(我们这里使用的是ServletContextListener),并且实现它里面的方法</span></span><br><span class="line"><span class="comment"> *    1.1 contextInitialized()这个方法在ServletContext对象被创建出来的时候执行，也就是说在服务器启动的时候执行</span></span><br><span class="line"><span class="comment"> *    1.2 contextDestroyed()这个方法会在ServletContext对象被销毁的时候执行，也就是说在服务器关闭的时候执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在web.xml中注册(配置)监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在服务器启动的时候，模拟创建SpringMVC的核心容器...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在服务器启动的时候，模拟销毁SpringMVC的核心容器...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="②-注册监听器"><a href="#②-注册监听器" class="headerlink" title="② 注册监听器"></a>② 注册监听器</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.manman.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文学懂过滤器和监听器&quot;&gt;&lt;a href=&quot;#一文学懂过滤器和监听器&quot; class=&quot;headerlink&quot; title=&quot;一文学懂过滤器和监听器&quot;&gt;&lt;/a&gt;一文学懂过滤器和监听器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一文了解转发与重定向</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2022-10-16T14:59:54.000Z</published>
    <updated>2022-10-16T15:05:02.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文了解转发与重定向"><a href="#一文了解转发与重定向" class="headerlink" title="一文了解转发与重定向"></a>一文了解转发与重定向</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p><strong>先看一下思维导图了解一下大体</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91.png" alt=""></p><h1 id="第1章-请求的转发与重定向"><a href="#第1章-请求的转发与重定向" class="headerlink" title="第1章 请求的转发与重定向"></a>第1章 请求的转发与重定向</h1><p>请求的转发与重定向是web应用页面跳转的主要手段，在Web应用中使用非常广泛。所以我们一定要搞清楚他们的区别。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1562000421414.png" alt="1562000421414"></p><h3 id="8-1-请求的转发"><a href="#8-1-请求的转发" class="headerlink" title="8.1 请求的转发"></a>8.1 请求的转发</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1557754164834.png" alt="1557754164834"></p><ul><li>第一个Servlet接收到了浏览器端的请求，进行了一定的处理，然后没有立即对请求进行响应，而是将请求“交给下一个Servlet”继续处理，下一个Servlet处理完成之后对浏览器进行了响应。<strong>在服务器内部将请求“交给”其它组件继续处理就是请求的转发。</strong>对浏览器来说，一共只发了一次请求，服务器内部进行的“转发”浏览器感觉不到，同时浏览器地址栏中的地址不会变成“下一个Servlet”的虚拟路径。</li><li><code>HttpServletRequest</code> 代表HTTP请求，对象由Servlet容器创建。转发的情况下，两个<code>Servlet</code> 可以共享同一个<code>Request</code>对象中保存的数据。</li><li>当需要将后台获取的数据传送到 <code>JSP</code>上显示的时候，就可以先将数据存放到Request对象中，再转发到JSP从属性域中获取。此时由于是“转发”，所以它们二者共享 <code>Request</code> 对象中的数据。</li><li>转发的情况下，可以访问WEB-INF下的资源。</li><li><strong>转发以“/”开始表示项目根路径，重定向以”/”开始表示主机地址。</strong></li><li>功能：<ul><li>获取请求参数</li><li>获取请求路径即URL地址相关信息</li><li>在请求域中保存数据</li><li>转发请求</li></ul></li><li>代码举例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//1.使用RequestDispatcher对象封装目标资源的虚拟路径</span></span><br><span class="line"><span class="type">RequestDispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> request.getRequestDispatcher(<span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line"><span class="comment">//2.调用RequestDispatcher对象的forward()方法“前往”目标资源</span></span><br><span class="line"><span class="comment">//[注意：传入的参数必须是传递给当前Servlet的service方法的</span></span><br><span class="line"><span class="comment">//那两个ServletRequest和ServletResponse对象]</span></span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-请求的重定向"><a href="#8-2-请求的重定向" class="headerlink" title="8.2 请求的重定向"></a>8.2 请求的重定向</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1557754122187.png" alt="1557754122187"></p><ul><li><p>第一个Servlet接收到了浏览器端的请求，进行了一定的处理，然后给浏览器一个特殊的响应消息，这个特殊的响应消息会通知浏览器去访问另外一个资源，这个动作是服务器和浏览器自动完成的。<strong>整个过程中浏览器端会发出两次请求</strong>，且在<strong>浏览器地址栏里面能够看到地址的改变</strong>，改变为下一个资源的地址。</p></li><li><p>重定向的情况下，原Servlet和目标资源之间就不能共享请求域数据了。</p></li><li><p>HttpServletResponse代表HTTP响应，对象由Servlet容器创建。</p></li><li><p>功能：</p><ul><li>向浏览器输出数据</li><li>重定向请求</li></ul></li><li><p>重定向的响应报文的头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line">Location: success.html</span><br></pre></td></tr></table></figure></li><li><p>应用：</p><ul><li><p>用户从 login.html 页面提交登录请求数据给LoginServlet处理。</p><p>如果账号密码正确，需要让用户跳转到成功页面，通过servlet向响应体中写入成功页面过于复杂，通过重定向将成功页面的地址交给浏览器并设置响应状态码为302，浏览器会自动进行跳转</p></li></ul></li><li><p>代码举例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//1.调用HttpServletResponse对象的sendRedirect()方法</span></span><br><span class="line"><span class="comment">//2.传入的参数是目标资源的虚拟路径</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-3-对比请求的转发与重定向"><a href="#8-3-对比请求的转发与重定向" class="headerlink" title="8.3 对比请求的转发与重定向"></a>8.3 对比请求的转发与重定向</h3><div class="table-container"><table><thead><tr><th></th><th>转发</th><th>重定向</th></tr></thead><tbody><tr><td>浏览器感知</td><td>在服务器内部完成，浏览器感知不到</td><td>服务器以302状态码通知浏览器访问新地址，浏览器有感知</td></tr><tr><td>浏览器地址栏</td><td>不改变</td><td>改变</td></tr><tr><td>整个过程发送请求次数</td><td>一次</td><td>两次</td></tr><tr><td>执行效率</td><td>效率高</td><td>效率低</td></tr><tr><td>API（或发起者）</td><td>Request对象</td><td>Response对象</td></tr><tr><td>能否共享request对象数据</td><td>能</td><td>否</td></tr><tr><td>WEB-INF下的资源</td><td>能访问</td><td>不能访问</td></tr><tr><td>目标资源</td><td>必须是当前web应用中的资源</td><td>不局限于当前web应用</td></tr></tbody></table></div><blockquote><p>说明1：默认情况下，浏览器是不能访问服务器web-inf下的资源的，而服务器是可以访问的。</p><p>说明2：浏览器默认的绝对路径：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>​              服务器项目的代码中的绝对路径：<a href="http://localhost:8080/项目名/">http://localhost:8080/项目名/</a></p></blockquote><h1 id="第2章-请求与响应中的字符编码设置"><a href="#第2章-请求与响应中的字符编码设置" class="headerlink" title="第2章 请求与响应中的字符编码设置"></a>第2章 请求与响应中的字符编码设置</h1><h3 id="9-1-字符编码问题"><a href="#9-1-字符编码问题" class="headerlink" title="9.1 字符编码问题"></a>9.1 字符编码问题</h3><ul><li>我们 web 程序在接收请求并处理过程中，如果不注意编码格式及解码格式，很容易导致中文乱码，引起这个问题的原因到底在哪里？如何解决？</li><li>说到这个问题我们先来说一说字符集。<ul><li>什么是字符集，就是各种字符的集合，包括汉字，英文，标点符号等等。各国都有不同的文字、符号。这些文字符号的集合就叫字符集。</li><li>现有的字符集ASCII、GB2312、BIG5、GB18030、Unicode、UTF-8、ISO-8859-1等</li></ul></li><li>这些字符集，集合了很多的字符，然而，字符要以二进制的形式存储在计算机中，我们就需要对其进行编码，将编码后的二进制存入。取出时我们就要对其解码，将二进制解码成我们之前的字符。这个时候我们就需要制定一套编码解码标准。否则就会导致出现混乱，也就是我们的乱码。</li></ul><h3 id="9-2-编码与解码"><a href="#9-2-编码与解码" class="headerlink" title="9.2 编码与解码"></a>9.2 编码与解码</h3><ul><li>编码：将字符转换为二进制数</li></ul><div class="table-container"><table><thead><tr><th>汉字</th><th>编码方式</th><th>编码</th><th>二进制</th></tr></thead><tbody><tr><td>‘中’</td><td><strong>GB2312</strong></td><td><strong>D6D0</strong></td><td><strong>1101 0110-1101 0000</strong></td></tr><tr><td>‘中’</td><td><strong>UTF-16</strong></td><td><strong>4E2D</strong></td><td><strong>0100 1110-0010 1101</strong></td></tr><tr><td>‘中’</td><td><strong>UTF-8</strong></td><td><strong>E4B8AD</strong></td><td><strong>1110</strong> <strong>0100-</strong> <strong>1011</strong> <strong>1000-1010 1101</strong></td></tr></tbody></table></div><ul><li>解码：将二进制数转换为字符</li></ul><p>1110 0100-1011 1000-1010 1101 → E4B8AD → ’中’</p><ul><li>乱码：一段文本，使用A字符集编码，使用B字符集解码，就会产生乱码。所以解决乱码问题的根本方法就是统一编码和解码的字符集。</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558009252673.png" alt="1558009252673"></p><h3 id="9-3-解决请求乱码问题"><a href="#9-3-解决请求乱码问题" class="headerlink" title="9.3 解决请求乱码问题"></a>9.3 解决请求乱码问题</h3><p>解决乱码的方法：就是统一字符编码。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1558009756944.png" alt="1558009756944"></p><h4 id="9-3-1-GET请求"><a href="#9-3-1-GET请求" class="headerlink" title="9.3.1 GET请求"></a>9.3.1 GET请求</h4><ul><li>GET请求参数是在地址后面的。我们需要修改tomcat的配置文件。需要在server.xml文件修改Connector标签，添加URIEncoding=”utf-8”属性。</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1561220531242.png" alt="1561220531242"></p><ul><li>一旦配置好以后，可以解决当前工作空间中所有的GET请求的乱码问题。</li></ul><h4 id="9-3-2-POST请求"><a href="#9-3-2-POST请求" class="headerlink" title="9.3.2 POST请求"></a>9.3.2 POST请求</h4><ul><li><p>post请求提交了中文的请求体，服务器解析出现问题。</p></li><li><p>解决方法：在获取参数值之前，设置请求的解码格式，使其和页面保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>POST请求乱码问题的解决，只适用于当前的操作所在的类中。不能类似于GET请求一样统一解决。因为请求体有可能会上传文件。不一定都是中文字符。</p></li></ul><h3 id="9-4-解决响应乱码问题"><a href="#9-4-解决响应乱码问题" class="headerlink" title="9.4 解决响应乱码问题"></a>9.4 解决响应乱码问题</h3><ul><li><p>向浏览器发送响应的时候，要告诉浏览器，我使用的字符集是哪个，浏览器就会按照这种方式来解码。如何告诉浏览器响应内容的字符编码方案。很简单。</p></li><li><p>解决方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>解决方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>说明：有的人可能会想到使用response.setCharacterEncoding(“utf-8”)，设置reponse对象将UTF-8字符串写入到响应报文的编码为UTF-8。只这样做是不行的，还必须手动在浏览器中设置浏览器的解析用到的字符集。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文了解转发与重定向&quot;&gt;&lt;a href=&quot;#一文了解转发与重定向&quot; class=&quot;headerlink&quot; title=&quot;一文了解转发与重定向&quot;&gt;&lt;/a&gt;一文了解转发与重定向&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https://b</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>初始ServletContext</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E5%88%9D%E5%A7%8BServletContext/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E5%88%9D%E5%A7%8BServletContext/</id>
    <published>2022-10-16T14:59:35.000Z</published>
    <updated>2022-10-16T15:05:02.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初始ServletContext"><a href="#初始ServletContext" class="headerlink" title="初始ServletContext"></a>初始ServletContext</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p>在正式了解 <code>ServletConfig</code>  之前，先让大家有一个整体印象。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823224011140.png" alt="image-20220823224011140"><br>之前讲过ServletConfig, 我发现他们有两个共同的方法，我对他们的区别做了小小的总结<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822230342360.png" alt="image-20220822230342360"></p><p>上面的思维导图是对下面内容的总结，大家可以先看看，对等会的内容有一个大概印象，看完后，可以再回头看看这个思维导图。</p><h1 id="ServletContext是什么"><a href="#ServletContext是什么" class="headerlink" title="ServletContext是什么"></a>ServletContext是什么</h1><ul><li>ServletContext是一个接口，是<a href="https://so.csdn.net/so/search?q=Servlet&amp;spm=1001.2101.3001.7020">Servlet</a>规范中的一员，</li><li>ServletContext对象的创建也是Tomcat服务器来完成的。启动webapp的时候创建的。</li></ul><h1 id="ServletContext是谁实现的"><a href="#ServletContext是谁实现的" class="headerlink" title="ServletContext是谁实现的"></a>ServletContext是谁实现的</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tomcat服务器(WEB服务器)实现了ServletContext接口</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">org</span>.apache.catalina.core.ApplicationContextFacade <span class="keyword">implements</span> <span class="title class_">ServletContext</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Servlet对象是谁创建的，在什么时候创建的</li></ul><blockquote><p>ServletContext对象是WEB服务器启动的时候创建的<br>ServletContext对象是WEB服务器创建的</p></blockquote><h1 id="ServletContext的生命周期"><a href="#ServletContext的生命周期" class="headerlink" title="ServletContext的生命周期"></a>ServletContext的生命周期</h1><ul><li><p>对于一个webapp来说，ServletContext对象只有一个</p></li><li><p>一个web应用对应一个ServletContext实例，这个实例是应用部署启动后，servlet容器为应用创建的。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a7f1d3abfc7048c0a531ddda6c0b6b54.png" alt="在这里插入图片描述"></p><p><strong>ServletContext对象在服务器关闭的时候销毁</strong></p></li><li><p>一个Servlet对象对应一个ServletConfig。100个Servlet对象则对应100个ServletConfig对象。</p></li><li><p>只要在同一个webapp当中，只要在同一个应用当中，所有的Servlet对象都是共享同一个ServletContext对象的。</p></li><li><p>ServletContext对象在服务器启动阶段创建，在服务器关闭的时候销毁。这就是ServletContext对象的生命周期。ServletContext对象是应用级对象。</p></li><li><p>Tomcat服务器中有一个webapps，这个webapps下可以存放webapp，可以存放多个webapp，假设有100个webapp，那么就有100个ServletContext对象。但是，总之，一个应用，一个webapp肯定是只有一个ServletContext对象。<br>接下来，通过程序验证一下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">writer.print(<span class="string">&quot;ServletContext对象:&quot;</span>+servletContext+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822230557934.png" alt="image-20220822230557934"></p><p>一个webapp应用共享一个ServletContext对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">writer.print(<span class="string">&quot;ServletContext对象:&quot;</span>+servletContext+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/ed42916df9d84fcabca8bfb6b0bf2ee9.png" alt="在这里插入图片描述"><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822230614454.png" alt="image-20220822230614454"><br><strong><font color='red'>在同一个webapp下的Servlet都是共享同一个ServletContext对象</font></strong></p><ul><li>ServletContext被称为Servlet上下文对象。（<font color='red'>Servlet对象的四周环境对象。</font>&gt;）</li><li>一个ServletContext对象通常对应的是一个web.xml文件。</li><li>ServletContext对应显示生活中的什么例子呢？<ul><li>一个教室里有多个学生，那么每一个学生就是一个Servlet，这些学生都在同一个教室当中，那么我们可以把这个教室叫做ServletContext对象。那么也就是说放在这个ServletContext对象（环境）当中的数据，在同一个教室当中，物品都是共享的。比如：教室中有一个空调，所有的学生都可以操作。可见，空调是共享的。因为空调放在教室当中。教室就是ServletContext对象。</li><li>Tomcat是一个容器，一个容器可以放多个webapp,一个webapp对应一个ServletContext对象</li></ul></li></ul><h1 id="ServletContext接口中常用的方法"><a href="#ServletContext接口中常用的方法" class="headerlink" title="ServletContext接口中常用的方法"></a>ServletContext接口中常用的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>; <span class="comment">// 通过初始化参数的name获取value</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>; <span class="comment">// 获取所有的初始化参数的name</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.print(<span class="string">&quot;ServletContext对象:&quot;</span>+servletContext+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">initParameter</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;pageSize&quot;</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;pageSize=  &quot;</span>+initParameter);</span><br><span class="line"></span><br><span class="line">  Enumeration&lt;String&gt; names = servletContext.getInitParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line">            <span class="comment">//通过name获取value</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">initParameter</span> <span class="operator">=</span> servletContext.getInitParameter(s);</span><br><span class="line">            writer.println(s +<span class="string">&quot;---&gt;&quot;</span>+ initParameter +<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/3eefc83c7ca440e6b6d968e998e6aeac.png" alt="在这里插入图片描述"><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/93184e838c8e47ffbe12d6334af4dd66.png" alt="在这里插入图片描述"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--以上两个方法是ServletContext对象的方法，这个方法获取的是什么信息？是以下的配置信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>pageSize<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>startIndex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意：以上的配置信息属于应用级的配置信息，一般一个项目中共享的配置信息会放到以上的标签当中。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果你的配置信息只是想给某一个servlet作为参考，那么你配置到servlet标签当中即可，使用ServletConfig对象来获取。--&gt;</span></span><br></pre></td></tr></table></figure><p>获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径<br>在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取项目的根路径</span><br><span class="line">获取应用的根路径（非常重要），因为在java源代码当中有一些地方可能会需要应用的根路径，这个方法可以动态获取应用的根路径</span><br><span class="line">在java源码当中，不要将应用的根路径写死，因为你永远都不知道这个应用在最终部署的时候，起一个什么名字。</span><br><span class="line">       writer.print(<span class="string">&quot;获取项目的根路径:&quot;</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> servletContext.getContextPath();</span><br><span class="line">       <span class="comment">//  /servlet04</span></span><br><span class="line">       writer.println(contextPath+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822230717498.png" alt="image-20220822230717498"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取文件的绝对路径</span><br><span class="line"> <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;AServlet.java&quot;</span>);</span><br><span class="line">        writer.println(realPath+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823222908577.png" alt="image-20220823222908577"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  通过ServletContext对象也是可以记录日志的</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message, Throwable t)</span>;</span><br><span class="line">  这些日志信息记录到哪里了？</span><br><span class="line">  localhost<span class="number">.2022</span>-<span class="number">03</span>-<span class="number">12.</span>log</span><br><span class="line"></span><br><span class="line">  Tomcat服务器的logs目录下都有哪些日志文件？</span><br><span class="line"> catalina<span class="number">.2022</span>-<span class="number">03</span>-<span class="number">12.</span>log 服务器端的java程序运行的控制台信息。</span><br><span class="line"> localhost<span class="number">.2022</span>-<span class="number">03</span>-<span class="number">12.</span>log ServletContext对象的log方法记录的日志信息存储到这个文件中。</span><br><span class="line"> localhost_access_log<span class="number">.2022</span>-<span class="number">03</span>-<span class="number">12.</span>txt 访问日志</span><br></pre></td></tr></table></figure><h1 id="应用域-重点"><a href="#应用域-重点" class="headerlink" title="应用域(重点)"></a>应用域(重点)</h1><p>ServletContext 对象还有另一个名字：<font color='red'>应用域</font>（后面还有其他域，例如：请求域、会话域）</p><p>如果所有的用户共享一份数据，并且这个数据很少的被修改，并且这个数据量很少，可以将这些数据放到ServletContext这个应用域中</p><p>为什么是所有用户共享的数据？ 不是共享的没有意义。因为ServletContext这个对象只有一个。只有共享的数据放进去才有意义。</p><p>为什么数据量要小？ 因为数据量比较大的话，太占用堆内存，并且这个对象的生命周期比较长，服务器关闭的时候，这个对象才会被销毁。大数据量会影响服务器的性能。占用内存较小的数据量可以考虑放进去。</p><p>为什么这些共享数据很少的修改，或者说几乎不修改？<br>所有用户共享的数据，如果涉及到修改操作，必然会存在线程并发所带来的安全问题。所以放在ServletContext对象中的数据一般都是只读的。</p><p>数据量小、所有用户共享、又不修改，这样的数据放到ServletContext这个应用域当中，会大大提升效率。因为应用域相当于一个缓存，放到缓存中的数据，下次在用的时候，不需要从数据库中再次获取，大大提升执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  存（怎么向ServletContext应用域中存数据）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object value)</span>;   map.put(k, v)</span><br><span class="line">  取（怎么从ServletContext应用域中取数据）</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getAttribute</span><span class="params">(String name)</span>;   <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> map.get(k)</span><br><span class="line">  删（怎么删除ServletContext应用域中的数据）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span>;   map.remove(k)</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：以后我们编写Servlet类的时候，实际上是不会去直接继承GenericServlet类的，因为我们是B/S结构的系统，这种系统是基于HTTP超文本传输协议的，在Servlet规范当中，提供了一个类叫做HttpServlet，它是专门为HTTP协议准备的一个Servlet类。我们编写的Servlet类要继承HttpServlet。（HttpServlet是HTTP协议专用的。）使用HttpServlet处理HTTP协议更便捷。但是你需要知道它的继承结构：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;    javax.servlet.Servlet（接口）【爷爷】</span><br><span class="line">&gt;     javax.servlet.GenericServlet <span class="keyword">implements</span> <span class="title class_">Servlet</span>（抽象类）【儿子】</span><br><span class="line">&gt;     javax.servlet.http.HttpServlet <span class="keyword">extends</span> <span class="title class_">GenericServlet</span>（抽象类）【孙子】</span><br><span class="line">&gt;     </span><br><span class="line">&gt;    我们以后编写的Servlet要继承HttpServlet类。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前为止都接触过哪些缓存机制了？</p><ul><li>堆内存当中的字符串常量池。<ul><li>“abc” 先在字符串常量池中查找，如果有，直接拿来用。如果没有则新建，然后再放入字符串常量池。</li></ul></li><li>堆内存当中的整数型常量池。<ul><li>[-128 ~ 127] 一共256个Integer类型的引用，放在整数型常量池中。没有超出这个范围的话，直接从常量池中取。</li></ul></li><li>连接池(Connection Cache)<ul><li>这里所说的连接池中的连接是java语言连接数据库的连接对象：java.sql.Connection对象。</li><li>JVM是一个进程。MySQL数据库是一个进程。进程和进程之间建立连接，打开通道是很费劲的。是很耗费资源的。怎么办？可以提前先创建好N个Connection连接对象，将连接对象放到一个集合当中，我们把这个放有Connection对象的集合称为连接池。每一次用户连接的时候不需要再新建连接对象，省去了新建的环节，直接从连接池中获取连接对象，大大提升访问效率。</li><li>连接池<ul><li>最小连接数</li><li>最大连接数</li><li>连接池可以提高用户的访问效率。当然也可以保证数据库的安全性。</li></ul></li></ul></li><li>线程池<ul><li>Tomcat服务器本身就是支持多线程的。</li><li>Tomcat服务器是在用户发送一次请求，就新建一个Thread线程对象吗？<ul><li>当然不是，实际上是在Tomcat服务器启动的时候，会先创建好N多个线程Thread对象，然后将线程对象放到集合当中，称为线程池。用户发送请求过来之后，需要有一个对应的线程来处理这个请求，这个时候线程对象就会直接从线程池中拿，效率比较高。</li><li>所有的WEB服务器，或者应用服务器，都是支持多线程的，都有线程池机制。</li></ul></li></ul></li><li>redis<ul><li>NoSQL数据库。非关系型数据库。缓存数据库。</li></ul></li><li>向ServletContext应用域中存储数据，也等于是将数据存放到缓存cache当中</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初始ServletContext&quot;&gt;&lt;a href=&quot;#初始ServletContext&quot; class=&quot;headerlink&quot; title=&quot;初始ServletContext&quot;&gt;&lt;/a&gt;初始ServletContext&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;�</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>初识ServletConfig</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E5%88%9D%E8%AF%86ServletConfig/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/%E5%88%9D%E8%AF%86ServletConfig/</id>
    <published>2022-10-16T14:59:04.000Z</published>
    <updated>2022-10-16T15:05:02.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识ServletConfig"><a href="#初识ServletConfig" class="headerlink" title="初识ServletConfig"></a>初识ServletConfig</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><p><strong>可以先通过这个思维导图来大致了解一下关于ServletConfig</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220820100945035.png" alt="image-20220820100945035"></p><p>ServletConfig 是一个接口(jakarta.<a href="https://so.csdn.net/so/search?q=Servlet&amp;spm=1001.2101.3001.7020">Servlet</a>的一个接口)<br>ServletConfig 是Servlet规范的一员<br>全称:jakarta.servlet.ServletConfig<br>Servlet对象的配置信息对象。<br>ServletConfig对象中封装了标签中的配置信息。（web.xml文件中servlet的配置信息）<br>每个serlvet类的实例都有且只有一个对应的servletConfig对象</p><h1 id="谁去实现ServletConfig这个接口"><a href="#谁去实现ServletConfig这个接口" class="headerlink" title="谁去实现ServletConfig这个接口"></a>谁去实现ServletConfig这个接口</h1><p>public class org.apache.catalina.core.StandardWrapperFacade</p><p>结论:Tomcat服务器实现了ServletConfig这个接口——-WEB服务器实现了这个接口<br>不同服务器有不同的实现<br>思考：如果把Tomcat服务器换成jetty服务器，输出ServletConfig对象的时候，还是这个结果吗？<br>不一定一样，包名类名可能和Tomcat服务器不一样，但是他们都实现了ServletConfig这个规范</p><h1 id="一个Servlet对象有一个ServletConfig对象，他们之间是一对一"><a href="#一个Servlet对象有一个ServletConfig对象，他们之间是一对一" class="headerlink" title="一个Servlet对象有一个ServletConfig对象，他们之间是一对一"></a>一个Servlet对象有一个ServletConfig对象，他们之间是一对一</h1><h1 id="ServletConfig对象是谁创建？在什么时候创建？"><a href="#ServletConfig对象是谁创建？在什么时候创建？" class="headerlink" title="ServletConfig对象是谁创建？在什么时候创建？"></a>ServletConfig对象是谁创建？在什么时候创建？</h1><ul><li><p>Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。</p><ul><li><p>Tomcat服务器(WEB服务器)创建了ServletConfig对象<br>在创建Servlet对象的时候，同时创建了ServletConfig对象</p></li><li><p>Servlet对象是Tomcat服务器创建，并且ServletConfig对象也是Tomcat服务器创建。并且默认情况下，他们都是在用户发送第一次请求的时候创建。</p></li></ul></li><li><p>Tomcat服务器调用Servlet对象的init方法的时候需要传一个ServletConfig对象的参数给init方法。</p><h1 id="ServletConfig接口的作用"><a href="#ServletConfig接口的作用" class="headerlink" title="ServletConfig接口的作用"></a>ServletConfig接口的作用</h1></li></ul><p>Config是Configuration单词的缩写<br>ServletConfig对象翻译为:Servlet对象的配置信息对象<br>一个Servlet对象就有一个配置信息对象</p><h1 id="ServletConfig对象中包装的信息"><a href="#ServletConfig对象中包装的信息" class="headerlink" title="ServletConfig对象中包装的信息"></a>ServletConfig对象中包装的信息</h1><p>web.xml文件中标签中的配置信息</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span>; <span class="comment">// 通过初始化参数的name获取value</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"> &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;configTestServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.bjpowernode.servlet.ConfigTestServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;!--这里可以配置servlet对象的初始化信息 --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;driver&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;com.mysql.cj.jdbc.Driver&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">       </span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;configTestServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/test&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>String value=config.getInitParameter(“driver);<br>通过这个方法，传入name,可以获取初始化配置信息的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getInitParameterNames</span><span class="params">()</span>; <span class="comment">// 获取所有的初始化参数的name</span></span><br><span class="line"><span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span>; <span class="comment">// 获取ServletContext对象</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletName</span><span class="params">()</span>; <span class="comment">// 获取当前Servlet的name</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"> /</span><br><span class="line"> * <span class="meta">@author</span> gaoziman</span><br><span class="line"> * <span class="meta">@create</span> <span class="number">2022</span>--08--<span class="number">19</span> <span class="number">20</span>:<span class="number">39</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigTestServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        PrintWriter out=response.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServletConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletConfig();</span><br><span class="line">        <span class="comment">//org.apache.catalina.core.StandardWrapperFacade@778f4ce</span></span><br><span class="line">        out.println(<span class="string">&quot;ServletConfig对象:&quot;</span>+config);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">configServletName</span> <span class="operator">=</span> config.getServletName();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;servlet-name&gt;&quot;</span>+configServletName+<span class="string">&quot;&lt;/servlet-name&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//通过ServletConfig对象中的方法可以获取web.xml文件中的初始化参数配置信息</span></span><br><span class="line">        <span class="comment">//java.util.Enumeration&lt;java.lang.String&gt; getInitParameterNames()  获取所有初始化参数name</span></span><br><span class="line"><span class="comment">//java.lang.String   getInitParameter(java.lang.String name)   通过初始化参数的name，来获取value</span></span><br><span class="line">        Enumeration&lt;String&gt; initParameterNames = config.getInitParameterNames();<span class="comment">//获取对应name的value</span></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        out.println(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (initParameterNames.hasMoreElements())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> initParameterNames.nextElement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> config.getInitParameter(s);</span><br><span class="line"></span><br><span class="line">            out.println(s+<span class="string">&quot;-----&gt;&quot;</span>+value);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实际上获取一个Servlet对象的初始化参数，可以不用获取ServletConfig对象</span></span><br><span class="line">        <span class="comment">//因为适配器有相关方法</span></span><br><span class="line">        Enumeration&lt;String&gt; names = <span class="built_in">this</span>.getInitParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line">            System.out.println(s+<span class="string">&quot;----&gt;&quot;</span>+<span class="built_in">this</span>.getInitParameter(s));</span><br><span class="line">            <span class="comment">//out.println(&quot;&lt;br&gt;&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//怎么获取ServletContext对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方式通过ServletConfig对象来获取ServletContext对象</span></span><br><span class="line">        ServletContext application=config.getServletContext();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//org.apache.catalina.core.ApplicationContextFacade@bb8cbf0</span></span><br><span class="line">        out.print(<span class="string">&quot;&lt;br&gt;&quot;</span>+application);</span><br><span class="line">        <span class="comment">//第二种:通过this来获取ServletContext对象，注意:this必须是继承GenericServlet</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application2</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">//org.apache.catalina.core.ApplicationContextFacade@bb8cbf0</span></span><br><span class="line">        out.print(<span class="string">&quot;&lt;br&gt;&quot;</span>+application2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识ServletConfig&quot;&gt;&lt;a href=&quot;#初识ServletConfig&quot; class=&quot;headerlink&quot; title=&quot;初识ServletConfig&quot;&gt;&lt;/a&gt;初识ServletConfig&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS常用正则表达式大全</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/JS%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/JS%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/</id>
    <published>2022-10-16T14:58:31.000Z</published>
    <updated>2022-10-16T15:05:02.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS常用正则表达式大全"><a href="#JS常用正则表达式大全" class="headerlink" title="JS常用正则表达式大全"></a>JS常用正则表达式大全</h1><h2 id="JavaScript中使用正则表达式"><a href="#JavaScript中使用正则表达式" class="headerlink" title="JavaScript中使用正则表达式"></a>JavaScript中使用<a href="https://so.csdn.net/so/search?q=正则表达式&amp;spm=1001.2101.3001.7020">正则表达式</a></h2><hr><ol><li><strong>使用直接量写法</strong><br>以斜杆表示开始和结束：<code>var regex = /^[a-zA-Z]+$/;</code>，创建一个内容为<code>^[a-zA-Z]+$</code>的正则表达式，验证英文字母</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;str&quot;</span>).<span class="property">value</span>.<span class="title function_">trim</span>();<span class="comment">//获取指定id的内容，去除空格</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z]+$/</span>; <span class="comment">// 直接量正则表达式</span></span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的英文字母!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>2.使用内置构造函数生成</strong><br>通过实例化得到对象：<code>var regex = new RegExp(&#39;^[a-zA-Z]+$&#39;);</code>，创建一个内容为<code>^[a-zA-Z]+$</code>的正则表达式，验证英文字母，等价于上面直接量方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;str&quot;</span>).<span class="property">value</span>.<span class="title function_">trim</span>();<span class="comment">//获取指定id的内容，去除空格</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^[a-zA-Z]+$&#x27;</span>); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的英文字母!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>3. 下面是JS常用正则表达式</strong></p><p>JS验证代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证帮助</span></span><br><span class="line"><span class="keyword">var</span> verifyUtils = &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证输入的内容是否是空</span></span><br><span class="line"><span class="attr">isNull</span>:<span class="keyword">function</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\S/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;文本框不能为空，请输入内容！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证输入的字符是否是英文字母</span></span><br><span class="line"><span class="attr">isLetter</span>:<span class="keyword">function</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z]+$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的英文字母!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  验证日期格式是否为YYYY-MM-DD格式</span></span><br><span class="line">&#125;,<span class="attr">isDate</span>:<span class="keyword">function</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/</span>;</span><br><span class="line"><span class="keyword">var</span> r = str.<span class="title function_">match</span>(regex); <span class="comment">// 使用match方法获取指定字符串的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的日期格式!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  验证日期格式是否为YYYY-MM-DD hh:mm:ss格式</span></span><br><span class="line">&#125;,<span class="attr">isDateTime</span>:<span class="keyword">function</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;) (\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/</span>;</span><br><span class="line"><span class="keyword">var</span> r = str.<span class="title function_">match</span>(regex); <span class="comment">// 使用match方法获取指定字符串的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r==<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的日期格式!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证整数</span></span><br><span class="line">&#125;,<span class="attr">isInteger</span>:<span class="keyword">function</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[-+]?\d*$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的整数!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证双精度</span></span><br><span class="line">&#125;,<span class="attr">isDouble</span>:<span class="keyword">function</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[-\+]?\d+(\.\d+)?$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的小数!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证中文</span></span><br><span class="line">&#125;,<span class="title function_">isChinese</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[\u0391-\uFFE5]+$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的中文!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证邮箱</span></span><br><span class="line">&#125;,<span class="title function_">isEmail</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的邮箱格式!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证手机号</span></span><br><span class="line">&#125;,<span class="title function_">isPhone</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[3456789]\d&#123;9&#125;$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的手机号!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证身份证</span></span><br><span class="line">&#125;,<span class="title function_">isIdCard</span>(<span class="params">idStr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(idStr).<span class="property">value</span>.<span class="title function_">trim</span>();</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/</span>;</span><br><span class="line"><span class="keyword">if</span>(!regex.<span class="title function_">test</span>(str))&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;请输入正确的身份证号码!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>正则验证代码如下：</strong><br>验证字母：<code>/^[a-zA-Z]+$/</code><br>验证长度为3的字符：<code>/^.&#123;3&#125;$/</code><br>验证由26个英文字母组成的字符串：<code>/^[A-Za-z]+$/</code><br>验证日期YYYY-MM-DD：<code>/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/</code><br>验证邮编：<code>/^\d&#123;6&#125;$/</code><br>验证日期格式YYYY-MM-DD hh:mm:ss：<code>/^(\d&#123;1,4&#125;)(-|\/)(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;) (\d&#123;1,2&#125;):(\d&#123;1,2&#125;):(\d&#123;1,2&#125;)$/</code><br>验证整数：<code>/^[-+]?\d*$/</code><br>验证小数：<code>/^[-\+]?\d+(\.\d+)?$/</code><br>验证中文：<code>/^[\u0391-\uFFE5]+$/</code><br>验证邮箱：<code>/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/</code><br>验证手机号：<code>/^1[3456789]\d&#123;9&#125;$/</code><br>验证身份证：<code>/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/</code></p><p><strong>表达式分析：</strong><br>“/”代表一个正则表达式；<br>“^”代表字符串的开始位置，“$”代表字符串的结束位置；<br>“?”代表匹配前面的字符一个或零个，所以这里0?的意思是手机号码可以以0开头或不以0开头。<br>那里写的不对可以指出，如果你有更好的方式，可以一起讨论，希望可以帮助到大家，也可以加qq群：1007307899</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS常用正则表达式大全&quot;&gt;&lt;a href=&quot;#JS常用正则表达式大全&quot; class=&quot;headerlink&quot; title=&quot;JS常用正则表达式大全&quot;&gt;&lt;/a&gt;JS常用正则表达式大全&lt;/h1&gt;&lt;h2 id=&quot;JavaScript中使用正则表达式&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Get请求和Post请求的区别</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Get%E8%AF%B7%E6%B1%82%E5%92%8CPost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/Get%E8%AF%B7%E6%B1%82%E5%92%8CPost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-10-16T14:57:55.000Z</published>
    <updated>2022-10-16T15:05:02.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Get请求和Post请求的区别"><a href="#Get请求和Post请求的区别" class="headerlink" title="Get请求和Post请求的区别"></a>Get请求和Post请求的区别</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始</strong>  —————</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h1 id="什么是协议？"><a href="#什么是协议？" class="headerlink" title="什么是协议？"></a>什么是协议？</h1><ul><li><p>协议实际上是某些人，或者某些组织提前制定好的一套规范，大家都按照这个规范来，这样可以做到沟通无障碍。</p></li><li><p>协议就是一套规范，就是一套标准。由其他人或其他组织来负责制定的。</p></li><li><p>我说的话你能听懂，你说的话，我也能听懂，这说明我们之间是有一套规范的，一套协议的，这套协议就是：中国普通话协议。我们都遵守这套协议，我们之间就可以沟通无障碍。<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220823231411702.png" alt="image-20220823231411702" style="zoom: 80%;" /></p><h1 id="什么是HTTP协议？"><a href="#什么是HTTP协议？" class="headerlink" title="什么是HTTP协议？"></a>什么是HTTP协议？</h1></li><li><p>HTTP协议：是W3C制定的一种超文本传输协议。（<a href="https://so.csdn.net/so/search?q=通信协议&amp;spm=1001.2101.3001.7020">通信协议</a>：发送消息的模板提前被制定好。）</p></li><li><p>W3C：</p><ul><li>万维网联盟组织</li><li>负责制定标准的：HTTP HTML4.0 HTML5 XML DOM等规范都是W3C制定的。</li><li>万维网之父：<font color='skyblue'>蒂姆·伯纳斯·李</font></li></ul></li><li><p>什么是超文本？</p><ul><li>超文本说的就是：不是普通文本，比如流媒体：声音、视频、图片等。</li><li>HTTP协议支持：不但可以传送普通字符串，同样支持传递声音、视频、图片等流媒体信息。</li></ul></li><li><p>这种协议游走在B和S之间。B向S发数据要遵循HTTP协议。S向B发数据同样需要遵循HTTP协议。这样B和S才能解耦合。</p></li><li><p>什么是解耦合？</p><ul><li>B不依赖S。</li><li>S也不依赖B。</li><li>耦合是对象之间有依赖关系，减少耦合，可以扩展软件功能</li></ul></li><li><p>B/S表示：B/S结构的系统（浏览器访问WEB服务器的系统）</p></li><li><p>浏览器 向 WEB服务器发送数据，叫做：请求（request)</p></li><li><p>WEB服务器 向 浏览器发送数据，叫做：响应（response）</p></li><li><p>HTTP协议包括：</p><ul><li>请求协议<ul><li>浏览器 向 WEB服务器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。</li></ul></li><li>响应协议<ul><li>WEB服务器 向 浏览器发送数据的时候，这个发送的数据需要遵循一套标准，这套标准中规定了发送的数据具体格式。</li></ul></li></ul></li><li><p>HTTP协议就是提前制定好的一种消息模板。</p><ul><li>不管你是哪个品牌的浏览器，都是这么发。</li><li>不管你是哪个品牌的WEB服务器，都是这么发。</li><li>FF浏览器 可以向 Tomcat发送请求，也可以向Jetty服务器发送请求。浏览器不依赖具体的服务器品牌。</li><li>WEB服务器也不依赖具体的浏览器品牌。可以是FF浏览器，也可以是Chrome浏览器，可以是IE，都行。</li></ul></li><li><p>HTTP的请求协议（B —&gt; S）</p></li><li><p>HTTP的请求协议包括：4部分</p><p>- 请求行<br>- 请求头<br>- 空白行<br>- 请求体</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822231613359.png" alt="image-20220822231613359"></p></li><li><p>HTTP请求协议的具体报文：GET请求</p></li></ul><blockquote><p>GET /servlet05/getServlet?username=lucy&amp;userpwd=1111 HTTP/1.1 请求行<br>Host: localhost:8080 请求头<br>Connection: keep-alive<br>sec-ch-ua: “Google Chrome”;v=“95”, “Chromium”;v=“95”, “;Not A Brand”;v=“99”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “Windows”<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54</p><p>Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Sec-Fetch-Site: same-origin<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Referer: <a href="http://localhost:8080/servlet05/index.html">http://localhost:8080/servlet05/index.html</a><br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9</p></blockquote><p>空白行<br>请求体</p><ul><li><p>HTTP请求协议的具体报文：POST请求</p><blockquote><p>POST /servlet05/postServlet HTTP/1.1 请求行<br>Host: localhost:8080 请求头<br>Connection: keep-alive<br>Content-Length: 25<br>Cache-Control: max-age=0<br>sec-ch-ua: “Google Chrome”;v=“95”, “Chromium”;v=“95”, “;Not A Brand”;v=“99”<br>sec-ch-ua-mobile: ?0<br>sec-ch-ua-platform: “Windows”<br>Upgrade-Insecure-Requests: 1<br>Origin: <a href="http://localhost:8080">http://localhost:8080</a><br>Content-Type: application/x-www-form-urlencoded<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Sec-Fetch-Site: same-origin<br>Sec-Fetch-Mode: navigate<br>Sec-Fetch-User: ?1<br>Sec-Fetch-Dest: document<br>Referer: <a href="http://localhost:8080/servlet05/index.html">http://localhost:8080/servlet05/index.html</a><br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=0.9</p></blockquote><p>空白行<br>username=lisi&amp;userpwd=123 请求体</p><ul><li>请求行<ul><li>包括三部分：<ul><li>第一部分：请求方式（7种）<ul><li>get（常用的）</li><li>post（常用的）</li><li>delete</li><li>put</li><li>head</li><li>options</li><li>trace</li></ul></li><li>第二部分：URI<ul><li>什么是URI？ 统一资源标识符。代表网络中某个资源的名字。但是通过URI是无法定位资源的。</li><li>什么是URL？统一资源定位符。代表网络中某个资源，同时，通过URL是可以定位到该资源的。</li><li>URI和URL什么关系，有什么区别？<ul><li>URL包括URI</li><li><a href="http://localhost:8080/servlet05/index.html">http://localhost:8080/servlet05/index.html</a> 这是URL。</li><li>/servlet05/index.html 这是URI。</li></ul></li></ul></li><li>第三部分：HTTP协议版本号</li></ul></li></ul></li><li>请求头<ul><li>请求的主机</li><li>主机的端口</li><li>浏览器信息</li><li>平台信息</li><li>cookie等信息</li><li>…</li></ul></li><li>空白行<ul><li>空白行是用来区分“请求头”和“请求体”</li></ul></li><li>请求体<ul><li>向服务器发送的具体数据。</li></ul></li></ul></li><li><p>HTTP的响应协议（S —&gt; B）</p><ul><li><p>HTTP的响应协议包括：4部分</p><ul><li>状态行</li><li>响应头</li><li>空白行</li><li>响应体</li></ul></li><li><p>HTTP响应协议的具体报文：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok                                     状态行</span><br><span class="line">Content-Type: text/html;charset=UTF-8               响应头</span><br><span class="line">Content-Length: 160</span><br><span class="line">Date: Mon, 08 Nov 2021 13:19:32 GMT</span><br><span class="line">Keep-Alive: timeout=20</span><br><span class="line">Connection: keep-alive</span><br><span class="line">                                                    空白行</span><br><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span>                                     响应体</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>from get servlet<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>from get servlet<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>状态行</p><ul><li>三部分组成<ul><li>第一部分：协议版本号（HTTP/1.1）</li><li>第二部分：状态码（HTTP协议中规定的响应状态号。不同的响应结果对应不同的号码。）<ul><li>200 表示请求响应成功，正常结束。</li><li>404表示访问的资源不存在，通常是因为要么是你路径写错了，要么是路径写对了，但是服务器中对应的资源并没有启动成功。总之404错误是前端错误。</li><li>405表示前端发送的请求方式与后端请求的处理方式不一致时发生：<ul><li>比如：前端是POST请求，后端的处理方式按照get方式进行处理时，发生405</li><li>比如：前端是GET请求，后端的处理方式按照post方式进行处理时，发生405</li></ul></li><li>500表示服务器端的程序出现了异常。一般会认为是服务器端的错误导致的。</li><li>以4开始的，一般是浏览器端的错误导致的。</li><li>以5开始的，一般是服务器端的错误导致的。</li></ul></li><li>第三部分：状态的描述信息<ul><li>ok 表示正常成功结束。</li><li>not found 表示资源找不到。</li></ul></li></ul></li></ul></li><li><p>响应头：</p><ul><li>响应的内容类型</li><li>响应的内容长度</li><li>响应的时间</li><li>…</li></ul></li><li><p>空白行：</p><ul><li>用来分隔“响应头”和“响应体”的。</li></ul></li><li><p>响应体：</p><ul><li>响应体就是响应的正文，这些内容是一个长的字符串，这个字符串被浏览器渲染，解释并执行，最终展示出效果。</li></ul></li></ul><ul><li><p>怎么查看的协议内容？</p><ul><li>使用chrome浏览器：F12。然后找到network，通过这个面板可以查看协议的具体内容。</li></ul></li><li><p>怎么向服务器发送GET请求，怎么向服务器发送POST请求？</p><ul><li>到目前为止，只有一种情况可以发送POST请求：使用form表单，并且form标签中的method属性值为：method=“post”。</li><li>其他所有情况一律都是get请求：<ul><li>在浏览器地址栏上直接输入URL，敲回车，属于get请求。</li><li>在浏览器上直接点击超链接，属于get请求。</li><li>使用form表单提交数据时，form标签中没有写method属性，默认就是get</li><li>或者使用form的时候，form标签中method属性值为：method=“get”</li><li>…</li></ul></li></ul></li></ul><h1 id="HTTP协议的特点"><a href="#HTTP协议的特点" class="headerlink" title="HTTP协议的特点"></a>HTTP协议的特点</h1><p>1.简单快速:客户向服务器请求服务的时候，只需要传送请求方法和路径，请求方法一般是get和post，因为HTTP协议简单，所以HTTP服务器的程序规模小，通信速度快。<br>2.灵活：HTTP协议运行传输任意类型的数据对象，传输的类型由Content-Type标记<br>3.无连接:客户端向服务端发送一次请求，服务端接收后，连接就断开了，无连接表示每一次连接都只处理一个请求，这种方式可以节省传输时间.<br>举个例子：你打电话给朋友说让他帮忙买一瓶水，然后就把电话挂掉了，这个时候，想到说还要麻烦朋友做什么事情，就再打电话过去。<br>HTTP1.1版本以后，支持可连续连接，通过这种连接就有可能在建立一个TCP连接后，发送请求并得到回应，然后接着发送请求并得到回应。通过建立和释放TCP连接的开销分摊到多个请求，对每一个请求来说，因为TCO造成的相对开销被大大降低了，而且还可以发送流水线请求，就是说在发送请求1之后，在回应到来之前就可以发送请求2.</p><p>4.无状态。HTTP协议是无状态协议，无状态指的是对事务处理没有记忆能力，如果后面想要处理之前的信息的话，就必须重传，这样会导致每一次连接传送的数据量增大</p><h1 id="GET请求和POST请求有什么区别？"><a href="#GET请求和POST请求有什么区别？" class="headerlink" title="GET请求和POST请求有什么区别？"></a>GET请求和POST请求有什么区别？</h1><ul><li>get请求发送数据的时候，数据会挂在URI的后面，并且在URI后面添加一个“?”，”?”后面是数据。这样会导致发送的数据回显在浏览器的地址栏上。（get请求在“请求行”上发送数据）<ul><li><a href="http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111">http://localhost:8080/servlet05/getServlet?username=zhangsan&amp;userpwd=1111</a></li></ul></li><li>post请求发送数据的时候，在请求体当中发送。不会回显到浏览器的地址栏上。也就是说post发送的数据，在浏览器地址栏上看不到。（post在“请求体”当中发送数据）</li><li>get请求只能发送普通的字符串。并且发送的字符串长度有限制，不同的浏览器限制不同。这个没有明确的规范。</li><li>get请求无法发送大数据量。</li><li>post请求可以发送任何类型的数据，包括普通字符串，流媒体等信息：视频、声音、图片。</li><li>post请求可以发送大数据量，理论上没有长度限制。</li><li>get请求在W3C中是这样说的：get请求比较适合从服务器端获取数据。</li><li>post请求在W3C中是这样说的：post请求比较适合向服务器端传送数据。<br>可能好多人，一看到说get请求会把内容显示在地址栏上，就是不安全的<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822231731100.png" alt="image-20220822231731100"></li><li>get请求是安全的。get 请求是绝对安全的。为什么？因为get请求只是为了从服务器上获取数据。不会对服务器造成威胁。（get本身是安全的，你不要用错了。用错了之后又冤枉人家get不安全，你这样不好（太坏了），那是你自己的问题，不是get请求的问题。）</li><li>post请求是危险的。为什么？因为post请求是向服务器提交数据，如果这些数据通过后门的方式进入到服务器当中，服务器是很危险的。另外post是为了提交数据，所以一般情况下拦截请求的时候，大部分会选择拦截（监听）post请求。</li><li>注意:我这里说的安全是相对而言，事实上它们都不安全，比如get请求，会把数据显示在url上，但是我们要正确使用就不会出现这种问题。post请求则比较危险。</li><li>get请求支持缓存。<ul><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg">https://n.sinaimg.cn/finance/590/w240h350/20211101/b40c-b425eb67cabc342ff5b9dc018b4b00cc.jpg</a></li><li>任何一个get请求最终的“响应结果”都会被浏览器缓存起来。在浏览器缓存当中：</li><li>一个get请求的路径a 对应 一个资源。</li><li>一个get请求的路径b 对应 一个资源。</li><li>一个get请求的路径c 对应 一个资源。</li><li>…<br>- 实际上，你只要发送get请求，浏览器做的第一件事都是先从本地浏览器缓存中找，找不到的时候才会去服务器上获取。这种缓存机制目的是为了提高用户的体验。</li><li>有没有这样一个需求：我们不希望get请求走缓存，怎么办？怎么避免走缓存？我希望每一次这个get请求都去服务器上找资源，我不想从本地浏览器的缓存中取。</li><li>只要每一次get请求的请求路径不同即可。</li><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897898</a></li><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=789789787897899</a></li><li><a href="https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数">https://n.sinaimg.cn/finance/590/w240h350/20211101/7cabc342ff5b9dc018b4b00cc.jpg?t=系统毫秒数</a></li><li>怎么解决？可以在路径的后面添加一个每时每刻都在变化的“时间戳”，这样，每一次的请求路径都不一样，浏览器就不走缓存了。</li></ul></li><li>post请求不支持缓存。（POST是用来修改服务器端的资源的。）<ul><li>post请求之后，服务器“响应的结果”不会被浏览器缓存起来。因为这个缓存没有意义。</li></ul></li><li>GET请求和POST请求如何选择，什么时候使用GET请求，什么时候使用POST请求？</li><li>怎么选择GET请求和POST请求呢？衡量标准是什么呢？你这个请求是想获取服务器端的数据，还是想向服务器发送数据。如果你是想从服务器上获取资源，建议使用GET请求，如果你这个请求是为了向服务器提交数据，建议使用POST请求。</li><li>大部分的form表单提交，都是post方式，因为form表单中要填写大量的数据，这些数据是收集用户的信息，一般是需要传给服务器，服务器将这些数据保存/修改等。</li><li>如果表单中有敏感信息，还是建议适用post请求，因为get请求会回显敏感信息到浏览器地址栏上。（例如：密码信息）</li><li><strong>做文件上传，一定是post请求。要传的数据不是普通文本。</strong></li><li>其他情况都可以使用get请求。</li><li>不管你是get请求还是post请求，发送的请求数据格式是完全相同的，只不过位置不同，格式都是统一的：<ul><li>name=value&amp;name=value&amp;name=value&amp;name=value</li><li>name是什么？<ul><li>以form表单为例：form表单中input标签的name。</li></ul></li><li>value是什么？<ul><li>以form表单为例：form表单中input标签的value。</li></ul></li></ul></li></ul><h1 id="总结get和post"><a href="#总结get和post" class="headerlink" title="总结get和post"></a>总结get和post</h1><p>啰嗦一句，不要主观臆断。大家可能都会有这样的主观错误，认为get请求会把信息显示在地址栏，所以就是不安全，post就是安全的。我觉得这是一种常见的误区。其实这种安全只是相对的</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822231423610.png" alt="image-20220822231423610" style="zoom: 50%;" /><br>这个表格是从<code>W3cschool</code> 截取的</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220822231446203.png" alt="image-20220822231446203"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Get请求和Post请求的区别&quot;&gt;&lt;a href=&quot;#Get请求和Post请求的区别&quot; class=&quot;headerlink&quot; title=&quot;Get请求和Post请求的区别&quot;&gt;&lt;/a&gt;Get请求和Post请求的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主</summary>
      
    
    
    
    <category term="Web网页技术" scheme="https://manamn.space/categories/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
    <category term="Web网页技术" scheme="https://manamn.space/tags/Web%E7%BD%91%E9%A1%B5%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据库三大范式、ER图与实体类、外键约束与级联操作</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E3%80%81ER%E5%9B%BE%E4%B8%8E%E5%AE%9E%E4%BD%93%E7%B1%BB%E3%80%81%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E4%B8%8E%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E3%80%81ER%E5%9B%BE%E4%B8%8E%E5%AE%9E%E4%BD%93%E7%B1%BB%E3%80%81%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E4%B8%8E%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C/</id>
    <published>2022-10-16T14:52:17.000Z</published>
    <updated>2022-10-16T14:55:58.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库三大范式、ER图与实体类、外键约束与级联操作"><a href="#数据库三大范式、ER图与实体类、外键约束与级联操作" class="headerlink" title="数据库三大范式、ER图与实体类、外键约束与级联操作"></a>数据库三大范式、ER图与实体类、外键约束与级联操作</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h1 id="1-数据库三大范式🙊"><a href="#1-数据库三大范式🙊" class="headerlink" title="1. 数据库三大范式🙊"></a>1. 数据库三大范式🙊</h1><h2 id="1）范式"><a href="#1）范式" class="headerlink" title="1）范式"></a>1）范式</h2><ul><li><p>必须保证数据库设计的合理性</p><ul><li>数据库设计关系整个系统的架构，关系到后续开发效率和运行效率</li><li>数据库的设计主要包含了设计表结构和表之间的联系</li></ul></li><li><p>什么是合理的数据库 ？</p><ul><li>结构合理</li><li>冗余较小</li><li>尽量避免插入删除时修改异常</li></ul></li></ul><p>如何才能保证数据库设计水平</p><p>​          遵循一定的规则</p><p>​           在关系型数据库中这种规则就称为 <strong>范式</strong>。</p><p>• 什么是范式（NF= NormalForm）</p><p>​           范式是符合某一种设计要求的总结。</p><p>​           要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><h2 id="2）范式分类"><a href="#2）范式分类" class="headerlink" title="2）范式分类"></a>2）范式分类</h2><ul><li><p>第一范式</p><p>• 第二范式</p><p>• 第三范式</p><p>​         • 各个范式是依次嵌套包含的</p><p>​         • 范式越高，设计质量越高，在现实设计中也越难实现</p><p>​         • 一般数据库设计，只要达到第三范式，即可避免异常的出现 </p></li></ul><h2 id="3）第一范式"><a href="#3）第一范式" class="headerlink" title="3）第一范式"></a>3）第一范式</h2><ul><li><p>要求    </p><ul><li>最基本的范式</li><li><font color='red'>第一范式要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值</font></li><li>简单来说就是要确保数据的原子性。</li><li>第一范式的合理遵循需要根据系统的实际需求来定</li></ul><p>• 示例</p><ul><li>用户表（用户名，家庭地址）</li><li>用户表（用户名，省，城市，详细地址）</li><li>系（系名称，系主任，系高级职 称人数）</li><li>系（系名称，系主任，系教授人数，系副教授人数） </li></ul></li><li><p>比方说学生信息：</p><p>| 字段名 | 值   | 字段名 | 值   | 字段名 | 值   | 字段名   | 值           |<br>| ——— | —— | ——— | —— | ——— | —— | ———— | —————— |<br>| 姓名   | 张三 | 性别   | 男   | 民族   | 汉   | 出生日期 | 2000年x月x日 |</p></li></ul><p>  又比方说用户地址栏，一般情况下我们用一个varchar列来表示，其中值如下</p><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>家庭住址</td><td>湖北省武汉市武昌区某某街某某号</td></tr></tbody></table></div><p>  如果有相应的业务要求，这个字段就可以按第一范式进行拆分，这样在针对地址进行检索时更加精确方便</p><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>省份</td><td>湖北省</td><td>地市</td><td>武汉市</td><td>区名</td><td>武昌区</td><td>街道名</td><td>某某街道</td></tr></tbody></table></div><ul><li><p><strong>若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。</strong></p><p>比如：学生选课</p><p>张三选了计算机、高数、英语三门课。使用一个字段存放，这就违反了范式。</p></li></ul><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>姓名</td><td>张三</td><td>成绩</td><td>计算机80，英语90，高数70</td></tr></tbody></table></div><p>  应该设计学生选课表，并对学生信息表产生1对多的关联</p><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>学生编号</td><td>123</td><td>学生姓名</td><td>张三</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>学科编号</td><td>s1</td><td>学科名称</td><td>计算机</td></tr><tr><td>学科编号</td><td>s2</td><td>学科名称</td><td>英语</td></tr><tr><td>学科编号</td><td>s3</td><td>学科名称</td><td>高数</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th><th>字段名</th><th></th></tr></thead><tbody><tr><td>学生编号</td><td>123</td><td>学科编号</td><td>s1</td><td>成绩</td><td>80</td></tr><tr><td>学生编号</td><td>123</td><td>学科编号</td><td>s2</td><td>成绩</td><td>90</td></tr><tr><td>学生编号</td><td>123</td><td>学科编号</td><td>s3</td><td>成绩</td><td>70</td></tr></tbody></table></div><ul><li>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</li></ul><h2 id="4）第二范式"><a href="#4）第二范式" class="headerlink" title="4）第二范式"></a>4）第二范式</h2><ul><li>要求<ul><li><font color='red'>第二范式需要确保数据库表中的每一列都和主键相关，而不能只有一部分和主键相关（主要针对联合主键而言）。</font></li><li>即在一个数据库表中只能保存一种数据，不可以把多种数据保存到同一张表中。</li></ul></li><li>实例<ul><li>学号和课程编号作为联合主键</li><li><font color='red'>课程名称只依赖于课程编号，而和学号没有关系</font></li></ul></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps16.jpg" alt=""></p><p> 解决</p><ul><li>提取出学生表</li><li>提取成课程表</li><li>提取选课表，存放选课记录</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/wps16.jpg" alt="img"> </p><p>​       学生表                                选课表                                        课程表</p><h2 id="5）第三范式"><a href="#5）第三范式" class="headerlink" title="5）第三范式"></a>5）第三范式</h2><ul><li><p>要求</p><ul><li><font color = 'red'>第三范式确保数据表中的每一列数据都与主键相关，而不能间接相关。</font></li><li><font color = 'red'>属性不依赖其他非主属性.</font></li></ul></li></ul><p><strong>示例1：学生班级表</strong> </p><div class="table-container"><table><thead><tr><th>学号(主键)</th><th>学生姓名</th><th>班级编号</th><th>班级名称</th><th>班级信息</th></tr></thead><tbody><tr><td>023145</td><td>张三</td><td>987654</td><td>3班</td><td>特招班</td></tr><tr><td>023146</td><td>李四</td><td>987654</td><td>3班</td><td>特招班</td></tr><tr><td>023147</td><td>王五</td><td>987655</td><td>4班</td><td>普通班</td></tr><tr><td>023258</td><td>赵六</td><td>987654</td><td>3班</td><td>特招班</td></tr></tbody></table></div><p><strong>完善之后的方案：</strong></p><div class="table-container"><table><thead><tr><th>学号(主键)</th><th>学生姓名</th><th>班级编号</th></tr></thead><tbody><tr><td>023145</td><td>张三</td><td>987654</td></tr><tr><td>023146</td><td>李四</td><td>987654</td></tr><tr><td>023147</td><td>王五</td><td>987655</td></tr><tr><td>023258</td><td>赵六</td><td>987654</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>班级编号(主键)</th><th>班级名称</th><th>班级信息</th></tr></thead><tbody><tr><td>987654</td><td>3班</td><td>特招班</td></tr><tr><td>987655</td><td>4班</td><td>普通班</td></tr></tbody></table></div><p>​    示例2: 订单明细表</p><div class="table-container"><table><thead><tr><th>编号(主键)</th><th>图书id</th><th>图书名称</th><th>价格</th><th>作者</th><th>出版社</th><th>出版日期</th><th>数量</th></tr></thead><tbody><tr><td>023145</td><td>1</td><td>精通Java</td><td>60.00</td><td>张三</td><td>清华出版社</td><td>2007</td><td>1</td></tr><tr><td>023146</td><td>2</td><td>Oracle</td><td>65.00</td><td>李四</td><td>机械出版社</td><td>2009</td><td>1</td></tr><tr><td>023147</td><td>3</td><td>JSP</td><td>87</td><td>王五</td><td>电子出版社</td><td>2014</td><td>3</td></tr><tr><td>023258</td><td>1</td><td>精通Java</td><td>60.00</td><td>张三</td><td>清华出版社</td><td>2007</td><td>2</td></tr><tr><td>023259</td><td>2</td><td>Oracle</td><td>65.00</td><td>李四</td><td>机械出版社</td><td>2009</td><td>3</td></tr></tbody></table></div><p><strong>完善之后的方案：分割成图书表和订单表两种表</strong></p><div class="table-container"><table><thead><tr><th>图书id</th><th>图书名称</th><th>价格</th><th>作者</th><th>出版社</th><th>出版日期</th></tr></thead><tbody><tr><td>1</td><td>精通Java</td><td>60.00</td><td>张三</td><td>清华出版社</td><td>2007</td></tr><tr><td>2</td><td>Oracle</td><td>65.00</td><td>李四</td><td>机械出版社</td><td>2009</td></tr><tr><td>3</td><td>JSP</td><td>87</td><td>王五</td><td>电子出版社</td><td>2014</td></tr><tr><td>4</td><td>Struts2</td><td>56</td><td>赵六</td><td>清华出版社</td><td>2005</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>编号(主键)</th><th>图书id</th><th>数量</th></tr></thead><tbody><tr><td>023145</td><td>1</td><td>1</td></tr><tr><td>023146</td><td>2</td><td>1</td></tr><tr><td>023147</td><td>3</td><td>3</td></tr><tr><td>023258</td><td>2</td><td>2</td></tr><tr><td>023259</td><td>2</td><td>3</td></tr></tbody></table></div><h2 id="6）范式的优缺点"><a href="#6）范式的优缺点" class="headerlink" title="6）范式的优缺点"></a>6）范式的优缺点</h2><p> 优点</p><ul><li>结构合理</li><li>冗余较小</li><li>尽量避免插入删除修改异常</li></ul><p>• 缺点</p><ul><li>性能降低</li><li>多表查询比单表查询速度慢</li><li>数据库的设计应该根据当前情况和需求做出灵活的处理。</li><li>在实际设计中，要整体遵循范式理论。</li><li>如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时<strong>可以适当增加冗余而提高性能。</strong></li></ul><p>• 示例：</p><p>​      比如经常购物车条目的中除了条目编号，商品编号，商品数量外，可以增加经常使用的商品名称，商品价格等</p><p>图书表</p><div class="table-container"><table><thead><tr><th>图书id</th><th>图书名称</th><th>价格</th><th>作者</th><th>出版社</th><th>出版日期</th></tr></thead><tbody><tr><td>1</td><td>精通Java</td><td>60</td><td>张三</td><td>清华出版社</td><td>2007</td></tr><tr><td>2</td><td>Oracle宝典</td><td>65</td><td>李四</td><td>机械出版社</td><td>2009</td></tr><tr><td>3</td><td>JSP</td><td>87</td><td>王五</td><td>电子出版社</td><td>2014</td></tr><tr><td>4</td><td>Struts2</td><td>56</td><td>赵六</td><td>清华出版社</td><td>2005</td></tr></tbody></table></div><p>订单表中增加冗余列图书名称、价格，以空间换时间。</p><div class="table-container"><table><thead><tr><th>编号(主键)</th><th>图书id</th><th>图书名称</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>023145</td><td>1</td><td>精通Java</td><td>60</td><td>1</td></tr><tr><td>023146</td><td>2</td><td>Oracle宝典</td><td>65</td><td>1</td></tr><tr><td>023147</td><td>3</td><td>JSP</td><td>87</td><td>3</td></tr><tr><td>023258</td><td>1</td><td>精通Java</td><td>60</td><td>2</td></tr></tbody></table></div><h2 id="7）总结"><a href="#7）总结" class="headerlink" title="7）总结"></a>7）总结</h2><ul><li>范式是指导数据库设计的规范化原则，可以保证数据库的设计质量。</li><li><font color = 'red'>第一范式 ： 字段不能再分。</font></li><li><font color = 'red'>第二范式 ： 不存在局部依赖（要和主键相关）。</font></li><li><font color = 'red'>第三范式： 不包含传递依赖（间接依赖）。</font></li><li>使用范式可以减少冗余，但是会降低性能。</li><li>特定的表可以违反第三范式，但是可以增加其性能。</li></ul><h1 id="2-ER图与实体🍢"><a href="#2-ER图与实体🍢" class="headerlink" title="2. ER图与实体🍢"></a>2. ER图与实体🍢</h1><blockquote><p>ER图是我们建立概念数据模型的工具<br>​        数据模型是现实世界中数据特征的抽象。数据模型应该满足三个方面的要求：<br>​                01 能够比较真实地模拟现实世界<br>​                02 容易为人所理解<br>​                03 便于计算机实现</p></blockquote><p>​        概念数据模型也称信息模型，它以实体－联系(<strong>Entity-RelationShip</strong>,简称E-R)理论为基础，并对这一理论进行了扩充。它从用户的观点出发对信息进行建模，主要用于数据库的概念级设计。    </p><h4 id="ER图图例"><a href="#ER图图例" class="headerlink" title="ER图图例"></a>ER图图例</h4><p>​        ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。</p><p>​        ER图的<strong>实体（entity）</strong>即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。</p><p>​        ER图的<strong>属性（attribute）</strong>即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</p><p>​        ER图的<strong>关系（relationship）</strong>用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系。</p><p>​        ER图中关联关系有三种：</p><p>​        <strong>1对1（1:1）</strong> ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p><p>​        <strong>1对多（1:N）</strong> ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p><p>​        <strong>多对多（M:N）</strong> ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20170101154040319.png" alt="img">ER的实        实体还会细分为<strong>弱实体</strong>和<strong>强实体</strong>：</p><p>​        弱实体：一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如上图的学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20170101211800859.png" alt="img"></p><p>​        弱实体和强实体的联系必然只有1：N或者1：1，这是由于弱实体完全依赖于强实体，强实体不存在，那么弱实体就不存在，所以弱实体是完全参与联系的，因此弱实体与联系之间的联系也是用的双线菱形。</p><p>​        <strong>复合实体：</strong>复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示。</p><p>​        下图就是一个典型的复合实体，因为只是举例，相对粗糙，用户和商品两个实体是M：N的关系，中间又订单这个实体联系，因此订单这个实体是一个复合实体，同时如果用户 实体不存在，就没有订单实体的存在，因此对于用户实体来讲订单是弱实体，同理商品实体如果不存在，同样不存在订单实体，因此对商品实体而言订单是弱实体，具体如图：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20170101220128826.png" alt="img"></p><h4 id="ER物理模型与数据建模"><a href="#ER物理模型与数据建模" class="headerlink" title="ER物理模型与数据建模"></a>ER物理模型与数据建模</h4><p>​        上面说的原生ER图，主要用于模型分析，实际上我们更常用的ER图的物理模型。</p><p>​        这里是一个在线免费ER图绘制网站，<a href="https://www.freedgo.com/erd-index.html，我们用这个工具来讲解一下ER图的分析绘制、及导出成SQL的过程。">https://www.freedgo.com/erd-index.html，我们用这个工具来讲解一下ER图的分析绘制、及导出成SQL的过程。</a></p><p>​        进入页面，可以点击“格式”按钮，展现图例菜单。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200312040016715.png" alt="image-20200312040016715"></p><p>​        我们可以选择实体关系/MySQL下的图标来完成学生班级课程模型模型。</p><h5 id="建立学生表模型"><a href="#建立学生表模型" class="headerlink" title="建立学生表模型"></a>建立学生表模型</h5><p>​        表名：student</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>s_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>s_name</td><td>varchar（20）</td><td>学生姓名</td></tr><tr><td>s_code</td><td>varchar(20)</td><td>学号</td></tr></tbody></table></div><p>点击对应的表图标，将之拖入到主体图纸上。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/MA3HJ8B9N45AK0Y_ZVR5R.png" alt="img"></p><p>双击表头“MySQL Table”，可以编辑表名。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/T%7D%5DO$QJN%60AJH@Q29JIT9K5J.png" alt="img"></p><p>在字段上点击右键，选“列修改”，可以设置列属性。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/0%7BUUGFSL$M6U1AHY1%5D%5D6ON.png" alt="img" style="zoom:67%;" /></p><p>改成以下样子</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/D6D%J{22N@2]YWUQ[_1XKKW.png" alt="img" style="zoom:67%;" /></p><p>点击”应用”。</p><p>编辑完成后</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312042421.png" alt="QQ截图20200312042421"></p><p>在其上点击右键，选择“选中sql”，可以看到弹出窗口自动生成建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS student (s_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_name VARCHAR(20) NOT NULL default  ‘’,</span><br><span class="line">s_code VARCHAR(20) NOT NULL default  ‘’</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="建立学生辅助信息表模型"><a href="#建立学生辅助信息表模型" class="headerlink" title="建立学生辅助信息表模型"></a>建立学生辅助信息表模型</h5><p>表名：studentAdd</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>a_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>s_id</td><td>int</td><td>学生id</td></tr><tr><td>s_address</td><td>varchar(60)</td><td>学生住址</td></tr></tbody></table></div><p>仿照上面流程，完成此表的模型。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312043128.png" alt="QQ截图20200312043128"></p><p>然后点击“1对1关系”图标。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312043321.png" alt="QQ截图20200312043321"></p><p>将两个端点分别拖动到student.s_id和studentAdd.s_id上去。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312043452.png" alt="QQ截图20200312043452"></p><p>点击 数据库 -&gt; MySQL -&gt; 全部SQL 就可以看到完整的sql建表语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> student (s_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">s_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’,</span><br><span class="line">s_code <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> studentAdd (a_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">s_id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="number">0</span>,</span><br><span class="line">s_address <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> studentAdd <span class="keyword">add</span> <span class="keyword">constraint</span> studentAdd_s_id_fk0  <span class="keyword">foreign</span> key (s_id) <span class="keyword">references</span> student (s_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里针对1对1关系，建立了外键关联。</p><h5 id="建立班级信息表模型"><a href="#建立班级信息表模型" class="headerlink" title="建立班级信息表模型"></a>建立班级信息表模型</h5><p>表名：class</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>c_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>c_name</td><td>varchar(60)</td><td>班级名称</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>表名：classStudent</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>cs_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>c_id</td><td>int</td><td>班级ID</td></tr><tr><td>s_id</td><td>int</td><td>学生ID</td></tr></tbody></table></div><p>仿照上面流程，完成此表的模型。</p><p>并建立class.c_id 与 classStudent.c_id 的1对多关联，及student.s_id 与 classStudent.s_id的关联</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312044550.png" alt="QQ截图20200312044550" style="zoom:67%;" /></p><p>再看完整的建表sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> student (s_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">s_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’,</span><br><span class="line">s_code <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> studentAdd (a_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">s_id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="number">0</span>,</span><br><span class="line">s_address <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> studentAdd <span class="keyword">add</span> <span class="keyword">constraint</span> studentAdd_s_id_fk0  <span class="keyword">foreign</span> key (s_id) <span class="keyword">references</span> student (s_id);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> class (c_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">c_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> classStudent (cs_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">c_id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">s_id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> classStudent <span class="keyword">add</span> <span class="keyword">constraint</span> classStudent_c_id_fk0  <span class="keyword">foreign</span> key (c_id) <span class="keyword">references</span> class (c_id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> classStudent <span class="keyword">add</span> <span class="keyword">constraint</span> classStudent_s_id_fk0  <span class="keyword">foreign</span> key (s_id) <span class="keyword">references</span> student (s_id);</span><br></pre></td></tr></table></figure><h5 id="建立课程班级信息表模型"><a href="#建立课程班级信息表模型" class="headerlink" title="建立课程班级信息表模型"></a>建立课程班级信息表模型</h5><p>表名：course</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>co_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>co_name</td><td>varchar(60)</td><td>课程名称</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>表名：courseClass</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>cc_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>co_id</td><td>int</td><td>课程ID</td></tr><tr><td>c_id</td><td>int</td><td>班级ID</td></tr></tbody></table></div><p>仿照上面流程，完成此表的模型。</p><p>并建立course.co_id 与 courseClass.co_id 的1对多关联，及class.c_id 与 courseClass.c_id的关联。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312045437.png" alt="QQ截图20200312045437" style="zoom:67%;" /></p><h5 id="导出完整建表sql"><a href="#导出完整建表sql" class="headerlink" title="导出完整建表sql"></a>导出完整建表sql</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> student (s_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">s_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’,</span><br><span class="line">s_code <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> studentAdd (a_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">s_id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="number">0</span>,</span><br><span class="line">s_address <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  ‘’</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> studentAdd <span class="keyword">add</span> <span class="keyword">constraint</span> studcentAdd_s_id_fk0  <span class="keyword">foreign</span> key (s_id) <span class="keyword">references</span> student (s_id);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> class (c_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">c_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> classStudent (cs_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">c_id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">s_id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> classStudent <span class="keyword">add</span> <span class="keyword">constraint</span> classStudent_c_id_fk0  <span class="keyword">foreign</span> key (c_id) <span class="keyword">references</span> class (c_id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> classStudent <span class="keyword">add</span> <span class="keyword">constraint</span> classStudent_s_id_fk0  <span class="keyword">foreign</span> key (s_id) <span class="keyword">references</span> student (s_id);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> course (co_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">co_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> courseClass (cc_id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">co_id <span class="type">INT</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">c_id <span class="type">INT</span>(<span class="number">20</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span>  <span class="string">&#x27;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> courseClass <span class="keyword">add</span> <span class="keyword">constraint</span> courseClass_co_id_fk0  <span class="keyword">foreign</span> key (co_id) <span class="keyword">references</span> course (co_id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> courseClass <span class="keyword">add</span> <span class="keyword">constraint</span> courseClass_c_id_fk0  <span class="keyword">foreign</span> key (c_id) <span class="keyword">references</span> class (c_id);</span><br></pre></td></tr></table></figure><h1 id="3-外键约束与级联操作🍒"><a href="#3-外键约束与级联操作🍒" class="headerlink" title="3. 外键约束与级联操作🍒"></a>3. 外键约束与级联操作🍒</h1><p>外键约束（FOREIGN KEY）用来在两个表的数据之间建立连接，它可以是<code>一列或者多列</code>，一个表可以有一个或者多个外键。</p><p>​    <strong>外键是表的一个字段，不是本表的主键，但对应另一个表的主键。</strong>定义外键后，不允许删除另一个表中具有关联关系的行。</p><p>​        外键对应的是<strong>参照完整性</strong>，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。</p><p>​        外键的主要作用是保持数据的一致性、完整性。</p><p>​        例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。</p><ul><li><p><strong>主表（父表）：</strong> 对于两个具有关联关系的表而言，相关联中字段中的主键所在的表就是主表。</p></li><li><p><strong>从表（子表）：</strong>    对于两个具有关联关系的表而言，相关联字段中的外键所在的表就是子表。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abf.png" alt="abf"></p></li></ul><h2 id="设置MySQL外键结束的约束"><a href="#设置MySQL外键结束的约束" class="headerlink" title="设置MySQL外键结束的约束"></a>设置MySQL外键结束的约束</h2><p>​                            <strong>定义MySQL外键的时候，需要遵守一下规则：</strong></p><ul><li>主表必须已经存在数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参表（顾名思义，就是自我参照的意思），这种结构称为自参完整性。</li><li>MySQL支持外键的存储引擎只有<code>InnoDB</code>，这里和主键有区别，注意区分。在创建外键的时候，要求主表必须有对应的索引。从表在创建外键的时候也会自动创建对应的索引。</li><li><strong>必须为主表定义主键。</strong></li><li>主键不能包含空值，但是允许在外键中出现空值。也就是说，<strong>只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。</strong></li><li>在主表的表名后面指定列名或列名的组合。<strong>这个列或列的组合必须是主表的主键或候选键（唯一键、复合主键）。</strong></li><li>外键中列的数目必须和主表的主键中列的数目相同。</li><li>外键中列的数据类型必须和主表主键中对应列的数据类型相同。</li></ul><h2 id="在创建表时指定外键约束"><a href="#在创建表时指定外键约束" class="headerlink" title="在创建表时指定外键约束"></a>在创建表时指定外键约束</h2><p>在数据表中创建外键使用 <strong>FOREIGN KEY</strong> 关键字，具体的语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY 字段名 [，字段名<span class="number">2</span>，…]</span><br><span class="line"><span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> 主键列<span class="number">1</span> [，主键列<span class="number">2</span>，…]</span><br></pre></td></tr></table></figure><p>其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 成绩;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 学生;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 科目;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 学生 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 科目 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_s <span class="keyword">FOREIGN</span> KEY(学生ID) <span class="keyword">REFERENCES</span> 学生(id),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_k <span class="keyword">FOREIGN</span> KEY(科目ID) <span class="keyword">REFERENCES</span> 科目(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> indexes <span class="keyword">from</span> 成绩;</span><br></pre></td></tr></table></figure><p>提示：关联指的是关系数据库中，相关表之间的联系。它是通过相同的属性或属性组来表示的。子表的外键必须关联父表的主键，且关联字段的数据类型必须匹配，如果类型不一样，则创建子表时会出现错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">3780</span> (HY000): <span class="keyword">Referencing</span> <span class="keyword">column</span> <span class="string">&#x27;学生ID&#x27;</span> <span class="keyword">and</span> referenced <span class="keyword">column</span> <span class="string">&#x27;id&#x27;</span> <span class="keyword">in</span> <span class="keyword">foreign</span> key <span class="keyword">constraint</span> <span class="string">&#x27;s&#x27;</span> <span class="keyword">are</span> incompatible.</span><br></pre></td></tr></table></figure><h2 id="建立外键以后产生的影响"><a href="#建立外键以后产生的影响" class="headerlink" title="建立外键以后产生的影响"></a>建立外键以后产生的影响</h2><p>在向从表中插入数据时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 成绩 <span class="keyword">values</span>(<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">12.3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 成绩(id, 成绩) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">12.3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 成绩 <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12.3</span>);</span><br><span class="line">Cannot <span class="keyword">add</span> <span class="keyword">or</span> <span class="keyword">update</span> a child <span class="type">row</span>: a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> fails (`test`.`成绩`, <span class="keyword">CONSTRAINT</span> `fk_c_s` <span class="keyword">FOREIGN</span> KEY (`学生ID`) <span class="keyword">REFERENCES</span> `学生` (`id`))</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 学生 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 科目 <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​        <strong>如果外键字段插入的值，在不为null时，必须在关联的主表字段中存在，才能插入成功，否则报错。</strong></p><p>​        在向从表中更新数据时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 成绩 <span class="keyword">set</span> 学生ID<span class="operator">=</span><span class="number">3</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"> Cannot <span class="keyword">add</span> <span class="keyword">or</span> <span class="keyword">update</span> a child <span class="type">row</span>: a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> fails (`test`.`成绩`, <span class="keyword">CONSTRAINT</span> `fk_c_s` <span class="keyword">FOREIGN</span> KEY (`学生ID`) <span class="keyword">REFERENCES</span> `学生` (`id`))</span><br><span class="line"> <span class="keyword">update</span> 成绩 <span class="keyword">set</span> 学生ID<span class="operator">=</span><span class="keyword">null</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>​        <strong>如果外键字段更新后的值，在不为null时，必须在关联的主表字段中存在时，才能更新成功，否则报错。</strong></p><p>​        </p><p>​        在向主表中更新存在已关联从表的字段数据时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 学生 set id=3 where id=2;</span><br><span class="line">delete from 学生 where id=2;</span><br><span class="line">Cannot delete or update a parent row: a foreign key constraint fails (`test`.`成绩`, CONSTRAINT `fk_c_s` FOREIGN KEY (`学生ID`) REFERENCES `学生` (`id`))</span><br></pre></td></tr></table></figure><p>​        <strong>无法更新主表中，存在已关联到从表的字段数据，只能更无关联的数据。</strong></p><p>​        在主表删除存在已关联从表的字段数据时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Cannot <span class="keyword">delete</span> <span class="keyword">or</span> <span class="keyword">update</span> a parent <span class="type">row</span>: a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> fails (`test`.`成绩`, <span class="keyword">CONSTRAINT</span> `fk_c_s` <span class="keyword">FOREIGN</span> KEY (`学生ID`) <span class="keyword">REFERENCES</span> `学生` (`id`))</span><br></pre></td></tr></table></figure><p>​        <strong>如果存在关联到将被删除的主表记录，的从表记录时，无法删除。必须先删除从表中对应记录后，才能删除主表记录。</strong></p><p>​        在删除从表记录时：</p><p>​        <strong>无影响</strong></p><p>​        在删除主表时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 学生;</span><br><span class="line"> Cannot <span class="keyword">drop</span> <span class="keyword">table</span> <span class="string">&#x27;学生&#x27;</span> referenced <span class="keyword">by</span> a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> <span class="string">&#x27;fk_c_s&#x27;</span> <span class="keyword">on</span> <span class="keyword">table</span> <span class="string">&#x27;成绩&#x27;</span>.</span><br></pre></td></tr></table></figure><p>​        <strong>当外键关系还存在时，不能删除主表。必须先删除外键后，才能删除主表。</strong></p><p>​        在删除从表时：<strong>无影响</strong></p><h2 id="在修改表时添加外键约束"><a href="#在修改表时添加外键约束" class="headerlink" title="在修改表时添加外键约束"></a>在修改表时添加外键约束</h2><p>在修改数据表时添加外键约束的语法规则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);</span><br></pre></td></tr></table></figure><p>我们还是来看看学生成绩表的例子。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 成绩;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 学生;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 科目;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 学生 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 科目 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 成绩 <span class="keyword">add</span> <span class="keyword">constraint</span> 成绩_学生ID_fk0  <span class="keyword">foreign</span> key (学生ID) <span class="keyword">references</span> 学生 (id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 成绩 <span class="keyword">add</span> <span class="keyword">constraint</span> 成绩_科目ID_fk0  <span class="keyword">foreign</span> key (科目ID) <span class="keyword">references</span> 科目 (id);</span><br></pre></td></tr></table></figure><h2 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h2><p>对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系，MySQL 中删除外键的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY <span class="operator">&lt;</span>外键约束名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>去除外键约束后，对应创建在从表上的索引，还继续存在，除非直接drop相关索引。</p><h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><p>​        在创建外键的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括<strong>RESTRICT、NO ACTION、SET NULL和CASCADE</strong>。</p><p>​        其中RESTRICT和NO ACTION相同，是指在子表有关联记录的情况下父表不能更新；CASCADE表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL则是表示父表在更新或者删除的时候，子表的对应字段被SET NULL。</p><h3 id="不允许级联操作"><a href="#不允许级联操作" class="headerlink" title="不允许级联操作"></a>不允许级联操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_s <span class="keyword">FOREIGN</span> KEY(学生ID) <span class="keyword">REFERENCES</span> 学生(id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_k <span class="keyword">FOREIGN</span> KEY(科目ID) <span class="keyword">REFERENCES</span> 科目(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--或者如下</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_s <span class="keyword">FOREIGN</span> KEY(学生ID) <span class="keyword">REFERENCES</span> 学生(id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_k <span class="keyword">FOREIGN</span> KEY(科目ID) <span class="keyword">REFERENCES</span> 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行no action设置之后，与未设置级联操作一致（no action实际是默认模式），删除和更新会报错。</p><h3 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_s <span class="keyword">FOREIGN</span> KEY(学生ID) <span class="keyword">REFERENCES</span> 学生(id) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_k <span class="keyword">FOREIGN</span> KEY(科目ID) <span class="keyword">REFERENCES</span> 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行了on update cascade设置之后，update操作主表，将主表数据和从表中关联的数据字段都一并更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 学生 <span class="keyword">set</span> id<span class="operator">=</span><span class="number">3</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩;</span><br></pre></td></tr></table></figure><h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_s <span class="keyword">FOREIGN</span> KEY(学生ID) <span class="keyword">REFERENCES</span> 学生(id) <span class="keyword">ON</span> <span class="keyword">delete</span> CASCADE,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_k <span class="keyword">FOREIGN</span> KEY(科目ID) <span class="keyword">REFERENCES</span> 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行了on delete cascade设置之后，delete操作主表，将主表数据和从表中关联的数据都一并删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩;</span><br></pre></td></tr></table></figure><p>on update cascade 与 on delete cascade 可以连起来写。</p><h3 id="级联设置为null"><a href="#级联设置为null" class="headerlink" title="级联设置为null"></a>级联设置为null</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 成绩 (id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">学生ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">科目ID <span class="type">INT</span>(<span class="number">10</span>),</span><br><span class="line">成绩 <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_s <span class="keyword">FOREIGN</span> KEY(学生ID) <span class="keyword">REFERENCES</span> 学生(id) <span class="keyword">ON</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_c_k <span class="keyword">FOREIGN</span> KEY(科目ID) <span class="keyword">REFERENCES</span> 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行了on delete set null 或 on update set null 设置之后，delete 或 update 操作主表，将主表数据和从表中关联的数据字段都一并设为null。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 学生 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 学生;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 成绩;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库三大范式、ER图与实体类、外键约束与级联操作&quot;&gt;&lt;a href=&quot;#数据库三大范式、ER图与实体类、外键约束与级联操作&quot; class=&quot;headerlink&quot; title=&quot;数据库三大范式、ER图与实体类、外键约束与级联操作&quot;&gt;&lt;/a&gt;数据库三大范式、ER图</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>悉知JDBC</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E6%82%89%E7%9F%A5JDBC/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E6%82%89%E7%9F%A5JDBC/</id>
    <published>2022-10-16T14:51:55.000Z</published>
    <updated>2022-10-16T14:55:58.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悉知JDBC"><a href="#悉知JDBC" class="headerlink" title="悉知JDBC"></a>悉知JDBC</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h2 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0. 学习目标"></a>0. 学习目标</h2><ul><li>掌握JDBC的概念</li><li>掌握JDBC操作单表CRUD的方法</li><li>掌握JDBC操作数据库事务的方法</li><li>掌握数据库操作工具类的实现方法</li><li>了解一些市面上的流行的连接池</li><li>了解并熟悉掌握三层架构</li></ul><h1 id="第1章JDBC概述"><a href="#第1章JDBC概述" class="headerlink" title="第1章JDBC概述"></a>第1章JDBC概述</h1><p><strong>首先看一下下面这张JDBC的思维导图理一下思路吧！！！</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/JDBC.png" style="zoom: 50%;" /></p><p>客户端操作MySQL数据库的方式</p><ol><li>使用第三方客户端来访问MySQL：SQLyog、Navicat、SQLWave、MyDB Studio、EMS SQL Manager for MySQL</li><li>使用MySQL自带的命令行方式</li><li><strong>通过Java来访问MySQL数据库，今天要学习的内容</strong></li></ol><p><strong>什么是JDBC</strong>：<code>Java DataBase Connectivity</code>(Java数据库连接) JDBC是Java访问数据库的<code>标准规范</code><br><strong>JDBC的作用</strong>：JDBC是用于执行SQL语句的Java API(<strong>Java语言通过JDBC可以操作数据库</strong>)</p><h2 id="1-1-JDBC概述"><a href="#1-1-JDBC概述" class="headerlink" title="1.1 JDBC概述"></a>1.1 JDBC概述</h2><p>JDBC：Java Database Connectivity，它是代表一组独立于任何数据库管理系统（DBMS）的API，声明在java.sql与javax.sql包中，是SUN(现在Oracle)提供的一组接口规范。由各个数据库厂商来提供实现类，这些实现类的集合构成了数据库驱动jar。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1561212287381.png" alt="1561212287381"></p><p>即JDBC技术包含两个部分：</p><p>（1）java.sql包和javax.sql包中的API</p><blockquote><p>因为为了项目代码的可移植性，可维护性，SUN公司从最初就制定了Java程序连接各种数据库的统一接口规范。这样的话，不管是连接哪一种DBMS软件，Java代码可以保持一致性。</p></blockquote><p>（2）各个数据库厂商提供的jar</p><blockquote><p>因为各个数据库厂商的DBMS软件各有不同，那么内部如何通过sql实现增、删、改、查等管理数据，只有这个数据库厂商自己更清楚，因此把接口规范的实现交给各个数据库厂商自己实现。</p></blockquote><h2 id="1-2-JDBC的由来"><a href="#1-2-JDBC的由来" class="headerlink" title="1.2.JDBC的由来"></a>1.2.JDBC的由来</h2><ol><li><p><strong>直接写代码操作数据库</strong><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc01.png" alt=""><br><strong>直接写代码操作数据库存在的问题：</strong></p><ol><li>不知道MySQL数据库的操作方式，解析方式</li><li>代码繁琐，写起来麻烦</li><li>MySQL和Oracle等其他数据库的操作方式和解析方式不同，每个数据库都要写一套代码</li><li>MySQL和Oracle等其他数据库相互切换麻烦</li></ol></li><li><p><strong>JDBC规范定义接口，具体的实现由各大数据库厂商来实现</strong><br>JDBC是Java访问数据库的标准规范。真正怎么操作数据库还需要具体的实现类，也就是数据库驱动。每个数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动。所以我们只需要会调用JDBC接口中的方法即可。数据库驱动由数据库厂商提供。<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc02.png" alt=""></p></li></ol><p><strong>JDBC的好处：</strong></p><ol><li>我们只需要会调用JDBC接口中的方法即可，使用简单</li><li>使用同一套Java代码，进行少量的修改就可以访问其他JDBC支持的数据库</li></ol><p><strong>JDBC会用到的包：</strong></p><ol><li>java.sql：JDBC访问数据库的基础包，在JavaSE中的包。如：java.sql.Connection</li><li>javax.sql： JDBC访问数据库的扩展包</li><li>数据库的驱动，各大数据库厂商来实现。如：MySQL的驱动：com.mysql.jdbc.Driver</li></ol><p><strong>JDBC四个核心对象</strong><br>这几个类都是在java.sql包中</p><ol><li>DriverManager: 用于注册驱动</li><li>Connection: 表示与数据库创建的连接</li><li>Statement: 执行SQL语句的对象</li><li>ResultSet: 结果集或一张虚拟表<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc03.png" alt=""></li></ol><h2 id="1-3-JDBC使用步骤"><a href="#1-3-JDBC使用步骤" class="headerlink" title="1.3 JDBC使用步骤"></a>1.3 JDBC使用步骤</h2><p>代码编写步骤：</p><p>JDBC访问数据库步骤</p><blockquote><p>1：注册一个Driver驱动</p><p>三部曲：</p><p>​    （1）将DBMS数据库管理软件的驱动jar拷贝到项目的libs目录中</p><p>​              例如：mysql-connector-java-5.1.36-bin.jar</p><p>​     （2）把驱动jar添加到项目的build path中</p><p>​     （3）将驱动类加载到内存中</p><p>​               Class.forName(“com.mysql.jdbc.Driver”);</p><p>2：获取数据库连接（Connection）</p><p>​     Connection conn = DriverManager.getConnection(url,username,password);</p><p>​     mysql的url：jdbc:mysql://localhost:3306/数据库名?参数名=参数值</p><p>​     jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;characterEncoding=utf8</p><p>​    （如果JDBC程序与服务器端       的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集</p><p>3：创建SQL命令发送器Statement</p><p>​     创建Statement或PreparedStatement对象</p><p>4：通过Statement发送SQL命令并得到结果</p><p>5：处理结果（select语句）</p><p>6：关闭数据库资源ResultSet  Statement  Connection</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1561213163143.png" alt="1561213163143"></p><h2 id="1-4-相关的API："><a href="#1-4-相关的API：" class="headerlink" title="1.4 相关的API："></a>1.4 相关的API：</h2><h3 id="相关API介绍"><a href="#相关API介绍" class="headerlink" title="相关API介绍"></a>相关API介绍</h3><h4 id="1、DriverManager：驱动管理类"><a href="#1、DriverManager：驱动管理类" class="headerlink" title="1、DriverManager：驱动管理类"></a>1、DriverManager：驱动管理类</h4><p>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>加载驱动，这样驱动只会注册一次</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01 &#123;</span><br><span class="line">public <span class="keyword">static</span> void main(String[] args) throws Exception &#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;); </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 后期可以将&quot;com.mysql.jdbc.Driver&quot;字符串写在文件中.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、Connection：代表数据库连接"><a href="#2、Connection：代表数据库连接" class="headerlink" title="2、Connection：代表数据库连接"></a>2、Connection：代表数据库连接</h4><blockquote><p>注意：使用<code>DriverManager.registerDriver(new com.mysql.jdbc.Driver());</code>，存在两方面不足</p><ol><li>硬编码，后期不易于程序扩展和维护</li><li>驱动被注册两次</li></ol></blockquote><h4 id="3、Statement和PreparedStatement：用来执行sql"><a href="#3、Statement和PreparedStatement：用来执行sql" class="headerlink" title="3、Statement和PreparedStatement：用来执行sql"></a>3、Statement和PreparedStatement：用来执行sql</h4><p>​    执行增、删、改：int executeUpate()</p><p>​    执行查询：ResultSet executeQuery()</p><h4 id="4、如何遍历ResultSet-？"><a href="#4、如何遍历ResultSet-？" class="headerlink" title="4、如何遍历ResultSet ？"></a>4、如何遍历ResultSet ？</h4><p>​    （1）boolean next()：判断是否还有下一行</p><p>​    （2）getString(字段名或序号),getInt(字段名或序号),getObject(字段名或序号)</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li><code>String url</code>：连接数据库的URL，用于说明连接数据库的位置</li><li><code>String user</code>：数据库的账号</li><li><code>String password</code>：数据库的密码</li></ol><p>连接数据库的URL地址格式：<code>协议名:子协议://服务器名或IP地址:端口号/数据库名?参数=参数值</code><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc13.png" alt=""><br>MySQL写法：<code>jdbc:mysql://localhost:3306/dayxx如果是本地服务器，端口号是默认的3306，则可以简写：</code>jdbc:mysql:///db1</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>如果数据出现乱码需要加上参数: ?characterEncoding=utf8，表示让数据库以UTF-8编码来处理数据。<br>如: jdbc:mysql://localhost:3306/dayxx?characterEncoding=utf8</p></blockquote><p>若出现以下内容,代表数据库服务没有启动</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220820122713724.png" alt="image-20220820122713724" style="zoom:80%;" /></p><p><code>示例代码1：增、删、改</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJDBC</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"><span class="comment">//1、注册驱动</span></span><br><span class="line"><span class="comment">//(1)方式一：Class.forName(&quot;驱动类的全名称&quot;)</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//(2)创建驱动类的对象</span></span><br><span class="line"><span class="comment">//new com.mysql.jdbc.Driver();//硬编码</span></span><br><span class="line"><span class="comment">//(3)通过DriverManager注册驱动</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());//硬编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取连接，连接数据库</span></span><br><span class="line">        <span class="comment">//TCP/IP协议编程，需要服务器的IP地址和端口号</span></span><br><span class="line"><span class="comment">//mysql的url格式：jdbc协议:子协议://主机名:端口号/要连接的数据库名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;<span class="comment">//其中test是数据库名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、执行sql</span></span><br><span class="line"><span class="comment">//添加一个部门到数据库的t_department表中</span></span><br><span class="line"><span class="comment">//(1)编写sql</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_department values(null,&#x27;计算部2&#x27;,&#x27;计算钞票2&#x27;)&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 回忆：TCP/IP程序时</span></span><br><span class="line"><span class="comment"> * Socket代表连接</span></span><br><span class="line"><span class="comment"> * socket.getOutputStream()来发送数据，</span></span><br><span class="line"><span class="comment"> * socket.getInputStream()来接收数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可以把Connection比喻成Socket</span></span><br><span class="line"><span class="comment"> *    把Statement比喻成OutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//(2)获取Statement对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="comment">//(3)执行sql</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> st.executeUpdate(sql);</span><br><span class="line"><span class="comment">//(4)处理结果</span></span><br><span class="line">System.out.println(len&gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭</span></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>示例代码2：查询</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSelect</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">// 1、注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、连接数据库</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、执行sql</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM t_department&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sql);<span class="comment">//ResultSet看成InputStream</span></span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;<span class="comment">//next()表示是否还有下一行</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">did</span> <span class="operator">=</span> rs.getObject(<span class="number">1</span>);<span class="comment">//获取第n列的值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">dname</span> <span class="operator">=</span> rs.getObject(<span class="number">2</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">desc</span> <span class="operator">=</span> rs.getObject(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int did = rs.getInt(&quot;did&quot;);//也可以根据列名称，并且可以按照数据类型获取</span></span><br><span class="line"><span class="comment">String dname = rs.getString(&quot;dname&quot;);</span></span><br><span class="line"><span class="comment">String desc = rs.getString(&quot;description&quot;);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">System.out.println(did +<span class="string">&quot;\t&quot;</span> + dname + <span class="string">&quot;\t&quot;</span>+ desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、关闭</span></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第2章-使用PreparedStatement处理CRUD"><a href="#第2章-使用PreparedStatement处理CRUD" class="headerlink" title="第2章  使用PreparedStatement处理CRUD"></a>第2章  使用PreparedStatement处理CRUD</h1><h2 id="2-1-通过PreparedStatement来解决Statement的问题"><a href="#2-1-通过PreparedStatement来解决Statement的问题" class="headerlink" title="2.1 通过PreparedStatement来解决Statement的问题"></a>2.1 通过PreparedStatement来解决Statement的问题</h2><p>Statement的问题：通过PreparedStatement来代替</p><h3 id="1-sql拼接"><a href="#1-sql拼接" class="headerlink" title="1. sql拼接"></a>1. sql拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_employee(ename,tel,gender,salary) values(&#x27;&quot;</span> + ename + <span class="string">&quot;&#x27;,&#x27;&quot;</span> + tel + <span class="string">&quot;&#x27;,&#x27;&quot;</span> + gender + <span class="string">&quot;&#x27;,&quot;</span> + salary +<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> st.executeUpdate(sql);</span><br></pre></td></tr></table></figure><h3 id="2-sql注入"><a href="#2-sql注入" class="headerlink" title="2 . sql注入"></a>2 . sql注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM t_employee where ename=&#x27;&quot;</span> + ename + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">//如果我此时从键盘输入ename值的时候，输入：张三&#x27; or &#x27;1&#x27;= &#x27;1</span></span><br><span class="line"><span class="comment">//结果会把所有数据都查询出来</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> st.executeQuery(sql);</span><br></pre></td></tr></table></figure><h3 id="3-处理blob等类型的数据"><a href="#3-处理blob等类型的数据" class="headerlink" title="3. 处理blob等类型的数据"></a>3. 处理blob等类型的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建含有Blob字段类型的表 测试插入</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user(username,photo) values(&#x27;zs&#x27;, 图片字节流)&quot;</span>;</span><br><span class="line"><span class="comment">//此时photo是blob类型的数据时，无法在sql中直接拼接</span></span><br></pre></td></tr></table></figure><p>PreparedStatement解决问题：</p><h3 id="4-避免sql拼接"><a href="#4-避免sql拼接" class="headerlink" title="4. 避免sql拼接"></a>4. 避免sql拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_employee(ename,tel,gender,salary) values(?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);<span class="comment">//这里要传带？的sql，然后mysql端就会对这个sql进行预编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置？的具体值</span></span><br><span class="line"><span class="comment">/*pst.setString(1, ename);</span></span><br><span class="line"><span class="comment">pst.setString(2, tel);</span></span><br><span class="line"><span class="comment">pst.setString(3, gender);</span></span><br><span class="line"><span class="comment">pst.setDouble(4, salary);*/</span></span><br><span class="line"></span><br><span class="line">pst.setObject(<span class="number">1</span>, ename);</span><br><span class="line">pst.setObject(<span class="number">2</span>, tel);</span><br><span class="line">pst.setObject(<span class="number">3</span>, gender);</span><br><span class="line">pst.setObject(<span class="number">4</span>, salary);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pst.executeUpdate();<span class="comment">//此处不能传sql</span></span><br><span class="line">System.out.println(len);</span><br></pre></td></tr></table></figure><h3 id="5-不会有sql注入"><a href="#5-不会有sql注入" class="headerlink" title="5. 不会有sql注入"></a>5. 不会有sql注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM t_employee where ename=?&quot;</span>;</span><br><span class="line"><span class="comment">//即使输入&#x27;张三&#x27; or &#x27;1&#x27;= &#x27;1&#x27;也没问题</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间加入设置？的值</span></span><br><span class="line">pst.setObject(<span class="number">1</span>, ename);</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br></pre></td></tr></table></figure><h3 id="6-处理blob类型的数据"><a href="#6-处理blob类型的数据" class="headerlink" title="6. 处理blob类型的数据"></a>6. 处理blob类型的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user(username,photo) values(?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置？的值</span></span><br><span class="line">pst.setObject(<span class="number">1</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/QMDownload/img/美女/15.jpg&quot;</span>);</span><br><span class="line">pst.setBlob(<span class="number">2</span>, fis);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>注意两个问题：</p><p>①my.ini关于上传的字节流文件有大小限制，可以在my.ini中配置变量</p><p>​    max_allowed_packet=16M</p><p>②每一种blob有各自大小限制：</p><p>tinyblob:255字节、blob:65k、mediumblob:16M、longblob:4G</p></li></ul><h2 id="2-2-获取自增长键值"><a href="#2-2-获取自增长键值" class="headerlink" title="2.2 获取自增长键值"></a>2.2 获取自增长键值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们通过JDBC往数据库的表格中添加一条记录，其中有一个字段是自增的，那么在JDBC这边怎么在添加之后直接获取到这个自增的值</span></span><br><span class="line"><span class="comment"> * PreparedStatement是Statement的子接口。</span></span><br><span class="line"><span class="comment"> * Statement接口中有一些常量值：</span></span><br><span class="line"><span class="comment"> * （1）Statement.RETURN_GENERATED_KEYS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 要先添加后获取到自增的key值：</span></span><br><span class="line"><span class="comment"> * （1）PreparedStatement pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span></span><br><span class="line"><span class="comment"> * （2）添加sql执行完成后,通过PreparedStatement的对象调用getGeneratedKeys()方法来获取自增长键值，遍历结果集</span></span><br><span class="line"><span class="comment"> * ResultSet rs = pst.getGeneratedKeys();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAutoIncrement</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//1、注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、执行sql</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_department values(null,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里在创建PreparedStatement对象时，传入第二个参数的作用，就是告知服务器端</span></span><br><span class="line"><span class="comment"> * 当执行完sql后，把自增的key值返回来。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置？的值</span></span><br><span class="line">pst.setObject(<span class="number">1</span>, <span class="string">&quot;测试部&quot;</span>);</span><br><span class="line">pst.setObject(<span class="number">2</span>, <span class="string">&quot;测试项目数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pst.executeUpdate();<span class="comment">//返回影响的记录数</span></span><br><span class="line"><span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//从pst中获取到服务器端返回的键值</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.getGeneratedKeys();</span><br><span class="line"><span class="comment">//因为这里的key值可能多个，因为insert语句可以同时添加多行，所以用ResultSet封装</span></span><br><span class="line"><span class="comment">//这里因为只添加一条，所以用if判断</span></span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> rs.getObject(<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;自增的key值did =&quot;</span> + key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭</span></span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-批处理"><a href="#2-3-批处理" class="headerlink" title="2.3 批处理"></a>2.3 批处理</h2><p>需要在url的末尾添加此参数：rewriteBatchedStatements=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 批处理：</span></span><br><span class="line"><span class="comment"> * 批量处理sql</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如：</span></span><br><span class="line"><span class="comment"> * （1）订单明细表的多条记录的添加</span></span><br><span class="line"><span class="comment"> * （2）批量添加模拟数据</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 不用批处理，和用批处理有什么不同？</span></span><br><span class="line"><span class="comment"> * 批处理的效率很多</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如何进行批处理操作？</span></span><br><span class="line"><span class="comment"> * （1）在url中要加一个参数</span></span><br><span class="line"><span class="comment"> *     rewriteBatchedStatements=true</span></span><br><span class="line"><span class="comment"> *     那么我们的url就变成了  jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="comment"> *     这里的?，表示?后面是客户端给服务器端传的参数，多个参数直接使用&amp;分割</span></span><br><span class="line"><span class="comment"> * （2）调用方法不同</span></span><br><span class="line"><span class="comment"> * pst.addBatch();</span></span><br><span class="line"><span class="comment"> * int[] all = pst.executeBatch();</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意：如果批量添加时，insert使用values,不要使用value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBatch</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//例如：在部门表t_department中添加1000条模拟数据</span></span><br><span class="line"><span class="comment">//1、注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//2、获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//3、执行sql</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_department values(null,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//设置？的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">1000</span>; i++) &#123;</span><br><span class="line">pst.setObject(<span class="number">1</span>, <span class="string">&quot;模拟部门&quot;</span>+i);</span><br><span class="line">pst.setObject(<span class="number">2</span>, <span class="string">&quot;模拟部门的简介&quot;</span>+i);</span><br><span class="line">pst.addBatch();<span class="comment">//添加到批处理一组操作中，攒一块处理</span></span><br><span class="line"><span class="comment">/*          if(i % 500 == 0)&#123;//有时候也攒一部分，执行一部分</span></span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line"><span class="comment">pst.executeBatch();</span></span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line"><span class="comment">pst.clearBatch();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line">pst.executeBatch();</span><br><span class="line"><span class="comment">//4、关闭</span></span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;耗时：&quot;</span> + (end - start));<span class="comment">//耗时：821</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第3章-JDBC实现对单表数据增、删、改、查"><a href="#第3章-JDBC实现对单表数据增、删、改、查" class="headerlink" title="第3章 JDBC实现对单表数据增、删、改、查"></a>第3章 JDBC实现对单表数据增、删、改、查</h1><p>我们要对数据库进行增、删、改、查，需要使用<code>Statement</code>对象来执行SQL语句。</p><h2 id="4-1-JDBC实现对单表数据增、删、改"><a href="#4-1-JDBC实现对单表数据增、删、改" class="headerlink" title="4.1 JDBC实现对单表数据增、删、改"></a>4.1 JDBC实现对单表数据增、删、改</h2><p><strong>案例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///mysqltest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">System.out.println(conn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从连接中拿到一个Statement对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.插入记录</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO category (cname) VALUES (&#x27;手机&#x27;);&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">System.out.println(<span class="string">&quot;影响的行数:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.修改记录</span></span><br><span class="line">sql = <span class="string">&quot;UPDATE category SET cname=&#x27;汽车&#x27; WHERE cid=4;&quot;</span>;</span><br><span class="line">i = stmt.executeUpdate(sql);</span><br><span class="line">System.out.println(<span class="string">&quot;影响的行数:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.删除记录</span></span><br><span class="line">sql = <span class="string">&quot;DELETE FROM category WHERE cid=1;&quot;</span>;</span><br><span class="line">i = stmt.executeUpdate(sql);</span><br><span class="line">System.out.println(<span class="string">&quot;影响的行数:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例效果</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc17.png" alt=""></p><h2 id="4-2-JDBC实现对单表数据查询"><a href="#4-2-JDBC实现对单表数据查询" class="headerlink" title="4.2 JDBC实现对单表数据查询"></a>4.2 JDBC实现对单表数据查询</h2><p><strong>使用JDBC查询数据库中的数据的步骤</strong></p><ol><li>注册驱动</li><li>获取连接</li><li>获取到Statement</li><li>使用Statement执行SQL</li><li>ResultSet处理结果</li><li>关闭资源</li></ol><p><strong>案例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///mysqltest&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM category;&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有一个指针,只能取指针指向的那条记录</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123; <span class="comment">// 指针移动一行,有数据才返回true</span></span><br><span class="line"><span class="comment">// 取出数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">cid</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;cid&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">cname</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;cname&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cid + <span class="string">&quot; == &quot;</span> + cname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>如果光标在第一行之前，使用rs.getXXX()获取列值，报错：Before start of result set</li><li>如果光标在最后一行之后，使用rs.getXXX()获取列值，报错：After end of result set</li></ol></blockquote><p><strong>案例效果</strong><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc20.png" alt=""></p><blockquote><p>总结：其实我们使用JDBC操作数据库的步骤都是固定的。不同的地方是在编写SQL语句</p><ol><li>注册驱动</li><li>获取连接</li><li>获取到Statement</li><li>使用Statement执行SQL</li><li>ResultSet处理结果</li><li>关闭资源</li></ol></blockquote><h1 id="第4章-JDBC事务"><a href="#第4章-JDBC事务" class="headerlink" title="第4章 JDBC事务"></a>第4章 JDBC事务</h1><p>之前我们是使用MySQL的命令来操作事务。接下来我们使用JDBC来操作银行转账的事务。</p><h2 id="5-1-准备数据"><a href="#5-1-准备数据" class="headerlink" title="5.1 准备数据"></a>5.1 准备数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">balance <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account (NAME, balance) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">1000</span>), (<span class="string">&#x27;李四&#x27;</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="5-2-API介绍"><a href="#5-2-API介绍" class="headerlink" title="5.2 API介绍"></a>5.2 API介绍</h2><p><code>Connection</code>接口中与事务有关的方法</p><ol><li><p>```java<br>void setAutoCommit(boolean autoCommit) throws SQLException;<br>false：开启事务， ture：关闭事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```java</span><br><span class="line">   void commit() throws SQLException;</span><br><span class="line">   提交事务</span><br></pre></td></tr></table></figure></li><li><p>```java<br>void rollback() throws SQLException;<br>回滚事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 5.3 使用步骤</span><br><span class="line"></span><br><span class="line">1. 注册驱动</span><br><span class="line">2. 获取连接</span><br><span class="line">3. 获取到Statement</span><br><span class="line">4. **开启事务**</span><br><span class="line">5. 使用PrepareStatement执行SQL</span><br><span class="line">6. **提交或回滚事务**</span><br><span class="line">7. 处理结果集</span><br><span class="line">8. 关闭资源</span><br><span class="line"></span><br><span class="line">## 5.4 案例代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line"> * mysql默认每一个连接是自动提交事务的。</span><br><span class="line"> * 那么当我们在JDBC这段，如果有多条语句想要组成一个事务一起执行的话，那么在JDBC这边怎么设置手动提交事务呢？</span><br><span class="line"> * (1)在执行之前，设置手动提交事务</span><br><span class="line"> * Connection的对象.setAutoCommit(false)</span><br><span class="line"> * (2)成功：</span><br><span class="line"> * Connection的对象.commit();</span><br><span class="line"> * 失败：</span><br><span class="line"> * Connection的对象.rollback();</span><br><span class="line"> * </span><br><span class="line"> * 补充说明：</span><br><span class="line"> * 为了大家养成要的习惯，在关闭Connection的对象之前，把连接对象设置回自动提交</span><br><span class="line"> * (3)Connection的对象.setAutoCommit(true)</span><br><span class="line"> * </span><br><span class="line"> * 因为我们现在的连接是建立新的连接，那么如果没有还原为自动提交，没有影响。</span><br><span class="line"> * 但是我们后面实际开发中，每次获取的连接，不一定是新的连接，而是从连接池中获取的旧的连接，而且你关闭也不是真关闭，而是还给连接池，供别人接着用。以防别人拿到后，以为是自动提交的，而没有commit，最终数据没有成功。</span><br><span class="line">   */</span><br><span class="line">   public class TestTransaction &#123;</span><br><span class="line">   public static void main(String[] args) throws Exception&#123;</span><br><span class="line">   /*</span><br><span class="line">    * 一般涉及到事务处理的话，那么业务逻辑都会比较复杂。</span><br><span class="line">    * 例如：购物车结算时：</span><br><span class="line">    * （1）在订单表中添加一条记录</span><br><span class="line">    * （2）在订单明细表中添加多条订单明细的记录（表示该订单买了什么东西）</span><br><span class="line">    * （3）修改商品表的销量和库存量</span><br><span class="line">    * ...</span><br><span class="line">    * 那么我们今天为了大家关注事务的操作，而不会因为复杂的业务逻辑的影响导致我们的理解，那么我们这里故意</span><br><span class="line">    * 用两条修改语句来模拟组成一个简单的事务。</span><br><span class="line">    * update t_department set description = &#x27;xx&#x27; where did = 2;</span><br><span class="line">    * update t_department set description = &#x27;yy&#x27; where did = 3;</span><br><span class="line">    * </span><br><span class="line">    * 我希望这两天语句要么一起成功，要么一起回滚</span><br><span class="line">    * 为了制造失败，我故意把第二条语句写错</span><br><span class="line">    * update t_department set description = &#x27;yy&#x27; （少了where） did = 3;</span><br><span class="line">    */</span><br><span class="line">       </span><br><span class="line">//1、注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">//2、获取连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/test&quot;, &quot;root&quot;, &quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">//设置手动提交事务</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">//3、执行sql</span><br><span class="line">String sql1 = &quot;update t_department set description = &#x27;xx&#x27; where did = 2&quot;;</span><br><span class="line">String sql2 = &quot;update t_department set description = &#x27;yy&#x27; did = 3&quot;;//这是错的</span><br><span class="line"></span><br><span class="line">//使用prepareStatement的sql也可以不带?</span><br><span class="line">PreparedStatement pst = null;</span><br><span class="line">try &#123;</span><br><span class="line">pst = conn.prepareStatement(sql1);</span><br><span class="line">int len = pst.executeUpdate();</span><br><span class="line">System.out.println(&quot;第一条：&quot; + (len&gt;0?&quot;成功&quot;:&quot;失败&quot;));</span><br><span class="line"></span><br><span class="line">pst = conn.prepareStatement(sql2);</span><br><span class="line">len = pst.executeUpdate();</span><br><span class="line">System.out.println(&quot;第二条：&quot; + (len&gt;0?&quot;成功&quot;:&quot;失败&quot;));</span><br><span class="line"></span><br><span class="line">//都成功了，就提交事务</span><br><span class="line">System.out.println(&quot;提交&quot;);</span><br><span class="line">conn.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(&quot;回滚&quot;);</span><br><span class="line">//失败要回滚</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line">//4、关闭</span><br><span class="line">pst.close();</span><br><span class="line">conn.setAutoCommit(true);//还原为自动提交</span><br><span class="line">conn.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 拿到连接</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///dayxx&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="type">Statement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="comment">// 张三减500</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE account SET balance = balance - 500 WHERE id=1;&quot;</span>;</span><br><span class="line">pstmt.executeUpdate(sql);</span><br><span class="line"><span class="comment">// 模拟异常</span></span><br><span class="line"><span class="comment">// int i = 10 / 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 李四加500</span></span><br><span class="line">sql = <span class="string">&quot;UPDATE account SET balance = balance + 500 WHERE id=2;&quot;</span>;</span><br><span class="line">pstmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">pstmt.close();</span><br><span class="line"><span class="comment">// 成功,提交事务</span></span><br><span class="line">System.out.println(<span class="string">&quot;成功,提交事务&quot;</span>);</span><br><span class="line">conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// 失败,回滚事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;出了异常,回滚事务&quot;</span>);</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-案例效果"><a href="#5-5-案例效果" class="headerlink" title="5.5 案例效果"></a>5.5 案例效果</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/jdbc21.png" alt=""></p><p><strong>说明：</strong>JDBC操作MySQL默认是自动提交事务的，事务不安全；可以手动开启事务管理，进行事务提交和回滚。</p><h1 id="第5章-数据库连接池"><a href="#第5章-数据库连接池" class="headerlink" title="第5章 数据库连接池"></a>第5章 数据库连接池</h1><h2 id="1、什么是数据库连池"><a href="#1、什么是数据库连池" class="headerlink" title="1、什么是数据库连池"></a>1、什么是数据库连池</h2><p>连接对象的缓冲区。负责申请，分配管理，释放连接的操作。</p><h2 id="2、为什么要使用数据库连接池"><a href="#2、为什么要使用数据库连接池" class="headerlink" title="2、为什么要使用数据库连接池"></a>2、为什么要使用数据库连接池</h2><p>Connection对象在每次执行DML和DQL的过程中都要创建一次,DML和DQL执行完毕后,connection对象都会被销毁. connection对象是可以反复使用的,没有必要每次都创建新的.该对象的创建和销毁都是比较消耗系统资源的,如何实现connection对象的反复使用呢?使用连接池技术实现。</p><h2 id="3-连接池的优势"><a href="#3-连接池的优势" class="headerlink" title="3.连接池的优势"></a>3.连接池的优势</h2><ul><li>预先准备一些链接对象,放入连接池中,当多个线程并发执行时,可以避免短时间内一次性大量创建链接对象,减少计算机单位时间内的运算压力,提高程序的响应速度</li><li>实现链接对象的反复使用,可以大大减少链接对象的创建次数,减少资源的消耗</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1600053286973.png" alt="1600053286973"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1600053272909.png" alt="1600053272909"></p><h2 id="4、市面上有很多现成的数据库连接池技术："><a href="#4、市面上有很多现成的数据库连接池技术：" class="headerlink" title="4、市面上有很多现成的数据库连接池技术："></a>4、市面上有很多现成的数据库连接池技术：</h2><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口（通常被称为数据源），该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池，<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以</strong></li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池</li><li><strong>HikariCP</strong>是由日本程序员开源的一个数据库连接池组件，代码非常轻量，并且速度非常的快。根据官方提供的数据，在i7,开启32个线程32个连接的情况下，进行随机数据库读写操作，HikariCP 的速度是现在常用的C3P0数据库连接池的数百倍。在SpringBoot2.0 中，官方也是推荐使用 HikariCP</li></ul></li></ul><h2 id="5-使用HikariCP作为连接池"><a href="#5-使用HikariCP作为连接池" class="headerlink" title="5. 使用HikariCP作为连接池"></a>5. 使用HikariCP作为连接池</h2><h3 id="HikariCP特点"><a href="#HikariCP特点" class="headerlink" title="HikariCP特点"></a>HikariCP特点</h3><blockquote><ol><li>字节码精简 ：优化代码（HikariCP利用了一个第三方的Java字节码修改类库Javassist来生成委托实现动态代理，动态代理的实现在ProxyFactory类），直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；</li><li>优化代理和拦截器：减少代码，例如HikariCP的Statement proxy只有100行代码，只有BoneCP的十分之一；</li><li>自定义数组类型（FastStatementList）代替ArrayList：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描，相对与ArrayList极大地提升了性能，而其中的区别是，ArrayList在每次执行get(Index)方法时，都需要对List的范围进行检查，而FastStatementList不需要，在能确保范围的合法性的情况下，可以省去范围检查的开销。<br>自定义集合类型（ConcurrentBag）：支持快速插入和删除，特别是在同一线程既添加又删除项时，提高并发读写的效率；</li><li>针对CPU的时间片算法进行优化：尽可能在一个时间片里面完成各种操作（具体机制比较模糊）。</li><li>针对连接中断的情况：比其他CP响应时间上有了极好的优化，响应时间为5S，会抛出SqlException异常，并且后续的getConnection()可以正常进行。</li></ol></blockquote><p><strong>关于Connection的操作：另外在Java代码中，很多都是在使用完之后直接关闭连接，以前都是从头到尾遍历，来关闭对应的Connection，而HikariCP则是从尾部对Connection集合进行扫描，整体上来说，从尾部开始的性能更好一些。</strong></p><h3 id="HikariCP配置"><a href="#HikariCP配置" class="headerlink" title="HikariCP配置"></a>HikariCP配置</h3><ul><li><p>maximum-pool-size 池中最大连接数（包括空闲和正在使用的连接）</p></li><li><p>minimum-idle 池中最小空闲连接数量。默认值10</p></li><li><p>pool-name 连接池的名字</p></li><li><p>auto-commit 是否自动提交池中返回的连接。默认值为true。</p></li><li><p>idle-timeout 空闲时间。仅在minimum-idle小于maximum-poop-size的时候才会起作用。默认值10分钟。</p></li><li><p>max-lifetime 连接池中连接的最大生命周期。当连接一致处于闲置状态时，数据库可能会主动断开连接。</p></li><li><p>connection-timeout 连接超时时间。默认值为30s，可以接收的最小超时时间为250ms。但是连接池请求也可以自定义超时时间。</p></li></ul><h1 id="第6章-JDBC获取连接与关闭连接工具类实现"><a href="#第6章-JDBC获取连接与关闭连接工具类实现" class="headerlink" title="第6章 JDBC获取连接与关闭连接工具类实现"></a>第6章 JDBC获取连接与关闭连接工具类实现</h1><p>​    通过上面案例需求我们会发现每次去执行SQL语句都需要注册驱动，获取连接，得到Statement，以及释放资源。发现很多重复的劳动，我们可以将重复的代码定义到某个类的方法中。直接调用方法，可以简化代码。<br>​    那么我们接下来定义一个<code>JDBCUtil</code>类。把注册驱动，获取连接，得到Statement，以及释放资源的代码放到这个类的方法中。以后直接调用方法即可。</p><h2 id="6-1-编写JDBC工具类步骤"><a href="#6-1-编写JDBC工具类步骤" class="headerlink" title="6.1 编写JDBC工具类步骤"></a>6.1 编写JDBC工具类步骤</h2><ol><li>将固定字符串定义为常量</li><li>在静态代码块中注册驱动(只注册一次)</li><li>提供一个获取连接的方法<code>static Connection getConneciton();</code></li><li>定义关闭资源的方法<code>close(Connection conn, Statement stmt, ResultSet rs)</code></li><li>重载关闭方法<code>close(Connection conn, Statement stmt)</code></li></ol><h2 id="6-2-案例代码"><a href="#6-2-案例代码" class="headerlink" title="6.2 案例代码"></a>6.2 案例代码</h2><p><code>JDBCUtil.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manman.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zaxxer.hikari.HikariConfig;</span><br><span class="line"><span class="keyword">import</span> com.zaxxer.hikari.HikariDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gaoziman</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/15 19:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///jdbc?serverTimezone=UTC&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HikariDataSource dataSource;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未加载到配置文件，使用默认配置&quot;</span>);</span><br><span class="line">            properties.setProperty(<span class="string">&quot;driverClassName&quot;</span>, driverClass);</span><br><span class="line">            properties.setProperty(<span class="string">&quot;jdbcUrl&quot;</span>, url);</span><br><span class="line">            properties.setProperty(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">            properties.setProperty(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>(properties);</span><br><span class="line">        dataSource = <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">      <span class="doctag">@return</span>0000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回收连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">evictConnection</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">        dataSource.evictConnection(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(String sql,Class&lt;T&gt; c)</span> &#123;</span><br><span class="line">        List&lt;T&gt; tlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             conn = dataSource.getConnection();</span><br><span class="line">            <span class="comment">//3、获取预编译对象</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 4、执行SQL</span></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 5、处理结果集</span></span><br><span class="line">            <span class="type">List</span> <span class="variable">tList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取结果集元数据</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">md</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">//  获得总列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCounts</span> <span class="operator">=</span> md.getColumnCount();</span><br><span class="line">            <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">                <span class="comment">//   根据反射创建对象 将每一行的数据封装到一个对象中 这里在外层通过反射创建对象</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=columnCounts ; i++) &#123;</span><br><span class="line">                    <span class="comment">//     获取结果集中每一行每一列中的数据</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">cellValue</span> <span class="operator">=</span> rs.getObject(i);</span><br><span class="line">                    <span class="comment">//      结果集中的每一列的列名 == 实体类中的属性名 这里可以通过使用反射给属性名赋值</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> md.getColumnName(i);</span><br><span class="line">                    <span class="comment">//      根据属性名来获取属性的代理对象</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> c.getDeclaredField(columnName);</span><br><span class="line">                    f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cellValue != <span class="literal">null</span>)</span><br><span class="line">                        f.set(t, cellValue);</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="comment">//        将这些字段封装到对象中</span></span><br><span class="line">                    tList.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//返回集合</span></span><br><span class="line">            JdbcUtils.evictConnection(conn);</span><br><span class="line">            <span class="keyword">return</span> tList;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增删改操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql , Object... params)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        conn = JdbcUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    3、获取预编译对象</span></span><br><span class="line">         ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//设置参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;params.length ; i++) &#123;</span><br><span class="line">            ps.setObject(i+<span class="number">1</span>,params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//    4、执行SQL</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">        JdbcUtils.evictConnection(conn);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第7章-三层架构的设计原则"><a href="#第7章-三层架构的设计原则" class="headerlink" title="第7章 三层架构的设计原则"></a>第7章 三层架构的设计原则</h1><p>​        三层架构(3-tier architecture) ，通常意义上的三层架构就是将整个业务应用划分为：表示层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了 “<strong>高内聚低耦合</strong>” 的思想。</p><p>​        在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。推荐的分层式结构一般分为三层，从上至下分别为：<strong>表示层、业务逻辑层（又或称为领域层）、数据访问层</strong>。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/u=2241965189,1328553484&amp;fm=15&amp;gp=0.jpg" alt="img"></p><p><strong>1、表现层(UI)：</strong>通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。</p><p><strong>2、业务逻辑层(BLL)：</strong>针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。 　　</p><p><strong>3、数据访问层(DAL)：</strong>该层所做事务直接操作数据库，针对数据的增添、删除、修改、查找等。</p><p><strong>表示层</strong></p><p>位于最外层(最上层)，离用户最近。用于显示数据和接收用户输入的数据，为用户提供一种交互式操作的界面。</p><p><strong>业务逻辑层</strong></p><p><strong>业务逻辑层(Business Logic Layer)</strong>无疑是系统架构中体现核心价值的部分。它的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求有关的系统设计，也即是说它是与系统所应对的领域(Domain)逻辑有关，很多时候，也将业务逻辑层称为领域层。</p><p>例如Martin Fowler在《Patterns of Enterprise Application Architecture》一书中，将整个架构分为三个主要的层：表示层、领域层和数据源层。作为领域驱动设计的先驱Eric Evans，对业务逻辑层作了更细致地划分，细分为应用层与领域层，通过分层进一步将领域逻辑与领域逻辑的解决方案分离。</p><p>业务逻辑层在体系架构中的位置很关键，它处于数据访问层与表示层中间，起到了数据交换中承上启下的作用。由于层是一种弱耦合结构，层与层之间的依赖是向下的，底层对于上层而言是“无知”的，改变上层的设计对于其调用的底层而言没有任何影响。</p><p>如果在分层设计时，遵循了面向接口设计的思想，那么这种向下的依赖也应该是一种弱依赖关系。因而在不改变接口定义的前提下，理想的分层式架构，应该是一个支持可抽取、可替换的“抽屉”式架构。正因为如此，业务逻辑层的设计对于一个支持可扩展的架构尤为关键，因为它扮演了两个不同的角色。</p><p>对于数据访问层而言，它是调用者;对于表示层而言，它却是被调用者。依赖与被依赖的关系都纠结在业务逻辑层上，如何实现依赖关系的解耦，则是除了实现业务逻辑之外留给设计师的任务。</p><p><strong>数据层</strong></p><p><strong>数据访问层（Data Access Layer）</strong>：有时候也称为是持久层，其功能主要是负责数据库的访问，可以访问数据库系统、二进制文件、文本文档或是XML文档。</p><p>简单的说法就是实现对数据表的Select，Insert，Update，Delete的操作。如果要加入ORM的元素，那么就会包括对象和数据表之间的mapping，以及对象实体的持久化。</p><p><strong>优缺点</strong></p><p><strong>优点</strong></p><p>1、开发人员可以只关注整个结构中的其中某一层;</p><p>2、可以很容易的用新的实现来替换原有层次的实现;</p><p>3、可以降低层与层之间的依赖;</p><p>4、有利于标准化;</p><p>5、利于各层逻辑的复用。</p><p>6、结构更加的明确</p><p>7、在后期维护的时候，极大地降低了维护成本和维护时间</p><p><strong>缺点</strong></p><p>1、降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。</p><p>2、有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。</p><p>3、增加了开发成本。</p><p><strong>规则</strong></p><p>三层结构的程序不是说把项目分成DAL, BLL, WebUI三个模块就叫三层了, 下面几个问题在你的项目里面：</p><ol><li><p><strong>UILayer里面只有少量(或者没有)SQL语句或者存储过程调用, 并且这些语句保证不会修改数据?</strong></p></li><li><p><strong>如果把UILayer拿掉, 你的项目还能在Interface/API的层次上提供所有功能吗?</strong></p></li><li><p><strong>你的DAL可以移植到其他类似环境的项目吗?</strong></p></li><li><p><strong>三个模块, 可以分别运行于不同的服务器吗?</strong></p></li></ol><p>如果不是所有答案都为YES, 那么你的项目还不能算是严格意义上的三层程序. 三层程序有一些需要约定遵守的规则：　</p><ol><li><p>最关键的, UI层只能作为一个外壳, 不能包含任何BizLogic的处理过程</p></li><li><p>设计时应该从BLL出发, 而不是UI出发. BLL层在API上应该实现所有BizLogic, 以面向对象的方式</p></li><li><p>不管数据层是一个简单的SqlHelper也好, 还是带有Mapping过的Classes也好, 应该在一定的抽象程度上做到系统无关</p></li><li><p>不管使用<code>COM+(</code>Enterprise Service), 还是<code>Remoting,</code> 还是<code>WebService</code>之类的远程对象技术, 不管部署的时候是不是真的分别部署到不同的服务器上, 最起码在设计的时候要做这样的考虑, 更远的, 还得考虑多台服务器通过负载均衡作集群</p></li></ol><p>所以考虑一个项目是不是应该应用三层/多层设计时, 先得考虑下是不是真的需要? 实际上大部分程序就开个WebApplication就足够了, 完全没必要作的这么复杂. 而多层结构, 是用于解决真正复杂的项目需求的。</p><h1 id="第8章-以用户登录为例解析三层架构逻辑实现"><a href="#第8章-以用户登录为例解析三层架构逻辑实现" class="headerlink" title="第8章 以用户登录为例解析三层架构逻辑实现"></a>第8章 以用户登录为例解析三层架构逻辑实现</h1><p>​        要以三层架构来实现一个业务，我们要从几个方面入手，按先后顺序来区分：</p><p>​            1、分析需求</p><p>​            2、拆解业务逻辑</p><p>​            3、确定调用关系</p><p>​            4、定义接口</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702092155503.png" alt="image-20200702092155503"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702092126026.png" alt="image-20200702092126026"></p><p>定义接口：</p><p>表示层：</p><blockquote><p>​    采集用户输入(输入：String用户名，String密码，<br>​                  输出：user对象(包含username和password属性))<br>​    显示登录信息(输入：login对象，输出：String login.loginStatus值)</p><p>​    显示错误信息(输入：login对象，输出：String login.errorInfo值)</p><p>1、思考：我们用scan对象来获取用户输入，为什么接口方法不定义成<br>(输入：scan对象或无输入对象，输出：user对象)？</p><p>2、思考：显示登录信息的输出，为什么不用login对象，而是要输出login.loginStatus的值？</p></blockquote><p>逻辑层：</p><blockquote><p>​    校验用户密码，生成登录状态<br>​        (输入：user对象,<br>​         输出：login对象(包含loginStatus和errorInfo属性))</p><p>​                  判断是否允许登录<br>​        (输入：login对象，<br>​         输出：boolean)</p><p>3、思考：校验用户密码方法的输入为什么不定义成接受拼好的查询SQL ?</p></blockquote><p>数据访问层：</p><blockquote><p>​    查询用户密码<br>​        (输入：user对象,<br>​         输出：String password) 如果没查到用户，返回null，否则返回数据库中             存的密码。)</p><p>​                  判断是否允许登录<br>​        (输入：login对象，<br>​         输出：boolean)</p><p>4、思考：查询用户密码，为什么不直接返回是否登录成功的true或false ?</p></blockquote><p>思考解答：</p><blockquote><p>1、考虑封装的通用性，scan是命令行实现，如果是web实现，则需要使用request对象，这样接口就做不到通用</p><p>2、输出也要考虑通用性，如果输出login对象，那么需要在表现层的其他方法或更上层中拆解login对象。如果是web页面带模板解析，还能拆解对象，但是命令行的展现终端是System.out，不具备拆解能力。</p><p>3、如果在逻辑层拼好sql，那么数据访问层只能使用数据库，不能适应文本文件存储底层的情况。</p><p>4、如果使用单点登录等框架，还可能需要调用远程方法来判断登录，这样可以预留实现空间。</p><p>​      三层架构功能要区分清晰，不要混淆。要尽量考虑可扩展性，哪怕牺牲复杂度。</p></blockquote><h1 id="第9章-数据访问层DAO实现"><a href="#第9章-数据访问层DAO实现" class="headerlink" title="第9章 数据访问层DAO实现"></a>第9章 数据访问层DAO实现</h1><h3 id="数据访问层概念"><a href="#数据访问层概念" class="headerlink" title="数据访问层概念"></a>数据访问层概念</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/aaa.png" alt="aaa"></p><blockquote><p>数据持久化目标：<br>      可以是数据库，也可以是普通文件，或xml。<br>      还可以是云端设备等，</p><p>设计数据访问层的一个目的就是<br>     可以广泛适应各种持久化设备，把设计复杂度屏蔽在层的内部，抽取出简单的接口供上层使用。</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702100823312.png" alt="image-20200702100823312"></p><p>​        如果不采用持久层设计，则导致业务代码与数据访问代码紧密耦合，可读性差，不利于后期修改和维护，不利于代码复用。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702101058913.png" alt="image-20200702101058913"></p><p>​        采用数据访问层后，可以把数据访问代码封装在层内部，从而对上层调用屏蔽实现细节，提高系统适应性，提供代码复用率。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702101336596.png" alt="image-20200702101336596"></p><p>​        通过针对数据访问层接口编程，可以在同一接口下实现不同数据库的持久类，从而简化上层调用，提高系统可扩展性。</p><h3 id="什么是DAO"><a href="#什么是DAO" class="headerlink" title="什么是DAO"></a>什么是DAO</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702143651922.png" alt="image-20200702143651922"></p><blockquote><p>1）、DAO全称是（Data Access Objects) ，数据库访问对象，主要的功能就是用于进行数据操作的，在程序的标准开发架构中属于数据访问层的操作。</p><p>2）、DAO层一般有接口和该接口的实现类！ 接口用于规范实现类！ 实现类一般用于用于操作数据库！ 一般操作修改，添加，删除数据库操作的步骤很相似，就写了一个公共类DAO类 ，修改，添加，删除数据库操作时 直接调用公共类DAO类！</p></blockquote><p>​        DAO设计模式可以减少代码量，增强程序的可移植性，提高代码的可读性。在整个DAO中实际上都是以接口为操作标准的，即：客户端依靠DAO实现的接口进行操作，而服务端要将接口进行具体的实现。DAO由以下几个部分组成。</p><p>1）、VO实体类：主要由属性、setter、getter方法组成，VO类中的属性与表中的字段相对应，每一个VO类的对象都表示表中的每一条记录，即包含属性和表中字段完全对应的类。</p><p>2）、DAO接口：主要定义操作的接口，定义一系列数据库的原子性操作，例如：增加、修改、删除、按ID查询等，即提供了用户所有的操作方法（就如老师给学生提供一些学习方法）。</p><p>3）、Impl(DAO实现类)： DAO接口的真实实现类，完成具体的数据库操作，但是不负责数据库的打开和关闭，即实现DAO中所有的方法（就如老师给提供的方法看你如何去完成）；</p><p>4）、DatabaseConnection数据库连接类: 专门负责数据库操作的类，即连接数据库并获取连接对象，执行SQL。</p><h3 id="如何实现数据访问层"><a href="#如何实现数据访问层" class="headerlink" title="如何实现数据访问层"></a>如何实现数据访问层</h3><h4 id="实现实体类"><a href="#实现实体类" class="headerlink" title="实现实体类"></a>实现实体类</h4><p><strong>实体类的特征：</strong></p><blockquote><p>​        1.属性一般用private修饰（getter/setter方法——-用public修饰）；</p><p>​        2.最好实现java.io.Serializable接口支持序列化机制，可以将该对象转换成字节序列而保存在磁盘上或在网络上传输；</p><p>​        3.对实体类提供无参构造方法，根据业务需要提供相应的有参构造方法；</p><p>​        4.定义属性serialVersionUID，解决不同版本之间的序列化问题（可选）</p><p>​           (private static final long serialVersionUID=2070056025956126480L)</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200702144730677.png" alt="image-20200702144730677"></p><p><strong>其次要实现接口类</strong></p><blockquote><p>​        接口类的定义要根据业务需求，在逻辑层的调用需求，都需要在接口层定义相应的接口。<br>​        只要是实现了此接口的实现类，都可以在逻辑层被正常调用，这样就实现了底层实现类更新扩展替换，而不影响到逻辑层代码的目的。</p></blockquote><p><strong>然后要实现接口的实现类</strong></p><blockquote><p>​         接口的实现类具体实现接口逻辑，根据底层存储的不同，可以有多种不同的实现类，每个实现类对应一种底层存储。最后要实现数据库操作工具类。避免数据库连接和关闭代码的重复使用，方便修改。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;悉知JDBC&quot;&gt;&lt;a href=&quot;#悉知JDBC&quot; class=&quot;headerlink&quot; title=&quot;悉知JDBC&quot;&gt;&lt;/a&gt;悉知JDBC&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https://blog.csdn.net/qq_</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>初识MySQL索引</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E5%88%9D%E8%AF%86MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E5%88%9D%E8%AF%86MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2022-10-16T14:51:37.000Z</published>
    <updated>2022-10-16T14:55:58.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识MySQL索引"><a href="#初识MySQL索引" class="headerlink" title="初识MySQL索引"></a>初识MySQL索引</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><blockquote><p>索引这个东西，在我还没接触到MySQL的学习中，就已经听到无数次了，现在正好赶上了MySQL阶段的学习，那就一起来啃一啃索引这个硬骨头!!!</p></blockquote><p>可以毫不夸张的说，系统中 SQL 的好坏，是能直接决定你系统的快慢的。但是在优化之前大家是否想过一个问题？</p><p>那就是：<code>我们优化的原则是什么？</code> <code>优化SQL的理论基础是什么？</code></p><p>所以说了这么多只想告诉大家，在真正的开始索引优化之前，我们需要彻底搞明白索引的原理。这样再谈优化你将觉得更丝滑~</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220812222205065.png" alt="image-20220812222205065"></p><h1 id="1-索引的本质"><a href="#1-索引的本质" class="headerlink" title="1.索引的本质"></a>1.索引的本质</h1><p>索引的本质是一种排好序的数据结构。这个我相信其实大家并不陌生，因为谈到索引很多人自然而然的就会联想到字典中或者是文章中的目录。</p><p><strong>下面谈谈我对索引的看法吧</strong></p><blockquote><p>索引是对数据库表中的字段 （可以是一个字段也可以是多个字段）的值进行排序的数据结构。索引就像一个数的目录一样，可以快速访问我们想要访问的目录，在数据库中就是可以快速访问到数据库表中具有一定特点的数据信息。这个只是索引的表面，实际上索引的底层是一些高级的数据结构，只不过我们看不到，在数据库中已经帮我们写好了，在数据库中其实有很多种类的数据结构，常见的有<code>平衡二叉树</code>，<code>红黑树</code>，<code>Hash表</code>，<code>B+树</code>等，但是在MySQL数据库中主要是<strong>B+树</strong>。</p></blockquote><h2 id="1️⃣索引的优缺点"><a href="#1️⃣索引的优缺点" class="headerlink" title="1️⃣索引的优缺点"></a>1️⃣索引的优缺点</h2><p>索引可以大大提高MySQL的检索速度，为什么不对表中的每一个列创建一个索引呢？</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><code>优点</code></h3><ol><li>索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>索引可以帮助服务器避免排序和创建临时表</li><li>索引可以将随机IO变成顺序IO</li><li>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性</li><li>关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><code>缺点</code></h3><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那</li><li>需要占用的空间会更大</li><li>对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度</li><li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li><li>对于非常小的表，大部分情况下简单的全表扫描更高效；</li></ol><h2 id="2️⃣创建索引准则"><a href="#2️⃣创建索引准则" class="headerlink" title="2️⃣创建索引准则"></a>2️⃣创建索引准则</h2><p>索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><h3 id="应该创建索引的列"><a href="#应该创建索引的列" class="headerlink" title="应该创建索引的列"></a><code>应该创建索引的列</code></h3><ul><li>在经常需要搜索的列上，可以加快搜索的速度</li><li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li><li>在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度</li><li>在经常需要根据范围（&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范是连续的</li><li>在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ul><h3 id="不该创建索引的列"><a href="#不该创建索引的列" class="headerlink" title="不该创建索引的列"></a><code>不该创建索引的列</code></h3><ul><li>对于那些在查询中很少使用或者参考的列不应该创建索引。</li><li>若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>对于那些只有很少数据值或者重复值多的列也不应该增加索引。</li><li>这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，<code>即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</code></li><li>对于那些定义为text, image和bit数据类型的列不应该增加索引。这些列的数据量要么相当大，要么取值很少。</li><li>当该列修改性能要求远远高于检索性能时，不应该创建索引。<strong>（修改性能和检索性能是互相矛盾的）</strong></li></ul><h1 id="2-索引的分类"><a href="#2-索引的分类" class="headerlink" title="2.索引的分类"></a>2.索引的分类</h1><h2 id="2-1-主键索引"><a href="#2-1-主键索引" class="headerlink" title="2.1 主键索引"></a>2.1 主键索引</h2><blockquote><p>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(column_list); </span><br></pre></td></tr></table></figure><h2 id="2-2-唯一索引"><a href="#2-2-唯一索引" class="headerlink" title="2.2 唯一索引"></a>2.2 唯一索引</h2><blockquote><p>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX IndexName <span class="keyword">ON</span> `TableName` (`字段名`(length));</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list); </span><br></pre></td></tr></table></figure><h2 id="2-3-普通索引"><a href="#2-3-普通索引" class="headerlink" title="2.3 普通索引"></a>2.3 普通索引</h2><blockquote><p>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IndexName <span class="keyword">ON</span> `TableName`(`字段名`(length));</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> INDEX IndexName(`字段名`(length));</span><br></pre></td></tr></table></figure><h2 id="2-4-全局索引"><a href="#2-4-全局索引" class="headerlink" title="2.4 全局索引"></a>2.4 全局索引</h2><blockquote><p>全文索引：它查找的是文本中的关键词，主要用于全文检索。<code>一般很少用</code></p></blockquote><p>全文索引：FULLTEXT索引用于全文搜索。只有InnoDB和 MyISAM存储引擎支持，FULLTEXT索引仅适用于 CHAR， VARCHAR和 TEXT列。</p><p>​        <code>创建全文索引</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tc_10;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_10(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  fulltext i_tc10_a(bbb)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_10 <span class="keyword">add</span> fulltext i_tc10_b(bbb);</span><br></pre></td></tr></table></figure><p>​        删除全文索引，与删除普通索引一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index i_tc10_b on tc_10;</span><br></pre></td></tr></table></figure><h1 id="3-操作索引"><a href="#3-操作索引" class="headerlink" title="3. 操作索引"></a>3. 操作索引</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">索引名称 index_name 是可以省略的，省略后，索引的名称和索引列名相同。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建普通索引 </span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建普通组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name_1,col_name_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建唯一组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name(col_name_1,col_name_2);</span><br></pre></td></tr></table></figure><h2 id="修改表结构创建索引"><a href="#修改表结构创建索引" class="headerlink" title="修改表结构创建索引"></a>修改表结构创建索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(col_name);</span><br></pre></td></tr></table></figure><h2 id="创建表时直接指定索引"><a href="#创建表时直接指定索引" class="headerlink" title="创建表时直接指定索引"></a>创建表时直接指定索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    col_name <span class="type">VARCHAR</span> (<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX index_name (col_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><p><strong>删除唯一索引的方法与删除普通索引相同。</strong></p><h2 id="其它相关命令"><a href="#其它相关命令" class="headerlink" title="其它相关命令"></a>其它相关命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">desc</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看生成表的SQL</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看索引信息（包括索引结构等）</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span>  table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看SQL执行时间（精确到小数点后8位）</span></span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">SQL...</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识MySQL索引&quot;&gt;&lt;a href=&quot;#初识MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;初识MySQL索引&quot;&gt;&lt;/a&gt;初识MySQL索引&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https://blog.</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>一文了解视图、存储过程、触发器</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2022-10-16T14:51:18.000Z</published>
    <updated>2022-10-16T14:55:58.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文了解视图、存储过程、触发器"><a href="#一文了解视图、存储过程、触发器" class="headerlink" title="一文了解视图、存储过程、触发器"></a>一文了解视图、存储过程、触发器</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h1 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h1><h4 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h4><p>​        视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。</p><p>　　通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用查询动态生成。</p><p>​        基表：用来创建视图的表叫做基表 base table。</p><h4 id="为什么要使用视图"><a href="#为什么要使用视图" class="headerlink" title="为什么要使用视图"></a>为什么要使用视图</h4><p>​        因为视图的诸多优点，如下</p><p>　　1）简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</p><p>　　2）安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</p><p>　　3）数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</p><p>总而言之，使用视图的大部分情况是为了<strong>保障数据安全性，提高查询效率。</strong></p><h4 id="如何创建视图"><a href="#如何创建视图" class="headerlink" title="如何创建视图"></a>如何创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><blockquote><p>1）OR REPLACE：表示替换已有视图</p><p>2）ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p><p>3）select_statement：表示select语句</p><p>4）[WITH [CASCADED | LOCAL] CHECK OPTION]：表示视图在更新时保证在视图的权限范围之内</p><p>　　cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件</p><p>​        local表示更新视图的时候，要满足该视图定义的一个条件即可。</p></blockquote><p>例子：创建单表视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_stu1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v_stu1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_stu2 <span class="keyword">as</span> <span class="keyword">select</span> sid, sname <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v_stu2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_stu3(学生编号, 学生姓名) <span class="keyword">as</span> <span class="keyword">select</span> sid, sname <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v_stu3;</span><br></pre></td></tr></table></figure><p>例子：创建多表关联视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_tc1 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> tname, cname <span class="keyword">from</span> teacher, course <span class="keyword">where</span> tid<span class="operator">=</span>teacher_id;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_tc2(教师名称，担任课程) <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> tname, cname <span class="keyword">from</span> teacher, course <span class="keyword">where</span> tid<span class="operator">=</span>teacher_id;</span><br></pre></td></tr></table></figure><p>​        视图将我们不需要的数据过滤掉，将相关的列名用我们自定义的列名替换。视图作为一个访问接口，不管基表的表结构和表名有多复杂。</p><p> 　    如果创建视图时不明确指定视图的列名，那么列名就和定义视图的select子句中的列名完全相同；</p><p>　　如果显式的指定视图的列名就按照指定的列名。</p><p><strong>注意：显示指定视图列名，要求视图名后面的列的数量必须匹配select子句中的列的数量。</strong></p><p>​        视图存在2种执行算法。</p><blockquote><p>​        marge：合并的执行方式，指在执行视图时，将视图的sql语句与外部查询视图的sql混合在一起，一次执行。</p><p>​        temptable：临时表模式，在执行视图时，先执行视图的sql语句，生成一个临时表，再在临时表的基础上执行查询视图的sql。</p><p>​        undefined：未定义模式，mysql会在创建时，自动确定使用哪种执行算法。</p></blockquote><h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><p>​        视图一旦创建完毕，就可以像一个普通表那样使用，视图主要用来查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_name;</span><br></pre></td></tr></table></figure><p>​        还可以使用 show create view 语句查看视图信息。</p><p>​        查看库中存在哪些视图。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.views <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="更改视图"><a href="#更改视图" class="headerlink" title="更改视图"></a>更改视图</h4><p>​        CREATE OR REPLACE VIEW语句修改视图</p><p>​        基本格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> view_name <span class="keyword">as</span> <span class="keyword">select</span>语句;</span><br></pre></td></tr></table></figure><p>​        <strong>在视图存在的情况下可对视图进行修改，视图不存在的情况下可创建视图。</strong></p><p>​        还可以使用ALTER语句修改视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span></span><br><span class="line">    [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line">    [DEFINER <span class="operator">=</span> &#123; <span class="keyword">user</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> &#125;]</span><br><span class="line">    [<span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">    [<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>​        注意：修改视图是指修改数据库中已存在的表的定义，当基表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致。</p><h4 id="操作视图数据"><a href="#操作视图数据" class="headerlink" title="操作视图数据"></a>操作视图数据</h4><p>​        <strong>因为视图本身没有数据，因此对视图进行的dml操作最终都体现在基表中</strong></p><p>​        当然，视图的DML操作，不是所有的视图都可以做DML操作。</p><p>有下列内容之一，视图不能做DML操作：</p><blockquote><p>　　　　①select子句中包含distinct</p><p>　　　　②select子句中包含组函数</p><p>　　　　③select语句中包含group by子句</p><p>　　　　④select语句中包含order by子句</p><p>　　　　⑤select语句中包含union 、union all等集合运算符</p><p>　　　　⑥where子句中包含相关子查询</p><p>　　　　⑦from子句中包含多个表</p><p>　　　　⑧如果视图中有计算列，则不能更新</p><p>　　　　⑨如果基表中有某个具有非空约束的列未出现在视图定义中，则不能做insert操作</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_stu4 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> v_stu4 <span class="keyword">values</span>(<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;赵四&#x27;</span>,<span class="string">&#x27;2002-2-3&#x27;</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> v_stu4 <span class="keyword">where</span> sid<span class="operator">=</span><span class="number">18</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h4 id="drop删除视图"><a href="#drop删除视图" class="headerlink" title="drop删除视图"></a>drop删除视图</h4><p>　　删除视图是指删除数据库中已存在的视图，删除视图时，只能删除视图的定义，不会删除数据，也就是说不动基表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_name [, view_name] ...</span><br></pre></td></tr></table></figure><h4 id="使用WITH-CHECK-OPTION约束"><a href="#使用WITH-CHECK-OPTION约束" class="headerlink" title="使用WITH CHECK OPTION约束"></a>使用WITH CHECK OPTION约束</h4><p>​        对于可以执行DML操作的视图，定义时可以带上WITH CHECK OPTION约束</p><p>​        作用：对视图所做的DML操作的结果，不能违反视图的WHERE条件的限制。</p><p>​        示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_stu5 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> birthday <span class="operator">&gt;</span> <span class="string">&#x27;2005-1-1&#x27;</span> <span class="keyword">with</span> <span class="keyword">check</span> option;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> v_stu5 <span class="keyword">values</span>(<span class="number">19</span>,<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;孙五&#x27;</span>,<span class="string">&#x27;2002-2-3&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>MySQL 5.0 版本开始支持存储过程。</p><p>​        <strong>存储过程（Stored Procedure）</strong>是一种在数据库中存储的复杂程序，以便外部程序调用的一种数据库对象。</p><p>​        存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>​        存储过程思想上很简单，就是数据库 SQL 语言层面的<strong>代码封装与重用</strong>。</p><p>​        <strong>存储过程通常有以下优点：</strong></p><p>​        存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>​        存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p><p>​        存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p><p>​        存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。</p><p>​        存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p><p>​        <strong>存储过程的缺点</strong></p><p>​        存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</p><p>​        存储过程的性能调校与撰写，受限于各种数据库系统。</p><h4 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">    [DEFINER <span class="operator">=</span> &#123; <span class="keyword">user</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> &#125;]</span><br><span class="line">　<span class="keyword">PROCEDURE</span> sp_name ([proc_parameter[,...]])</span><br><span class="line">    [characteristic ...] routine_body</span><br><span class="line"><span class="comment">-- 声明过程名称、参数列表</span></span><br><span class="line"> </span><br><span class="line">proc_parameter:</span><br><span class="line">    [ <span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">INOUT</span> ] param_name type</span><br><span class="line"> </span><br><span class="line">characteristic:</span><br><span class="line">    COMMENT <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  <span class="operator">|</span> <span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line">  <span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line">  <span class="operator">|</span> &#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line">  <span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="comment">-- 这是附加的一些存储过程描述信息，一般很少使用，这里不做详解</span></span><br><span class="line"> </span><br><span class="line">routine_body:</span><br><span class="line">　　Valid <span class="keyword">SQL</span> routine statement</span><br><span class="line"><span class="comment">-- SQL路由描述，一般也很少使用</span></span><br><span class="line"> </span><br><span class="line">[begin_label:] <span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 开始存储过程标记</span></span><br><span class="line">　　[statement_list]</span><br><span class="line"><span class="comment">-- 存储过程主体</span></span><br><span class="line">　　　　……　　　</span><br><span class="line"><span class="keyword">END</span> [end_label]</span><br><span class="line"><span class="comment">-- 结束存储过程标记</span></span><br></pre></td></tr></table></figure><h4 id="一个最简单的无参数存储过程示例"><a href="#一个最简单的无参数存储过程示例" class="headerlink" title="一个最简单的无参数存储过程示例"></a>一个最简单的无参数存储过程示例</h4><p>​        我们来创建一个最简单的存储过程，没有入参出参、内部只有一条语句，向测试表中插入一条语句。</p><p>​        数据准备:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ptest_01(</span><br><span class="line">  pid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">pname <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_01()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> p_01();</span><br></pre></td></tr></table></figure><h4 id="带有入参的存储过程示例"><a href="#带有入参的存储过程示例" class="headerlink" title="带有入参的存储过程示例"></a>带有入参的存储过程示例</h4><p>​        在存储过程中传参分 <strong>in ,out , inout</strong> 三种</p><p>​        <strong>in 可以输出从外部传入的变量 不会改变传进变量本来的值</strong></p><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_02(<span class="keyword">in</span> name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(name);</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name1;</span><br><span class="line">  <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name2;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@name</span><span class="operator">=</span><span class="string">&#x27;www&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> p_02(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ptest_01;</span><br></pre></td></tr></table></figure><p>​        可以发现，<strong>in 参数在过程体中被改变后，改变的值不能带出过程体，过程体外还是原值。</strong></p><h4 id="带有出参的存储过程示例"><a href="#带有出参的存储过程示例" class="headerlink" title="带有出参的存储过程示例"></a>带有出参的存储过程示例</h4><p>​        <strong>out 不能输出从外部传进的值 会改变传进变量本来的值</strong></p><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_03(<span class="keyword">out</span> name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(name);</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name1;</span><br><span class="line">  <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name2;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@name</span><span class="operator">=</span><span class="string">&#x27;rrr&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> p_03(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ptest_01;</span><br></pre></td></tr></table></figure><p>​        </p><h4 id="带有出入参的存储过程示例"><a href="#带有出入参的存储过程示例" class="headerlink" title="带有出入参的存储过程示例"></a>带有出入参的存储过程示例</h4><p><strong>inout 既可以从外部传进的值，也可以改变传进变量本来的值</strong></p><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_04(<span class="keyword">inout</span> name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(name);</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name1;</span><br><span class="line">  <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name2;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@name</span><span class="operator">=</span><span class="string">&#x27;rrr&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> p_04(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ptest_01;</span><br></pre></td></tr></table></figure><p>​        可以发现，<strong>inout 参数可以传值进入过程体，过程题内部被赋值后的值可以带出过程体。</strong></p><h4 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h4><p>​        查看某个数据库中建立的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> status <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines</span><br><span class="line"><span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> routine_type<span class="operator">=</span><span class="string">&#x27;PROCEDURE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​        查看创建存储过程的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p_06;</span><br></pre></td></tr></table></figure><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> p_05; </span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p_06; </span><br></pre></td></tr></table></figure><h4 id="存储过程体语法"><a href="#存储过程体语法" class="headerlink" title="存储过程体语法"></a>存储过程体语法</h4><h5 id="变量的声明、引用、赋值"><a href="#变量的声明、引用、赋值" class="headerlink" title="变量的声明、引用、赋值"></a>变量的声明、引用、赋值</h5><p>​        在MySQL编程中，存在两种变量：</p><p>​        <strong>用户变量（可以在过程体内外声明，生存周期为当前会话，两个不同会话之间，同名的变量，不会互相覆盖）。</strong></p><p>​        <strong>局部变量（只能在过程体中声明，离开过程体之后，变量被销毁）。</strong></p><p>​        用户变量不需要声明，可以直接通过赋值来创建变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@aaa</span> <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>​        局部变量使用 declare 关键字声明，使用 set 关键字赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> variable_name [,variable_name...] datatype [<span class="keyword">DEFAULT</span> <span class="keyword">value</span>];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_05()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> abc <span class="type">int</span> <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">set</span> abc <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">select</span> abc;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">select</span> abc;</span><br></pre></td></tr></table></figure><p>​        除了使用 set 赋值，还可以通过 select 语句赋值；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pname <span class="keyword">from</span> ptest_01 limit <span class="number">1</span> <span class="keyword">into</span> <span class="variable">@n1</span>;</span><br><span class="line"><span class="keyword">select</span> pname <span class="keyword">into</span> <span class="variable">@n2</span> <span class="keyword">from</span> ptest_01 limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@n1</span>, <span class="variable">@n2</span>;</span><br><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_06()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> n3, n4 <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;000&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> pname <span class="keyword">from</span> ptest_01 limit <span class="number">1</span> <span class="keyword">into</span> n3;</span><br><span class="line">    <span class="keyword">select</span> pname <span class="keyword">into</span> n4 <span class="keyword">from</span> ptest_01 limit <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">select</span> n3, n4;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_06();</span><br></pre></td></tr></table></figure><p>​        <strong>注意：使用 select 语句赋值时，返回结果集必须是单行单值。</strong></p><h5 id="程序控制结构-分支结构"><a href="#程序控制结构-分支结构" class="headerlink" title="程序控制结构 - 分支结构"></a>程序控制结构 - 分支结构</h5><h6 id="if-then-else-语句"><a href="#if-then-else-语句" class="headerlink" title="if-then-else 语句"></a>if-then-else 语句</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_07(<span class="keyword">in</span> n1 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">if(n1 <span class="operator">&gt;=</span> <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 &gt;= 0&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 &lt; 0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_07();</span><br></pre></td></tr></table></figure><p>​        <strong>跟js中的语法类似，但是分支判断开始时，if的判断逻辑后面要加入 then ，结束时需要加入 end if;</strong></p><h6 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_08(<span class="keyword">in</span> n1 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span>(n1)</span><br><span class="line">  <span class="keyword">when</span>(<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 = 1&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;1111&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;11111&#x27;</span>);</span><br><span class="line">  <span class="keyword">when</span>(<span class="number">2</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 = 2&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;2222&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;22222&#x27;</span>);</span><br><span class="line">  <span class="keyword">when</span>(<span class="number">3</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 = 3&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;3333&#x27;</span>);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;33333&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 = other&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_08();</span><br></pre></td></tr></table></figure><p>​        <strong>与 js 相比，没有  switch 关键字，由 case 代替 switch，when 后面加枚举值，在后面加 then。同时不需要break。结束时加入 end case。</strong></p><h5 id="程序控制结构-循环结构"><a href="#程序控制结构-循环结构" class="headerlink" title="程序控制结构 - 循环结构"></a>程序控制结构 - 循环结构</h5><h6 id="while…end-while-循环"><a href="#while…end-while-循环" class="headerlink" title="while…end while 循环"></a>while…end while 循环</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_11(<span class="keyword">in</span> n1 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> n2 <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> n2 <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">while(n2 <span class="operator">&lt;</span> n1 ) do</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(concat(<span class="string">&#x27;n2 = &#x27;</span>,n2));</span><br><span class="line">  <span class="keyword">set</span> n2 <span class="operator">=</span> n2 <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;while is over.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_11(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>​        <strong>while(判断逻辑表达式) 后面要加 do，结束时写 end while; 类似 js 中的 while 循环 。</strong></p><h6 id="repeat····-end-repea-循环"><a href="#repeat····-end-repea-循环" class="headerlink" title="repeat···· end repea 循环"></a>repeat···· end repea 循环</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_12(<span class="keyword">in</span> n1 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> n3 <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> n3 <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">repeat</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(concat(<span class="string">&#x27;n3 = &#x27;</span>,n3));</span><br><span class="line">  <span class="keyword">set</span> n3 <span class="operator">=</span> n3 <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">  until(n3 <span class="operator">&gt;</span> n1)</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;repeat is over.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_12(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>​        <strong>类型 js 中的 do … while 循环，不判断条件，直接进循环体，在 until 时判断条件，为逻辑真时退出循环。结束时写 end repeat; 关键字。</strong></p><h6 id="loop-·····endloop-循环"><a href="#loop-·····endloop-循环" class="headerlink" title="loop ·····endloop 循环"></a>loop ·····endloop 循环</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_13(<span class="keyword">in</span> n1 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> n4 <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> n4 <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">loop_lable: loop</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(concat(<span class="string">&#x27;n4 = &#x27;</span>,n4));</span><br><span class="line">  <span class="keyword">set</span> n4 <span class="operator">=</span> n4 <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">  if(n4 <span class="operator">&gt;</span> n1) <span class="keyword">then</span> leave loop_lable;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> loop;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;loop is over.&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_13(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>​        <strong>loop 循环本质上是一个死循环，靠循环体中加入强制跳出循环语句，配合标号语句来标记 loop 头部，来结束循环。</strong></p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器（trigger）：监视某种情况，并触发某种操作，它是提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，<strong>它的执行不是由程序调用</strong>，也不是手工启动，而是由事件来触发，例如当对一个表进行操作（ <strong>insert，delete， update</strong>）时就会激活它执行。</p><h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器经常用于加强数据的完整性约束和业务规则等。 触发器依赖于四个要素：<br>​        1.监视地点(table)<br>​        2.监视事件(insert/update/delete)<br>​        3.触发时间(after/before)<br>​        4.触发事件(内部执行逻辑)</p><p>​    完成作用是：</p><p>​        <strong>在写入数据前后，强制检验或者转换数据(保证护数据安全)</strong></p><p>​    错误处理时：</p><p>​        <strong>触发器发生错误时，前面用户已经执行成功的操作会被撤销，类似事务的回滚</strong></p><h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><h5 id="创建语法-1"><a href="#创建语法-1" class="headerlink" title="创建语法"></a>创建语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter $ <span class="operator">/</span><span class="operator">/</span>设置MySQL执行结束标志，默认为;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tg_name  <span class="comment">-- 触发器名称</span></span><br><span class="line">  after<span class="operator">|</span>before  <span class="comment">-- 触发时间</span></span><br><span class="line">  <span class="keyword">insert</span><span class="operator">|</span><span class="keyword">update</span><span class="operator">|</span><span class="keyword">delete</span>  <span class="comment">-- 监视事件 </span></span><br><span class="line">  <span class="keyword">on</span> table_name <span class="comment">-- 监控表名</span></span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  <span class="comment">-- 固定写法</span></span><br><span class="line">  <span class="keyword">begin</span>  <span class="comment">-- 开始触发器内部逻辑</span></span><br><span class="line">    <span class="keyword">update</span> goods <span class="keyword">set</span> num<span class="operator">=</span>num<span class="number">-2</span> <span class="keyword">where</span> gid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>$  <span class="comment">-- 结束触发器内部逻辑</span></span><br><span class="line">delimiter ;  <span class="operator">/</span><span class="operator">/</span>重新将MySQL执行结束标志设置为;</span><br></pre></td></tr></table></figure><p>​        <strong>注意：</strong>因为mysql的执行结束标识默认是;。如果运行以上的sql语句，mysql碰到;时会自动停止执行，然后end语句就执行不到了。所以我们需要先将mysql的结束标识符改为其他的字符，一般都选用$或者$$，这里选用$来作为执行的结束标识。</p><p>​    触发时间：当 SQL 指令发生时，会令行中数据发生变化，而每张表中对应的行有两种状态：数据操作前和操作后</p><p><strong>before</strong>：表中数据发生改变前的状态<br><strong>after</strong>：表中数据发生改变后的状态<br><strong>PS：如果 before 触发器失败或者语句本身失败，将不执行 after 触发器(如果有的话)</strong></p><p>​    触发事件：触发器是针对数据发送改变才会被触发，对应的操作只有</p><p><strong>INSERT</strong><br><strong>DELETE</strong><br><strong>UPDATE</strong></p><p>注意事项：<br>        触发器名必须在每个表中唯一，但不是在每个数据库中唯一，即同一数据库中的两个表可能具有相同名字的触发器，每个表的每个事件每次只允许一个触发器，因此，每个表最多支持 <strong>6</strong> 个触发器，<strong>before/after insert、before/after delete、before/after update</strong></p><h5 id="简单触发器示例1"><a href="#简单触发器示例1" class="headerlink" title="简单触发器示例1"></a>简单触发器示例1</h5><p>​        订单货品示例，数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods(</span><br><span class="line">  gid <span class="type">int</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  num <span class="type">smallint</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ord(</span><br><span class="line">  oid <span class="type">int</span>,</span><br><span class="line">  gid <span class="type">int</span>,</span><br><span class="line">  much <span class="type">smallint</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;cat&#x27;</span>,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="number">63</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;pig&#x27;</span>,<span class="number">87</span>);</span><br></pre></td></tr></table></figure><p>​        业务目标</p><p>​                在ord订单表新增一条时，将goods表中 gid=1 的货品数量减少2。</p><p>​        触发器逻辑分析</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">监视谁：ord（订单表）</span><br><span class="line">监视动作：<span class="keyword">insert</span>（插入操作）</span><br><span class="line">触发时间：after（在插入操作后触发）</span><br><span class="line">触发事件：<span class="keyword">update</span>（触发更新操作）</span><br></pre></td></tr></table></figure><p>​        创建触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t1 </span><br><span class="line">  after <span class="keyword">insert</span></span><br><span class="line">  <span class="keyword">on</span> ord</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> goods <span class="keyword">set</span> num<span class="operator">=</span>num<span class="number">-2</span> <span class="keyword">where</span> gid <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p>​        我们来检查触发器有没有生效。</p><h5 id="简单触发器示例2"><a href="#简单触发器示例2" class="headerlink" title="简单触发器示例2"></a>简单触发器示例2</h5><p>​        学生成绩示例，数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu (</span><br><span class="line">  stu_id <span class="type">int</span> <span class="keyword">PRIMARY</span> key auto_increment,</span><br><span class="line">  stu_code <span class="type">int</span>,</span><br><span class="line">  stu_name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> sc (</span><br><span class="line">  sc_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  stu_code <span class="type">int</span>,</span><br><span class="line">  stu_score <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​    业务目标 ：</p><p>​        在插入学生表一条记录的时候，插入成绩表一条记录，写入学生编号，成绩为80</p><p>​    触发器逻辑分析</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">监视谁：stu（学生表）</span><br><span class="line">监视动作：<span class="keyword">insert</span>（插入操作）</span><br><span class="line">触发时间：after（在插入操作后触发）</span><br><span class="line">触发事件：<span class="keyword">insert</span>（触发更新操作）</span><br></pre></td></tr></table></figure><p>​    创建触发器</p><p>​        <strong>触发器针对的是数据库中的每一行记录，每行数据在操作前后都会有一个对应的状态，触发器将没有操作之前的状态保存到 old 关键字中，将操作后的状态保存到 new 中</strong>。</p><p>需要注意的是，old 和 new 不是所有触发器都有<br><strong>INSERT型触发器    没有 old，只有 new，new 表示将要(插入前)或者已经增加(插入后)的数据</strong><br><strong>UPDATE型触发器    既有 old 也有 new，old 表示更新之前的数据，new 表示更新之后的数据</strong><br><strong>DELETE型触发器    没有 new，只有 old，old 表示将要(删除前)或者已经被删除(删除后)的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> sc_h (</span><br><span class="line">  sc_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">stu_code <span class="type">int</span>,</span><br><span class="line">  before_update_code <span class="type">int</span>,</span><br><span class="line">after_update_code <span class="type">int</span>,</span><br><span class="line">  before_update_score <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">after_update_score <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t2</span><br><span class="line">  after <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> stu <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> sc(stu_code,stu_score) <span class="keyword">values</span>(new.stu_code, <span class="number">80.0</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t2a</span><br><span class="line">  after <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> sc <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> sc_h(stu_code, before_update_code, after_update_code,</span><br><span class="line">before_update_score,  after_update_score)</span><br><span class="line"><span class="keyword">values</span>(new.stu_code, old.stu_code, new.stu_code,</span><br><span class="line">old.stu_score, new.stu_score);</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p>​        检查一下触发器是否正常工作。</p><h4 id="带传值的触发器"><a href="#带传值的触发器" class="headerlink" title="带传值的触发器"></a>带传值的触发器</h4><h5 id="升级简单触发器1"><a href="#升级简单触发器1" class="headerlink" title="升级简单触发器1"></a>升级简单触发器1</h5><p>​        在 2.2 简单触发器1 中，我们将固定商品的数量减少2，现在我们将升级这个逻辑，将订单中对应商品的数量建少订单中对应的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t3</span><br><span class="line">  after <span class="keyword">insert</span></span><br><span class="line">  <span class="keyword">on</span> ord</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- new 代表 ord 表中新增的数据</span></span><br><span class="line">    <span class="keyword">update</span> goods <span class="keyword">set</span> num <span class="operator">=</span> num <span class="operator">-</span> new.much <span class="keyword">where</span> gid <span class="operator">=</span> new.gid;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><h5 id="进一步升级简单触发器1"><a href="#进一步升级简单触发器1" class="headerlink" title="进一步升级简单触发器1"></a>进一步升级简单触发器1</h5><p>​     如果在订单数量大于商品库存数量时，该怎么办？</p><p>​     这里需要检查库存量与订货数量，当订货量大于库存量时，放弃订单。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t4</span><br><span class="line">  before <span class="keyword">insert</span></span><br><span class="line">  <span class="keyword">on</span> ord</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- 取出 goods 表中对应 id 的库存</span></span><br><span class="line">    <span class="comment">-- new 代表 orders 表中新增的数据</span></span><br><span class="line">    <span class="keyword">select</span> num <span class="keyword">from</span> goods <span class="keyword">where</span> gid <span class="operator">=</span> new.gid <span class="keyword">into</span> <span class="variable">@num</span>;    </span><br><span class="line">    <span class="comment">-- 用即将插入的 orders 表中的库存和 goods 表中的库存进行比较</span></span><br><span class="line">    <span class="comment">-- 如果库存不够，中断操作</span></span><br><span class="line">    if <span class="variable">@num</span> <span class="operator">&lt;</span> new.num <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 中断操作：暴力解决，主动出错</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> xxx <span class="keyword">values</span>(xxx);</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p><strong>如果在触发器中出现错误，那么前面的已经执行的操作也会全部回滚</strong></p><h5 id="升级简单触发器1的另一种方法"><a href="#升级简单触发器1的另一种方法" class="headerlink" title="升级简单触发器1的另一种方法"></a>升级简单触发器1的另一种方法</h5><p>如果在订单数量大于商品库存数量时，我们还可以强制修改订单订货 数量为库存数量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t5</span><br><span class="line">  before <span class="keyword">insert</span></span><br><span class="line">  <span class="keyword">on</span> ord</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> restNum <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">select</span> num <span class="keyword">into</span> restNum <span class="keyword">from</span> goods <span class="keyword">where</span> gid <span class="operator">=</span> new.gid;</span><br><span class="line">    if new.much <span class="operator">&gt;</span> restNum <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">set</span> new.much <span class="operator">=</span> restNum;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">update</span> goods <span class="keyword">set</span> num<span class="operator">=</span>num<span class="operator">-</span>new.much <span class="keyword">where</span> gid<span class="operator">=</span>new.gid;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p>​        <strong>注意</strong>：这里如果使用的是after就会报错，如果使用的是after，就会先执行insert操作，也就是插入订单操作，然后在进行判断下单数量和库存量，得出新的下单数量，可是已经执行了下单操作了，所以就会报错。这里必须使用before操作。</p><h4 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h4><h5 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure><p>​    还可以带上数据库名、表名的条件查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.TRIGGERS <span class="keyword">where</span> trigger_schema<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> event_object_table<span class="operator">=</span><span class="string">&#x27;ord&#x27;</span>;</span><br></pre></td></tr></table></figure><p>   查看创建触发器的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称;</span><br></pre></td></tr></table></figure><h5 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 触发器名称;</span><br></pre></td></tr></table></figure><h5 id="触发器的使用限制"><a href="#触发器的使用限制" class="headerlink" title="触发器的使用限制"></a>触发器的使用限制</h5><p>​        <strong>触发器不是程序员手工调用的，是DBMS自动调用，由对应语句触发。</strong></p><p>​        <strong>MySQL 的触发器中不能对本表进行 insert、update 和 delete 操作，否则会报错</strong></p><p>​        <strong>for each row是干什么的？</strong></p><p>在oracle触发器中，触发器分为行触发器和语句触发器</p><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tn</span><br><span class="line">    after <span class="keyword">update</span></span><br><span class="line">    <span class="keyword">on</span> xxtable</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">    #每一行受影响，触发事件都执行，叫做行触发器</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      sqlN;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span>` `xxtable ``<span class="keyword">set</span>` `xxx<span class="operator">=</span>xxx ``<span class="keyword">where</span>` `id<span class="operator">&gt;</span><span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>该修改操作假设100行，那么sqlN，会触发100次。</p><p>在oracle中，for each row如果不写，无论update语句一次影响了多少行，都只执行一次触发事件。<br>比如：1人下了订单，买了5件商品，insert 5次，可以用行级触发器，修改5次库存；用语句级触发器触发，insert一条发货提醒。<br>遗憾的是mysql目前不支持语句级触发器。</p><p><strong>优点</strong></p><ul><li>触发器可以通过数据库中的关联表实现级联更改，即一张表数据的改变会影响其他表的数据</li><li>可以保证数据安全，并进行安全校验</li></ul><p><strong>缺点</strong></p><ul><li>过分依赖触发器，影响数据库的结构，增加数据库的维护成本</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文了解视图、存储过程、触发器&quot;&gt;&lt;a href=&quot;#一文了解视图、存储过程、触发器&quot; class=&quot;headerlink&quot; title=&quot;一文了解视图、存储过程、触发器&quot;&gt;&lt;/a&gt;一文了解视图、存储过程、触发器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>一文了解MySQL事务</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3MySQL%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-10-16T14:50:55.000Z</published>
    <updated>2022-10-16T14:55:58.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文了解MySQL事务"><a href="#一文了解MySQL事务" class="headerlink" title="一文了解MySQL事务"></a>一文了解MySQL事务</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h1 id="1-事务概述😪"><a href="#1-事务概述😪" class="headerlink" title="1.事务概述😪"></a>1.事务概述😪</h1><h2 id="事务处理-（事务操作）"><a href="#事务处理-（事务操作）" class="headerlink" title="事务处理 （事务操作）"></a>事务处理 （事务操作）</h2><blockquote><p><strong>保证所有的事务都为同一个工作单元来执行，即使出现了任何故障，也不会改变这样的执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。</strong></p></blockquote><p>​    一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的 ：</p><blockquote><p>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如转账操作：A账户要转账给B账户，那么A账户上减少的钱数和B账户上增加的钱数必须一致，也就是说A账户的转出操作和B账户的 </span><br><span class="line">转入操作要么全部执行，要么全不执行；如果其中一个操作出现异常而没有执行的话，就会导致账户A和账户B的转入转出金额不一   </span><br><span class="line">致的情况，为而事实上这种情况是不允许发生的，所以为了防止这种情况的发生，需要使用事务处理。</span><br></pre></td></tr></table></figure><p><strong>当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）; 同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</strong></p><p><strong>当一个数据库事务在执行的过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</strong></p><h1 id="2-数据库事务的特性👀"><a href="#2-数据库事务的特性👀" class="headerlink" title="2.数据库事务的特性👀"></a>2.数据库事务的特性👀</h1><p>以银行转账举例，说明如何通过数据库事务保证数据的准确性和完整性。从帐号A到帐号B需要6个操作：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1422237-20181122103041637-782687204.png" alt="img"></p><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p><blockquote><p>1、从A账号中把余额读出来（500）。<br>2、对A账号做减法操作（500-100）。<br>3、把结果写回A账号中（400）。<br>4、从B账号中把余额读出来（500）。<br>5、对B账号做加法操作（500+100）。<br>6、把结果写回B账号中（600）。</p></blockquote><p>在这个过程中可能会出现以下问题:</p><ol><li>转账操作的第一步执行成功,A账户上的钱减少了100元,但是第二步执行失败或者未执行便发生系统崩溃,导致B账户并没有相应增加100元。</li><li>转账操作刚完成就发生系统崩溃,系统重启恢复时丢失了崩溃前的转账记录。</li><li>同时又另一个用户转账给B账户,由于同时对B账户进行操作,导致B账户金额出现异常。</li></ol><h2 id="事务的ACID属性："><a href="#事务的ACID属性：" class="headerlink" title="事务的ACID属性："></a>事务的ACID属性：</h2><ul><li><p><strong>原子性（Atomicity）</strong></p><blockquote><p>保证上述例子中 1-6所有过程，要么都执行，要么都不执行、一旦在执行某个过程发生问题，就需要执行回滚操作，假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p></blockquote><p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong></p><blockquote><p>在转账之前，A账户和B账户总共有500元 + 500元 = 1000元，在转账之后，A和B的账户中现在有400 + 600=1000元。也就是，说数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p></blockquote><p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong></p><blockquote><p>在A账户向B账户转账的过程中，只要事务没有提交，那么，A账户和B账户的余额就不会有变化。如果在A账户向B账户转账的过程中，C账户也向B账户进行转账，那么最后，B账户的钱是A账户转进来的余额 + C账户转进来的余额 + B账户余额。</p></blockquote><p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong></p><blockquote><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！</p></blockquote><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ul><p>  <strong>关于事务的定义有几点需要注意：</strong></p><ol><li>数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。</li><li>构成逻辑整体的这些数据库操作,要么全部执行成功,要么全部不执行。</li><li>构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不管事务是否执行成功,数据库总能保持一致性状态。</li><li>以上即使在数据库出现故障以及并发事务存在的情况下依然成立。</li></ol><p>  <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1599461002700.png" alt=""></p><h1 id="3-如何实现数据库事务☕"><a href="#3-如何实现数据库事务☕" class="headerlink" title="3.如何实现数据库事务☕"></a>3.如何实现数据库事务☕</h1><p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面</p><ul><li>事务的并发执行</li><li>事务故障或系统故障</li></ul><p>数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。</p><p>并发控制技术保证了<strong>事务的隔离性</strong>,使数据库的一致性状态不会因为并发执行的操作被破坏。<br>日志恢复技术保证了<strong>事务的原子性</strong>,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1422237-20181122103102223-1059881337.png" alt="img"></p><h1 id="4-MySQL中如何开启、提交-、回滚事务🧅"><a href="#4-MySQL中如何开启、提交-、回滚事务🧅" class="headerlink" title="4. MySQL中如何开启、提交 、回滚事务🧅"></a>4. MySQL中如何开启、提交 、回滚事务🧅</h1><p>MYSQL 事务处理主要有两种方法：</p><p>1、用 <code>begin/start transaction</code>, ROLLBACK, COMMIT来实现</p><ul><li><p>begin/start transaction 开始一个事务</p></li><li><p>rollback 事务回滚</p></li><li><p>commit 事务确认</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> sname<span class="operator">=</span><span class="string">&#x27;王军&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li></ul><p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p><ul><li><p><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</p></li><li><p><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> session variables <span class="keyword">like</span> <span class="string">&#x27;autocommit&#x27;</span>;  <span class="comment">--查看自动提交状态</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">--关闭自动提交</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> off;  <span class="comment">--关闭自动提交</span></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> sname<span class="operator">=</span><span class="string">&#x27;飞飞&#x27;</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-事务的隔离级别💧"><a href="#5-事务的隔离级别💧" class="headerlink" title="5. 事务的隔离级别💧"></a>5. 事务的隔离级别💧</h1><h2 id="5-1-事务并发问题"><a href="#5-1-事务并发问题" class="headerlink" title="5. 1 事务并发问题"></a>5. 1 事务并发问题</h2><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><strong>脏读 ： </strong> 对于两个事务 T1 , T2 ,  T1已经读到了事务T2更新但是<strong>还未提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1599461151424.png" alt="1599461151424"></p><ul><li><p><strong>不可重复读 ：</strong> 对于两个事务T1 ， T2 ，  T1读取一个字段之后，T2对该事务进行了 <strong>更新/修改</strong>操作。之后T1再次读取该字段的时候，值就不一样了。</p><p>​                                <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1599461170319.png" alt="1599461170319"></p></li><li><p><strong>幻读 : </strong> 对于两个事物 T1 ， T2 ，T1从表中读取一个字段，此时T2进行<strong>插入/ 删除</strong>了一些新的行， 之后, 如果 T1 再次读取同一个表, 就会多/少几行。</p></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1599461184631.png" alt="1599461184631"></p><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是<code>修改</code>，幻读的重点在于<code>新增或者删除</code>。 </p><p>​    <strong>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p><blockquote><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。 </p><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读 </p></blockquote><h2 id="5-2事务隔离级别"><a href="#5-2事务隔离级别" class="headerlink" title="5.2事务隔离级别"></a>5.2事务隔离级别</h2><h3 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a>2、事务隔离级别</h3><p><strong>数据库事务的隔离性</strong>：数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。<strong>一个事务与其他事务隔离的程度称为隔离级别。</strong>数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p><p><strong>数据库提供的 4 种事务隔离级别：</strong></p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>描述</th></tr></thead><tbody><tr><td>read-uncommitted</td><td>允许A事务读取其他事务未提交和已提交的数据。会出现<strong>脏读、不可重复读、幻读</strong>问题</td></tr><tr><td>read-committed</td><td>只允许A事务读取其他事务已提交的数据。可以避免脏读，但仍然会出现 <strong>不可重复读、幻读</strong> 问题</td></tr><tr><td>repeatable-read</td><td>确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读。但是幻读问题仍然存在。</td></tr><tr><td>serializable</td><td>确保事务可以从一个表中读取相同的行，相同的记录。在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作。所有并发问题都可以避免，但性能十分低下。</td></tr></tbody></table></div><ul><li>Oracle 支持的 2 种事务隔离级别：<strong>READ-COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。</li><li>Mysql 支持 4 种事务隔离级别。 Mysql 默认的事务隔离级别为: <strong>REPEATABLE-READ</strong>。在mysql中REPEATABLE READ的隔离级别也可以避免幻读了。</li></ul><h2 id="5-3-查看事务隔离级别"><a href="#5-3-查看事务隔离级别" class="headerlink" title="5.3 查看事务隔离级别"></a>5.3 查看事务隔离级别</h2><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接。每个数据库连接都有一个变量 @@tx_isolation, 表示当前连接的事务隔离级别。mysql服务也有一个全局变量@@global.tx_isolation，表示所有连接的默认事务隔离级别。</p><ul><li>查看当前mysql连接的隔离级别: </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><ul><li>查看全局的隔离级别：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global.tx_isolation;</span><br></pre></td></tr></table></figure><ul><li>设置当前 mysql连接的隔离级别:  </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tx_isolation <span class="operator">=</span><span class="string">&#x27;repeatable-read&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>设置数据库系统的全局的隔离级别:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> tx_isolation <span class="operator">=</span><span class="string">&#x27;read-committed&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的隔离级别中间是减号，不是下划线。</p></blockquote><p><strong>实验一下，首先做数据准备</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;  <span class="comment">--查看当前隔离级别</span></span><br></pre></td></tr></table></figure><p>MySQL默认的事务隔离等级，可重复读（repeatable reads）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--首先我们创建一个表作为测试表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> test_trac;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> test_trac (</span><br><span class="line">    t_id <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    t_name <span class="type">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--我们开两个会话，一个用客户端(会话A)，一个用命令行(会话B)，会话A开启事务</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);  <span class="comment">--在会话A上执行</span></span><br><span class="line"><span class="comment">--在会话B上读取，会发现无法读取未提交的数据，会话A执行commit后，会话B可以正常读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--将会话B的事务隔离级别设为“读未提交”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac;</span><br><span class="line"><span class="comment">--显示会话A插入之前的值</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ccc0&#x27;</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="comment">--在sessionA未提交的情况下，会话B可读取：会话A的未提交的insert（脏读）；查询过后被修改（不可重读）；查询过被新增（幻读）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--将会话B的事务隔离级别设为“读已提交”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="comment">--会话A也开启事务</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ccc1&#x27;</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="comment">--在sessionA未提交的情况下，sessionB读不到这条记录，除非sessionA已提交</span></span><br><span class="line">sessionA: <span class="keyword">commit</span>;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="comment">--关键是会话B的自己的事务未办结提交过程中，读取到了会话A提交的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--现在把会话B的隔离基本设为“可重复读”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level repeatable read;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="comment">--可重复读的例子</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ddd0&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">sessionA: <span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">--虽然会话A已提交事务，会话B查询，得不到新的值，除非会话B也提交。</span></span><br><span class="line">sessionB: <span class="keyword">commit</span>;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="comment">--幻读的例子</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction; </span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionA: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="comment">--会话A和B开启事务后，读取的结果集。会话A发现可以插入某个值，插入并提交。会话B也要插入同样的值，结果发现主键冲突，也就是数据库库在查询之后，新增了对应的数据。但是会话B的事务中不知道这个改变。</span></span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ddd1&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">sessionA: <span class="keyword">commit</span>;</span><br><span class="line">sessionB: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ddd1&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">sessionB: ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;ddd1&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line"><span class="comment">--如果会话A插入一个主键值，未提交。会话B插入同样的主键值，在会话A未提交的情况下被阻塞，指导会话A提交或回滚。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--现在把会话B的隔离基本设为“串行化”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level serializable;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line"><span class="comment">--在此隔离等级下，一旦有某个事务进行了insert、update、delete操作更新类数据，所有其他会话的select操作会被阻塞，除非更新的会话被提交。</span></span><br><span class="line"><span class="comment">--如果两个会话都更新过了，第一个会话select被阻塞，第二个会话进行select直接报错</span></span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br></pre></td></tr></table></figure><h1 id="6-行锁与表锁🔍"><a href="#6-行锁与表锁🔍" class="headerlink" title="6. 行锁与表锁🔍"></a>6. 行锁与表锁🔍</h1><p>​    所有的事务实现，处理并发冲突，都需要依赖锁来实现。</p><p>​        一般可以分为两类，一个是<strong>悲观锁</strong>，一个是<strong>乐观锁</strong>，悲观锁一般就是我们通常说的数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制，比如hibernate实现的乐观锁甚至编程语言也有乐观锁的思想的应用。</p><p><strong>悲观锁</strong>：顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。</p><h4 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h4><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单。所以获取锁和释放锁的速度很快。由于<strong>表级锁一次会将整个表锁定</strong>，所以可以很好的避免困扰我们的死锁问题。<br>当然，锁定颗粒度大所带来<strong>最大的负面影响就是出现锁定资源争用的概率也会最高</strong>，致使并大度大打折扣。<br>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p><h4 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h4><p>行级锁定最大的特点就是<strong>锁定对象的颗粒度很小</strong>，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发<strong>生锁定资源争用的概率也最小</strong>，<strong>能够给予应用程序尽可能大的并发处理能力</strong>而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以<strong>每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了</strong>。此外，行级锁定也最容易发生死锁。<br>使用行级锁定的主要是InnoDB存储引擎。</p><p><strong>表级锁：开销小，加锁快；较难出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</strong><br><strong>行级锁：开销大，加锁慢；容易出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文了解MySQL事务&quot;&gt;&lt;a href=&quot;#一文了解MySQL事务&quot; class=&quot;headerlink&quot; title=&quot;一文了解MySQL事务&quot;&gt;&lt;/a&gt;一文了解MySQL事务&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;🏠个人主页：&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Java第二阶段_day03_MySQL进阶</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-day03-MySQL%E8%BF%9B%E9%98%B6/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-day03-MySQL%E8%BF%9B%E9%98%B6/</id>
    <published>2022-10-16T14:50:30.000Z</published>
    <updated>2022-10-16T14:55:58.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java第二阶段-day03-MySQL进阶"><a href="#Java第二阶段-day03-MySQL进阶" class="headerlink" title="Java第二阶段_day03_MySQL进阶"></a>Java第二阶段_day03_MySQL进阶</h1><h2 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0. 学习目标"></a>0. 学习目标</h2><ul><li>掌握数据库子查询的概念</li><li>掌握数据库子查询的使用方法及场景</li><li>掌握MySQL常用函数与分页查询方法</li><li>掌握数据库事务的概念，及事务的特性</li><li>掌握开启事务的方法</li><li>掌握数据库事务隔离的等级划分，各种事务隔离等级下的数据表现</li><li>掌握MySQL的默认事务隔离等级及设置MySQL事务隔离等级的方法</li><li>了解悲观锁、乐观锁、行级锁、表级锁的概念</li><li>掌握数据库设计范式</li><li>掌握ER图基本设计方法</li><li>掌握基本数据库对象（索引、视图、存储过程、触发器）管理方法</li><li>了解数据库主从复制方法</li></ul><h2 id="第1章-子查询"><a href="#第1章-子查询" class="headerlink" title="第1章 子查询"></a>第1章 子查询</h2><h3 id="子查询是什么"><a href="#子查询是什么" class="headerlink" title="子查询是什么"></a>子查询是什么</h3><p>​        子查询就是在查询中嵌套<strong>另外一个查询</strong>的查询。子查询需要使用<strong>括号</strong>括起来。</p><p>​        为了满足业务上的特定的要求，我们往往很难，或者不能在一个查询中得到需要的结果。这时通过嵌套另外一个查询，获取中间结果，然后再在这个结果上加工，就可以比较方便地得到想要的结果。</p><p>​        按照子查询出现的位置，我们可以将子查询分成4类，<strong>select型子查询、where型子查询、from型子查询、exists型子查询</strong>。</p><p>​        安装子查询返回的结果集，我们可以将子查询分成</p><p>​                <strong>标量子查询：返回单一值的标量，最简单的形式。</strong></p><p>​                <strong>列子查询：返回的结果集是 N 行一列。</strong></p><p>​                <strong>行子查询：返回的结果集是一行 N 列。</strong></p><p>​                <strong>表子查询：返回的结果集是 N 行 N 列。</strong>    </p><p>​        同时一个需求，往往可以用不同方式的子查询来实现。子查询不仅可以出现在select语句中、还可以出现在insert、update、delete、create table语句中。</p><h3 id="select型子查询"><a href="#select型子查询" class="headerlink" title="select型子查询"></a>select型子查询</h3><p>​        select型子查询就是子查询出现在主查询的select字段列表中。</p><p>​        例如有一个部门表、和员工表，部门表的部门ID字段与员工表中的部门ID字段存在1对多的关联。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> dept;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept (</span><br><span class="line">  dept_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dept_name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> empl;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> empl (</span><br><span class="line">  empl_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">empl_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dept_id <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(dept_name) <span class="keyword">values</span>(<span class="string">&#x27;开发部&#x27;</span>), (<span class="string">&#x27;测试部&#x27;</span>), (<span class="string">&#x27;实施运维部&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> empl(empl_name, dept_id) <span class="keyword">values</span>(<span class="string">&#x27;赵大&#x27;</span>,<span class="number">1</span>), (<span class="string">&#x27;钱二&#x27;</span>,<span class="number">2</span>), (<span class="string">&#x27;张三&#x27;</span>,<span class="number">3</span>), (<span class="string">&#x27;李四&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>​        需求：要查出每个部门的员工数有多少。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT d.dept_name, ( </span><br><span class="line">    SELECT COUNT(*)</span><br><span class="line">    FROM empl e</span><br><span class="line">    WHERE e.dept_id = d.dept_id</span><br><span class="line"> ) empl_num</span><br><span class="line"> FROM dept d;</span><br></pre></td></tr></table></figure><p>​        当然，我们可以使用关联查询来处理，多数使用子查询的场合都可以使用关联查询来替代，具体使用哪种方式，取决于哪种方式更加清晰直观、运行速度更快。</p><p>​        select型子查询只支持标量子查询，子查询的数量没有限制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, (<span class="keyword">select</span> <span class="number">1</span>) <span class="keyword">as</span> a1, (<span class="keyword">select</span> <span class="number">2</span>) <span class="keyword">as</span> a2 <span class="keyword">from</span> dept;</span><br><span class="line"><span class="keyword">select</span> dept_name, (<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>) <span class="keyword">as</span> a1, (<span class="keyword">select</span> <span class="number">2</span>) <span class="keyword">as</span> a2 <span class="keyword">from</span> dept;</span><br><span class="line"><span class="comment">-- 第2句sql是错的，Operand should contain 1 column(s)</span></span><br></pre></td></tr></table></figure><h3 id="where型子查询"><a href="#where型子查询" class="headerlink" title="where型子查询"></a>where型子查询</h3><p>​        顾名思义，where型子查询就是子查询出现在主查询的where条件子句中。</p><p>​        比如说where条件中，需要某字段值=从子查询中查出来的某一个值（标量子查询）；某字段的值，在子查询查出来的值区段内，<strong>in / not in</strong> 列子查询。 </p><p>​        需求：列出开发部的员工列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select empl_id, empl_name from empl</span><br><span class="line">where dept_id = (select dept_id from dept where dept_name like &#x27;%开发部%&#x27;);</span><br></pre></td></tr></table></figure><p>​        需求，列出开发部与测试部的员工列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empl_id, empl_name <span class="keyword">from</span> empl</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> dept_id <span class="keyword">from</span> dept</span><br><span class="line">  <span class="keyword">where</span> dept_name <span class="keyword">like</span> <span class="string">&#x27;%开发部%&#x27;</span> <span class="keyword">or</span> dept_name <span class="keyword">like</span> <span class="string">&#x27;%测试部%&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​        需求，列出不是开发部与测试部的员工列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empl_id, empl_name <span class="keyword">from</span> empl</span><br><span class="line"><span class="keyword">where</span> dept_id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> dept_id <span class="keyword">from</span> dept</span><br><span class="line">  <span class="keyword">where</span> dept_name <span class="keyword">like</span> <span class="string">&#x27;%开发部%&#x27;</span> <span class="keyword">or</span> dept_name <span class="keyword">like</span> <span class="string">&#x27;%测试部%&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​    <strong>where 型子查询，如果是 where 列 =（内层 sql） 则内层 sql 返回的必须是单行单列，单个值（标量子查询）。</strong></p><p>​    <strong>where 型子查询，如果是 where 列 in / not in（内层 sql） 则内层 sql 返回的必须是单列，可以多行（列子查询）。</strong></p><p>​    <strong>in / not in 不能使用索引，大数据量下通常会严重影响性能，慎重使用。</strong></p><h3 id="from型子查询"><a href="#from型子查询" class="headerlink" title="from型子查询"></a>from型子查询</h3><p>​        需要理解一个概念：<strong>查询结果集在结构上可以当成表看</strong>，那就可以当成临时表对他进行再次查询：</p><p>​        需求：列出开发部和测试部的姓李的员工列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select empl_id, empl_name</span><br><span class="line">from (select empl_id, empl_name from empl, dept</span><br><span class="line">      where empl.dept_id = dept.dept_id</span><br><span class="line">        and dept_name in(&#x27;开发部&#x27;,&#x27;测试部&#x27;) ) ta</span><br><span class="line">where ta.empl_name like &#x27;李%&#x27;;</span><br></pre></td></tr></table></figure><p>​        某些时候，单个sql无法完成的结果集，通过from型子查询，可以比较简明清晰地逼近需求结果，最终完成。</p><p>​        在上面的例子中，from型子查询，是表子查询。但也可以是标量子查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select aaa from (select 1 as aaa) ta;</span><br></pre></td></tr></table></figure><p>​        也可以列子查询和行子查询。</p><p>​        <strong>注意：将子查询结果充当一张表，要求必须起别名。</strong></p><h3 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h3><p>​        exists型子查询，又叫<strong>相关子查询</strong>。</p><p>​        例如，查询存在实际员工的部门名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span> dept d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> empl e</span><br><span class="line">    <span class="keyword">WHERE</span> d.dept_id<span class="operator">=</span>e.dept_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        其语法是在where子句中，exists(完整的查询语句）。这时外层父查询先执行，在处理每一条记录时，执行子查询，子查询有结果返回，不是0条时，则此记录进入返回的结果集，否则将被剔除。</p><p>​        又如：查询没有女朋友的男神信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT b.*</span><br><span class="line">FROM boys b</span><br><span class="line">WHERE NOT EXISTS(</span><br><span class="line">    SELECT boyfriend_id</span><br><span class="line">    FROM girls g</span><br><span class="line">    WHERE b.b_id=g.boyfriend_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="any、some和all关键字"><a href="#any、some和all关键字" class="headerlink" title="any、some和all关键字"></a>any、some和all关键字</h3><p>​        我们在where型子查询中，使用了 in 与 not in 关键字。这是一种集合处理。还有集合处理的关键字，也经常用到子查询中，就是 any 和 all 关键字（some是 any的同义词，较少使用）。</p><div class="table-container"><table><thead><tr><th>运算符\关键字</th><th>ANY</th><th>ALL</th></tr></thead><tbody><tr><td>&gt; 、&gt;=</td><td>最小值</td><td>最大值</td></tr><tr><td>&lt;、&lt;=</td><td>最大值</td><td>最小值</td></tr><tr><td>=</td><td>任意值</td><td></td></tr><tr><td>&lt;&gt;、!=</td><td></td><td>任意值</td></tr></tbody></table></div><p>​        我们来看个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个职位表</span><br><span class="line">CREATE TABLE salary_table(</span><br><span class="line">  id SMALLINT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  position VARCHAR(40) NOT NULL,</span><br><span class="line">  salary INT);</span><br><span class="line">insert salary_table(position,salary) values(&#x27;JAVA&#x27;,8000),(&#x27;Java&#x27;,8400),(&#x27;Java&#x27;,9000),(&#x27;Python&#x27;,6500),(&#x27;Python&#x27;,10000),(&#x27;Python&#x27;,8900);</span><br><span class="line">select *  from salary_table;</span><br></pre></td></tr></table></figure><p>​        需求：查找出高于 Python  职位任一职位工资的其它职位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM salary_table</span><br><span class="line">  WHERE salary &gt; ANY( SELECT salary FROM salary_table WHERE position = &#x27;Python&#x27;)</span><br><span class="line">    and position not like &#x27;%Python%&#x27;;</span><br></pre></td></tr></table></figure><p>​        需求：查找出高于 Python  职位任何职位工资的其它职位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM salary_table</span><br><span class="line">  WHERE salary &gt; all( SELECT salary FROM salary_table WHERE position = &#x27;Python&#x27;)</span><br><span class="line">    and position not like &#x27;%Python%&#x27;;</span><br></pre></td></tr></table></figure><p>​    需求：查找出等于Python  职位任何职位工资的其它职位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM salary_table</span><br><span class="line">  WHERE salary = any( SELECT salary FROM salary_table WHERE position = &#x27;Python&#x27;)</span><br><span class="line">    and position not like &#x27;%Python%&#x27;;</span><br></pre></td></tr></table></figure><p><strong>注意：= any 等价于 in，!= all 等价于 not in，= all 是没有 意义的。</strong></p><h2 id="第2章-常用函数与分页查询"><a href="#第2章-常用函数与分页查询" class="headerlink" title="第2章 常用函数与分页查询"></a>第2章 常用函数与分页查询</h2><p>​        函数存储着一系列sql语句，调用函数就是一次性执行这些语句。所以函数可以降低语句重复。</p><p>​        函数与存储过程的区别：函数只会返回一个值，不允许返回一个结果集。存储过程没有返回值，只是可以带返回参数。</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>数学函数是MySQL中常用的一类函数。其主要用于处理数字，包括整型和浮点数等等。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ABS(X)</td><td>返回X的绝对值。</td></tr><tr><td>FLOOR(X)</td><td>返回不大于X的最大整数。</td></tr><tr><td>CEIL(X)、CEILING(X)</td><td>返回不小于X的最小整数。</td></tr><tr><td>TRUNCATE(X,D)</td><td>返回数值X保留到小数点后D位的值，截断时不进行四舍五入。</td></tr><tr><td>ROUND(X)</td><td>返回离X最近的整数，截断时要进行四舍五入。</td></tr><tr><td>ROUND(X,D)</td><td>保留X小数点后D位的值，截断时要进行四舍五入。</td></tr><tr><td><strong>RAND()</strong></td><td>返回0~1的随机数。</td></tr><tr><td>SIGN(X)</td><td>返回X的符号(负数，零或正)对应-1，0或1。</td></tr><tr><td>PI()</td><td>返回圆周率的值。默认的显示小数位数是6位。</td></tr><tr><td>POW(x,y)、POWER(x,y)</td><td>返回x的y次乘方的值。</td></tr><tr><td>SQRT(x)</td><td>返回非负数的x的二次方根。</td></tr><tr><td>EXP(x)</td><td>返回e的x乘方后的值。</td></tr><tr><td>MOD(N,M)</td><td>返回N除以M以后的余数。</td></tr><tr><td>LOG(x)</td><td>返回x的自然对数，x相对于基数2的对数。</td></tr><tr><td>LOG10(x)</td><td>返回x的基数为10的对数。</td></tr><tr><td>RADIANS(x)</td><td>返回x由角度转化为弧度的值。</td></tr><tr><td>DEGREES(x)</td><td>返回x由弧度转化为角度的值。</td></tr><tr><td>SIN(x)、ASIN(x)</td><td>前者返回x的正弦，其中x为给定的弧度值；后者返回x的反正弦值，x为正弦。</td></tr><tr><td>COS(x)、ACOS(x)</td><td>前者返回x的余弦，其中x为给定的弧度值；后者返回x的反余弦值，x为余弦。</td></tr><tr><td>TAN(x)、ATAN(x)</td><td>前者返回x的正切，其中x为给定的弧度值；后者返回x的反正切值，x为正切。</td></tr><tr><td>COT(x)</td><td>返回给定弧度值x的余切。</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- rand获取到的是一个 0 ~ 1 之间的小数</span><br><span class="line">select rand() from dual;</span><br><span class="line">-- 如果要特定范围的随机整数，可以将此小数乘以特定值后取整</span><br><span class="line">select round(rand()*100) from dual;</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>字符串函数是MySQL中最常用的一类函数。字符串函数主要用于处理表中的字符串。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>CHAR_LENGTH(str)</td><td>计算字符串字符个数。</td></tr><tr><td>LENGTH(str)</td><td>返回值为字符串str的长度，单位为字节。</td></tr><tr><td><strong>CONCAT(s1,s2，…)</strong></td><td>返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为NULL则返回值为NULL。</td></tr><tr><td><strong>SUBSTRING(s,n,len)</strong>、MID(s,n,len)</td><td>两个函数作用相同，从字符串s中返回一个第n个字符开始、长度为len的字符串。</td></tr><tr><td>CONCAT_WS(x,s1,s2,…)</td><td>返回多个字符串拼接之后的字符串，每个字符串之间有一个x。</td></tr><tr><td>INSERT(s1,x,len,s2)</td><td>返回字符串s1，其子字符串起始于位置x，被字符串s2取代len个字符。</td></tr><tr><td>INSTR(s1, s2)</td><td>返回字符串s2，在字符串s1中开始的位置，下标从1开始，没有找到返回0。</td></tr><tr><td>LOWER(str)、LCASE(str)</td><td>将str中的字母全部转换成小写。</td></tr><tr><td>UPPER(str)、UCASE(str)</td><td>将字符串中的字母全部转换成大写。</td></tr><tr><td>LEFT(s,n)、RIGHT(s,n)</td><td>前者返回字符串s从最左边开始的n个字符，后者返回字符串s从最右边开始的n个字符。</td></tr><tr><td>LPAD(s1,len,s2)、RPAD(s1,len,s2)</td><td>前者返回s1，其左边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符；前者返回s1，其右边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符。</td></tr><tr><td>LTRIM(s)、RTRIM(s)</td><td>前者返回字符串s，其左边所有空格被删除；后者返回字符串s，其右边所有空格被删除。</td></tr><tr><td>TRIM(s)</td><td>返回字符串s删除了两边空格之后的字符串。</td></tr><tr><td>TRIM(s1 FROM s)</td><td>删除字符串s两端所有子字符串s1，未指定s1的情况下则默认删除空格。</td></tr><tr><td>REPEAT(s,n)</td><td>返回一个由重复字符串s组成的字符串，字符串s的数目等于n。</td></tr><tr><td>SPACE(n)</td><td>返回一个由n个空格组成的字符串。</td></tr><tr><td>REPLACE(s,s1,s2)</td><td>返回一个字符串，用字符串s2替代字符串s中所有的字符串s1。</td></tr><tr><td>STRCMP(s1,s2)</td><td>若s1和s2中所有的字符串都相同，则返回0；根据当前分类次序，第一个参数小于第二个则返回-1，其他情况返回1。</td></tr><tr><td>LOCATE(str1,str)、POSITION(str1 IN str)、INSTR(str,str1)</td><td>三个函数作用相同，返回子字符串str1在字符串str中的开始位置（从第几个字符开始）。</td></tr><tr><td>REVERSE(s)</td><td>将字符串s反转。</td></tr><tr><td>ELT(N,str1,str2,str3,str4,…)</td><td>返回第N个字符串。</td></tr><tr><td>FIELD(s,s1,s2,…)</td><td>返回第一个与字符串s匹配的字符串的位置。</td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回在字符串s2中与s1匹配的字符串的位置。</td></tr><tr><td>MAKE_SET(x,s1,s2,…)</td><td>按x的二进制数从s1，s2…，sn中选取字符串</td></tr></tbody></table></div><p>重要的函数示例 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="comment">-- concat是连接字符串，mysql中concat支持3个参数，oracle中只有2个参数的版本</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">2</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- substring带两个参数时，表示从第一个参数字符串中截取，从第二个参数位置字符开始（包含第二个参数位置的字符），到字符串尾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;12345&#x27;</span>, <span class="number">2</span>,<span class="number">2</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- substring带两个参数时，表示从第一个参数字符串中截取，从第二个参数位置字符开始（包含第二个参数位置的字符）</span></span><br><span class="line"><span class="comment">-- 截取第三个参数所指长度的字符</span></span><br></pre></td></tr></table></figure><h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><p>日期和时间函数是MySQL中另一最常用的函数。其主要用于对表中的日期和时间数据的处理。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>CURDATE()、CURRENT_DATE()</td><td>返回当前日期，格式：yyyy-MM-dd。</td></tr><tr><td>CURTIME()、CURRENT_TIME()</td><td>返回当前时间，格式：HH:mm:ss。</td></tr><tr><td><strong>NOW()、CURRENT_TIMESTAMP()、</strong>LOCALTIME()、SYSDATE()、LOCALTIMESTAMP()</td><td>返回当前日期和时间，格式：yyyy-MM-dd HH:mm:ss。</td></tr><tr><td>DATEDIFF(d1,d2)</td><td>计算日期d1与d2之间相隔的天数。</td></tr><tr><td>ADDDATE(d,n)</td><td>计算起始日期d加上n天的日期，n为正数向后推，负数向前。</td></tr><tr><td><strong>DATE_FORMAT(d,f)</strong></td><td>按照表达式 f 的要求显示日期d。</td></tr><tr><td>TIME_FORMAT(t,f)</td><td>按照表达式 f 的要求显示时间t。</td></tr><tr><td>STR_TO_DATE(s,f)</td><td>按照表达式 f 的要求，转换字符串s成日期时间类型。</td></tr><tr><td>UNIX_TIMESTAMP()</td><td>返回一个格林尼治标准时间1970-01-01 00:00:00到现在的秒数。</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>返回一个格林尼治标准时间1970-01-01 00:00:00到指定时间的秒数。</td></tr><tr><td>FROM_UNIXTIME(date)</td><td>和UNIX_TIMESTAMP互为反函数，把UNIX时间戳转换为普通格式的时间。</td></tr><tr><td>UTC_DATE()</td><td>返回当前UTC（世界标准时间）日期值，其格式为”YYYY-MM-DD”或”YYYYMMDD”。</td></tr><tr><td>UTC_TIME()</td><td>返回当前UTC时间值，其格式为”YYYY-MM-DD”或”YYYYMMDD”。具体使用哪种取决于函数用在字符串还是数字语境中</td></tr><tr><td>MONTH(d)</td><td>返回日期d中的月份值，范围是1~12。</td></tr><tr><td>MONTHNAME(d)</td><td>返回日期d中的月份名称，如：January、February等。</td></tr><tr><td>DAYNAME(d)</td><td>返回日期d是星期几，如：Monday、Tuesday等。</td></tr><tr><td>DAYOFWEEK(d)</td><td>返回日期d是星期几，如：1表示星期日，2表示星期一等。</td></tr><tr><td>WEEKDAY(d)</td><td>返回日期d是星期几，如：0表示星期一，1表示星期二等。</td></tr><tr><td>WEEK(d)</td><td>计算日期d是本年的第几个星期，范围是0~53。</td></tr><tr><td>WEEKOFYEAR(d)</td><td>计算日期d是本年的第几个星期，范围是1~53。</td></tr><tr><td>DAYOFYEAR(d)</td><td>计算日期d是本年的第几天。</td></tr><tr><td>DAYOFMONTH(d)</td><td>计算日期d是本月的第几天。</td></tr><tr><td>YEAR(d)</td><td>返回日期d中的年份值。</td></tr><tr><td>QUARTER(d)</td><td>返回日期d是第几季度，范围是1~4。</td></tr><tr><td>HOUR(t)</td><td>返回时间t中的小时值。</td></tr><tr><td>MINUTE(t)</td><td>返回时间t中的分钟值。</td></tr><tr><td>SECOND(t)</td><td>返回时间t中的秒钟值。</td></tr><tr><td>EXTRACT(type FROM date)</td><td>从日期中提取一部分，type可以是YEAR、YEAR_MONTH、DAY_HOUR、DAY_MICROSECOND、DAY_MINUTE、DAY_SECOND</td></tr><tr><td>TIME_TO_SEC(t)</td><td>将时间t转换为秒。</td></tr><tr><td>SEC_TO_TIME(s)</td><td>将以秒为单位的时间s转换为时分秒的格式。</td></tr><tr><td>TO_DAYS(d)</td><td>计算日期d至0000年1月1日的天数。</td></tr><tr><td>FROM_DAYS(n)</td><td>计算从0000年1月1日开始n天后的日期。</td></tr><tr><td>ADDDATE(d,INTERVAL expr type)</td><td>计算起始日期d加上一个时间段后的日期。</td></tr><tr><td>DATE_ADD(d,INTERVAL expr type)</td><td>同ADDDATE(d,INTERVAL expr type)</td></tr><tr><td>SUBDATE(d,n)</td><td>计算起始日期d减去n天的日期。</td></tr><tr><td>SUBDATE(d,INTERVAL expr type)</td><td>计算起始日期d减去一个时间段后的日期。</td></tr><tr><td>ADDTIME(t,n)</td><td>计算起始时间t加上n秒的时间。</td></tr><tr><td>SUBTIME(t,n)</td><td>计算起始时间t减去n秒的时间。</td></tr><tr><td><strong>DATE_FORMAT(d,f)</strong></td><td>按照表达式 f 的要求显示日期d。</td></tr><tr><td>TIME_FORMAT(t,f)</td><td>按照表达式 f 的要求显示时间t。</td></tr><tr><td>GET_FORMAT(type, s)</td><td>根据字符串s获取type类型数据的显示格式。</td></tr></tbody></table></div><p>参数说明：</p><p>type格式：</p><p>SECOND 秒 SECONDS</p><p>MINUTE 分钟 MINUTES</p><p>HOUR 时间 HOURS</p><p>DAY 天 DAYS</p><p>MONTH 月 MONTHS</p><p>YEAR 年 YEARS</p><p>MINUTE_SECOND 分钟和秒 “MINUTES:SECONDS”</p><p>HOUR_MINUTE 小时和分钟 “HOURS:MINUTES”</p><p>DAY_HOUR 天和小时 “DAYS HOURS”</p><p>YEAR_MONTH 年和月 “YEARS-MONTHS”</p><p>HOUR_SECOND 小时, 分钟， “HOURS:MINUTES:SECONDS”</p><p>DAY_MINUTE 天, 小时, 分钟 “DAYS HOURS:MINUTES”</p><p>DAY_SECOND 天, 小时, 分钟, 秒 “DAYS HOURS:MINUTES:SECONDS”</p><p>重要的函数示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(),<span class="string">&#x27;%Y年%m月%d日 %H时%i分%s秒&#x27;</span>);  <span class="comment">-- 输出结果：2019年01月17日 19时18分08秒</span></span><br></pre></td></tr></table></figure><h3 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h3><p>条件函数用来在SQL语句中进行条件判断。根据不同的条件，执行不同的SQL语句。MySQL支持的条件判断函数及作用。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><strong>IF(expr,v1,v2)</strong></td><td>如果表达式expr成立，则执行v1；否则执行v2。</td></tr><tr><td><strong>IFNULL(v1,v2)</strong></td><td>如果v1不为空，则显示v1的值；否则显示v2的值。</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><p>重要函数示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT IF(TRUE,&#x27;A&#x27;,&#x27;B&#x27;); -- 输出结果：A</span><br><span class="line">SELECT IFNULL(NULL,&#x27;B&#x27;); -- 输出结果：B</span><br><span class="line">SELECT IFNULL(&#x27;pan_junbiao的博客&#x27;,&#x27;B&#x27;); -- 输出结果：pan_junbiao的博客</span><br></pre></td></tr></table></figure><h3 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h3><p>系统信息函数用来查询MySQL数据库的系统信息。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>VERSION()</td><td>获取数据库的版本号。</td></tr><tr><td>CONNECTION_ID()</td><td>获取服务器的连接数。</td></tr><tr><td>DATABASE()、SCHEMA()</td><td>获取当前数据库名。</td></tr><tr><td>USER()、SYSTEM_USER()、SESSION_USER()</td><td>获取当前用户名。</td></tr><tr><td>CURRENT_USER()、CURRENT_USER</td><td>获取当前用户名。</td></tr><tr><td>CHARSET(str)</td><td>获取字符串str的字符集。</td></tr><tr><td>COLLATION(str)</td><td>获取字符串str的字符排序方法。</td></tr><tr><td>LAST_INSERT_ID()</td><td>获取最近生成的AUTO_INCREMENT值。</td></tr></tbody></table></div><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><p>加密函数是MySQL中用来对数据进行加密的函数。因为数据库中有些很敏感的信息不希望被其他人看到，所以就可以通过加密的方式来使这些数据变成看似乱码的数据。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>对字符串str进行加密。经此函数加密后的数据是不可逆的。其经常用于对普通数据进行加密。</td></tr><tr><td>MD5(str)</td><td>对字符串str进行MD5加密。经常用于对普通数据进行加密。</td></tr><tr><td>ENCODE(str,pass_str)</td><td>使用字符串pass_str来加密字符串str。加密后的结果是一个二进制数，必须使用BLOB类型的字段来保存它。</td></tr><tr><td>DECODE(crypt_str,pass_str)</td><td>使用字符串pass_str来为crypt_str解密。</td></tr></tbody></table></div><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p>MySQL中除了上述内置函数以外，还包含很多函数。例如，数字格式化函数FORMAT(x,n)，IP地址与数字的转换函数INET_ATON(ip)，还有加锁函数GET_LOCT(name,time)、解锁函数RELEASE_LOCK(name)等等。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>FORMAT(X,D)</td><td>将数字X格式化，将X保留到小数点后D位，截断时要进行四舍五入。</td></tr><tr><td>CONV(N,from_base,to_base)</td><td>不同进制数之间的转换，返回值为数值N的字符串表示，由from_base进制转换为to_base进制。</td></tr><tr><td>INET_ATON(expr)</td><td>给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数，地址可以使4或8比特。</td></tr><tr><td>INET_NTOA(expr)</td><td>给定一个数字网络地址（4或8比特），返回作为字符串的该地址的点地址表示。</td></tr><tr><td>BENCHMARK(count,expr)</td><td>重复执行count次表达式expr，它可以用于计算MySQL处理表达式的速度，结果值通常是0（0只是表示很快，并不是没有速度）。另一个作用是用它在MySQL客户端内部报告语句执行的时间。</td></tr><tr><td>CONVERT(str USING charset)</td><td>使用字符集charset表示字符串str。</td></tr></tbody></table></div><h3 id="limit关键字与分页查询"><a href="#limit关键字与分页查询" class="headerlink" title="limit关键字与分页查询"></a>limit关键字与分页查询</h3><p>在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，mysql已经为我们提供了这样一个功能。</p><p>​        语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> <span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>  </span><br></pre></td></tr></table></figure><p>​        LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。</p><p>​        我们先看看一个参数的情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp limit 3;</span><br><span class="line">select * from emp order by emp_id desc limit 3;</span><br><span class="line">select * from emp order by hiredate limit 3;</span><br></pre></td></tr></table></figure><pre><code>     两个参数的情况下，第1个参数为结果集中需返回的起始记录位置（从1开始，到第n条记录后开始算），第2个参数是从开始返回的记录起，需返回的条数。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from emp limit 3,2;</span><br><span class="line">select * from emp order by emp_id desc limit 3,2;</span><br><span class="line">select * from emp order by hiredate limit 3;</span><br></pre></td></tr></table></figure><p>​        早起版本，5.5以前，为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp LIMIT 3,-1;</span><br></pre></td></tr></table></figure><p>​        但是现在8的版本已经不支持这种写法了。</p><p>​        limit子句最常用的地方是做分页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ... from 表名 where ... order by ... limit (页号*每页记录条数), 每页记录条数</span><br></pre></td></tr></table></figure><h2 id="第3章-数据库事务"><a href="#第3章-数据库事务" class="headerlink" title="第3章 数据库事务"></a>第3章 数据库事务</h2><h3 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h3><p>​        <strong>事务(Transaction)</strong>，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。</p><p>​        一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p><blockquote><p>1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p></blockquote><p>​        当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p><p>​        在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p><h3 id="数据库事务的特性"><a href="#数据库事务的特性" class="headerlink" title="数据库事务的特性"></a>数据库事务的特性</h3><p>​        事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为<strong>ACID</strong>特性。</p><blockquote><p><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。<br><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br><strong>持久性（Durability）</strong>：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</p></blockquote><p>​        以银行转账举例，说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1422237-20181122103041637-782687204.png" alt="img"></p><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p><p>1、从A账号中把余额读出来（500）。<br>2、对A账号做减法操作（500-100）。<br>3、把结果写回A账号中（400）。<br>4、从B账号中把余额读出来（500）。<br>5、对B账号做加法操作（500+100）。<br>6、把结果写回B账号中（600）。</p><p>在这个过程中可能会出现以下问题:</p><ul><li>1.转账操作的第一步执行成功,A账户上的钱减少了100元,但是第二步执行失败或者未执行便发生系统崩溃,导致B账户并没有相应增加100元。</li><li>2.转账操作刚完成就发生系统崩溃,系统重启恢复时丢失了崩溃前的转账记录。</li><li>3.同时又另一个用户转账给B账户,由于同时对B账户进行操作,导致B账户金额出现异常。</li></ul><h4 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h4><p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。<br>如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！</p><p>​        关于事务的定义有几点需要注意：</p><ul><li>1.数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。</li><li>2.构成逻辑整体的这些数据库操作,要么全部执行成功,要么全部不执行。</li><li>3.构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不管事务是否执行成功,数据库总能保持一致性状态。</li><li>4.以上即使在数据库出现故障以及并发事务存在的情况下依然成立。</li></ul><h4 id="如何实现数据库事务"><a href="#如何实现数据库事务" class="headerlink" title="如何实现数据库事务"></a>如何实现数据库事务</h4><p>在事务的ACID特性中,C即一致性是事务的根本追求,而对数据一致性的破坏主要来自两个方面</p><ul><li>1.事务的并发执行</li><li>2.事务故障或系统故障</li></ul><p>数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。</p><p>并发控制技术保证了<strong>事务的隔离性</strong>,使数据库的一致性状态不会因为并发执行的操作被破坏。<br>日志恢复技术保证了<strong>事务的原子性</strong>,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1422237-20181122103102223-1059881337.png" alt="img"></p><h3 id="MySQL中如何开启、提交-、回滚事务"><a href="#MySQL中如何开启、提交-、回滚事务" class="headerlink" title="MySQL中如何开启、提交 、回滚事务"></a>MySQL中如何开启、提交 、回滚事务</h3><p>MYSQL 事务处理主要有两种方法：</p><p>1、用 BEGIN/start transaction, ROLLBACK, COMMIT来实现</p><ul><li><p>begin/start transaction 开始一个事务</p></li><li><p>rollback 事务回滚</p></li><li><p>commit 事务确认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update student set sname=&#x27;王军&#x27; where id=;</span><br><span class="line">rollback;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ul><p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p><ul><li><p><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</p></li><li><p><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show session variables like &#x27;autocommit&#x27;;  --查看自动提交状态</span><br><span class="line">set session autocommit = 0;  --关闭自动提交</span><br><span class="line">set session autocommit = off;  --关闭自动提交</span><br><span class="line">update student set sname=&#x27;王军&#x27;;</span><br><span class="line">rollback;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li></ul><h3 id="事务的隔离等级"><a href="#事务的隔离等级" class="headerlink" title="事务的隔离等级"></a>事务的隔离等级</h3><p><strong>并发事务处理带来的问题</strong></p><ul><li><strong>更新丢失（Lost Update）</strong><br>当两个或多个事务选择同一行，然后基于最初选定的值更新改行时，有于每个事务都不知道其他事务的存在，就会发生更新问题：最后的更新覆盖了由其他事务所做的更新。</li><li><strong>脏读（Dirty Reads）</strong><br>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为“脏读”。<br>事务A读取到事务B已经修改但未提交的数据，还在这个数据基础上做了修改。此时，如果事务B回滚了，事务A的数据无效，不符合一致性要求。</li><li><strong>不可重读（Non-Repetable Reads）</strong><br>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现起读出的数据已经发生了改变、或某些记录已经被删除。这种现象叫做“不可重读”。<br>事务A读取到了事务B已经提交的修改数据，不符合隔离性。</li><li><strong>幻读（Phantom Reads）</strong><br>一个事务按照相同的查询条件读取以前检索过的数据，却发现某些事务插入了满足其查询条件的新数据，这种现象称为“幻读”。<br>事务A读取了事务B提交的新增数据，不符合隔离性。</li></ul><p><strong>事务的隔离等级</strong></p><ol><li>事务具有隔离性,理论上来说事务之间的执行不应该相互产生影响,其对数据库的影响应该和它们串行执行时一样。</li><li>然而完全的隔离性会导致系统并发性能很低,降低对资源的利用率,因而实际上对隔离性的要求会有所放宽,这也会一定程度造成对数据库一致性要求降低</li><li>SQL标准为事务定义了不同的隔离级别,从低到高依次是</li></ol><ul><li><p><strong>读未提交(READ UNCOMMITTED)</strong></p></li><li><p><strong>读已提交(READ COMMITTED)</strong></p></li><li><p><strong>可重复读(REPEATABLE READ)</strong></p></li><li><p><strong>串行化(SERIALIZABLE)</strong></p><p>事务的隔离级别越低,可能出现的并发异常越多,但是通常而言系统能提供的并发能力越强。</p></li></ul><p>​        不同的隔离级别与可能的并发异常的对应情况如下表所示,有一点需要强调,这种对应关系只是理论上的,对于特定的数据库实现不一定准确，mysql的Innodb存储引擎通过Next-Key Locking技术在可重复读级别就消除了幻读的可能。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1422237-20181122103221352-219869675.png" alt="img"></p><p>实验一下，首先做数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@transaction_isolation;  --查看当前隔离级别</span><br></pre></td></tr></table></figure><p>MySQL默认的事务隔离等级，可重复读（repeatable reads）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--首先我们创建一个表作为测试表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> test_trac;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> test_trac (</span><br><span class="line">    t_id <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">primary</span> key,</span><br><span class="line">    t_name <span class="type">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--我们开两个会话，一个用客户端(会话A)，一个用命令行(会话B)，会话A开启事务</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);  <span class="comment">--在会话A上执行</span></span><br><span class="line"><span class="comment">--在会话B上读取，会发现无法读取未提交的数据，会话A执行commit后，会话B可以正常读取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--将会话B的事务隔离级别设为“读未提交”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level read uncommitted;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac;</span><br><span class="line"><span class="comment">--显示会话A插入之前的值</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ccc0&#x27;</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="comment">--在sessionA未提交的情况下，会话B可读取：会话A的未提交的insert（脏读）；查询过后被修改（不可重读）；查询过被新增（幻读）。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--将会话B的事务隔离级别设为“读已提交”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level read committed;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="comment">--会话A也开启事务</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ccc1&#x27;</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="comment">--在sessionA未提交的情况下，sessionB读不到这条记录，除非sessionA已提交</span></span><br><span class="line">sessionA: <span class="keyword">commit</span>;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="comment">--关键是会话B的自己的事务未办结提交过程中，读取到了会话A提交的数据。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--现在把会话B的隔离基本设为“可重复读”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level repeatable read;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="comment">--可重复读的例子</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ddd0&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">sessionA: <span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">--虽然会话A已提交事务，会话B查询，得不到新的值，除非会话B也提交。</span></span><br><span class="line">sessionB: <span class="keyword">commit</span>;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="comment">--幻读的例子</span></span><br><span class="line">sessionA: <span class="keyword">start</span> transaction; </span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;</span><br><span class="line">sessionA: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">sessionB: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_trac <span class="keyword">where</span> t_name<span class="operator">=</span><span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line"><span class="comment">--会话A和B开启事务后，读取的结果集。会话A发现可以插入某个值，插入并提交。会话B也要插入同样的值，结果发现主键冲突，也就是数据库库在查询之后，新增了对应的数据。但是会话B的事务中不知道这个改变。</span></span><br><span class="line">sessionA: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ddd1&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">sessionA: <span class="keyword">commit</span>;</span><br><span class="line">sessionB: <span class="keyword">insert</span> <span class="keyword">into</span> test_trac <span class="keyword">values</span>(<span class="string">&#x27;ddd1&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">sessionB: ERROR <span class="number">1062</span> (<span class="number">23000</span>): Duplicate entry <span class="string">&#x27;ddd1&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;PRIMARY&#x27;</span></span><br><span class="line"><span class="comment">--如果会话A插入一个主键值，未提交。会话B插入同样的主键值，在会话A未提交的情况下被阻塞，指导会话A提交或回滚。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--现在把会话B的隔离基本设为“串行化”</span></span><br><span class="line">sessionB: <span class="keyword">set</span> session transaction isolation level serializable;</span><br><span class="line">sessionB: <span class="keyword">start</span> transaction;  <span class="comment">--开启事务</span></span><br><span class="line"><span class="comment">--在此隔离等级下，一旦有某个事务进行了insert、update、delete操作更新类数据，所有其他会话的select操作会被阻塞，除非更新的会话被提交。</span></span><br><span class="line"><span class="comment">--如果两个会话都更新过了，第一个会话select被阻塞，第二个会话进行select直接报错</span></span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="行锁与表锁"><a href="#行锁与表锁" class="headerlink" title="行锁与表锁"></a>行锁与表锁</h3><p>​        所有的事务实现，处理并发冲突，都需要依赖锁来实现。</p><p>​        一般可以分为两类，一个是<strong>悲观锁</strong>，一个是<strong>乐观锁</strong>，悲观锁一般就是我们通常说的数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制，比如hibernate实现的乐观锁甚至编程语言也有乐观锁的思想的应用。</p><p><strong>悲观锁</strong>：顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。</p><h4 id="1-表级锁定（table-level）"><a href="#1-表级锁定（table-level）" class="headerlink" title="1.表级锁定（table-level）"></a>1.表级锁定（table-level）</h4><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单。所以获取锁和释放锁的速度很快。由于<strong>表级锁一次会将整个表锁定</strong>，所以可以很好的避免困扰我们的死锁问题。<br>当然，锁定颗粒度大所带来<strong>最大的负面影响就是出现锁定资源争用的概率也会最高</strong>，致使并大度大打折扣。<br>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p><h4 id="2-行级锁定（row-level）"><a href="#2-行级锁定（row-level）" class="headerlink" title="2.行级锁定（row-level）"></a>2.行级锁定（row-level）</h4><p>行级锁定最大的特点就是<strong>锁定对象的颗粒度很小</strong>，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发<strong>生锁定资源争用的概率也最小</strong>，<strong>能够给予应用程序尽可能大的并发处理能力</strong>而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以<strong>每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了</strong>。此外，行级锁定也最容易发生死锁。<br>使用行级锁定的主要是InnoDB存储引擎。</p><p><strong>表级锁：开销小，加锁快；较难出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</strong><br><strong>行级锁：开销大，加锁慢；容易出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</strong></p><h2 id="第4章-数据库表设计"><a href="#第4章-数据库表设计" class="headerlink" title="第4章 数据库表设计"></a>第4章 数据库表设计</h2><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p>​        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p><p>​        但是有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。</p><p>​        严格第说，数据库有五范式，但是四、BC范式是对第三范式的补充，所以我们一般说三范式。</p><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><ul><li><p><strong>第一范式（1NF）要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。</strong></p><p>比方说学生信息：</p><p>| 字段名 | 值   | 字段名 | 值   | 字段名 | 值   | 字段名   | 值           |<br>| ——— | —— | ——— | —— | ——— | —— | ———— | —————— |<br>| 姓名   | 张三 | 性别   | 男   | 民族   | 汉   | 出生日期 | 1999年x月x日 |</p></li></ul><p>  又比方说用户地址栏，一般情况下我们用一个varchar列来表示，其中值如下</p><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>家庭住址</td><td>湖北省武汉市武昌区某某街某某号</td></tr></tbody></table></div><p>  如果有相应的业务要求，这个字段就可以按第一范式进行拆分，这样在针对地址进行检索时更加精确方便</p><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>省份</td><td>湖北省</td><td>地市</td><td>武汉市</td><td>区名</td><td>武昌区</td><td>街道名</td><td>某某街道</td></tr></tbody></table></div><ul><li><p><strong>若某一列有多个值，可以将该列单独拆分成一个实体，新实体和原实体间是一对多的关系。</strong></p><p>比如：学生选课</p><p>张三选了计算机、高数、英语三门课。使用一个字段存放，这就违反了范式。</p></li></ul><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>姓名</td><td>张三</td><td>成绩</td><td>计算机80，英语90，高数70</td></tr></tbody></table></div><p>  应该设计学生选课表，并对学生信息表产生1对多的关联</p><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>学生编号</td><td>123</td><td>学生姓名</td><td>张三</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th></tr></thead><tbody><tr><td>学科编号</td><td>s1</td><td>学科名称</td><td>计算机</td></tr><tr><td>学科编号</td><td>s2</td><td>学科名称</td><td>英语</td></tr><tr><td>学科编号</td><td>s3</td><td>学科名称</td><td>高数</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>字段名</th><th>值</th><th>字段名</th><th>值</th><th>字段名</th><th></th></tr></thead><tbody><tr><td>学生编号</td><td>123</td><td>学科编号</td><td>s1</td><td>成绩</td><td>80</td></tr><tr><td>学生编号</td><td>123</td><td>学科编号</td><td>s2</td><td>成绩</td><td>90</td></tr><tr><td>学生编号</td><td>123</td><td>学科编号</td><td>s3</td><td>成绩</td><td>70</td></tr></tbody></table></div><ul><li>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><ul><li>满足第二范式（2NF）必须先满足第一范式（1NF）。</li><li>第二范式要求实体中每一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。</li><li>完全依赖：主键可能由多个属性构成，完全依赖要求不允许存在非主属性依赖于主键中的某一部分属性。</li><li>若存在哪个非主属性依赖于主键中的一部分属性，那么要将发生部分依赖的这一组属性单独新建一个实体，并且在旧实体中用外键与新实体关联，并且新实体与旧实体间是一对多的关系。</li></ul><p>​        比方说：</p><p>​        比如要设计一个订单信息表，因为订单中可能会有多种商品多次订货信息，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p>​        这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，订单表的商品编号与商品表的商品编号产生多对1的关联，即可满足第二范式。</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><ul><li><p>满足第三范式必须先满足第二范式。</p></li><li><p>第三范式要求：实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。</p></li><li><p>如果一个实体中出现其他实体的非主属性，可以将这两个实体用外键关联，而不是将另一张表的非主属性直接写在当前表中。</p></li></ul><p>  第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><h3 id="ER图与实体"><a href="#ER图与实体" class="headerlink" title="ER图与实体"></a>ER图与实体</h3><p>ER图是我们建立概念数据模型的工具<br>​        数据模型是现实世界中数据特征的抽象。数据模型应该满足三个方面的要求：<br>​                1）能够比较真实地模拟现实世界<br>​                2）容易为人所理解<br>​                3）便于计算机实现</p><p>​        概念数据模型也称信息模型，它以实体－联系(<strong>Entity-RelationShip</strong>,简称E-R)理论为基础，并对这一理论进行了扩充。它从用户的观点出发对信息进行建模，主要用于数据库的概念级设计。    </p><h4 id="ER图图例"><a href="#ER图图例" class="headerlink" title="ER图图例"></a>ER图图例</h4><p>​        ER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。</p><p>​        ER图的<strong>实体（entity）</strong>即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。</p><p>​        ER图的<strong>属性（attribute）</strong>即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。</p><p>​        ER图的<strong>关系（relationship）</strong>用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系。</p><p>​        ER图中关联关系有三种：</p><p>​        <strong>1对1（1:1）</strong> ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。</p><p>​        <strong>1对多（1:N）</strong> ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。</p><p>​        <strong>多对多（M:N）</strong> ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20170101154040319.png" alt="img">ER的实        实体还会细分为<strong>弱实体</strong>和<strong>强实体</strong>：</p><p>​        弱实体：一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如上图的学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20170101211800859.png" alt="img"></p><p>​        弱实体和强实体的联系必然只有1：N或者1：1，这是由于弱实体完全依赖于强实体，强实体不存在，那么弱实体就不存在，所以弱实体是完全参与联系的，因此弱实体与联系之间的联系也是用的双线菱形。</p><p>​        <strong>复合实体：</strong>复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示。</p><p>​        下图就是一个典型的复合实体，因为只是举例，相对粗糙，用户和商品两个实体是M：N的关系，中间又订单这个实体联系，因此订单这个实体是一个复合实体，同时如果用户 实体不存在，就没有订单实体的存在，因此对于用户实体来讲订单是弱实体，同理商品实体如果不存在，同样不存在订单实体，因此对商品实体而言订单是弱实体，具体如图：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20170101220128826.png" alt="img"></p><h4 id="ER物理模型与数据建模"><a href="#ER物理模型与数据建模" class="headerlink" title="ER物理模型与数据建模"></a>ER物理模型与数据建模</h4><p>​        上面说的原生ER图，主要用于模型分析，实际上我们更常用的ER图的物理模型。</p><p>​        这里是一个在线免费ER图绘制网站，<a href="https://www.freedgo.com/erd-index.html，我们用这个工具来讲解一下ER图的分析绘制、及导出成SQL的过程。">https://www.freedgo.com/erd-index.html，我们用这个工具来讲解一下ER图的分析绘制、及导出成SQL的过程。</a></p><p>​        进入页面，可以点击“格式”按钮，展现图例菜单。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200312040016715.png" alt="image-20200312040016715"></p><p>​        我们可以选择实体关系/MySQL下的图标来完成学生班级课程模型模型。</p><h5 id="建立学生表模型"><a href="#建立学生表模型" class="headerlink" title="建立学生表模型"></a>建立学生表模型</h5><p>​        表名：student</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>s_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>s_name</td><td>varchar（20）</td><td>学生姓名</td></tr><tr><td>s_code</td><td>varchar(20)</td><td>学号</td></tr></tbody></table></div><p>点击对应的表图标，将之拖入到主体图纸上。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/MA3HJ8B9N45AK0Y_ZVR5R.png" alt="img"></p><p>双击表头“MySQL Table”，可以编辑表名。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/T%7D%5DO$QJN%60AJH@Q29JIT9K5J.png" alt="img"></p><p>在字段上点击右键，选“列修改”，可以设置列属性。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/0%7BUUGFSL$M6U1AHY1%5D%5D6ON.png" alt="img"></p><p>改成以下样子</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/D6D%J{22N@2]YWUQ[_1XKKW.png" alt="img"></p><p>点击”应用”。</p><p>编辑完成后</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312042421.png" alt="QQ截图20200312042421"></p><p>在其上点击右键，选择“选中sql”，可以看到弹出窗口自动生成建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS student (s_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_name VARCHAR(20) NOT NULL default  ‘’,</span><br><span class="line">s_code VARCHAR(20) NOT NULL default  ‘’</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="建立学生辅助信息表模型"><a href="#建立学生辅助信息表模型" class="headerlink" title="建立学生辅助信息表模型"></a>建立学生辅助信息表模型</h5><p>表名：studentAdd</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>a_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>s_id</td><td>int</td><td>学生id</td></tr><tr><td>s_address</td><td>varchar(60)</td><td>学生住址</td></tr></tbody></table></div><p>仿照上面流程，完成此表的模型。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312043128.png" alt="QQ截图20200312043128"></p><p>然后点击“1对1关系”图标。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312043321.png" alt="QQ截图20200312043321"></p><p>将两个端点分别拖动到student.s_id和studentAdd.s_id上去。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312043452.png" alt="QQ截图20200312043452"></p><p>点击 数据库 -&gt; MySQL -&gt; 全部SQL 就可以看到完整的sql建表语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS student (s_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_name VARCHAR(20) NOT NULL default  ‘’,</span><br><span class="line">s_code VARCHAR(20) NOT NULL default  ‘’</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS studentAdd (a_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_id INT(10) UNSIGNED NOT NULL default  0,</span><br><span class="line">s_address VARCHAR(60) NOT NULL default  ‘’</span><br><span class="line">);</span><br><span class="line">alter table studentAdd add constraint studentAdd_s_id_fk0  foreign key (s_id) references student (s_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里针对1对1关系，建立了外键关联。</p><h5 id="建立班级信息表模型"><a href="#建立班级信息表模型" class="headerlink" title="建立班级信息表模型"></a>建立班级信息表模型</h5><p>表名：class</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>c_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>c_name</td><td>varchar(60)</td><td>班级名称</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>表名：classStudent</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>cs_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>c_id</td><td>int</td><td>班级ID</td></tr><tr><td>s_id</td><td>int</td><td>学生ID</td></tr></tbody></table></div><p>仿照上面流程，完成此表的模型。</p><p>并建立class.c_id 与 classStudent.c_id 的1对多关联，及student.s_id 与 classStudent.s_id的关联</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312044550.png" alt="QQ截图20200312044550"></p><p>再看完整的建表sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS student (s_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_name VARCHAR(20) NOT NULL default  ‘’,</span><br><span class="line">s_code VARCHAR(20) NOT NULL default  ‘’</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS studentAdd (a_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_id INT(10) UNSIGNED NOT NULL default  0,</span><br><span class="line">s_address VARCHAR(60) NOT NULL default  ‘’</span><br><span class="line">);</span><br><span class="line">alter table studentAdd add constraint studentAdd_s_id_fk0  foreign key (s_id) references student (s_id);</span><br><span class="line">CREATE TABLE IF NOT EXISTS class (c_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">c_name VARCHAR(20) NOT NULL default  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS classStudent (cs_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">c_id INT(10) NOT NULL,</span><br><span class="line">s_id INT(10) NOT NULL</span><br><span class="line">);</span><br><span class="line">alter table classStudent add constraint classStudent_c_id_fk0  foreign key (c_id) references class (c_id);</span><br><span class="line">alter table classStudent add constraint classStudent_s_id_fk0  foreign key (s_id) references student (s_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="建立课程班级信息表模型"><a href="#建立课程班级信息表模型" class="headerlink" title="建立课程班级信息表模型"></a>建立课程班级信息表模型</h5><p>表名：course</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>co_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>co_name</td><td>varchar(60)</td><td>课程名称</td></tr><tr><td></td><td></td></tr></tbody></table></div><p>表名：courseClass</p><div class="table-container"><table><thead><tr><th>字段名</th><th>数据类型</th><th>字段描述</th></tr></thead><tbody><tr><td>cc_id</td><td>int</td><td>主键，自动增长</td></tr><tr><td>co_id</td><td>int</td><td>课程ID</td></tr><tr><td>c_id</td><td>int</td><td>班级ID</td></tr></tbody></table></div><p>仿照上面流程，完成此表的模型。</p><p>并建立course.co_id 与 courseClass.co_id 的1对多关联，及class.c_id 与 courseClass.c_id的关联。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20200312045437.png" alt="QQ截图20200312045437"></p><h5 id="导出完整建表sql"><a href="#导出完整建表sql" class="headerlink" title="导出完整建表sql"></a>导出完整建表sql</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS student (s_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_name VARCHAR(20) NOT NULL default  ‘’,</span><br><span class="line">s_code VARCHAR(20) NOT NULL default  ‘’</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS studentAdd (a_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">s_id INT(10) UNSIGNED NOT NULL default  0,</span><br><span class="line">s_address VARCHAR(60) NOT NULL default  ‘’</span><br><span class="line">);</span><br><span class="line">alter table studentAdd add constraint studcentAdd_s_id_fk0  foreign key (s_id) references student (s_id);</span><br><span class="line">CREATE TABLE IF NOT EXISTS class (c_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">c_name VARCHAR(20) NOT NULL default  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS classStudent (cs_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">c_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">s_id INT(10) UNSIGNED NOT NULL</span><br><span class="line">);</span><br><span class="line">alter table classStudent add constraint classStudent_c_id_fk0  foreign key (c_id) references class (c_id);</span><br><span class="line">alter table classStudent add constraint classStudent_s_id_fk0  foreign key (s_id) references student (s_id);</span><br><span class="line">CREATE TABLE IF NOT EXISTS course (co_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">co_name VARCHAR(20) NOT NULL default  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS courseClass (cc_id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">co_id INT(20) UNSIGNED NOT NULL default  &#x27;&#x27;,</span><br><span class="line">c_id INT(20) UNSIGNED NOT NULL default  &#x27;&#x27;</span><br><span class="line">);</span><br><span class="line">alter table courseClass add constraint courseClass_co_id_fk0  foreign key (co_id) references course (co_id);</span><br><span class="line">alter table courseClass add constraint courseClass_c_id_fk0  foreign key (c_id) references class (c_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外键约束与级联操作"><a href="#外键约束与级联操作" class="headerlink" title="外键约束与级联操作"></a>外键约束与级联操作</h3><p>外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。</p><p>​        <strong>外键是表的一个字段，不是本表的主键，但对应另一个表的主键。</strong>定义外键后，不允许删除另一个表中具有关联关系的行。</p><p>​        外键对应的是<strong>参照完整性</strong>，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。</p><p>​        外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。</p><ul><li><strong>主表（父表）</strong>：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。</li><li><strong>从表（子表）</strong>：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。</li><li><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abf.png" alt="abf"></li></ul><h4 id="选取设置-MySQL-外键约束的字段"><a href="#选取设置-MySQL-外键约束的字段" class="headerlink" title="选取设置 MySQL 外键约束的字段"></a>选取设置 MySQL 外键约束的字段</h4><p>​        定义一个外键时，需要遵守下列规则：</p><ul><li>主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。</li><li>MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，要求主表必须有对应的索引，从表在创建外键的时候也会自动创建对应的索引。</li><li><strong>必须为主表定义主键</strong>。</li><li>主键不能包含空值，但允许在外键中出现空值。也就是说，<strong>只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。</strong></li><li>在主表的表名后面指定列名或列名的组合。<strong>这个列或列的组合必须是主表的主键或候选键（唯一键、复合主键）。</strong></li><li>外键中列的数目必须和主表的主键中列的数目相同。</li><li>外键中列的数据类型必须和主表主键中对应列的数据类型相同。</li></ul><h4 id="在创建表时设置外键约束"><a href="#在创建表时设置外键约束" class="headerlink" title="在创建表时设置外键约束"></a>在创建表时设置外键约束</h4><p>在数据表中创建外键使用 <strong>FOREIGN KEY</strong> 关键字，具体的语法规则如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY 字段名 [，字段名<span class="number">2</span>，…]</span><br><span class="line"><span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> 主键列<span class="number">1</span> [，主键列<span class="number">2</span>，…]</span><br></pre></td></tr></table></figure><p>其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table 成绩;</span><br><span class="line">drop table 学生;</span><br><span class="line">drop table 科目;</span><br><span class="line">CREATE TABLE IF NOT EXISTS 学生 (id int PRIMARY KEY,</span><br><span class="line">name varchar(10),</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS 科目 (id int PRIMARY KEY,</span><br><span class="line">name varchar(10)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2),</span><br><span class="line">CONSTRAINT fk_c_s FOREIGN KEY(学生ID) REFERENCES 学生(id),</span><br><span class="line">CONSTRAINT fk_c_k FOREIGN KEY(科目ID) REFERENCES 科目(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">show indexes from 成绩;</span><br></pre></td></tr></table></figure><p>提示：关联指的是关系数据库中，相关表之间的联系。它是通过相同的属性或属性组来表示的。子表的外键必须关联父表的主键，且关联字段的数据类型必须匹配，如果类型不一样，则创建子表时会出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 3780 (HY000): Referencing column &#x27;学生ID&#x27; and referenced column &#x27;id&#x27; in foreign key constraint &#x27;s&#x27; are incompatible.</span><br></pre></td></tr></table></figure><h4 id="建立外键关联以后的影响"><a href="#建立外键关联以后的影响" class="headerlink" title="建立外键关联以后的影响"></a>建立外键关联以后的影响</h4><p>​        在向从表中插入数据时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 成绩 <span class="keyword">values</span>(<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">12.3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 成绩(id, 成绩) <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">12.3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 成绩 <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12.3</span>);</span><br><span class="line">Cannot <span class="keyword">add</span> <span class="keyword">or</span> <span class="keyword">update</span> a child <span class="type">row</span>: a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> fails (`test`.`成绩`, <span class="keyword">CONSTRAINT</span> `fk_c_s` <span class="keyword">FOREIGN</span> KEY (`学生ID`) <span class="keyword">REFERENCES</span> `学生` (`id`))</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 学生 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 科目 <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​        <strong>如果外键字段插入的值，在不为null时，必须在关联的主表字段中存在，才能插入成功，否则报错。</strong></p><p>​        在向从表中更新数据时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 成绩 set 学生ID=3 where id=3;</span><br><span class="line"> Cannot add or update a child row: a foreign key constraint fails (`test`.`成绩`, CONSTRAINT `fk_c_s` FOREIGN KEY (`学生ID`) REFERENCES `学生` (`id`))</span><br><span class="line"> update 成绩 set 学生ID=null where id=3;</span><br></pre></td></tr></table></figure><p>​        <strong>如果外键字段更新后的值，在不为null时，必须在关联的主表字段中存在时，才能更新成功，否则报错。</strong></p><p>​        </p><p>​        在向主表中更新存在已关联从表的字段数据时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 学生 set id=3 where id=2;</span><br><span class="line">delete from 学生 where id=2;</span><br><span class="line">Cannot delete or update a parent row: a foreign key constraint fails (`test`.`成绩`, CONSTRAINT `fk_c_s` FOREIGN KEY (`学生ID`) REFERENCES `学生` (`id`))</span><br></pre></td></tr></table></figure><p>​        <strong>无法更新主表中，存在已关联到从表的字段数据，只能更无关联的数据。</strong></p><p>​        在主表删除存在已关联从表的字段数据时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 学生 where id=2;</span><br><span class="line">Cannot delete or update a parent row: a foreign key constraint fails (`test`.`成绩`, CONSTRAINT `fk_c_s` FOREIGN KEY (`学生ID`) REFERENCES `学生` (`id`))</span><br></pre></td></tr></table></figure><p>​        <strong>如果存在关联到将被删除的主表记录，的从表记录时，无法删除。必须先删除从表中对应记录后，才能删除主表记录。</strong></p><p>​        在删除从表记录时：</p><p>​        <strong>无影响</strong></p><p>​        在删除主表时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 学生;</span><br><span class="line"> Cannot <span class="keyword">drop</span> <span class="keyword">table</span> <span class="string">&#x27;学生&#x27;</span> referenced <span class="keyword">by</span> a <span class="keyword">foreign</span> key <span class="keyword">constraint</span> <span class="string">&#x27;fk_c_s&#x27;</span> <span class="keyword">on</span> <span class="keyword">table</span> <span class="string">&#x27;成绩&#x27;</span>.</span><br></pre></td></tr></table></figure><p>​        <strong>当外键关系还存在时，不能删除主表。必须先删除外键后，才能删除主表。</strong></p><p>​        在删除从表时：</p><p>​        <strong>无影响</strong></p><h4 id="在修改表时添加外键约束"><a href="#在修改表时添加外键约束" class="headerlink" title="在修改表时添加外键约束"></a>在修改表时添加外键约束</h4><p>在修改数据表时添加外键约束的语法规则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);</span><br></pre></td></tr></table></figure><p>我们还是来看看学生成绩表的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drop table 成绩;</span><br><span class="line">drop table 学生;</span><br><span class="line">drop table 科目;</span><br><span class="line">CREATE TABLE IF NOT EXISTS 学生 (id int PRIMARY KEY,</span><br><span class="line">name varchar(10)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS 科目 (id int PRIMARY KEY,</span><br><span class="line">name varchar(10)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2)</span><br><span class="line">);</span><br><span class="line">alter table 成绩 add constraint 成绩_学生ID_fk0  foreign key (学生ID) references 学生 (id);</span><br><span class="line">alter table 成绩 add constraint 成绩_科目ID_fk0  foreign key (科目ID) references 科目 (id);</span><br></pre></td></tr></table></figure><h4 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h4><p>对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系，MySQL 中删除外键的语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;</span><br></pre></td></tr></table></figure><p>去除外键约束后，对应创建在从表上的索引，还继续存在，除非直接drop相关索引。</p><h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><p>​        在创建外键的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括<strong>RESTRICT、NO ACTION、SET NULL和CASCADE</strong>。</p><p>​        其中RESTRICT和NO ACTION相同，是指在子表有关联记录的情况下父表不能更新；CASCADE表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL则是表示父表在更新或者删除的时候，子表的对应字段被SET NULL。</p><h5 id="不允许级联操作"><a href="#不允许级联操作" class="headerlink" title="不允许级联操作"></a>不允许级联操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2),</span><br><span class="line">CONSTRAINT fk_c_s FOREIGN KEY(学生ID) REFERENCES 学生(id) ON DELETE RESTRICT ON UPDATE RESTRICT,</span><br><span class="line">CONSTRAINT fk_c_k FOREIGN KEY(科目ID) REFERENCES 科目(id)</span><br><span class="line">);</span><br><span class="line">--或者如下</span><br><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2),</span><br><span class="line">CONSTRAINT fk_c_s FOREIGN KEY(学生ID) REFERENCES 学生(id) ON DELETE NO ACTION ON UPDATE NO ACTION,</span><br><span class="line">CONSTRAINT fk_c_k FOREIGN KEY(科目ID) REFERENCES 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行no action设置之后，与未设置级联操作一致（no action实际是默认模式），删除和更新会报错。</p><h5 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2),</span><br><span class="line">CONSTRAINT fk_c_s FOREIGN KEY(学生ID) REFERENCES 学生(id) ON UPDATE CASCADE,</span><br><span class="line">CONSTRAINT fk_c_k FOREIGN KEY(科目ID) REFERENCES 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行了on update cascade设置之后，update操作主表，将主表数据和从表中关联的数据字段都一并更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 学生 set id=3 where id=2;</span><br><span class="line">select * from 学生;</span><br><span class="line">select * from 成绩;</span><br></pre></td></tr></table></figure><h5 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2),</span><br><span class="line">CONSTRAINT fk_c_s FOREIGN KEY(学生ID) REFERENCES 学生(id) ON delete CASCADE,</span><br><span class="line">CONSTRAINT fk_c_k FOREIGN KEY(科目ID) REFERENCES 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行了on delete cascade设置之后，delete操作主表，将主表数据和从表中关联的数据都一并删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from 学生 where id=2;</span><br><span class="line">select * from 学生;</span><br><span class="line">select * from 成绩;</span><br></pre></td></tr></table></figure><p>on update cascade 与 on delete cascade 可以连起来写。</p><h5 id="级联设置为null"><a href="#级联设置为null" class="headerlink" title="级联设置为null"></a>级联设置为null</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS 成绩 (id int PRIMARY KEY,</span><br><span class="line">学生ID INT(10),</span><br><span class="line">科目ID INT(10),</span><br><span class="line">成绩 DECIMAL(10,2),</span><br><span class="line">CONSTRAINT fk_c_s FOREIGN KEY(学生ID) REFERENCES 学生(id) ON delete set null,</span><br><span class="line">CONSTRAINT fk_c_k FOREIGN KEY(科目ID) REFERENCES 科目(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>进行了on delete set null 或 on update set null 设置之后，delete 或 update 操作主表，将主表数据和从表中关联的数据字段都一并设为null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from 学生 where id=2;</span><br><span class="line">select * from 学生;</span><br><span class="line">select * from 成绩;</span><br></pre></td></tr></table></figure><h2 id="第5章-常用数据库对象（视图、索引、存储过程、触发器）"><a href="#第5章-常用数据库对象（视图、索引、存储过程、触发器）" class="headerlink" title="第5章 常用数据库对象（视图、索引、存储过程、触发器）"></a>第5章 常用数据库对象（视图、索引、存储过程、触发器）</h2><h3 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h3><h4 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h4><p>​        视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。</p><p>　　通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用查询动态生成。</p><p>​        基表：用来创建视图的表叫做基表 base table。</p><h4 id="为什么要使用视图"><a href="#为什么要使用视图" class="headerlink" title="为什么要使用视图"></a>为什么要使用视图</h4><p>​        因为视图的诸多优点，如下</p><p>　　1）简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</p><p>　　2）安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</p><p>　　3）数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</p><p>总而言之，使用视图的大部分情况是为了<strong>保障数据安全性，提高查询效率。</strong></p><h4 id="如何创建视图"><a href="#如何创建视图" class="headerlink" title="如何创建视图"></a>如何创建视图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">[WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>1）OR REPLACE：表示替换已有视图</p><p>2）ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表</p><p>3）select_statement：表示select语句</p><p>4）[WITH [CASCADED | LOCAL] CHECK OPTION]：表示视图在更新时保证在视图的权限范围之内</p><p>　　cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件</p><p>　　local表示更新视图的时候，要满足该视图定义的一个条件即可。</p><p>例子：创建单表视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create view v_stu1 as select * from student;</span><br><span class="line">select * from v_stu1;</span><br><span class="line">create view v_stu2 as select sid, sname from student;</span><br><span class="line">select * from v_stu2;</span><br><span class="line">create view v_stu3(学生编号, 学生姓名) as select sid, sname from student;</span><br><span class="line">select * from v_stu3;</span><br></pre></td></tr></table></figure><p>例子：创建多表关联视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create view v_tc1 as</span><br><span class="line">select tname, cname from teacher, course where tid=teacher_id;</span><br><span class="line">create view v_tc2(教师名称，担任课程) as</span><br><span class="line">select tname, cname from teacher, course where tid=teacher_id;</span><br></pre></td></tr></table></figure><p>​        视图将我们不需要的数据过滤掉，将相关的列名用我们自定义的列名替换。视图作为一个访问接口，不管基表的表结构和表名有多复杂。</p><p> 　    如果创建视图时不明确指定视图的列名，那么列名就和定义视图的select子句中的列名完全相同；</p><p>　　如果显式的指定视图的列名就按照指定的列名。</p><p><strong>注意：显示指定视图列名，要求视图名后面的列的数量必须匹配select子句中的列的数量。</strong></p><p>​        视图存在2种执行算法。</p><p>​        marge：合并的执行方式，指在执行视图时，将视图的sql语句与外部查询视图的sql混合在一起，一次执行。</p><p>​        temptable：临时表模式，在执行视图时，先执行视图的sql语句，生成一个临时表，再在临时表的基础上执行查询视图的sql。</p><p>​        undefined：未定义模式，mysql会在创建时，自动确定使用哪种执行算法。</p><h4 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h4><p>​        视图一旦创建完毕，就可以像一个普通表那样使用，视图主要用来查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from view_name;</span><br></pre></td></tr></table></figure><p>​        还可以使用 show create view 语句查看视图信息。</p><p>​        查看库中存在哪些视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.views where table_schema=&#x27;test&#x27;;</span><br></pre></td></tr></table></figure><h4 id="更改视图"><a href="#更改视图" class="headerlink" title="更改视图"></a>更改视图</h4><p>​        CREATE OR REPLACE VIEW语句修改视图</p><p>​        基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create or replace view view_name as select语句;</span><br></pre></td></tr></table></figure><p>​        <strong>在视图存在的情况下可对视图进行修改，视图不存在的情况下可创建视图。</strong></p><p>​        还可以使用ALTER语句修改视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER</span><br><span class="line">    [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;]</span><br><span class="line">    [DEFINER = &#123; user | CURRENT_USER &#125;]</span><br><span class="line">    [SQL SECURITY &#123; DEFINER | INVOKER &#125;]</span><br><span class="line">VIEW view_name [(column_list)]</span><br><span class="line">AS select_statement</span><br><span class="line">    [WITH [CASCADED | LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure><p>​        注意：修改视图是指修改数据库中已存在的表的定义，当基表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致。</p><h4 id="操作视图数据"><a href="#操作视图数据" class="headerlink" title="操作视图数据"></a>操作视图数据</h4><p>​        <strong>因为视图本身没有数据，因此对视图进行的dml操作最终都体现在基表中</strong></p><p>​        当然，视图的DML操作，不是所有的视图都可以做DML操作。</p><p>有下列内容之一，视图不能做DML操作：</p><p>　　①select子句中包含distinct</p><p>　　②select子句中包含组函数</p><p>　　③select语句中包含group by子句</p><p>　　④select语句中包含order by子句</p><p>　　⑤select语句中包含union 、union all等集合运算符</p><p>　　⑥where子句中包含相关子查询</p><p>　　⑦from子句中包含多个表</p><p>　　⑧如果视图中有计算列，则不能更新</p><p>　　⑨如果基表中有某个具有非空约束的列未出现在视图定义中，则不能做insert操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create view v_stu4 as select * from student;</span><br><span class="line">insert into v_stu4 values(18,&#x27;男&#x27;, &#x27;3&#x27;, &#x27;赵四&#x27;,&#x27;2002-2-3&#x27;);</span><br><span class="line">delete from v_stu4 where sid=18;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure><h4 id="drop删除视图"><a href="#drop删除视图" class="headerlink" title="drop删除视图"></a>drop删除视图</h4><p>　　删除视图是指删除数据库中已存在的视图，删除视图时，只能删除视图的定义，不会删除数据，也就是说不动基表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] view_name [, view_name] ...</span><br></pre></td></tr></table></figure><h4 id="使用WITH-CHECK-OPTION约束"><a href="#使用WITH-CHECK-OPTION约束" class="headerlink" title="使用WITH CHECK OPTION约束"></a>使用WITH CHECK OPTION约束</h4><p>​        对于可以执行DML操作的视图，定义时可以带上WITH CHECK OPTION约束</p><p>​        作用：对视图所做的DML操作的结果，不能违反视图的WHERE条件的限制。</p><p>​        示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view v_stu5 as select * from student where birthday &gt; &#x27;2005-1-1&#x27; with check option;</span><br><span class="line">insert into v_stu5 values(19,&#x27;男&#x27;, &#x27;3&#x27;, &#x27;孙五&#x27;,&#x27;2002-2-3&#x27;);</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>​        MySQL的索引主要分为<strong>主键索引(PRIMARY KEY)，唯一索引(UNIQUE) ，普通索引(INDEX)和全文索引(FULLTEXT)</strong> 。</p><p>​        MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p><p>​        索引分<strong>单列索引</strong>和<strong>组合索引</strong>。单列索引，即一个索引只包含单个列，组合索引，即一个索引包含多个列。一个表可以有多个单列索引与这组合索引。</p><p>​        创建索引时，你需要确保该索引是应用在SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p><p>​        实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p><p>​        但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p><p>​        建立索引会占用磁盘空间的索引文件。</p><h4 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h4><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX i_tc9_a <span class="keyword">ON</span> tc_9(bbb(<span class="number">15</span>));</span><br><span class="line"><span class="keyword">CREATE</span> INDEX i_tc9_a <span class="keyword">ON</span> tc_9(bbb(<span class="number">15</span>), ccc)</span><br></pre></td></tr></table></figure><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度。</p><p>​        在已存在的表上追加普通索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tc_9 ADD INDEX i_tc_9b(bbb);</span><br><span class="line">ALTER table tc_9 ADD INDEX i_tc_9b(bbb, ccc);</span><br></pre></td></tr></table></figure><p>创建表的时候直接指定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_9(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  index i_tc_9a (bbb)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_9(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  index i_tc_9a (bbb, ccc)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        以这种模式定义的索引，可以不指定索引名称。</p><h4 id="查看表上的索引"><a href="#查看表上的索引" class="headerlink" title="查看表上的索引"></a>查看表上的索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from tc_9;</span><br></pre></td></tr></table></figure><p>​        可以查看到创建在表上的所有索引名称。</p><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index i_tc_9a on tc_9;</span><br></pre></td></tr></table></figure><p>​        删除表时，会一并删除表上的全部索引。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>​        它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式</p><p>​        创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX i_tc_9b ON tc_9(bbb); </span><br></pre></td></tr></table></figure><p>​        在已存在的表上追加唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER table tc_9 ADD UNIQUE i_tc_9c (bbb)</span><br></pre></td></tr></table></figure><p>​        创建表的时候直接指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table tc_9(</span><br><span class="line">  aaa int primary key,</span><br><span class="line">  bbb varchar(20),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  unique i_tc_9a (bbb)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        <strong>删除唯一索引的方法与删除普通索引相同。</strong></p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>​        主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候指定了主键，就会创建主键索引， CREATE INDEX不能用来创建主键索引，使用 ALTER TABLE来代替。</p><p>​        创建主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tc_10;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_10(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_10(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">primary</span> key(aaa)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_10(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_10 <span class="keyword">add</span> <span class="keyword">primary</span> key(aaa);</span><br></pre></td></tr></table></figure><p>​        删除主键</p><p>​        可以使用 ALTER 命令删除主键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tc_10 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><p>​        删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。而不能使用删除普通索引的方法来删除主键索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这都是错误的。</span></span><br><span class="line"><span class="keyword">drop</span> index <span class="keyword">PRIMARY</span> <span class="keyword">on</span> tc_10;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">primary</span> key <span class="keyword">on</span> tc_10;</span><br></pre></td></tr></table></figure><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>​        全文索引：FULLTEXT索引用于全文搜索。只有InnoDB和 MyISAM存储引擎支持，FULLTEXT索引仅适用于 CHAR， VARCHAR和 TEXT列。</p><p>​        创建全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tc_10;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_10(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  fulltext i_tc10_a(bbb)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_10 <span class="keyword">add</span> fulltext i_tc10_b(bbb);</span><br></pre></td></tr></table></figure><p>​        删除全文索引，与删除普通索引一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index i_tc10_b on tc_10;</span><br></pre></td></tr></table></figure><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​        MySQL 5.0 版本开始支持存储过程。</p><p>​        <strong>存储过程（Stored Procedure）</strong>是一种在数据库中存储的复杂程序，以便外部程序调用的一种数据库对象。</p><p>​        存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>​        存储过程思想上很简单，就是数据库 SQL 语言层面的<strong>代码封装与重用</strong>。</p><p>​        <strong>存储过程通常有以下优点：</strong></p><p>​        存储过程增强了SQL语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</p><p>​        存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。</p><p>​        存储过程能实现较快的执行速度。如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。</p><p>​        存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。</p><p>​        存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。</p><p>​        <strong>存储过程的缺点</strong></p><p>​        存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</p><p>​        存储过程的性能调校与撰写，受限于各种数据库系统。</p><h4 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">    [DEFINER <span class="operator">=</span> &#123; <span class="keyword">user</span> <span class="operator">|</span> <span class="built_in">CURRENT_USER</span> &#125;]</span><br><span class="line">　<span class="keyword">PROCEDURE</span> sp_name ([proc_parameter[,...]])</span><br><span class="line">    [characteristic ...] routine_body</span><br><span class="line"><span class="comment">-- 声明过程名称、参数列表</span></span><br><span class="line"> </span><br><span class="line">proc_parameter:</span><br><span class="line">    [ <span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">INOUT</span> ] param_name type</span><br><span class="line"> </span><br><span class="line">characteristic:</span><br><span class="line">    COMMENT <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  <span class="operator">|</span> <span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line">  <span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line">  <span class="operator">|</span> &#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line">  <span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="comment">-- 这是附加的一些存储过程描述信息，一般很少使用，这里不做详解</span></span><br><span class="line"> </span><br><span class="line">routine_body:</span><br><span class="line">　　Valid <span class="keyword">SQL</span> routine statement</span><br><span class="line"><span class="comment">-- SQL路由描述，一般也很少使用</span></span><br><span class="line"> </span><br><span class="line">[begin_label:] <span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 开始存储过程标记</span></span><br><span class="line">　　[statement_list]</span><br><span class="line"><span class="comment">-- 存储过程主体</span></span><br><span class="line">　　　　……　　　</span><br><span class="line"><span class="keyword">END</span> [end_label]</span><br><span class="line"><span class="comment">-- 结束存储过程标记</span></span><br></pre></td></tr></table></figure><h4 id="一个最简单的无参数存储过程示例"><a href="#一个最简单的无参数存储过程示例" class="headerlink" title="一个最简单的无参数存储过程示例"></a>一个最简单的无参数存储过程示例</h4><p>​        我们来创建一个最简单的存储过程，没有入参出参、内部只有一条语句，向测试表中插入一条语句。</p><p>​        数据准备:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ptest_01(</span><br><span class="line">  pid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">pname <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_01()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call p_01();</span><br></pre></td></tr></table></figure><h4 id="带有入参的存储过程示例"><a href="#带有入参的存储过程示例" class="headerlink" title="带有入参的存储过程示例"></a>带有入参的存储过程示例</h4><p>​        在存储过程中传参分 <strong>in ,out , inout</strong> 三种</p><p>​        <strong>in 可以输出从外部传入的变量 不会改变传进变量本来的值</strong></p><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_02(<span class="keyword">in</span> name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(name);</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name1;</span><br><span class="line">  <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name2;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @name=&#x27;www&#x27;;</span><br><span class="line">call p_02(@name);</span><br><span class="line">select @name;</span><br><span class="line">select * from ptest_01;</span><br></pre></td></tr></table></figure><p>​        可以发现，<strong>in 参数在过程体中被改变后，改变的值不能带出过程体，过程体外还是原值。</strong></p><h4 id="带有出参的存储过程示例"><a href="#带有出参的存储过程示例" class="headerlink" title="带有出参的存储过程示例"></a>带有出参的存储过程示例</h4><p>​        <strong>out 不能输出从外部传进的值 会改变传进变量本来的值</strong></p><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_03(<span class="keyword">out</span> name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(name);</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name1;</span><br><span class="line">  <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name2;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @name=&#x27;rrr&#x27;;</span><br><span class="line">call p_03(@name);</span><br><span class="line">select @name;</span><br><span class="line">select * from ptest_01;</span><br></pre></td></tr></table></figure><p>​        </p><h4 id="带有出入参的存储过程示例"><a href="#带有出入参的存储过程示例" class="headerlink" title="带有出入参的存储过程示例"></a>带有出入参的存储过程示例</h4><p><strong>inout 既可以从外部传进的值，也可以改变传进变量本来的值</strong></p><p>​        创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_04(<span class="keyword">inout</span> name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(name);</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name1;</span><br><span class="line">  <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;hahaha&#x27;</span>;</span><br><span class="line">  <span class="keyword">select</span> name <span class="keyword">as</span> name2;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>​        创建完成后，我们调用一下此存储过程，查看效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @name=&#x27;rrr&#x27;;</span><br><span class="line">call p_04(@name);</span><br><span class="line">select @name;</span><br><span class="line">select * from ptest_01;</span><br></pre></td></tr></table></figure><p>​        可以发现，<strong>inout 参数可以传值进入过程体，过程题内部被赋值后的值可以带出过程体。</strong></p><h4 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h4><p>​        查看某个数据库中建立的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> status <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines</span><br><span class="line"><span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> routine_type<span class="operator">=</span><span class="string">&#x27;PROCEDURE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​        查看创建存储过程的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p_06;</span><br></pre></td></tr></table></figure><h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop procedure p_05; </span><br><span class="line">drop procedure if exists p_06; </span><br></pre></td></tr></table></figure><h4 id="存储过程体语法"><a href="#存储过程体语法" class="headerlink" title="存储过程体语法"></a>存储过程体语法</h4><h5 id="变量的声明、引用、赋值"><a href="#变量的声明、引用、赋值" class="headerlink" title="变量的声明、引用、赋值"></a>变量的声明、引用、赋值</h5><p>​        在MySQL编程中，存在两种变量：</p><p>​        <strong>用户变量（可以在过程体内外声明，生存周期为当前会话，两个不同会话之间，同名的变量，不会互相覆盖）。</strong></p><p>​        <strong>局部变量（只能在过程体中声明，离开过程体之后，变量被销毁）。</strong></p><p>​        用户变量不需要声明，可以直接通过赋值来创建变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="variable">@aaa</span> <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>​        局部变量使用 declare 关键字声明，使用 set 关键字赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> variable_name [,variable_name...] datatype [<span class="keyword">DEFAULT</span> <span class="keyword">value</span>];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_05()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> abc <span class="type">int</span> <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">set</span> abc <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">select</span> abc;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">select</span> abc;</span><br></pre></td></tr></table></figure><p>​        除了使用 set 赋值，还可以通过 select 语句赋值；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select pname from ptest_01 limit 1 into @n1;</span><br><span class="line">select pname into @n2 from ptest_01 limit 1;</span><br><span class="line">select @n1, @n2;</span><br><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line">create procedure p_06()</span><br><span class="line">begin</span><br><span class="line">declare n3, n4 varchar(20) default &#x27;000&#x27;;</span><br><span class="line">select pname from ptest_01 limit 1 into n3;</span><br><span class="line">    select pname into n4 from ptest_01 limit 1;</span><br><span class="line">    select n3, n4;</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line">call p_06();</span><br></pre></td></tr></table></figure><p>​        <strong>注意：使用 select 语句赋值时，返回结果集必须是单行单值。</strong></p><h5 id="程序控制结构-分支结构"><a href="#程序控制结构-分支结构" class="headerlink" title="程序控制结构 - 分支结构"></a>程序控制结构 - 分支结构</h5><h6 id="if-then-else-语句"><a href="#if-then-else-语句" class="headerlink" title="if-then-else 语句"></a>if-then-else 语句</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p_07(<span class="keyword">in</span> n1 <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">if(n1 <span class="operator">&gt;=</span> <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 &gt;= 0&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> ptest_01(pname) <span class="keyword">value</span>(<span class="string">&#x27;n1 &lt; 0&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> p_07();</span><br></pre></td></tr></table></figure><p>​        <strong>跟js中的语法类似，但是分支判断开始时，if的判断逻辑后面要加入 then ，结束时需要加入 end if;</strong></p><h6 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create procedure p_08(in n1 int)</span><br><span class="line">begin</span><br><span class="line">case(n1)</span><br><span class="line">  when(1) then</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;n1 = 1&#x27;);</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;1111&#x27;);</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;11111&#x27;);</span><br><span class="line">  when(2) then</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;n1 = 2&#x27;);</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;2222&#x27;);</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;22222&#x27;);</span><br><span class="line">  when(3) then</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;n1 = 3&#x27;);</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;3333&#x27;);</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;33333&#x27;);</span><br><span class="line">  else</span><br><span class="line">    insert into ptest_01(pname) value(&#x27;n1 = other&#x27;);</span><br><span class="line">end case;</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line">call p_08();</span><br></pre></td></tr></table></figure><p>​        <strong>与 js 相比，没有  switch 关键字，由 case 代替 switch，when 后面加枚举值，在后面加 then。同时不需要break。结束时加入 end case。</strong></p><h5 id="程序控制结构-循环结构"><a href="#程序控制结构-循环结构" class="headerlink" title="程序控制结构 - 循环结构"></a>程序控制结构 - 循环结构</h5><h6 id="while…end-while-循环"><a href="#while…end-while-循环" class="headerlink" title="while…end while 循环"></a>while…end while 循环</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create procedure p_11(in n1 int)</span><br><span class="line">begin</span><br><span class="line">declare n2 int;</span><br><span class="line">set n2 = 0;</span><br><span class="line">while(n2 &lt; n1 ) do</span><br><span class="line">  insert into ptest_01(pname) value(concat(&#x27;n2 = &#x27;,n2));</span><br><span class="line">  set n2 = n2 + 1;</span><br><span class="line">end while;</span><br><span class="line">insert into ptest_01(pname) value(&#x27;while is over.&#x27;);</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line">call p_11(3);</span><br></pre></td></tr></table></figure><p>​        <strong>while(判断逻辑表达式) 后面要加 do，结束时写 end while; 类似 js 中的 while 循环 。</strong></p><h6 id="repeat····-end-repea-循环"><a href="#repeat····-end-repea-循环" class="headerlink" title="repeat···· end repea 循环"></a>repeat···· end repea 循环</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create procedure p_12(in n1 int)</span><br><span class="line">begin</span><br><span class="line">declare n3 int;</span><br><span class="line">set n3 = 0;</span><br><span class="line">repeat</span><br><span class="line">  insert into ptest_01(pname) value(concat(&#x27;n3 = &#x27;,n3));</span><br><span class="line">  set n3 = n3 + 1;</span><br><span class="line">  until(n3 &gt; n1)</span><br><span class="line">end repeat;</span><br><span class="line">insert into ptest_01(pname) value(&#x27;repeat is over.&#x27;);</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line">call p_12(3);</span><br></pre></td></tr></table></figure><p>​        <strong>类型 js 中的 do … while 循环，不判断条件，直接进循环体，在 until 时判断条件，为逻辑真时退出循环。结束时写 end repeat; 关键字。</strong></p><h6 id="loop-·····endloop-循环"><a href="#loop-·····endloop-循环" class="headerlink" title="loop ·····endloop 循环"></a>loop ·····endloop 循环</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create procedure p_13(in n1 int)</span><br><span class="line">begin</span><br><span class="line">declare n4 int;</span><br><span class="line">set n4 = 0;</span><br><span class="line">loop_lable: loop</span><br><span class="line">  insert into ptest_01(pname) value(concat(&#x27;n4 = &#x27;,n4));</span><br><span class="line">  set n4 = n4 + 1;</span><br><span class="line">  if(n4 &gt; n1) then leave loop_lable;</span><br><span class="line">  end if;</span><br><span class="line">end loop;</span><br><span class="line">insert into ptest_01(pname) value(&#x27;loop is over.&#x27;);</span><br><span class="line">end$</span><br><span class="line">delimiter ;</span><br><span class="line">call p_13(3);</span><br></pre></td></tr></table></figure><p>​        <strong>loop 循环本质上是一个死循环，靠循环体中加入强制跳出循环语句，配合标号语句来标记 loop 头部，来结束循环。</strong></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​        触发器（trigger）：监视某种情况，并触发某种操作，它是提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，<strong>它的执行不是由程序调用</strong>，也不是手工启动，而是由事件来触发，例如当对一个表进行操作（ <strong>insert，delete， update</strong>）时就会激活它执行。</p><h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器经常用于加强数据的完整性约束和业务规则等。 触发器依赖于四个要素：<br>​        1.监视地点(table)<br>​        2.监视事件(insert/update/delete)<br>​        3.触发时间(after/before)<br>​        4.触发事件(内部执行逻辑)</p><p>​    完成作用是：</p><p>​        <strong>在写入数据前后，强制检验或者转换数据(保证护数据安全)</strong></p><p>​    错误处理时：</p><p>​        <strong>触发器发生错误时，前面用户已经执行成功的操作会被撤销，类似事务的回滚</strong></p><h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><h5 id="创建语法-1"><a href="#创建语法-1" class="headerlink" title="创建语法"></a>创建语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter $ //设置MySQL执行结束标志，默认为;</span><br><span class="line">create trigger tg_name  -- 触发器名称</span><br><span class="line">  after|before  -- 触发时间</span><br><span class="line">  insert|update|delete  -- 监视事件 </span><br><span class="line">  on table_name -- 监控表名</span><br><span class="line">  for each row  -- 固定写法</span><br><span class="line">  begin  -- 开始触发器内部逻辑</span><br><span class="line">    update goods set num=num-2 where gid = 1;</span><br><span class="line">end$  -- 结束触发器内部逻辑</span><br><span class="line">delimiter ;  //重新将MySQL执行结束标志设置为;</span><br></pre></td></tr></table></figure><p>​        <strong>注意：</strong>因为mysql的执行结束标识默认是;。如果运行以上的sql语句，mysql碰到;时会自动停止执行，然后end语句就执行不到了。所以我们需要先将mysql的结束标识符改为其他的字符，一般都选用$或者$$，这里选用$来作为执行的结束标识。</p><p>​    触发时间：当 SQL 指令发生时，会令行中数据发生变化，而每张表中对应的行有两种状态：数据操作前和操作后</p><p><strong>before</strong>：表中数据发生改变前的状态<br><strong>after</strong>：表中数据发生改变后的状态<br><strong>PS：如果 before 触发器失败或者语句本身失败，将不执行 after 触发器(如果有的话)</strong></p><p>​    触发事件：触发器是针对数据发送改变才会被触发，对应的操作只有</p><p><strong>INSERT</strong><br><strong>DELETE</strong><br><strong>UPDATE</strong></p><p>注意事项：<br>        触发器名必须在每个表中唯一，但不是在每个数据库中唯一，即同一数据库中的两个表可能具有相同名字的触发器，每个表的每个事件每次只允许一个触发器，因此，每个表最多支持 <strong>6</strong> 个触发器，<strong>before/after insert、before/after delete、before/after update</strong></p><h5 id="简单触发器示例1"><a href="#简单触发器示例1" class="headerlink" title="简单触发器示例1"></a>简单触发器示例1</h5><p>​        订单货品示例，数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table goods(</span><br><span class="line">  gid int,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  num smallint</span><br><span class="line">);</span><br><span class="line">create table ord(</span><br><span class="line">  oid int,</span><br><span class="line">  gid int,</span><br><span class="line">  much smallint</span><br><span class="line">);</span><br><span class="line">insert into goods values(1,&#x27;cat&#x27;,40);</span><br><span class="line">insert into goods values(2,&#x27;dog&#x27;,63);</span><br><span class="line">insert into goods values(3,&#x27;pig&#x27;,87);</span><br></pre></td></tr></table></figure><p>​        业务目标</p><p>​                在ord订单表新增一条时，将goods表中 gid=1 的货品数量减少2。</p><p>​        触发器逻辑分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">监视谁：ord（订单表）</span><br><span class="line">监视动作：insert（插入操作）</span><br><span class="line">触发时间：after（在插入操作后触发）</span><br><span class="line">触发事件：update（触发更新操作）</span><br></pre></td></tr></table></figure><p>​        创建触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create trigger t1 </span><br><span class="line">  after insert</span><br><span class="line">  on ord</span><br><span class="line">  for each row</span><br><span class="line">  begin</span><br><span class="line">    update goods set num=num-2 where gid = 1;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure><p>​        我们来检查触发器有没有生效。</p><h5 id="简单触发器示例2"><a href="#简单触发器示例2" class="headerlink" title="简单触发器示例2"></a>简单触发器示例2</h5><p>​        学生成绩示例，数据准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table stu (</span><br><span class="line">  stu_id int PRIMARY key auto_increment,</span><br><span class="line">  stu_code int,</span><br><span class="line">  stu_name varchar(20)</span><br><span class="line">);</span><br><span class="line">create  table sc (</span><br><span class="line">  sc_id int primary key auto_increment,</span><br><span class="line">  stu_code int,</span><br><span class="line">  stu_score decimal(8,2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​    业务目标 ：</p><p>​        在插入学生表一条记录的时候，插入成绩表一条记录，写入学生编号，成绩为80</p><p>​    触发器逻辑分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">监视谁：stu（学生表）</span><br><span class="line">监视动作：insert（插入操作）</span><br><span class="line">触发时间：after（在插入操作后触发）</span><br><span class="line">触发事件：insert（触发更新操作）</span><br></pre></td></tr></table></figure><p>​    创建触发器</p><p>​        <strong>触发器针对的是数据库中的每一行记录，每行数据在操作前后都会有一个对应的状态，触发器将没有操作之前的状态保存到 old 关键字中，将操作后的状态保存到 new 中</strong>。</p><p>需要注意的是，old 和 new 不是所有触发器都有<br><strong>INSERT型触发器    没有 old，只有 new，new 表示将要(插入前)或者已经增加(插入后)的数据</strong><br><strong>UPDATE型触发器    既有 old 也有 new，old 表示更新之前的数据，new 表示更新之后的数据</strong><br><strong>DELETE型触发器    没有 new，只有 old，old 表示将要(删除前)或者已经被删除(删除后)的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> sc_h (</span><br><span class="line">  sc_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">stu_code <span class="type">int</span>,</span><br><span class="line">  before_update_code <span class="type">int</span>,</span><br><span class="line">after_update_code <span class="type">int</span>,</span><br><span class="line">  before_update_score <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">after_update_score <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t2</span><br><span class="line">  after <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> stu <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> sc(stu_code,stu_score) <span class="keyword">values</span>(new.stu_code, <span class="number">80.0</span>);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> t2a</span><br><span class="line">  after <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> sc <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> sc_h(stu_code, before_update_code, after_update_code,</span><br><span class="line">before_update_score,  after_update_score)</span><br><span class="line"><span class="keyword">values</span>(new.stu_code, old.stu_code, new.stu_code,</span><br><span class="line">old.stu_score, new.stu_score);</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure><p>​        检查一下触发器是否正常工作。</p><h4 id="带传值的触发器"><a href="#带传值的触发器" class="headerlink" title="带传值的触发器"></a>带传值的触发器</h4><h5 id="升级简单触发器1"><a href="#升级简单触发器1" class="headerlink" title="升级简单触发器1"></a>升级简单触发器1</h5><p>​        在 2.2 简单触发器1 中，我们将固定商品的数量减少2，现在我们将升级这个逻辑，将订单中对应商品的数量建少订单中对应的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create trigger t3</span><br><span class="line">  after insert</span><br><span class="line">  on ord</span><br><span class="line">  for each row</span><br><span class="line">  begin</span><br><span class="line">    -- new 代表 ord 表中新增的数据</span><br><span class="line">    update goods set num = num - new.much where gid = new.gid;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure><h5 id="进一步升级简单触发器1"><a href="#进一步升级简单触发器1" class="headerlink" title="进一步升级简单触发器1"></a>进一步升级简单触发器1</h5><p>​     如果在订单数量大于商品库存数量时，该怎么办？</p><p>​     这里需要检查库存量与订货数量，当订货量大于库存量时，放弃订单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create trigger t4</span><br><span class="line">  before insert</span><br><span class="line">  on ord</span><br><span class="line">  for each row</span><br><span class="line">  begin</span><br><span class="line">    -- 取出 goods 表中对应 id 的库存</span><br><span class="line">    -- new 代表 orders 表中新增的数据</span><br><span class="line">    select num from goods where gid = new.gid into @num;    </span><br><span class="line">    -- 用即将插入的 orders 表中的库存和 goods 表中的库存进行比较</span><br><span class="line">    -- 如果库存不够，中断操作</span><br><span class="line">    if @num &lt; new.num then</span><br><span class="line">        -- 中断操作：暴力解决，主动出错</span><br><span class="line">        insert into xxx values(xxx);</span><br><span class="line">    end if;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure><p><strong>如果在触发器中出现错误，那么前面的已经执行的操作也会全部回滚</strong></p><h5 id="升级简单触发器1的另一种方法"><a href="#升级简单触发器1的另一种方法" class="headerlink" title="升级简单触发器1的另一种方法"></a>升级简单触发器1的另一种方法</h5><p>如果在订单数量大于商品库存数量时，我们还可以强制修改订单订货 数量为库存数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create trigger t5</span><br><span class="line">  before insert</span><br><span class="line">  on ord</span><br><span class="line">  for each row</span><br><span class="line">  begin</span><br><span class="line">    declare restNum int;</span><br><span class="line">    select num into restNum from goods where gid = new.gid;</span><br><span class="line">    if new.much &gt; restNum then</span><br><span class="line">      set new.much = restNum;</span><br><span class="line">    end if;</span><br><span class="line">    update goods set num=num-new.much where gid=new.gid;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure><p>​        <strong>注意</strong>：这里如果使用的是after就会报错，如果使用的是after，就会先执行insert操作，也就是插入订单操作，然后在进行判断下单数量和库存量，得出新的下单数量，可是已经执行了下单操作了，所以就会报错。这里必须使用before操作。</p><h4 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h4><h5 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure><p>​    还可以带上数据库名、表名的条件查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.TRIGGERS where trigger_schema=&#x27;test&#x27; and event_object_table=&#x27;ord&#x27;;</span><br></pre></td></tr></table></figure><p>   查看创建触发器的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create trigger 触发器名称;</span><br></pre></td></tr></table></figure><h5 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop trigger 触发器名称;</span><br></pre></td></tr></table></figure><h5 id="触发器的使用限制"><a href="#触发器的使用限制" class="headerlink" title="触发器的使用限制"></a>触发器的使用限制</h5><p>​        <strong>触发器不是程序员手工调用的，是DBMS自动调用，由对应语句触发。</strong></p><p>​        <strong>MySQL 的触发器中不能对本表进行 insert、update 和 delete 操作，否则会报错</strong></p><p>​        <strong>for each row是干什么的？</strong></p><p>在oracle触发器中，触发器分为行触发器和语句触发器</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create trigger tn</span><br><span class="line">    after update</span><br><span class="line">    on xxtable</span><br><span class="line">    for each row</span><br><span class="line">    #每一行受影响，触发事件都执行，叫做行触发器</span><br><span class="line">    begin</span><br><span class="line">      sqlN;</span><br><span class="line">end$</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update` `xxtable ``set` `xxx=xxx ``where` `id&gt;100;</span><br></pre></td></tr></table></figure><p>该修改操作假设100行，那么sqlN，会触发100次。</p><p>在oracle中，for each row如果不写，无论update语句一次影响了多少行，都只执行一次触发事件。<br>比如：1人下了订单，买了5件商品，insert 5次，可以用行级触发器，修改5次库存；用语句级触发器触发，insert一条发货提醒。<br>遗憾的是mysql目前不支持语句级触发器。</p><p><strong>优点</strong></p><ul><li>触发器可以通过数据库中的关联表实现级联更改，即一张表数据的改变会影响其他表的数据</li><li>可以保证数据安全，并进行安全校验</li></ul><p><strong>缺点</strong></p><ul><li>过分依赖触发器，影响数据库的结构，增加数据库的维护成本</li></ul><h2 id="第6章-MySQL的主从复制"><a href="#第6章-MySQL的主从复制" class="headerlink" title="第6章 MySQL的主从复制"></a>第6章 MySQL的主从复制</h2><p>​       mysql数据库提供了一种主从备份的机制，其实就是把主数据库的所有的数据同时写到备份的数据库中。实现mysql数据库的热备份。<br>​       热备份与冷备份的区别：冷备份必须在关停服务下备份数据，热备份可以在服务上线时备份数据。</p><p>​       要实现热备mysql的版本都高于3.2。还有一个基本的原则就是作为从数据库的数据版本可以高于主服务器数据库的版本，但是不可以低于主服务器的数据库版本。</p><p>​        做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</p><p>​        随着架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。<br>读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。</p><p>​       主从复制热备份的好处</p><p> 1—在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压）<br> 2—在从服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全）<br> 3—当主服务器出现问题时，可以切换到从服务器。（提升安全性）</p><p><img src="D:\Program Files (x86" alt="img">\gakataka\Student\recv\第2阶段___JavaWeb\Java第二阶段_day03_MySQL高级\Java第二阶段_day03_MySQL进阶知识点\Java第二阶段_day03_MySQL进阶.assets\20180520113302183)</p><h3 id="主从复制的具体操作方法"><a href="#主从复制的具体操作方法" class="headerlink" title="主从复制的具体操作方法"></a><strong>主从复制的具体操作方法</strong></h3><p>​        首先至少安装两个MySQL数据库。</p><p>​        然后配置主服务器的 my.ini 文件。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1606768-20190408141542384-1806385355.png" alt="img"></p><p>​        <strong>3306是mysql默认端口号，这里master实例中可以不用修改；server-id用来指定唯一id，不同的mysql实例不重复即可；binlog-do-db指定需要复制的数据库；log-bin用来开启二进制日志文件</strong></p><p>​        再来配合从服务器的 my.ini 文件。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1606768-20190408141652586-1476718742.png" alt="img"></p><p>​        <strong>replicate-do-db：需要同步的数据库名称，与master上的配置保持一致。</strong></p><p>在从服务器上进行设置</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1212417-20191127191245177-1874899605.png" alt="img"></p><p>在从服务器上start slave</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1212417-20191127191446842-327450629.png" alt="img"></p><p>在从服务器上查看主从状态 show slave status （/G,将内容竖向显示）</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1212417-20191127191733106-1215626420.png" alt="img"></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主库File和position与从库一致，则证明主从同步了</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1212417-20191127192111183-1372510560.png" alt="img"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1212417-20191127192317762-233252557.png" alt="img"></p><p><strong>在master上创建一个专门用于复制的账户，并给它授予主从复制权限</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1606768-20190408141727864-1499288102.png" alt="img"></p><p>授权完成后，注意执行 flush privileges。</p><p>主从配置完成后，所有对主服务器的操作，都会复制到从服务器上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java第二阶段-day03-MySQL进阶&quot;&gt;&lt;a href=&quot;#Java第二阶段-day03-MySQL进阶&quot; class=&quot;headerlink&quot; title=&quot;Java第二阶段_day03_MySQL进阶&quot;&gt;&lt;/a&gt;Java第二阶段_day03_MySQL</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Java第二阶段_day02_MySQL进阶</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-day02-MySQL%E8%BF%9B%E9%98%B6/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-day02-MySQL%E8%BF%9B%E9%98%B6/</id>
    <published>2022-10-16T14:49:33.000Z</published>
    <updated>2022-10-16T14:55:58.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java第二阶段-day02-MySQL进阶"><a href="#Java第二阶段-day02-MySQL进阶" class="headerlink" title="Java第二阶段_day02_MySQL进阶"></a>Java第二阶段_day02_MySQL进阶</h1><h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>能够使用SQL语句操作数据库</li><li>掌握MYSQL支持的数据类型</li><li>能够使用SQL语句操作表结构</li><li>能够使用SQL语句进行数据的添加修改和删除的操作</li><li>能够使用SQL语句简单查询数据</li><li>能够使用SQL关联查询</li></ul><h1 id="1-数据定义语言（DDL）🧬"><a href="#1-数据定义语言（DDL）🧬" class="headerlink" title="1. 数据定义语言（DDL）🧬"></a>1. 数据定义语言（DDL）🧬</h1><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ol><li><p>直接创建数据库<br><code>CREATE DATABASE 数据库名;</code></p></li><li><p>判断是否存在并创建数据库(了解)<br><code>CREATE DATABASE IF NOT EXISTS 数据库名;</code></p></li><li><p>创建数据库并指定字符集(了解)<br><code>CREATE DATABASE 数据库名 CHARACTER SET 字符集;</code></p></li><li><p>具体操作：</p></li></ol><ul><li><p>直接创建数据库db1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db1;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="直接创建数据库"></p></li><li><p>判断是否存在并创建数据库db2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> db2;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%B9%B6%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="判断是否存在并创建数据库"></p></li><li><p>创建数据库并指定字符集为gbk</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db2 <span class="type">CHARACTER</span> <span class="keyword">SET</span> gbk;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E6%8C%87%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt="创建数据库并指定字符集"></p></li></ul><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><ol><li><p>查看所有的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW databases;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="查看所有数据库"></p></li><li><p>查看某个数据库的定义信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure></li></ol><p>   <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BF%A1%E6%81%AF.png" alt="查看某个数据库的定义信息"></p><h3 id="修改数据库-了解"><a href="#修改数据库-了解" class="headerlink" title="修改数据库(了解)"></a>修改数据库(了解)</h3><p>修改数据库字符集格式</p><p><code>ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;</code></p><p>具体操作：</p><ul><li><p>将db3数据库的字符集改成utf8</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db3 <span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt="修改数据库字符集"></p></li></ul><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p><code>DROP DATABASE 数据库名;</code></p><p>具体操作：</p><ul><li><p>删除db2数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE db2;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="删除数据库"></p></li></ul><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ol><li>查看正在使用的数据库<br><code>SELECT DATABASE();</code></li><li>使用/切换数据库<br><code>USE 数据库名;</code></li></ol><p>具体操作：</p><ul><li><p>查看正在使用的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="查看正在使用的数据库"></p></li><li><p>使用db1数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE db1;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BD%BF%E7%94%A8db1%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="使用db1数据库"></p></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><blockquote><p><strong>如果已执行 use 数据库名; 可以省略数据库名。</strong></p></blockquote><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名 (</span><br><span class="line">   字段名 字段类型 [ <span class="keyword">primary</span> key <span class="operator">|</span> <span class="keyword">unique</span> <span class="operator">|</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line">      <span class="operator">|</span> <span class="type">binary</span> <span class="operator">|</span> <span class="keyword">default</span> 缺省值 <span class="operator">|</span> comment 注释语句],</span><br><span class="line">   ......</span><br><span class="line">) [ ENGINE<span class="operator">=</span>InnoDB <span class="operator">|</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ];</span><br></pre></td></tr></table></figure><p>表可选项：</p><blockquote><p>if not exists：如果不存在就执行建表</p><p>engine：设置数据引擎，默认为innodb</p><p>default charset：设置默认字符编码</p><p>字段可选项：</p><p>primary key：主键，值唯一，不可为null</p><p>unique：唯一键，值唯一，可以为null</p><p>not null：不可为null，不写这一项，则默认为可以接受null值</p><p>auto_increment：自动增长，只能与整数类型搭配，默认每次增长1</p><p>binary：与字符类型搭配，在字段比较时大小写敏感</p><p>default：设置缺省值，若插入值为null时，则使用默认值填充</p><p>comment：设置字段注释</p></blockquote><p>示例：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200723113701000.png" alt="image-20200723113701000"></p><h3 id="MySQL的数值数据类型"><a href="#MySQL的数值数据类型" class="headerlink" title="MySQL的数值数据类型"></a>MySQL的数值数据类型</h3><p>​        MySQL支持所有标准SQL数值数据类型。</p><p>​        这些类型包括严格数值数据类型(<strong>INTEGER、SMALLINT、DECIMAL和NUMERIC</strong>)，以及近似数值数据类型(<strong>FLOAT、REAL和DOUBLE PRECISION</strong>)。</p><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1 字节</td><td style="text-align:left">(-128，127) FF 1111 1111</td><td style="text-align:left">(0，255)</td><td style="text-align:left">小整数值</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2 字节</td><td style="text-align:left">(-32 768，32 767)</td><td style="text-align:left">(0，65 535)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3 字节</td><td style="text-align:left">(-8 388 608，8 388 607)</td><td style="text-align:left">(0，16 777 215)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">INT或INTEGER</td><td style="text-align:left">4 字节</td><td style="text-align:left">(-2,147,483,648，2,147,483,647)</td><td style="text-align:left">(0，4 294 967 295)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8 字节</td><td style="text-align:left">(-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)</td><td style="text-align:left">(0，18 446 744 073 709 551 615)</td><td style="text-align:left">极大整数值</td></tr></tbody></table></div><p>关键字<strong>INT</strong>是<strong>INTEGER</strong>的同义词，关键字<strong>DEC</strong>是<strong>DECIMAL</strong>的同义词。</p><p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p><p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><p>​        <strong>TINYINT</strong>，1字节，8位，16进制最大表示为FF，2进制表示最大为1111 1111，有符号，第一位为符号为（整数为0，负数为1），所以整数最大值为0111 1111（127），负数最大值为1111 1111（-128），无符号的最大值是255。</p><ul><li><p>可以用unsigned控制是否有符号位</p></li><li><p>可以使用zerofill控制是否有前导零</p></li><li><p>也存在布尔类型。首先mysql是不支持布尔类型的,当把一个数据设置成布尔类型的时候,数据库会自动转换成tinyint(1)的数据类型,其实这个就是变相的布尔。 默认值也就是1,0两种,分别对应了布尔类型的true和false。</p></li><li><p>类型后面(1)，代表的显示长度，只有跟zerofill配合起来才能用。简单地说，没有(1)，会显示成00x数字，具体连数字带前导零总共几位，有(n)来限制。</p></li></ul><p>  我们在这里测试一下。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 (</span><br><span class="line">c1 TINYINT,</span><br><span class="line">c2 tinyint UNSIGNED,</span><br><span class="line">c3 tinyint ZEROFILL );</span><br></pre></td></tr></table></figure><p>  然后执行sql，分别看看执行结果，分析报错信息。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">-3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">127</span>, <span class="number">2</span>, <span class="number">-3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">-128</span>, <span class="number">128</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">-128</span>, <span class="number">256</span>, <span class="number">255</span>);</span><br></pre></td></tr></table></figure><p>  总结：zerofill具备unsigned的隐藏属性，不能存负值。</p><blockquote><p><strong>SMALLINT</strong>，2字节，16位，16进制最大表示为FFFF。</p><p><strong>MEDIUMINT</strong>，3字节，24位，16进制最大表示为FF FFFF。</p><p><strong>INT</strong>或<strong>INTEGER</strong> ，4字节，32位 ，16进制最大表示为FFFF FFFF。</p><p><strong>BIGINT</strong>，8字节，64位 ，16进制最大表示为FFFF FFFF FFFF FFFF。</p><p>​    这些类型都可以用unsigned和zerofill修饰。</p></blockquote><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">FLOAT</td><td style="text-align:left">4 字节</td><td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align:left">单精度 浮点数值</td></tr><tr><td style="text-align:left">DOUBLE</td><td style="text-align:left">8 字节</td><td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">双精度 浮点数值</td></tr></tbody></table></div><p>科学计数法，0.123 * 10^1。</p><p>创建该类型字段时，可以设置（M，D）模式控制数值范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test4 (</span><br><span class="line">  f1 <span class="type">float</span>,</span><br><span class="line">  f2 <span class="type">float</span>(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">  f3 <span class="type">float</span>(<span class="number">16</span>，<span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">123.456789</span>, <span class="number">123.456789</span>, <span class="number">123.456789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">1234.56789</span>, <span class="number">1234.56789</span>, <span class="number">1234.56789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">12345.6789</span>, <span class="number">12345.6789</span>, <span class="number">12345.6789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">123456.789</span>, <span class="number">123456.789</span>, <span class="number">123456.789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">1234567.89</span>, <span class="number">1234567.89</span>, <span class="number">1234567.89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">12345678.9</span>, <span class="number">12345678.9</span>, <span class="number">12345678.9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test4 <span class="keyword">values</span> (<span class="number">123456789</span>, <span class="number">123456789</span>, <span class="number">123456789</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test4;</span><br></pre></td></tr></table></figure><p><strong>从上面看出：</strong>默认的float类型都只能存6个数字（包括小数点前后的位数），整数超过6位就被科学计数表示（id=4），小数位超出则需要四舍五入。</p><p>float(m,d)：小数点后位数为d，即整数位数为（m-d），整数位超出则整数为(m-d)个，小数点后位数为(d)个9999，不用科学计算了；若小数位超出，则需要四舍五入。</p><p>单精度浮点数的精度是不高的，我们可以试试double。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test5;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test5 (</span><br><span class="line">  d1 <span class="keyword">double</span>,</span><br><span class="line">  d2 <span class="keyword">double</span>(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">  d3 <span class="keyword">double</span>(<span class="number">16</span>, <span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">123.456789</span>, <span class="number">123.456789</span>, <span class="number">123.456789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">1234.56789</span>, <span class="number">1234.56789</span>, <span class="number">1234.56789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">12345.6789</span>, <span class="number">12345.6789</span>, <span class="number">12345.6789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">123456.789</span>, <span class="number">123456.789</span>, <span class="number">123456.789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">1234567.89</span>, <span class="number">1234567.89</span>, <span class="number">1234567.89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">12345678.9</span>, <span class="number">12345678.9</span>, <span class="number">12345678.9</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test5 <span class="keyword">values</span> (<span class="number">123456789</span>, <span class="number">123456789</span>, <span class="number">123456789</span>);</span><br></pre></td></tr></table></figure><p>双精度浮点型的有效精度更高（16位左右），可以容纳更多的值。</p><h4 id="定点小数类型"><a href="#定点小数类型" class="headerlink" title="定点小数类型"></a><strong>定点小数类型</strong></h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">DECIMAL</td><td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">小数值</td></tr></tbody></table></div><p>我们创建一个包含decimal类型字段的表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test6;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test6 (</span><br><span class="line">  d1 <span class="type">decimal</span>,</span><br><span class="line">  d2 <span class="type">decimal</span>(<span class="number">6</span>, <span class="number">2</span>),</span><br><span class="line">  d3 <span class="type">decimal</span>(<span class="number">32</span>, <span class="number">4</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test6 <span class="keyword">values</span> (<span class="number">123.456789</span>, <span class="number">123.456789</span>, <span class="number">123.456789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test6 <span class="keyword">values</span> (<span class="number">1234.56789</span>, <span class="number">1234.56789</span>, <span class="number">1234.56789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test6 <span class="keyword">values</span> (<span class="number">12345.6789</span>, <span class="number">12345.6789</span>, <span class="number">12345.6789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test6 <span class="keyword">values</span> (<span class="number">123456.789</span>, <span class="number">123456.789</span>, <span class="number">123456.789</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test6 <span class="keyword">values</span> (<span class="number">1234567.89</span>, <span class="number">1234567.89</span>, <span class="number">1234567.89</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test6 <span class="keyword">values</span> (<span class="number">12345678.9</span>, <span class="number">12345678.9</span>, <span class="number">12345678.9</span>);</span><br></pre></td></tr></table></figure><p>decimal型的默认整数位为10，小数位为0，即默认为整数。</p><p>在MySQL中，定点数以字符串形式存储，因此，其精度比浮点数要高，而且浮点数会出现误差，这是浮点数一直存在的缺陷。如果要对数据的精度要求比较高，还是选择定点数decimal比较安全。</p><h4 id="MySQL-数值类型溢出处理-了解"><a href="#MySQL-数值类型溢出处理-了解" class="headerlink" title="MySQL 数值类型溢出处理(了解)"></a><strong>MySQL 数值类型溢出处理</strong>(了解)</h4><p>当 MySQL 在某个数值列上存储超出列数据类型允许范围的值时，结果取决于当时生效的 SQL 模式</p><ul><li><p>如果启用了严格的 SQL 模式，则 MySQL 会根据 SQL 标准拒绝带有错误的超出范围的值，并且插入失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;TRADITIONAL&#x27;</span>; <span class="comment">-- 将当前会话的模式设置严格模式</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如果没有启用任何限制模式，那么 MySQL 会将值裁剪到列数据类型范围的上下限值并存储</p><ul><li>当超出范围的值分配给整数列时，MySQL 会存储表示列数据类型范围的相应端点的值</li><li>当为浮点或定点列分配的值超出指定（或默认）精度和比例所隐含的范围时，MySQL 会存储表示该范围的相应端点的值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">-- 禁用所有模式</span></span><br></pre></td></tr></table></figure></li></ul><p>不光是insert 的时候，其他时候也可能会触发数值溢出。</p><p>数值表达式求值过程中的溢出会导致错误，例如，因为最大的有符号 BIGINT 值是 9223372036854775807，因此以下表达式会产生错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">9223372036854775807</span> <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1690</span> (<span class="number">22003</span>): <span class="type">BIGINT</span> <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">in</span> <span class="string">&#x27;(9223372036854775807 + 1)&#x27;</span></span><br></pre></td></tr></table></figure><p>为了在这种情况下使操作成功，需要将值转换为 unsigned</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| CAST(9223372036854775807 AS UNSIGNED) + 1 |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|                       9223372036854775808 |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>整数数值之间的减去，如果其中一个类型为 UNSIGNED ，默认情况下会生成无符号结果。如果为负，则会引发错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="number">0</span> <span class="keyword">AS</span> UNSIGNED) <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1690</span> (<span class="number">22003</span>): <span class="type">BIGINT</span> UNSIGNED <span class="keyword">value</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">in</span> <span class="string">&#x27;(cast(0 as unsigned) - 1)&#x27;</span></span><br></pre></td></tr></table></figure><p>这种情况下，如果启用了 NO_UNSIGNED_SUBTRACTION SQL 模式，则结果为负。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;NO_UNSIGNED_SUBTRACTION&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="number">0</span> <span class="keyword">AS</span> UNSIGNED) <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">CAST</span>(<span class="number">0</span> <span class="keyword">AS</span> UNSIGNED) <span class="operator">-</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span>                      <span class="number">-1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果此类操作的结果用于更新 UNSIGNED 整数列，则结果将裁剪为列类型的最大值，如果启用了 NO_UNSIGNED_SUBTRACTION 则裁剪为 0。但如果启用了严格的 SQL 模式，则会发生错误并且列保持不变。</p><h4 id="MySQL的日期时间数据类型"><a href="#MySQL的日期时间数据类型" class="headerlink" title="MySQL的日期时间数据类型"></a>MySQL的日期时间数据类型</h4><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><div class="table-container"><table><thead><tr><th>日期时间类型</th><th>占用空间</th><th>日期格式</th><th>最小值</th><th>最大值</th><th>零值表示</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td><td>0000-00-00 00:00:00</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00</td><td>结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>00000000000000</td></tr><tr><td>DATE</td><td>4 bytes</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-31</td><td>0000-00-00</td></tr><tr><td>TIME</td><td>3 bytes</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td><td>00:00:00</td></tr><tr><td>YEAR</td><td>1 bytes</td><td>YYYY</td><td>1901</td><td>2155</td><td>0000</td></tr></tbody></table></div><p>我们来创建 一个表试试。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> dt01;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dt01(</span><br><span class="line">  d1 <span class="keyword">year</span>,</span><br><span class="line">  d2 <span class="type">date</span>,</span><br><span class="line">  d3 <span class="type">time</span>,</span><br><span class="line">  d4 datetime,</span><br><span class="line">  d5 <span class="type">timestamp</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2020-3-4&#x27;</span>, <span class="string">&#x27;3:4:5&#x27;</span>,<span class="string">&#x27;2020-3-4 3:4:5&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;20200304&#x27;</span>, <span class="string">&#x27;131415&#x27;</span>,<span class="string">&#x27;20200304131415&#x27;</span>, <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2020-3-4&#x27;</span>, <span class="string">&#x27;3:4:5&#x27;</span>,<span class="string">&#x27;2020-3-4 3:4:5&#x27;</span>, <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2020:3:4&#x27;</span>, <span class="string">&#x27;03:04:05&#x27;</span>,<span class="string">&#x27;2020:3:4 3:4:5&#x27;</span>, <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2020-3-4&#x27;</span>, <span class="string">&#x27;3:4:5&#x27;</span>,</span><br><span class="line">STR_TO_DATE(<span class="string">&#x27;2019-12-5 7:8:9&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>), <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2020-3-4&#x27;</span>, <span class="string">&#x27;3:4:5&#x27;</span>,</span><br><span class="line">STR_TO_DATE(<span class="string">&#x27;2019*12*5 7&amp;8&amp;9&#x27;</span>, <span class="string">&#x27;%Y*%m*%d %H&amp;%i&amp;%s&#x27;</span>), <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dt01 <span class="keyword">values</span> (<span class="string">&#x27;2020&#x27;</span>, <span class="string">&#x27;2020-3-4&#x27;</span>, <span class="string">&#x27;3:4:5&#x27;</span>,</span><br><span class="line">STR_TO_DATE(<span class="string">&#x27;2019年12月12日 7时8分9秒&#x27;</span>, <span class="string">&#x27;%Y年%m月%d日 %H时%i分%s秒&#x27;</span>), <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>日期时间类型转换成格式字符串，可以使用这种方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(now(), ‘<span class="operator">%</span>Y<span class="operator">-</span><span class="operator">%</span>m<span class="operator">-</span><span class="operator">%</span>d <span class="operator">%</span>H:<span class="operator">%</span>i:<span class="operator">%</span>s’); </span><br></pre></td></tr></table></figure><p>格式字符串转换成日期时间类型，可以使用这个函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STR_TO_DATE(<span class="string">&#x27;2019-12-5 7:8:9&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>)</span><br></pre></td></tr></table></figure><p>format可以使用的值为：</p><blockquote><p>%M 月名字(January……December)</p><p>%W 星期名字(Sunday……Saturday) </p><p>%D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） </p><p>%Y 年, 数字, 4 位</p><p>%y 年, 数字, 2 位 </p><p>%a 缩写的星期名字(Sun……Sat) </p><p>%d 月份中的天数, 数字(00……31) </p><p>%e 月份中的天数, 数字(0……31) </p><p>%m 月, 数字(01……12) </p><p>%c 月, 数字(1……12) </p><p>%b 缩写的月份名字(Jan……Dec) </p><p>%j 一年中的天数(001……366) </p><p>%H 小时(00……23) </p><p>%k 小时(0……23) </p><p>%h 小时(01……12) </p><p>%I 小时(01……12) </p><p>%l 小时(1……12) </p><p>%i 分钟, 数字(00……59) </p><p>%r 时间,12 小时(hh:mm:ss [AP]M) </p><p>%T 时间,24 小时(hh:mm:ss) </p><p>%S 秒(00……59) %s 秒(00……59) </p><p>%p AM或PM </p><p>%w 一个星期中的天数(0=Sunday ……6=Saturday ） </p><p>%U 星期(0……52), 这里星期天是星期的第一天 </p><p>%u 星期(0……52), 这里星期一是星期的第一天 </p><p>%% 一个文字“%”。</p></blockquote><h4 id="MySQL的字符串类型"><a href="#MySQL的字符串类型" class="headerlink" title="MySQL的字符串类型"></a>MySQL的字符串类型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">CHAR(n)</td><td style="text-align:left">0-255字符（*字符集字节数）</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left">VARCHAR(2000)</td><td style="text-align:left">0-65535 字节</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left">TINYBLOB</td><td style="text-align:left">0-255字节</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left">TINYTEXT</td><td style="text-align:left">0-255字节</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left">BLOB</td><td style="text-align:left">0-65 535字节</td><td style="text-align:left">二进制形式的长文本数据</td></tr><tr><td style="text-align:left">TEXT</td><td style="text-align:left">0-65 535字节</td><td style="text-align:left">长文本数据</td></tr><tr><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">0-16 777 215字节</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">0-16 777 215字节</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left">LONGBLOB</td><td style="text-align:left">0-4 294 967 295字节</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left">LONGTEXT</td><td style="text-align:left">0-4 294 967 295字节</td><td style="text-align:left">极大文本数据</td></tr></tbody></table></div><p><strong>CHAR 和 VARCHAR</strong> 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换，CHAR删除尾部的空格，VARCHAR则保留尾部的空格。</p><p>因为varchar要记录数据长度（系统根据数据长度自动分配空间），所以每个varchar数据产生后，系统都会在数据后面增加1-2个字节的额外开销：是用来保存数据所占用的空间长度</p><p>如果数据本身小于127个字符：额外开销一个字节；如果大于127个，就开销两个字节。</p><p>最大长度根据字符集换算，GBK每个字符2个字节，UTF8每个字符3个字节，utf8mb4每个字符4字节，那么</p><p>在GBK字符集下，varchar最大长度<strong>32766</strong>，UTF8最大长度<strong>21844</strong>，UTF8MB4最大长度16384。</p><p>我们来验证一下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test7 (</span><br><span class="line">  test_char <span class="type">varchar</span>(<span class="number">21845</span>)</span><br><span class="line">) <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test7 (</span><br><span class="line">  test_char <span class="type">varchar</span>(<span class="number">32766</span>)</span><br><span class="line">) <span class="type">character</span> <span class="keyword">set</span> gbk;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test7 (</span><br><span class="line">  test_char <span class="type">varchar</span>(<span class="number">16383</span>)</span><br><span class="line">) <span class="type">character</span> <span class="keyword">set</span> utf8mb4;</span><br></pre></td></tr></table></figure><p>还有一个有趣的现象，mysql表的每行记录字节总和不能超过65535。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table test7 (</span><br><span class="line">  c1 char(100),</span><br><span class="line">  c2 varchar(21845)</span><br><span class="line">) character set utf8;</span><br><span class="line"></span><br><span class="line">create table test7 (</span><br><span class="line">  c1 char(100),</span><br><span class="line">  c2 varchar(21744)</span><br><span class="line">) character set utf8;</span><br></pre></td></tr></table></figure><p><strong>BLOB</strong> 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 <strong>TEXT</strong> 类型：<strong>TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT</strong>。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><p>1.BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。<br>2.BLOB存储的数据只能整体读出。<br>3.TEXT可以指定字符集，BLOB不用指定字符集。</p><h4 id="MySQL的枚举类型（了解）"><a href="#MySQL的枚举类型（了解）" class="headerlink" title="MySQL的枚举类型（了解）"></a>MySQL的枚举类型（了解）</h4><p>枚举类型：在数据插入之前，先设定几个项，这几个项就是可能最终出现的数据结果。</p><p>如果确定某个字段的数据只有那么几个值：如性别，男、女、保密，系统就可以在设定字段的时候规定当前字段只能存放固定的几个值：使用枚举</p><p>基本语法：enum(数据值1,数据值2…)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line">  sex enum(<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">desc</span> student;</span><br></pre></td></tr></table></figure><p>插入数据：合法数据，字段对应的值必须是设定表的时候所确定的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student values(&#x27;男&#x27;);</span><br><span class="line">insert into student values(&#x27;xx&#x27;);</span><br></pre></td></tr></table></figure><p>我们可以把这个student表扩展一下，来看看enum与字符字段的区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table student (</span><br><span class="line">  s char(1),</span><br><span class="line">  sex enum(&#x27;男&#x27;, &#x27;女&#x27;)</span><br><span class="line">) character set utf8mb4;</span><br><span class="line">insert into student values(&#x27;男&#x27;,&#x27;男&#x27;);</span><br><span class="line">insert into student values(&#x27;女&#x27;,&#x27;女&#x27;);</span><br><span class="line">select * from student;</span><br><span class="line">select s+0,  sex+0 from student;</span><br></pre></td></tr></table></figure><p>验证结果说明，enum实际在数据库中以整型存放，获取值时，会进行对应值的转换。</p><p>在MySQL数据库中,连接字符串,如果我们使用+号的话,就会出现结果”0”,所以MySQL数据库,我们必须使用concat连接字符串。</p><h4 id="MySQL的SET类型（了解）"><a href="#MySQL的SET类型（了解）" class="headerlink" title="MySQL的SET类型（了解）"></a>MySQL的SET类型（了解）</h4><p>在ENUM中我们只能从允许值列表中给字段插入一个值，而在SET类型中可以给字段插入多个值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> set_t(</span><br><span class="line">a <span class="keyword">SET</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">desc</span> set_t;</span><br></pre></td></tr></table></figure><p>再来插些值看看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> set_t <span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> set_t <span class="keyword">VALUES</span>(<span class="string">&#x27;1,2,3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>插入值时值之间不能有空格，插入会报错，必须把空格去掉</p><p><strong>MySQL数据类型</strong><br>MySQL中的我们常使用的数据类型如下：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/MYSQL%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="MYSQL常用数据类型"></p><p>详细的数据类型如下(不建议详细阅读！)</p><div class="table-container"><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">类型名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">整数类型</td><td style="text-align:left">tinyInt</td><td style="text-align:left">很小的整数（两种整数选择时会用，比如说性别）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">smallint</td><td style="text-align:left">小的整数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">mediumint</td><td style="text-align:left">中等大小的整数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">int(integer)</td><td style="text-align:left">普通大小的整数（最常用）</td></tr><tr><td style="text-align:left">小数类型</td><td style="text-align:left">float</td><td style="text-align:left">单精度浮点数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">double</td><td style="text-align:left">双精度浮点数（最常用）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">decimal（m,d）</td><td style="text-align:left">压缩严格的定点数</td></tr><tr><td style="text-align:left">日期类型</td><td style="text-align:left">year</td><td style="text-align:left">YYYY  1901~2155</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">time</td><td style="text-align:left">HH:MM:SS  -838:59:59~838:59:59</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">date</td><td style="text-align:left">YYYY-MM-DD 1000-01-01~9999-12-3</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">datetime</td><td style="text-align:left">YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">timestamp</td><td style="text-align:left">YYYY-MM-DD HH:MM:SS  1970~01~01 00:00:01 UTC~2038-01-19 03:14:07UTC</td></tr><tr><td style="text-align:left">文本、二进制类型</td><td style="text-align:left">CHAR(M)</td><td style="text-align:left">M为0~255之间的整数</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">VARCHAR(M)</td><td style="text-align:left">M为0~65535之间的整数（普通字符串，最常用）</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">TINYBLOB</td><td style="text-align:left">允许长度0~255字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">BLOB</td><td style="text-align:left">允许长度0~65535字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">MEDIUMBLOB</td><td style="text-align:left">允许长度0~167772150字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">LONGBLOB</td><td style="text-align:left">允许长度0~4294967295字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">TINYTEXT</td><td style="text-align:left">允许长度0~255字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">TEXT</td><td style="text-align:left">允许长度0~65535字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">MEDIUMTEXT</td><td style="text-align:left">允许长度0~167772150字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">LONGTEXT</td><td style="text-align:left">允许长度0~4294967295字节</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">VARBINARY(M)</td><td style="text-align:left">允许长度0~M个字节的变长字节字符串</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">BINARY(M)</td><td style="text-align:left">允许长度0~M个字节的定长字节字符串</td></tr></tbody></table></div><blockquote><p><strong>注意：</strong>char与VARCHAR的区别：</p><p>1．CHAR的长度是固定的，而VARCHAR的长度是可以变化的， 比如，存储字符串“abc”，对于CHAR (20)，表示你存储的字符将占20个字节(包括17个空字符)，而同样的VARCHAR2 (20)则只占用3个字节的长度，20只是最大值，当你存储的字符小于20时，按实际长度存储。</p><p>2．CHAR的效率比VARCHAR2的效率稍高。</p><p>VARCHAR比CHAR节省空间，在效率上比CHAR会稍微差一些，即要想获得效率，就必须牺牲一定的空间，这也就是我们在数据库设计上常说的‘以空间换效率’。</p></blockquote><p>具体操作: </p><p>创建student表包含id,name,birthday字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">      id <span class="type">INT</span>,</span><br><span class="line">      name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">      birthday <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><ol><li><p>查看某个数据库中的所有表<br><code>SHOW TABLES;</code></p></li><li><p>查看表结构<br><code>DESC 表名;</code></p></li><li><p>查看创建表的SQL语句<br><code>SHOW CREATE TABLE 表名;</code></p><p>具体操作：</p></li></ol><ul><li><p>查看mysql数据库中的所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8.png" alt="查看某个数据库中的所有表"></p></li><li><p>查看student表的结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> student;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8Bstudent%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="查看student表的结构"></p></li><li><p>查看student的创建表SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8Bstudent%E7%9A%84%E5%88%9B%E5%BB%BA%E8%A1%A8SQL%E8%AF%AD%E5%8F%A5.png" alt="查看student的创建表SQL语句"></p></li></ul><h3 id="快速创建一个表结构相同的表"><a href="#快速创建一个表结构相同的表" class="headerlink" title="快速创建一个表结构相同的表"></a>快速创建一个表结构相同的表</h3><p><code>CREATE TABLE 新表名 LIKE 旧表名;</code></p><p>具体操作：</p><ul><li><p>创建s1表，s1表结构和student表结构相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 <span class="keyword">LIKE</span> student;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9B%B8%E5%90%8C%E7%9A%84%E8%A1%A8.png" alt="创建表结构相同的表"></p></li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ol><li>直接删除表<br><code>DROP TABLE 表名;</code></li><li>判断表是否存在并删除表(了解)<br><code>DROP TABLE IF EXISTS 表名;</code></li></ol><p>具体操作：</p><ul><li><p>直接删除表s1表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4%E8%A1%A8.png" alt="直接删除表"></p></li><li><p>判断表是否存在并删除s1表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A4%E6%96%AD%E8%A1%A8%E5%AD%98%E5%9C%A8%E5%B9%B6%E5%88%A0%E9%99%A4.png" alt="判断表存在并删除"></p></li></ul><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><blockquote><p>修改表结构使用不是很频繁，只需要知道下，等需要使用的时候再回来查即可</p></blockquote><ol><li><p>添加表列<br><code>ALTER TABLE 表名 ADD 列名 类型;</code></p><p>具体操作：</p><ul><li><p>为学生表添加一个新的字段remark,类型为varchar(20)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> remark <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5.png" alt="添加字段"></p></li></ul></li><li><p>修改列类型<br><code>ALTER TABLE 表名 MODIFY 列名 新的类型;</code><br>具体操作：</p><ul><li><p>将student表中的remark字段的改成varchar(100)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student MODIFY remark <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B.png" alt="修改字段类型"></p></li></ul></li><li><p>修改列名<br><code>ALTER TABLE 表名 CHANGE 旧列名 新列名 类型;</code><br>具体操作：</p><ul><li><p>将student表中的remark字段名改成intro，类型varchar(30)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student CHANGE remark intro <span class="type">varchar</span>(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%AD%97%E6%AE%B5%E5%90%8D%E7%A7%B0.png" alt="修改表字段名称"></p></li></ul></li><li><p>删除列<br><code>ALTER TABLE 表名 DROP 列名;</code><br>具体操作：</p><ul><li><p>删除student表中的字段intro</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> intro;</span><br></pre></td></tr></table></figure><p> <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5.png" alt="删除字段"></p></li></ul></li><li><p>修改表名<br><code>RENAME TABLE 表名 TO 新表名;</code><br>具体操作：</p><ul><li><p>将学生表student改名成student2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> student <span class="keyword">TO</span> student2;</span><br></pre></td></tr></table></figure><p> <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%90%8D.png" alt="修改表名"></p></li></ul></li><li><p>修改字符集<br><code>ALTER TABLE 表名 character set 字符集;</code><br>具体操作：</p><ul><li><p>将sutden2表的编码修改成gbk</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student2 <span class="type">character</span> <span class="keyword">set</span> gbk;</span><br></pre></td></tr></table></figure><p> <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt="修改字符集"></p></li></ul></li></ol><h1 id="2-单表查询语句（Select）🙈"><a href="#2-单表查询语句（Select）🙈" class="headerlink" title="2. 单表查询语句（Select）🙈"></a>2. 单表查询语句（Select）🙈</h1><blockquote><p>查询不会对数据库中的数据进行修改.只是一种显示数据的方式<br>准备数据</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student3 (</span><br><span class="line">  id <span class="type">int</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  age <span class="type">int</span>,</span><br><span class="line">  sex <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">  math <span class="type">int</span>,</span><br><span class="line">  english <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student3(id,NAME,age,sex,address,math,english) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;马云&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;杭州&#x27;</span>,<span class="number">66</span>,<span class="number">78</span>),(<span class="number">2</span>,<span class="string">&#x27;马化腾&#x27;</span>,<span class="number">45</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>,<span class="number">98</span>,<span class="number">87</span>),(<span class="number">3</span>,<span class="string">&#x27;马景涛&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">56</span>,<span class="number">77</span>),(<span class="number">4</span>,<span class="string">&#x27;柳岩&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>,<span class="number">76</span>,<span class="number">65</span>),(<span class="number">5</span>,<span class="string">&#x27;柳青&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;湖南&#x27;</span>,<span class="number">86</span>,<span class="keyword">NULL</span>),(<span class="number">6</span>,<span class="string">&#x27;刘德华&#x27;</span>,<span class="number">57</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>),(<span class="number">7</span>,<span class="string">&#x27;马德&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;香港&#x27;</span>,<span class="number">99</span>,<span class="number">99</span>),(<span class="number">8</span>,<span class="string">&#x27;德玛西亚&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;南京&#x27;</span>,<span class="number">56</span>,<span class="number">65</span>);</span><br></pre></td></tr></table></figure><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><h3 id="查询表所有数据"><a href="#查询表所有数据" class="headerlink" title="查询表所有数据"></a>查询表所有数据</h3><ol><li><p>使用<em>表示所有列<br>`SELECT </em> FROM 表名;`<br>具体操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student3;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%88%97-1593134997653.png" alt="查询所有列"></p></li><li><p>写出查询每列的名称<br><code>SELECT 字段名1, 字段名2, 字段名3, ... FROM 表名;</code><br>具体操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, NAME ,age, sex, address, math, english <span class="keyword">FROM</span> student3;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%88%97.png" alt="查询所有列"></p></li></ol><h3 id="查询指定列"><a href="#查询指定列" class="headerlink" title="查询指定列"></a>查询指定列</h3><p>查询指定列的数据,多个列之间以逗号分隔<br><code>SELECT 字段名1, 字段名2... FROM 表名;</code></p><p>具体操作：<br>查询student3表中的id , name , age , sex , address 列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, NAME ,age, sex, address <span class="keyword">FROM</span> student3;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E5%88%97-1593134997653.png" alt="查询指定字段"></p><h3 id="别名查询"><a href="#别名查询" class="headerlink" title="别名查询"></a>别名查询</h3><p>​    1、“*”，表示按照create table的顺序排列的所有列。 </p><p>​    2、表名.*，表示取回一个指定表中的所有列，适用于多表关联时，存在同名字段。列表中使用非限定列名，可能会产生解析错误。</p><p>​    2、按照用户所需顺序排列的列名的清单。 </p><p>​    3、可以使用别名取代列名，形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column name as column_heading </span><br></pre></td></tr></table></figure><p>​    mysql还支持不带as，直接空格跟别名的方式来指定别名。</p><p>​    4、表达式（列名、常量、函数，或以算术或逐位运算符连接的列名、常量和函数的任何组合）。 </p><p>​    5、内部函数或集合函数。 </p><p>​    6、上述各项的任何一种组合。 </p><h2 id="SQL的运算符"><a href="#SQL的运算符" class="headerlink" title="SQL的运算符"></a>SQL的运算符</h2><p>​        MySql中，数据库中的表结构确立后，表中的数据代表的意义就已经确定。而通过 MySQL 运算符进行运算，就可以获取到表结构以外的另一种数据。</p><p>​        例如，学生表中存在一个 birth 字段，这个字段表示学生的出生年份。而运用 MySQL 的算术运算符用当前的年份减学生出生的年份，那么得到的就是这个学生的实际年龄数据。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>​        算术运算符是 SQL 中最基本的运算符，MySQL 中的算术运算符如下表所示。</p><div class="table-container"><table><thead><tr><th>算术运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加法运算</td></tr><tr><td>-</td><td>减法运算</td></tr><tr><td>*</td><td>乘法运算</td></tr><tr><td>/</td><td>除法运算，返回商</td></tr><tr><td>%</td><td>求余运算，返回余数</td></tr></tbody></table></div><p>​        注意：在除法运算和模运算中，如果除数为0，将是非法除法，返回结果为NULL。</p><p>​        加法减法没什么可以说的，我们先来说说乘法。</p><p>​        整数的乘法结果是整数。小数的乘法呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">2</span><span class="operator">*</span><span class="number">3</span> <span class="keyword">as</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> t <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">2.0</span><span class="operator">*</span><span class="number">3.0</span> <span class="keyword">as</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> t    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到小数乘以小数，结果仍然是小数，我们需要关注精度，保留了乘数和被乘数的小数之和，系统并不会将小数点后的零自动去除。如果需要去除，则采用强制转换函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="number">1.234</span> <span class="operator">*</span> <span class="number">5.678</span> <span class="keyword">as</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> t        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7.006652</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">convert</span>(<span class="number">1.234</span> <span class="operator">*</span> <span class="number">5.678</span>, <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>)) <span class="keyword">as</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> t    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7.01</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>MySQL 的CONVERT()函数可用来获取一个类型的值，并产生另一个类型的值。具体的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONVERT(value, type);</span><br></pre></td></tr></table></figure><p>直接在sql中操作乘法的精度没问题，我们来看看字段操作怎么样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ta (</span><br><span class="line">aaa <span class="keyword">double</span>,</span><br><span class="line">bbb <span class="keyword">double</span>,</span><br><span class="line">ccc <span class="type">float</span>,</span><br><span class="line">ddd <span class="type">float</span>,</span><br><span class="line">eee <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">fff <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ta <span class="keyword">values</span> (<span class="number">1.23</span>, <span class="number">2.34</span>, <span class="number">1.23</span>, <span class="number">2.34</span>, <span class="number">1.23</span>, <span class="number">2.34</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> aaa, bbb, aaa<span class="operator">*</span>bbb, ccc, ddd, ccc<span class="operator">*</span>ddd, eee, fff ,eee<span class="operator">*</span>fff <span class="keyword">from</span> ta;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------------------+------+------+--------------------+------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> aaa  <span class="operator">|</span> bbb  <span class="operator">|</span> aaa<span class="operator">*</span>bbb            <span class="operator">|</span> ccc  <span class="operator">|</span> ddd  <span class="operator">|</span> ccc<span class="operator">*</span>ddd            <span class="operator">|</span> eee  <span class="operator">|</span> fff  <span class="operator">|</span> eee<span class="operator">*</span>fff <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------------------+------+------+--------------------+------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1.23</span> <span class="operator">|</span> <span class="number">2.34</span> <span class="operator">|</span> <span class="number">2.8781999999999996</span> <span class="operator">|</span> <span class="number">1.23</span> <span class="operator">|</span> <span class="number">2.34</span> <span class="operator">|</span> <span class="number">2.8781999390602095</span> <span class="operator">|</span> <span class="number">1.23</span> <span class="operator">|</span> <span class="number">2.34</span> <span class="operator">|</span>  <span class="number">2.8782</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+--------------------+------+------+--------------------+------+------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以发现除了decimal，float和double的乘法操作都存在精度问题，需要强转。</p><p>可以发现：</p><p>sql里面直接数相乘，与字段中decimal相乘一致，结果小数位数保留被乘数乘数之和。</p><p>double类型数相乘，结果的精度高于float数相乘。</p><p><strong>提示：能用decimal，就不要用float和double。</strong></p><p>除法操作，我们也来看看精度问题。跟乘法类似，</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/c02.png" alt="img"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/c03.png" alt="img"></p><p>进一步尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 1.22345 / 2.3456;</span><br><span class="line">insert into ta values (1.2345, 2.3456, 1.2345, 2.3456, 1.2345, 2.3456);</span><br><span class="line">select aaa, bbb, aaa/bbb, ccc, ddd, ccc/ddd, eee, fff ,eee/fff from ta where aaa=1.2345;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%605%7B%7D$D5ER7X3GD@TLJ@9SRT.png" alt="img"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/FUFI4950CV]H}X%J_}LS9.png" alt="img"></p><p>可以发现：</p><p>sql里面直接数相除，与字段中decimal相除一致，结果小数位数保留被除数除数之和。</p><p>double类型数相除，结果的精度高于float数相除。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>select语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录时符合条件的，比较结果为真，则返回1，为假则返回0，比较结果不确定则返回NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1&lt;2;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/2d4cba424042e9246df8ec218879c1f9.png" alt="2d4cba424042e9246df8ec218879c1f9"></p><p><strong>等于（==）与严格等于运算符（&lt;=&gt;）</strong></p><p>严格等于和等于运算符（=）的作用一致，只不过多了一个功能，就是可以判断NULL值，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 1=0,&#x27;2&#x27;=2,(1+3)=(2+2),NULL=NULL;</span><br><span class="line">select 1&lt;=&gt;0,&#x27;2&#x27;&lt;=&gt;2,(1+3)&lt;=&gt;(2+2),NULL&lt;=&gt;NULL;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abc.png" alt="abc"></p><p><strong>不等于运算符（&lt;&gt;或!=）</strong></p><p>不等于运算符用于判断数字、字符串、表达式是否不相等，如果不相等则返回 1，否则返回 0 ，但是不能判断 NULL 值。</p><p><strong>IS NULL 、IS NOT NULL</strong></p><blockquote><ul><li>IS NULL是 检验一个值是否为 NULL ，如果为 NULL ，返回值为 1，否则返回值为 0；</li><li>IS NOT NULL 检验一个值是否不为 NULL ，如果不为 NULL ，返回值为 1，否则返回值为 0。</li></ul></blockquote><p><strong>BETWEEN AND</strong></p><p>用于判断一个值是否落在两个值之间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 4 between 1 and 5,4 between 4 and 6,12 between 9 and 10;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abb.png" alt="abb"></p><p><strong>between … and 操作符是包含两边端点的。</strong></p><p><strong>IN、NOT IN</strong></p><blockquote><ul><li>IN ：判断一个值是否是 IN 列表中的任意一个值；</li><li>NOT IN ：判断一个值是否不是 IN 列表中的任意一个值。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 2 in(3,5,8,2), 2 not in(1,3,5);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abd.png" alt="abd"></p><p><strong>LIKE</strong></p><blockquote><ul><li>LIKE 运算符用来匹配字符串（正则表达式），如果匹配则返回 1，如果不匹配则返回 0；</li><li>LIKE 使用两种通配符：’%’ 用于匹配任何数目的字符，包括零字符 ； ‘_’ 只能匹配一个字符。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select &#x27;stud&#x27; like &#x27;stu_&#x27;,&#x27;stud&#x27; like &#x27;s___&#x27;,&#x27;stud&#x27; like &#x27;%d&#x27;;</span><br></pre></td></tr></table></figure><p><strong>REGEXP</strong></p><blockquote><p>1）REGEXP运算符用来匹配字符串，如果匹配则返回1，如果不匹配则返回0；<br>2）REGEXP 使用以下几种通配符：</p><ul><li>‘^’：用于匹配以什么开头的字符串；</li><li>‘$’：用以匹配以什么结尾的字符串；</li><li>‘.’：用于匹配任何一个单字符串；</li><li>‘[…]’：用于匹配在方括号内的任何字符；</li><li>‘*’用于匹配零个或多个在它前面的字符；</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;ssky&#x27; regexp &#x27;^s&#x27;, &#x27;ssky&#x27; regexp &#x27;y$&#x27;, &#x27;ssky&#x27; regexp &#x27;.sky&#x27;, &#x27;ssky&#x27; regexp &#x27;[ab]&#x27; ;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abe.png" alt="abe"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/347e7884f6b8ddb0270a510842d7c3fe.png" alt="347e7884f6b8ddb0270a510842d7c3fe"></p><p><strong>逻辑非（NOT 或 ！）</strong></p><blockquote><ul><li>当操作数为 0 时，所得值为 1；</li><li>当操作数为非 0 时，所得值为 0；</li><li>当操作数为 NULL 时，所得值为 NULL。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select not  10,!10,not(1-1),!(1-1),not 1+1,not null;</span><br></pre></td></tr></table></figure><p><strong>逻辑与（AND或&amp;&amp;）</strong></p><blockquote><ul><li>当所有操作数均为非零值、并且不为 NULL 时，所得值为 1；</li><li>当一个或多个操作数为 0 时，所得值为 0 ；</li><li>其余情况所得值为 NULL。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 1 and -1,1 &amp;&amp; 0,0 and null,1 &amp;&amp; null;</span><br></pre></td></tr></table></figure><p><strong>逻辑或（OR 或 || ）</strong></p><blockquote><ul><li>当两个操作数均为非 NULL 值，且任意一个操作数为非零值时，结果为 1 ，否则为 0；</li><li>当有一个操作数为 NULL ，且另一个操作数为非零值时，则结果为 1 ，否则结果为 NULL；</li><li>当两个操作数均为 NULL 时，则所得结果为 NULL。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 1 or -1 or 0,1 || 2,0 or null,null|| null;</span><br></pre></td></tr></table></figure><p><strong>逻辑异或（XOR）</strong></p><blockquote><ul><li>a XOR b 的计算等同于 ( a AND (NOT b) ) 或 ( (NOT a) AND b )；</li><li>当任意一个操作数为 NULL 时，返回值为 NULL；</li><li>对于非 NULL 的操作数，如果两个操作数都是非 0 值或者都是 0 值，则返回结果为 0；</li><li>如果一个为 0 值，另一个为非 0 值，返回结果为 1。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 1 xor 1,0 xor 0,1 xor 0,1 xor null,1 xor 1 xor 1;</span><br></pre></td></tr></table></figure><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>最低优先级为： <strong>:=</strong>。</p><p>最高优先级为： <strong>!、BINARY、 COLLATE</strong>。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/abg.png" alt="img"></p><p>​    <strong>用（），千万记得用括号。</strong></p><h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><p>​        where子句设置了搜索条件。</p><p>​        它在insert，update，delete语句中的应用方法也与在select语句中的应用方法完全相同。搜索条件紧跟在关键词where的后面。如果用户要在语句中使用多个搜索条件，则可用and或or连接。</p><p>​        搜索条件的基本语法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from test1 where aaa = &#x27;呵呵&#x27;;</span><br><span class="line">select* from test1 where not aaa = &#x27;呵呵&#x27;;</span><br><span class="line">select* from test1 where aaa != &#x27;呵呵&#x27;;</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="distinct关键字的用法"><a href="#distinct关键字的用法" class="headerlink" title="distinct关键字的用法"></a>distinct关键字的用法</h3><p>​        在mysql中，distinct关键字的主要作用就是对数据库表中一个或者多个字段重复的数据进行过滤，只返回其中的一条数据给用户，distinct只可以在select中使用。</p><p>​        distinct的原理：<br>​        distinct进行去重的主要原理是通过先对要进行去重的数据进行分组操作，然后从分组后的每组数据中去一条返回给客户端，在这个分组的过程可能会出现两种不同的情况：</p><p>​        distinct 依赖的字段全部包含索引：<br>​        该情况mysql直接通过操作索引对满足条件的数据进行分组，然后从分组后的每组数据中去一条数据。</p><p>​        distinct 依赖的字段未全部包含索引：<br>​        该情况由于索引不能满足整个去重分组的过程，所以需要用到临时表，mysql首先需要将满足条件的数据放到临时表中，然后在临时表中对该部分数据进行分组，然后从临时表中每个分组的数据中去一条数据，在临时表中进行分组的过程中不会对数据进行排序。</p><h4 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h4><p>​        GROUP BY 语句根据一个或多个列对结果集进行分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> bbb <span class="keyword">from</span> test1 <span class="keyword">group</span> <span class="keyword">by</span> bbb;</span><br><span class="line"><span class="comment">--这其实跟distinct返回的结果一致</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> bbb <span class="keyword">from</span> test1;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>​        <strong>聚合函数</strong>aggregation function又称为<strong>组函数</strong>。 默认情况下 聚合函数会对当前所在表当做一个组进行统计，MySQL提供了许多聚合函数，包括<code>AVG</code>，<code>COUNT</code>，<code>SUM</code>，<code>MIN</code>，<code>MAX</code>等。除<code>COUNT</code>函数外，其它聚合函数在执行计算时会忽略<code>NULL</code>值。</p><p>​        聚合函数的特点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　1.每个组函数接收一个参数（字段名或者表达式），统计结果中默认忽略字段为NULL的记录</span><br><span class="line">　　2.要想列值为NULL的行也参与组函数的计算，必须使用IFNULL函数对NULL值做转换。</span><br><span class="line">　　3.不允许出现嵌套 比如sum(max(xx))</span><br></pre></td></tr></table></figure><h4 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a>AVG函数</h4><p>​        AVG()函数计算一组值的平均值。 它计算过程中是忽略<code>NULL</code>值的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select avg(bbb) from test1;</span><br><span class="line">select aaa, avg(bbb) from test1 group by aaa;</span><br></pre></td></tr></table></figure><p>​        如果select的字段列表除了聚合函数以外，没有其他字段，可以不用group by分组子句。否则必须搭配group by使用。</p><h4 id="MAX-函数"><a href="#MAX-函数" class="headerlink" title="MAX()函数"></a>MAX()函数</h4><p>​        MAX()函数返回一组值中的最大值，其语法如下所示 -</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> aaa, <span class="built_in">max</span>(bbb) <span class="keyword">from</span> test1 <span class="keyword">group</span> <span class="keyword">by</span> aaa;</span><br></pre></td></tr></table></figure><h4 id="MIN-函数"><a href="#MIN-函数" class="headerlink" title="MIN()函数"></a>MIN()函数</h4><p>​        MIN()函数返回一组值中的最小值，其语法如下所示 -</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> aaa, <span class="built_in">min</span>(bbb) <span class="keyword">from</span> test1 <span class="keyword">group</span> <span class="keyword">by</span> aaa;</span><br></pre></td></tr></table></figure><p>​        </p><p>​        现在我们设想一个应用场景，计算公司部门的员工最高工资和最低工资，先创建表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">emp_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">emp_name <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;员工姓名&#x27;</span>,</span><br><span class="line">emp_dept <span class="type">varchar</span>(<span class="number">20</span>) comment <span class="string">&#x27;部门名称&#x27;</span>,</span><br><span class="line">salary <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) comment <span class="string">&#x27;工资&#x27;</span>,</span><br><span class="line">hiredate datetime comment <span class="string">&#x27;入职时间&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;赵大&#x27;</span>, <span class="string">&#x27;开发部&#x27;</span>, <span class="number">4500</span>, <span class="string">&#x27;2016-3-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;陈二&#x27;</span>, <span class="string">&#x27;开发部&#x27;</span>, <span class="number">5000</span>, <span class="string">&#x27;2015-5-6&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;开发部&#x27;</span>, <span class="number">7000</span>, <span class="string">&#x27;2012-7-4&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;测试部&#x27;</span>, <span class="number">5500</span>, <span class="string">&#x27;2015-3-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;测试部&#x27;</span>, <span class="number">3500</span>, <span class="string">&#x27;20180407&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;钱六&#x27;</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="number">6000</span>, <span class="string">&#x27;20170909&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(emp_name, emp_dept, salary, hiredate) <span class="keyword">values</span>(<span class="string">&#x27;周七&#x27;</span>, <span class="string">&#x27;财务部&#x27;</span>, <span class="number">5200</span>, <span class="string">&#x27;20170709&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p>​        我们要如何统计各个部门的最高工资和最低工资呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select emp_dept, max(salary) from emp group by emp_dept;</span><br><span class="line">select emp_dept, min(salary) from emp group by emp_dept;</span><br></pre></td></tr></table></figure><p>​        解释一下这个结果：<br>1、满足“SELECT子句中的列名必须为分组列或列函数”，因为SELECT有GROUP BY DEPT中包含的列DEPT。<br>2、“列函数对于GROUP BY子句定义的每个组各返回一个结果”，根据部门分组，对每个部门返回一个结果，就是每个部门的最高薪水。<br>3、分组查询可以在形成组和计算列函数之前具有消除非限定行的标准 WHERE 子句。必须在GROUP BY 子句之前指定 WHERE 子句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_dept, <span class="built_in">max</span>(salary) <span class="keyword">from</span> emp <span class="keyword">where</span> hiredate <span class="keyword">between</span> <span class="string">&#x27;20150101&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2016-12-31&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> emp_dept;</span><br></pre></td></tr></table></figure><h4 id="COUNT-函数"><a href="#COUNT-函数" class="headerlink" title="COUNT()函数"></a>COUNT()函数</h4><p>​        COUNT()函数返回结果集中的行数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from emp;</span><br><span class="line">select count(1) from emp;</span><br><span class="line">select count(emp_id) from emp;</span><br><span class="line">select emp_dept, count(emp_id) from emp group by emp_dept;</span><br></pre></td></tr></table></figure><p>注意：count() 在统计时，会计入null值。</p><h4 id="SUM-函数"><a href="#SUM-函数" class="headerlink" title="SUM()函数"></a>SUM()函数</h4><p>​        SUM()函数返回一组值的总和，SUM()函数忽略<code>NULL</code>值。如果找不到匹配行，则SUM()函数返回<code>NULL</code>值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_dept, <span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> emp_dept;</span><br><span class="line"><span class="keyword">select</span> emp_dept, <span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp  <span class="keyword">where</span> emp_dept<span class="operator">=</span><span class="string">&#x27;aaa&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> emp_dept;</span><br></pre></td></tr></table></figure><h3 id="Order-by-子句"><a href="#Order-by-子句" class="headerlink" title="Order by 子句"></a>Order by 子句</h3><p>​        如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 <strong>ORDER BY</strong> 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。    </p><p>以下是 SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure><ul><li>你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果。</li><li>你可以设定多个字段来排序。</li><li>你可以使用 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列。</li></ul><p>​        我们来看几个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from emp order by salary;</span><br><span class="line">--默认情况按升序排列</span><br><span class="line">select * from emp order by salary desc;</span><br><span class="line">--指定desc后按降序排列</span><br><span class="line">select emp_dept, sum(salary) from emp group by emp_dept order by emp_dept;</span><br><span class="line">--字符串也可以排序，排序依据为字符编码的二进制值</span><br><span class="line">select emp_dept, sum(salary) from emp group by emp_dept order by emp_dept desc;</span><br></pre></td></tr></table></figure><p>​        SELECT后被选择的列，可以在ORDER by和GROUP BY中，通过列名、列别名或者代表列位置的整数（从1开始）来引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_dept, sum(salary) from emp group by emp_dept order by 1 desc;</span><br></pre></td></tr></table></figure><h3 id="用-union-union-all来连接结果集"><a href="#用-union-union-all来连接结果集" class="headerlink" title="用 union/union all来连接结果集"></a>用 union/union all来连接结果集</h3><p>​        如果想选择其他几个表中的行或从一个单一的表作为一个单独的结果集行的几个集会，那么可以使用的UNION。</p><p>​        UNION 用于合并两个或多个 SELECT 语句的结果集，并消去表中任何重复行。如果允许重复的值，请使用 UNION ALL。我们来创建一个场景，学生表和教师表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">teacher_name varchar(20),</span><br><span class="line">teacher_city varchar(20)</span><br><span class="line">);</span><br><span class="line">create table student(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">student_name varchar(20),</span><br><span class="line">student_city varchar(20)</span><br><span class="line">);</span><br><span class="line">insert into teacher(teacher_name, teacher_city) values(&#x27;赵大&#x27;, &#x27;武汉&#x27;);</span><br><span class="line">insert into teacher(teacher_name, teacher_city) values(&#x27;陈二&#x27;, &#x27;鄂州&#x27;);</span><br><span class="line">insert into teacher(teacher_name, teacher_city) values(&#x27;张三&#x27;, &#x27;襄阳&#x27;);</span><br><span class="line"></span><br><span class="line">insert into student(student_name, student_city) values(&#x27;李四&#x27;, &#x27;宜昌&#x27;);</span><br><span class="line">insert into student(student_name, student_city) values(&#x27;王五&#x27;, &#x27;恩施&#x27;);</span><br><span class="line">insert into student(student_name, student_city) values(&#x27;钱六&#x27;, &#x27;黄石&#x27;);</span><br><span class="line">insert into student(student_name, student_city) values(&#x27;周七&#x27;, &#x27;孝感&#x27;);</span><br></pre></td></tr></table></figure><p>​        我们用两个查询分别取得两个表的结果集，然后连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from teacher</span><br><span class="line">union</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure><p>​        如果要获取老师和学生来自哪些城市，则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select teacher_city from teacher</span><br><span class="line">union</span><br><span class="line">select student_city from student;</span><br></pre></td></tr></table></figure><p>注意：</p><p>​        1、UNION 结果集中的列名总是等于第一个 SELECT 语句中的列名<br>​        2、UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。union只关注数据类型，数据业务含义是否相同不管。</p><p>​        我们再插入3条记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into student(student_name, student_city) values(&#x27;周七1&#x27;, &#x27;武汉&#x27;);</span><br><span class="line">insert into student(student_name, student_city) values(&#x27;周七2&#x27;, &#x27;武汉&#x27;);</span><br><span class="line">insert into student(student_name, student_city) values(&#x27;周七3&#x27;, &#x27;武汉&#x27;);</span><br></pre></td></tr></table></figure><p>​        比较一下3句sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> teacher_city <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> student_city <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> teacher_city <span class="keyword">from</span> teacher</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> student_city <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>​        union会将结果集去重，它比较结果集中的全部字段，所有字段都相同的将被去除。union all 不去重。</p><p><strong>union的用法及注意事项</strong></p><p>​        union:联合的意思，即把两次或多次查询结果合并起来。<br>​        要求：两次查询的列数必须一致<br>​        推荐：列的类型可以不一样，但推荐查询的每一列，想对应的类型以一样<br>​        可以来自多张表的数据：多次sql语句取出的列名可以不一致，此时以第一个sql语句的列名为准。<br>​        如果不同的语句中取出的行，有完全相同(这里表示的是每个列的值都相同)，那么union会将相同的行合并，        最终只保留一行。也可以这样理解，union会去掉重复的行。<br>​        如果不想去掉重复的行，可以使用union all。<br>​        如果子句中有order by,limit，需用括号()包起来。推荐放到所有子句之后，即对最终合并的结果来排序或筛选。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_dept, <span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> emp_dept</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> emp_dept, <span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> emp_dept</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_dept <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">--或者这样</span></span><br><span class="line">(<span class="keyword">select</span> emp_dept, <span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> emp_dept)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> emp_dept, <span class="built_in">sum</span>(salary) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> emp_dept)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_dept <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h1 id="3-模糊查询🧁"><a href="#3-模糊查询🧁" class="headerlink" title="3.模糊查询🧁"></a>3.模糊查询🧁</h1><p><code>糊查询</code> 需要使用 <code>like</code> 占位符，几个案例学会模糊查询，下面是stus表的数据</p><h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/eda0266dab164945904311714d61e79d.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stus;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809181513738.png" alt="image-20220809181513738"></p><h2 id="多个任意字符"><a href="#多个任意字符" class="headerlink" title="% 多个任意字符"></a>% 多个任意字符</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查询 stus 表中 name 以猪开头的学生信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> name <span class="keyword">like</span> &quot;吴%&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809181815175.png" alt="image-20220809181815175"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>查询 stus 表中 name 以三结尾的学生信息</span><br><span class="line"> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_stu <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">&#x27;%三&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809182034629.png" alt="image-20220809182034629"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>查询 stus 表中 name 中包含八的学生信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%八%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809182241049.png" alt="image-20220809182241049"></p><h2 id="单个任意字符"><a href="#单个任意字符" class="headerlink" title="_ 单个任意字符"></a>_ 单个任意字符</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span>查询 stus 表中 name 以张开头的且名字长度为<span class="number">2</span>的学生信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;张_&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809182457645.png" alt="image-20220809182457645"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span>查询 t_stu 表中 username 以刘开头的且名字长度为<span class="number">3</span>的学生信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;刘__&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809182602887.png" alt="image-20220809182602887"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>查询 t_stu 表中 username 以建军结尾的且名字长度为<span class="number">3</span>的学生信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;_建军&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809182712543.png" alt="image-20220809182712543"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7.</span>查询 t_stu 表中 username 以张开头以苗结尾的且名字长度为<span class="number">3</span>的学生信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;飞_飞&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809182828895.png" alt="image-20220809182828895"></p><h1 id="4-排序查询🍒"><a href="#4-排序查询🍒" class="headerlink" title="4. 排序查询🍒"></a>4. 排序查询🍒</h1><p>键字**：<code>order by</code><br>关系型数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出来的数据的顺序有意义，可以使用 <code>order by 子句</code>对查询结果进行排序，<code>默认是升序</code>，即从小到大 <code>ASC</code>，如果想要<code>降序</code>排序，则需要指定 <code>DESC</code></p><h2 id="脑图-1"><a href="#脑图-1" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/0a11f8d0311e428280c87c3fc88e6a0b.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><h2 id="ASC-升序"><a href="#ASC-升序" class="headerlink" title="ASC 升序"></a>ASC 升序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 查询stus表中名字字段，要求按照年龄的升序进行排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_stu <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809152621495.png" alt="image-20220809152621495"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 查询stus表中名字,年龄字段，要求按照年龄大于<span class="number">7</span>进行筛选之后按照年龄的升序进行排序</span><br><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> stus <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">7</span> <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809152748158.png" alt="image-20220809152748158"></p><h2 id="DESC-降序"><a href="#DESC-降序" class="headerlink" title="DESC 降序"></a>DESC 降序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> 查询t_stu表中名字字段，要求按照年龄的升序进行排序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_stu <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="limit-选学"><a href="#limit-选学" class="headerlink" title="limit 选学"></a>limit 选学</h2><p>这个还没讲到，如果你不知道，可以跳过，后面会将到哦</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.</span> 查询t_stu表中名字字段，要求按照年龄的升序进行排序，并通过limit返回一条数据，即年龄最小的</span><br><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> t_stu <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809152907230.png" alt="image-20220809152907230"></p><h2 id="位置问题"><a href="#位置问题" class="headerlink" title="位置问题"></a>位置问题</h2><blockquote><p>在使用 order by 子句对检索出的数据进行排序时，应该保证它是位于 from，如果有条件，应位于where之后，如果使用 limit ，它必须位于 order by 之后，使用子句的次序不对将产生错误消息</p></blockquote><h1 id="5-聚合函数🥇"><a href="#5-聚合函数🥇" class="headerlink" title="5. 聚合函数🥇"></a>5. 聚合函数🥇</h1><p>MySQL 提供了5个聚合函数，聚合函数能够汇总数据，这些函数是高效设计的，它们返回结果一般比你自己在客户机应用程序中计算要快的多</p><h2 id="脑图-2"><a href="#脑图-2" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/58988f8a8f124e4cb7870e62d7a4c5f1.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><h2 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h2><p>返回某列的平均值<br><code>查看t_stu表求的年龄平均值</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="string">&#x27;年龄平均值&#x27;</span> <span class="keyword">FROM</span> t_stu;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809153049794.png" alt="image-20220809153049794"></p><h2 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h2><p>返回某列的行数<br><code>查看t_stu表男性有多少人</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(id)  <span class="string">&#x27;男性人数&#x27;</span> <span class="keyword">FROM</span> t_stu <span class="keyword">WHERE</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809153136310.png" alt="image-20220809153136310"></p><h2 id="MAX"><a href="#MAX" class="headerlink" title="MAX()"></a>MAX()</h2><p>返回某列的最大值<br><code>找出表中最大年龄是多少</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="string">&#x27;&#x27;</span>最大年龄 <span class="keyword">FROM</span> t_stu;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809153229609.png" alt=""></p><h2 id="MIN"><a href="#MIN" class="headerlink" title="MIN()"></a>MIN()</h2><p>返回某列的最小值<br><code>找出表中最小年龄是多少</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age) <span class="string">&#x27;最小年龄&#x27;</span> <span class="keyword">FROM</span> t_stu;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809153320625.png" alt="image-20220809153320625"></p><h2 id="SUM"><a href="#SUM" class="headerlink" title="SUM()"></a>SUM()</h2><p>返回某列之和<br><code>查询所有人的年龄之和</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(age) <span class="string">&#x27;年龄之和&#x27;</span> <span class="keyword">FROM</span> t_stu;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809153401096.png" alt="image-20220809153401096"></p><h1 id="6-分组查询🔎"><a href="#6-分组查询🔎" class="headerlink" title="6. 分组查询🔎"></a>6. 分组查询🔎</h1><h2 id="脑图-3"><a href="#脑图-3" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/b2b835d7b1fe42a1abe0fe3cc8c7f73f.png" alt="在这里插入图片描述"></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对t_stu表的数据按照性别进行分组，并查看男女都有多少人</span><br><span class="line"><span class="keyword">SELECT</span>  sex <span class="string">&#x27;性别&#x27;</span>,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="string">&#x27;人数&#x27;</span>  <span class="keyword">FROM</span> t_stu <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex ;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809183216557.png" alt="image-20220809183216557"></p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> gradeId,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">from</span> stus <span class="keyword">group</span> <span class="keyword">by</span> gradeId <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----+</span></span><br><span class="line"><span class="operator">|</span> gradeId <span class="operator">|</span> num <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+-----+</span></span><br></pre></td></tr></table></figure><h2 id="having和where的区别"><a href="#having和where的区别" class="headerlink" title="having和where的区别"></a>having和where的区别</h2><ul><li>执行时间不一样：where是分组之前进行限定，不满足where条件，就不参与分组，而having是分组之后对结果进行过滤</li><li>可判断的条件不一样：where 不能对聚合函数进行判断，having可以</li><li>where &gt; 聚合函数 &gt; having</li></ul><h1 id="7-select子句查询顺序🖥️"><a href="#7-select子句查询顺序🖥️" class="headerlink" title="7. select子句查询顺序🖥️"></a>7. select子句查询顺序🖥️</h1><blockquote><p>select</p><p>from</p><p>where 行级过滤</p><p>group by 分组</p><p>having 组级过滤</p><p>order by 输出排序顺序</p><p>limit 要检索的条目数</p></blockquote><h1 id="8-数据操作语言-DML🥤"><a href="#8-数据操作语言-DML🥤" class="headerlink" title="8.数据操作语言-DML🥤"></a>8.数据操作语言-DML🥤</h1><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><h4 id="插入全部字段"><a href="#插入全部字段" class="headerlink" title="插入全部字段"></a>插入全部字段</h4><ul><li>所有的字段名都写出来<br><code>INSERT INTO 表名 (字段名1, 字段名2, 字段名3…) VALUES (值1, 值2, 值3);</code></li><li>不写字段名<br><code>INSERT INTO 表名 VALUES (值1, 值2, 值3…);</code></li></ul><h4 id="插入部分数据"><a href="#插入部分数据" class="headerlink" title="插入部分数据"></a>插入部分数据</h4><p>   <code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code><br>   没有添加数据的字段会使用NULL</p><ol><li><p>关键字说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 – 表示往哪张表中添加数据</span><br><span class="line">(字段名<span class="number">1</span>, 字段名<span class="number">2</span>, …)  <span class="comment">--  要给哪些字段设置值</span></span><br><span class="line"><span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, …); <span class="comment">-- 设置具体的值</span></span><br></pre></td></tr></table></figure></li><li><p>注意</p><blockquote><ul><li>值与字段必须对应，个数相同，类型相同</li><li>值的数据大小必须在字段的长度范围内</li><li>除了数值类型外，其它的字段类型的值必须使用引号引起。（建议单引号）</li><li>如果要插入空值，可以不写字段，或者插入null</li></ul></blockquote></li><li><p>具体操作:</p><ul><li>插入部分数据，往学生表中添加 id, name, age, sex数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (id, NAME, age, sex) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809131918134.png" alt="image-20220809131918134"></p><ul><li><p>向表中插入所有字段</p><ul><li>所有的字段名都写出来</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (NAME, id, age, sex, address) <span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220809131726790.png" alt="image-20220809131726790"></p><ul><li>不写字段名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%B7%BB%E5%8A%A0%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E6%95%B0%E6%8D%AE.png" alt="添加所有字段数据"></p></li></ul></li></ol><h4 id="操作日期时间类型字段"><a href="#操作日期时间类型字段" class="headerlink" title="操作日期时间类型字段"></a>操作日期时间类型字段</h4><p>在MySQL中，操作日期时间类型，需要注意以下几个方面</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200717104920494.png" alt="image-20200717104920494"></p><p><strong>第一种：YEAR（了解）</strong></p><p>1、数字或字符形式的值insert到表中YEAR字段后都是变成数字形式显示；</p><p>2、字符的’0’与’00’会转化为2000，字符‘0000’和数字的0与00则直接是0000；</p><p>3、不论字符还是数字形式的1~99都可以转化为对应年份，<70转成20XX，>=70转成19XX。</p><p>4、大于0，小于1901或超过2155是无法写入YEAR类型字段的。</p><p><strong>第二种：TIME</strong></p><p>1、尽量还是用字符形式做参数；</p><p>2、只有一个数字则表示秒，如果有两个数字和一个“：”则自动补充“00”作为秒；</p><p>3、前面一个数字加空格后跟着带“：”串，则前面数字要乘以24加上第一个“：”前的数字作为第一个“：”前的结果，其他不变。</p><p><strong>第三种：DATE</strong></p><p>1、YYYYMMDD与YYMMDD格式不论数字还是字符，都可以写入到DATE类型字段中；</p><p>2、YYMMDD格式中表示YY数字00~69转化为2000~2069，而70~99则转化为1970~1999。</p><p><strong>第四与第五种：DATETIME与TIMESTAMP</strong></p><p>1、TIMESTAMP未指定值的情况下会自动填充系统时间；</p><p>2、TIMESTAMP超出范围的值不能写入；</p><p>3、YYYY-MM-DD HH:MM:SS与YYYYMMDDHHMMSS格式都可以表示DATETIME与TIMESTAMP。</p><p>虽然MySQL支持直接在sql里写字符串形式的日期时间，但是这依赖于系统自带的日期数据格式，如果跟提供的日期时间串不匹配则不能正确解析，建议使用日期时间转换函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select str_to_date(&#x27;08.09.2008 08:09:30&#x27;, &#x27;%m.%d.%Y %h:%i:%s&#x27;); -- 2008-08-09 08:09:30</span><br><span class="line">select maketime(12,15,30); -- &#x27;12:15:30&#x27;</span><br><span class="line">select date_format(&#x27;2008-08-08 22:23:01&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;);  -- 20080808222301</span><br></pre></td></tr></table></figure><h4 id="DOS命令窗口操作数据乱码问题的解决"><a href="#DOS命令窗口操作数据乱码问题的解决" class="headerlink" title="DOS命令窗口操作数据乱码问题的解决"></a>DOS命令窗口操作数据乱码问题的解决</h4><blockquote><p>当我们使用DOS命令行进行SQL语句操作如有有中文会出现乱码，导致SQL执行失败<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/DOS%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%8101.png" alt="DOS中文乱码01"><br>错误原因:因为MySQL的客户端设置编码是utf8,而系统的DOS命令行编码是gbk，编码不一致导致的乱码<br><img src="D:\Program Files (x86" alt="DOS中文乱码02">\gakataka\Student\recv\第2阶段___JavaWeb\Java第二阶段_day02_MySQL进阶\Java第二阶段_day02_MySQL进阶知识点\Java第二阶段_day02_MySQL进阶.assets\DOS中文乱码02.png)</p></blockquote><p>查看 MySQL 内部设置的编码<br><code>show variables like &#39;character%&#39;;</code><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/DOS%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%8103.png" alt="DOS中文乱码03"></p><p>解决方案：修改client、connection、results的编码为GBK，保证和DOS命令行编码保持一致</p><ol><li><p>单独设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> character_set_client<span class="operator">=</span>gbk; </span><br><span class="line"><span class="keyword">set</span> character_set_connection<span class="operator">=</span>gbk;</span><br><span class="line"><span class="keyword">set</span> character_set_results<span class="operator">=</span>gbk;</span><br></pre></td></tr></table></figure></li><li><p>快捷设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> names gbk;</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上2种方式为临时方案，退出DOS命令行就失效了，需要每次都配置</p></blockquote></li><li><p>修改MySQL安装目录下的my.ini文件，重启服务所有地方生效。此方案将所有编码都修改了<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/DOS%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%8104.png" alt="DOS中文乱码04"></p></li></ol><h4 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h4><p>什么是蠕虫复制：在已有的数据基础之上，将原来的数据进行复制，插入到对应的表中<br>语法格式：<code>INSERT INTO 表名1 SELECT * FROM 表名2;</code><br>作用:将<code>表名2</code>中的数据复制到<code>表名1</code>中</p><p>具体操作:</p><ul><li>创建student2表，student2结构和student表结构一样</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student2 <span class="keyword">LIKE</span> student;</span><br></pre></td></tr></table></figure><ul><li>将student表中的数据添加到student2表中</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student2 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果只想复制student表中name,age字段数据到student2表中使用如下格式<br><code>INSERT INTO student2(NAME, age) SELECT NAME, age FROM student;</code><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E8%A0%95%E8%99%AB%E5%A4%8D%E5%88%B6.png" alt="蠕虫复制"></p></blockquote><h3 id="更新表记录"><a href="#更新表记录" class="headerlink" title="更新表记录"></a>更新表记录</h3><ol><li><p>不带条件修改数据<br><code>UPDATE 表名 SET 字段名=值;</code></p></li><li><p>带条件修改数据<br><code>UPDATE 表名 SET 字段名=值 WHERE 字段名=值;</code></p></li><li><p>关键字说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>: 修改数据</span><br><span class="line"><span class="keyword">SET</span>: 修改哪些字段</span><br><span class="line"><span class="keyword">WHERE</span>: 指定条件</span><br></pre></td></tr></table></figure></li><li><p>具体操作：</p><ul><li><p>不带条件修改数据，将所有的性别改成女</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%BF%AE%E6%94%B9%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE.png" alt="修改所有数据"></p></li><li><p>带条件修改数据，将id号为2的学生性别改成男</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%B8%A6%E6%9D%A1%E4%BB%B6%E4%BF%AE%E6%94%B9.png" alt="带条件修改"></p></li><li><p>一次修改多个列，把id为3的学生，年龄改成26岁，address改成北京</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">26</span>, address<span class="operator">=</span><span class="string">&#x27;北京&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BF%AE%E6%94%B92%E4%B8%AA%E5%AD%97%E6%AE%B5.png" alt="一次性修改2个字段"></p></li></ul></li></ol><h3 id="删除表记录"><a href="#删除表记录" class="headerlink" title="删除表记录"></a>删除表记录</h3><ol><li><p>不带条件删除数据<br><code>DELETE FROM 表名;</code></p></li><li><p>带条件删除数据<br><code>DELETE FROM 表名 WHERE 字段名=值;</code></p></li><li><p>truncate删除表记录<br><code>TRUNCATE TABLE 表名;</code></p><blockquote><p>truncate和delete的区别：</p><ul><li>delete是将表中的数据一条一条删除</li><li>truncate是将整个表摧毁，重新创建一个新的表,新的表结构和原来表结构一模一样</li></ul></blockquote></li></ol><blockquote><p> <img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/truncate.png" alt="truncate"></p></blockquote><ol><li><p>具体操作：</p><ul><li><p>带条件删除数据，删除id为3的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A0%E9%99%A4%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%AE%B0%E5%BD%95.png" alt="删除满足条件的记录"></p></li><li><p>不带条件删除数据,删除表中的所有数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95.png" alt="删除所有记录"></p></li></ul></li></ol><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E5%88%A4%E6%96%AD%E8%A1%A8%E5%AD%98%E5%9C%A8%E5%B9%B6%E5%88%A0%E9%99%A4-1593134997652.png" alt="判断表存在并删除"></p></li></ul><h1 id="9-SQL约束❤️"><a href="#9-SQL约束❤️" class="headerlink" title="9. SQL约束❤️"></a>9. SQL约束❤️</h1><p><strong>数据完整性</strong><br>数据完整性是为了保证插入到数据库中的数据是正确的,防止用户可能的错误输入。<br>数据完整性分为实<strong>体完整性、域完整性、参照完整性。</strong></p><p><strong>实体(行)完整性</strong></p><p>(实体完整性中的实体指的是表中的行,因为一行记录对应一个实体)<br>实体完整性规定表的一行在表中是唯一的实体,不能出现重复。<br>实体完整性通过表的主键来实现。</p><p><strong>域(列)完整性</strong></p><p>指数据库表的列（即字段）必须符合某种特定的数据类型或约束<br>非空约束：NOT NULL<br>唯一约束：UNIQUE</p><p><strong>参照完整性</strong></p><p>参照完整性指的就是多表之间的关系设计，主要使用外键约束。</p><p>约束英文：<strong>constraint</strong></p><p>​        约束实际上就是表中数据的限制条件</p><p>​        表在设计的时候加入约束的目的就是为了保证表中的记录完整和有效。</p><p>​        <strong>约束分类：</strong><br>1）not null ：非空约束，保证字段的值不能为空</p><p>2）default：默认约束，保证字段总会有值，即使没有插入值，都会有默认值！</p><p>3）unique：唯一，保证唯一性但是可以为空，比如座位号</p><p>4）primary key ：主建约束，同时保证唯一性和非空</p><p>5）foreign key：外键约束，用于限制两个表的关系，保证从表该字段的值来自于主表相关联的字段的值(此节与表之间的关系一起讲)。</p><p>6）check：检查性约束，限制字段输入值的范围</p><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>​        用<strong>not null</strong>约束的字段不能为null值，<strong>必须给定具体的数据</strong></p><p>​        创建非空约束的方法：</p><p>1、建表时创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_1(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  ccc datetime <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2、在已创建好的表的字段上去除、添加非空约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table tc_1 modify aaa int;</span><br><span class="line">alter table tc_1 modify bbb varchar(20) not null;</span><br></pre></td></tr></table></figure><p>​        非空约束不可以指定约束名称，在系统约束列表中也找不到对应的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TABLE_CONSTRAINTS <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure><p>3、删除表时会删除表上全部的非空约束。</p><h3 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h3><p>​        <strong>unique约束的字段，具有唯一性，不可重复，但可以为null。</strong></p><p>​        创建唯一性约束的方法：</p><p>1、建表时创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--列约束定义模式</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_2(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">  ccc datetime <span class="keyword">unique</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">--表约束定义模式</span></span><br><span class="line"><span class="comment">--表级约束可以给约束起名字(方便以后通过这个名字来删除这个约束)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_3(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">unique</span>(aaa),</span><br><span class="line">  <span class="keyword">unique</span>(bbb),</span><br><span class="line">  <span class="keyword">constraint</span> u_ccc <span class="keyword">unique</span>(ccc)</span><br><span class="line">);</span><br><span class="line"><span class="comment">--组合约束模式</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_4(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">unique</span>(aaa, bbb),</span><br><span class="line">  <span class="keyword">unique</span>(ccc)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2、在已创建好的表的字段上去除唯一约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找到对应的唯一约束名称</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TABLE_CONSTRAINTS <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;tc_3&#x27;</span>;</span><br><span class="line"><span class="comment">-- 唯一约束同时也是索引，还可以用索引方式找到</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tc_3;</span><br><span class="line"><span class="comment">-- 用删除索引的方法来删除唯一约束</span></span><br><span class="line"><span class="keyword">drop</span> index u_ccc <span class="keyword">on</span> tc_3;</span><br><span class="line"><span class="comment">-- 在删除表时会自动删除表上全部的唯一约束</span></span><br></pre></td></tr></table></figure><p>3、在已创建好的表的字段上追加唯一约束  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--以约束模式添加</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tc_3 <span class="keyword">ADD</span> <span class="keyword">unique</span>(ccc);</span><br><span class="line"><span class="comment">--以索引模式添加</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index u_ccc <span class="keyword">on</span> tc_3 (ccc);</span><br></pre></td></tr></table></figure><h3 id="默认值约束"><a href="#默认值约束" class="headerlink" title="默认值约束"></a>默认值约束</h3><p>​        “默认值（Default）”的完整称呼是“默认值约束（Default Constraint）”。MySQL默认值约束用来指定某列的默认值。</p><p>​        创建默认值约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_5(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">  ccc datetime <span class="keyword">default</span> <span class="string">&#x27;2020-1-1&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_5 <span class="keyword">values</span>();</span><br></pre></td></tr></table></figure><p>​        在已存在的表字段上添加、修改默认值约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table tc_5 modify aaa int default 5;</span><br><span class="line">alter table tc_5 modify bbb varchar(20) default &#x27;bbb&#x27;;</span><br></pre></td></tr></table></figure><p>​        删除已存在的默认值约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_5 modify aaa <span class="type">int</span> <span class="keyword">default</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_5 modify bbb <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 在删除表时会自动删除表上全部的默认约束</span></span><br></pre></td></tr></table></figure><p>​        与非空约束类似，默认值约束也无法指定名称，也无法在 information_schema.TABLE_CONSTRAINTS 表中查到。</p><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><p>​        表中的某个字段添加<strong>主键约束(primary key)</strong>后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值</p><p>​        1、主键约束（PRIMARY KEY）</p><p>​        1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。<br>​        2) 是不可能（或很难）更新．<br>​        3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．<br>​        4) 主健可作外健，唯一索引不可；</p><p>​        2、唯一性约束（UNIQUE）<br>​        1) 唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．<br>​        2) 只要唯一就可以更新．<br>​        3) 即表中任意两行在 指定列上都不允许有相同的值，允许空（NULL）．<br>​        4) 一个表上可以放置多个唯一性约束</p><pre><code>     3、唯一性约束和主键约束的区别： （1）.唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。 （2）.在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生**聚集索引**，而唯一性约束产生**非聚集索引**。</code></pre><p>​        在建表时创建主键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在列数据库类型后加入主键关键字</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_6(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 在所有字段声明完毕后，加入主键声明</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_6(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">primary</span> key(aaa)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 第2种模式下，可以创建成联合主键（复合主键）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_6(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">primary</span> key(aaa， bbb)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        在已创建的表上建立主键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_7(</span><br><span class="line">  aaa <span class="type">int</span>,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_7 <span class="keyword">add</span> <span class="keyword">primary</span> key(aaa);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_7 <span class="keyword">add</span> <span class="keyword">primary</span> key(aaa, bbb);</span><br></pre></td></tr></table></figure><p>​        主键约束可以在 information_schema.TABLE_CONSTRAINTS 表中查找到，其约束名称固定为 PRIMARY。</p><p>​        删除已存在主键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_7 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"><span class="comment">-- 在删除表时会自动删除表上的主键约束</span></span><br></pre></td></tr></table></figure><p>​        MySQL不支持直接修改主键索引，想要重定义一个表的主键索引，只能先删除原来的索引，再加入新的索引。</p><h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>​        检查约束可以限制新增 、修改字段值，使得其符合约束指定的规则</p><p>​        在创建表时建立检查约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_9(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">check</span>(aaa <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">and</span> aaa<span class="operator">&lt;</span><span class="number">1000</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_9(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">constraint</span> c_tc_9 <span class="keyword">check</span>(aaa <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">and</span> aaa<span class="operator">&lt;</span><span class="number">1000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>​        可以指定约束的名称，否则数据库管理系统将自行定义约束名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">123</span>, <span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;1-2-3&#x27;</span>);</span><br><span class="line"><span class="comment">-- 不满足约束的数据，无法插入记录表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">23</span>, <span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;1-2-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">1234</span>, <span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;1-2-3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​        检查约束可以作用于数值类型、日期类型、字符串类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tc_9(</span><br><span class="line">  aaa <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  bbb <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  ccc datetime,</span><br><span class="line">  <span class="keyword">constraint</span> c_tc_9a <span class="keyword">check</span>(aaa <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">and</span> aaa<span class="operator">&lt;</span><span class="number">1000</span>),</span><br><span class="line">  <span class="keyword">constraint</span> c_tc_9b <span class="keyword">check</span>(bbb <span class="keyword">in</span> (<span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>)),</span><br><span class="line">  <span class="keyword">constraint</span> c_tc_9c <span class="keyword">check</span>(ccc <span class="operator">&gt;</span> <span class="string">&#x27;2000-1-1&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">123</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;2001-2-3&#x27;</span>);</span><br><span class="line"><span class="comment">-- 不满足约束的数据，无法插入记录表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">223</span>, <span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;2001-2-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">223</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;1995-2-3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​        在已创建的表上追加检查约束 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_9 <span class="keyword">add</span> <span class="keyword">constraint</span> c_tc_9d <span class="keyword">check</span>(ccc <span class="operator">&lt;</span> <span class="string">&#x27;2020-1-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tc_9 <span class="keyword">values</span>(<span class="number">223</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;2025-2-3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​       <strong>注意：追加检查约束时，会检查相应字段的值，如果不满足检查约束的限制，检查约束无法创建。</strong></p><p>​        MySQL不支持修改已存在的检查约束，但是可以删除这个约束，再重新添加。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_9 <span class="keyword">drop</span> <span class="keyword">check</span> c_tc_9d;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tc_9 <span class="keyword">add</span> <span class="keyword">constraint</span> c_tc_9d <span class="keyword">check</span>(ccc <span class="operator">&lt;</span> <span class="string">&#x27;2020-1-1&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h3><p>​        当对应的字段不给值，或者说默认值，或者给null的时候会自动地被系统触发，系统会从当前字段中已有的最大值再进行+1，得到一个新的不同的值，通常和主键搭配。</p><p>​        自增长的特点 ：</p><p>　　　　a)、任何一个字段做自增长前提 自身是一个索引(key一栏有值)。</p><p>　　　　b)、自增长字段通常是整形。</p><p>　　　　c)、一个表中只能有1个自增长。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> my_auto_increment(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">) charset utf8;</span><br></pre></td></tr></table></figure><p><strong>自增长如果对应的字段输入了值，那么自增长失效，但是下一次还是能够正确的自增长(从最大值+1)。</strong></p><p>​        <strong>修改自增长。</strong></p><p>　　        自增长如果是涉及到字段改变，必须先删除自增长，后增加，一张表中只能有1个自增长。</p><p>　　　　 修改当前已存在自增长的值，修改只能比当前已有的自增长的最大值大，不能小(小则不生效)。</p><p>​        <strong>删除自增增长。</strong></p><p>​        自增长是字段的一个属性，可以通过modify属性来修改(字段没有自增长)。</p><p>​        <strong>语法：alter table 表名字 modify 字段名 数据类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table my_auto_increment modify id int;</span><br></pre></td></tr></table></figure><p>​        <strong>自增长为什么从1开始？又为什么每次都是自增1呢？</strong></p><p>​        所有系统的表现(如字符集、校对集)都是由系统的内部变量进行控制的。</p><p>　　<strong>查看自增长对应的变量的语法：show variables like ‘auto_increment%’;</strong> </p><p>​        可以修改变量实现不同的效果。如果对整个数据修改(而不是但张表)，这种方式是修改时会话级(当前客户端，当此连接有效，关闭失效)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--修改成一次自增为5</span></span><br><span class="line"><span class="keyword">set</span> auto_increment_increment <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h1 id="10-多表查询😋"><a href="#10-多表查询😋" class="headerlink" title="10. 多表查询😋"></a>10. 多表查询😋</h1><h3 id="脑图-4"><a href="#脑图-4" class="headerlink" title="脑图"></a>脑图</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a1818e50ebc846e6a36d6bb3a2a4c5bf.png" alt="在这里插入图片描述" style="zoom:67%;" /></p><p>试着查询两张表</p><p>​        在实际运用数据的场景中，往往我们使用的数据并不是来自一个表，而需要从多个表中抽取数据来形成我们需要的结果集。        </p><p>​        SQL 连接子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20180103220411541778.png" alt="20180103220411541778"></p><h3 id="等值连接与非等值连接"><a href="#等值连接与非等值连接" class="headerlink" title="等值连接与非等值连接"></a>等值连接与非等值连接</h3><p>​        连接条件是使用等式控制限定，就是等值连接。使用 !=、&gt;、&lt;等非=号来控制里连接条件的，就是非等值连接。</p><h3 id="交叉连接-—-笛卡尔乘积-cross-join"><a href="#交叉连接-—-笛卡尔乘积-cross-join" class="headerlink" title="交叉连接 — 笛卡尔乘积  cross join"></a>交叉连接 — 笛卡尔乘积  cross join</h3><p>​        当两个表或多个表，没有通过连接字段进行关联，而直接进行连接，这时会形成笛卡尔积，结果集会是所有参与连接的表的条数的乘积。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/2934349b033b5bb57f0eb50b36d3d539b700bc6e.gif" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a, student b;</span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name, c.bbb</span><br><span class="line"><span class="keyword">from</span> teacher a, student b, test01 c <span class="keyword">order</span> <span class="keyword">by</span> a.teacher_name;</span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name <span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> student b;</span><br></pre></td></tr></table></figure><p>​        笛卡尔积通常是没有意义的，不满足业务需求，实际运用中应避免笛卡尔积的形成。</p><p>​                <strong>不要漏写关联字段！！！        不要漏写关联字段！！！    不要漏写关联字段！！！</strong></p><h3 id="内连接-inner-join"><a href="#内连接-inner-join" class="headerlink" title="内连接 inner join"></a>内连接 inner join</h3><p>关键字：INNER JOIN</p><blockquote><p>连接结果仅包含符合连接条件的行组合起来作为结果集，参与连接的两个表都应该符合连接条件使用关键词：INNER JOIN 连接多张表</p><p>​    内连接使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据行，组合成新的纪录。结果只保留满足条件的记录。</p></blockquote><p>​        我们来重新创建教师表和学生表，建立一对多的关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> teacher;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">teacher_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">teacher_city <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">student_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">student_city <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">teacher_id <span class="type">int</span></span><br><span class="line"><span class="comment">-- CONSTRAINT fk_t_s foreign key (teacher_id) references teacher(id) on update cascade on delete cascade</span></span><br><span class="line">    <span class="comment">-- 单行注释用 &quot;-- &quot; 注意这个风格下&quot;--【空格】&quot; 也就是说“--&quot; 与注释之间是有空格的</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(teacher_name, teacher_city) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;赵大&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>), (<span class="string">&#x27;陈二&#x27;</span>, <span class="string">&#x27;鄂州&#x27;</span>), (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;襄阳&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(student_name, student_city, teacher_id ) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;宜昌&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;恩施&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;钱六&#x27;</span>, <span class="string">&#x27;黄石&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;周七&#x27;</span>, <span class="string">&#x27;孝感&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;胡八&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>数据准备完成后，我们来看看如何内连接两个表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a, student b <span class="keyword">where</span> a.id <span class="operator">=</span> b.teacher_id;</span><br><span class="line"><span class="comment">-- 或者是</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id;</span><br></pre></td></tr></table></figure><p>​        得到的结果是左边的表，去匹配右边的表，只取得左右两边都能匹配上的数据，匹配不上的数据抛弃。</p><p>​        左表中一条记录，对应右表中多条记录的，左表记录重复多次，每次匹配右表中的一条独立的记录。</p><p>​        我们再插入一些不构成关联的教师和学生的数据，来看看内关联如何处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(teacher_name, teacher_city) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;王胖&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(student_name, student_city, teacher_id ) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;大金牙&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h3><blockquote><p>内连接还有一种隐式的写法，即不需要显示的指定 <code>INNER JOIN</code> 关键字，需要注意，使用隐式内连接条件的关键字要使用 <code>where</code> 而不再是 <code>on</code></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a, student b <span class="keyword">where</span> a.id <span class="operator">=</span> b.teacher_id;</span><br></pre></td></tr></table></figure><h3 id="左外连接-left-out-join"><a href="#左外连接-left-out-join" class="headerlink" title="左外连接 left out join"></a>左外连接 left out join</h3><p>​        是指以左边的表的数据为基准，去匹配右边的表的数据，如果匹配到就显示，匹配不到就显示为null。关键字是left outer join，等效于left join。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id;</span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id</span><br><span class="line"><span class="keyword">where</span> b.teacher_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 这句sql等效于内连接</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id</span><br><span class="line"><span class="keyword">where</span> b.teacher_id <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 这句sql取出没有学生对应的老师</span></span><br></pre></td></tr></table></figure><p>​        得到的结果是左边的表，完整的全表数据，去匹配右边的表，取得右边能匹配上的数据，匹配不上的数据填null。</p><p>​        左表中一条记录，对应右表中多条记录的，左表记录重复多次，每次匹配右表中的一条独立的记录。</p><h3 id="右外连接-right-outer-join"><a href="#右外连接-right-outer-join" class="headerlink" title="右外连接 right outer join"></a>右外连接 right outer join</h3><p>​        是指以右边的表的数据为基准，去匹配左边的表的数据，如果匹配到就显示，匹配不到就显示为null。关键字是right outer join，等效于right join。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id;</span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id</span><br><span class="line"><span class="keyword">where</span> a.id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 这句sql等效于内连接</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id</span><br><span class="line"><span class="keyword">where</span> a.id <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 这句sql取出没有老师对应的学生</span></span><br></pre></td></tr></table></figure><p>​        得到的结果是右边的表，取完整的全表数据，去匹配左边的表，取得左边能匹配上的数据，匹配不上的数据填null。</p><p>​        右表中一条记录，对应左表中多条记录的，右表记录重复多次，每次匹配左表中的一条独立的记录。</p><h3 id="全外连接-full-outer-join"><a href="#全外连接-full-outer-join" class="headerlink" title="全外连接 full outer join"></a>全外连接 full outer join</h3><p>​        全外连接是在内连接的基础上将左表和右表的未匹配数据都加上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> TESTA </span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TESTB</span><br><span class="line"><span class="keyword">ON</span> TESTA.A<span class="operator">=</span>TESTB.A</span><br></pre></td></tr></table></figure><p>​        注意：MySQL不支持全外连接，但是Oracle支持全外连接。</p><p>​        其等效于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id</span><br><span class="line"><span class="keyword">union</span>  <span class="comment">-- 注意这里需要使用去重，而不是union all</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.teacher_id;</span><br></pre></td></tr></table></figure><h3 id="自然连接-natural-join"><a href="#自然连接-natural-join" class="headerlink" title="自然连接 natural join"></a>自然连接 natural join</h3><p>​        通过mysql自己判断完成连接过程,不需要指定连接条件，mysql会根据多个表内的相同字段作为连接条件。</p><p>​        自然连接分为两种：<strong>内自然连接(natural join)</strong>和外自然连接，其中外自然连接又分为<strong>左外自然连接(natural left join)</strong>和<strong>右外自然连接(rnatural right join)</strong>。<strong>注意：自然连接没有判断语句。</strong></p><p>​        内自然连接如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">join</span> student b;</span><br><span class="line"><span class="comment">-- 这实际等效于以下sql</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><p>​        所以使用自然连接的前提条件是连接字段必须同名。</p><p>​        我们来重新创建教师表和学生表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> teacher;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">teacher_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">teacher_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">teacher_city <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> student;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">student_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">student_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">student_city <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">teacher_id <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(teacher_name, teacher_city) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;赵大&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>), (<span class="string">&#x27;陈二&#x27;</span>, <span class="string">&#x27;鄂州&#x27;</span>), (<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;襄阳&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(student_name, student_city, teacher_id ) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;宜昌&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;恩施&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;钱六&#x27;</span>, <span class="string">&#x27;黄石&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;周七&#x27;</span>, <span class="string">&#x27;孝感&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;胡八一&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher(teacher_name, teacher_city) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;王胖子&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(student_name, student_city, teacher_id ) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;大金牙&#x27;</span>, <span class="string">&#x27;武汉&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>左外自然连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b;</span><br><span class="line"><span class="comment">-- 其等效于以下sql</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.teacher_id <span class="operator">=</span> b.teacher_id;</span><br></pre></td></tr></table></figure><p>右外自然连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> student b;</span><br><span class="line"><span class="comment">-- 其等效于以下sql</span></span><br><span class="line"><span class="keyword">select</span> a.teacher_name, b.student_name</span><br><span class="line"><span class="keyword">from</span> teacher a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.teacher_id <span class="operator">=</span> b.teacher_id;</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>​        <strong>自连接</strong>是连接的一种用法，但并不是连接的一种类型，因为他的本质是把一张表当成两张表来使用。 处理业务是有时在信息查询时需要进行对自身连接（自连接），所以我们需要为表定义别名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ta.student_name, tb.student_city</span><br><span class="line"><span class="keyword">from</span> studnet ta， student tb</span><br><span class="line"><span class="keyword">where</span> ta.student_id <span class="operator">=</span> tb.student_id;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java第二阶段-day02-MySQL进阶&quot;&gt;&lt;a href=&quot;#Java第二阶段-day02-MySQL进阶&quot; class=&quot;headerlink&quot; title=&quot;Java第二阶段_day02_MySQL进阶&quot;&gt;&lt;/a&gt;Java第二阶段_day02_MySQL</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Java第二阶段_day01_MySQL入门</title>
    <link href="https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-day01-MySQL%E5%85%A5%E9%97%A8/"/>
    <id>https://manamn.space/2022/10/16/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/Java%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-day01-MySQL%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-16T14:47:46.000Z</published>
    <updated>2022-10-16T14:55:58.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java第二阶段-day01-MySQL入门"><a href="#Java第二阶段-day01-MySQL入门" class="headerlink" title="Java第二阶段_day01_MySQL入门"></a>Java第二阶段_day01_MySQL入门</h1><blockquote><p>🏠个人主页：<a href="https://blog.csdn.net/qq_58608526?spm=1019.2139.3001.5343">不会写代码的满满</a><br>🧑个人简介：大家好，我是满满，一个想要与大家共同进步的男人😉😉<br>目前状况🎉：开学即将大三，目标就是半年内找到一份实习工作👏👏<br>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘</p></blockquote><p><strong>正文开始  —————</strong></p><h1 id="学习目标📋"><a href="#学习目标📋" class="headerlink" title="学习目标📋"></a>学习目标📋</h1><ul><li>能够理解数据库的概念</li><li>能够安装MySQL数据库</li><li>能够启动,关闭及登录MySQL</li><li>能够安装使用MySQL图形客户端Navicat</li><li>能够使用SQL语句操作数据库</li><li>能够使用SQL语句操作表结构</li><li>能够使用SQL语句简单查询数据</li></ul><h1 id="1-数据库概述👀"><a href="#1-数据库概述👀" class="headerlink" title="1.数据库概述👀"></a>1.数据库概述👀</h1><h2 id="1-1-计算机系统如何存储数据"><a href="#1-1-计算机系统如何存储数据" class="headerlink" title="1.1 计算机系统如何存储数据"></a>1.1 计算机系统如何存储数据</h2><p><strong>哪些算是计算机数据</strong></p><p>​        1、计算机程序代码，包括操作系统核心、各种运行库、用户应用程序等等。特点是不会经常变换，稳定性较高。</p><p>​        2、支持计算机程序运行的数据，比如说银行系统的账户信息，游戏系统中的玩家角色等级，金币数量、物品信息。        </p><p><strong>计算机系统的数据存放在哪里的</strong></p><p>​        一个计算机系统，其存储可以分为内存与外存。</p><p>​        内存的特点是高速高吞吐，异失性。比如CPU一级二级缓存，内存等，一旦掉电，所有内存数据都会丢失。</p><p>​        例如：数组,集合;new出来的对象存储在堆中.堆是内存中的一小块空间<br>​        优点：内存速度快<br>​        缺点：断电/程序退出,数据就清除了.内存价格贵</p><p>​        外存的特点是可以持久保存，可能是磁介质（硬盘），光介质（VCD、DVD、蓝光）、集成电路（U盘，固态硬盘）。但是其代价是存取数据较慢。</p><p>​        例如：普通磁盘文件<br>​        优点：永久保存<br>​        缺点：查找，增加，修改，删除数据比较麻烦，效率低</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/u=2903201159,2379232552&amp;fm=26&amp;gp=0.jpg" alt="img"></p><p>​        当遇到需要长期保留数据，不能因为应用停止，系统关机二丢失数据的话，那么我们只能选择外存来存储这些数据，比方说银行账户系统、qq聊天记录，游戏角色等级记录等等。</p><p>​        <strong>最终系统存储永久性数据的，就是通过一个个文件。</strong></p><p><strong>仅仅用文件存储数据有什么弊端</strong></p><p>​        对于单用户应用程序，使用文件存储数据不存在太大的问题，但是在多用户、大数据量、强数据私密性的情况下，只使用文件来存储就存在种种弊端。</p><p>​        1、文件的安全性问题，每个访问到文件系统的用户，都可以随意访问文件。</p><p>​        2、文件中查询数据，管理数据并不方便。</p><p>​        3、在文件中存取海量数据，速度和效率并不理想。</p><p>​        4、在程序中控制文件较繁琐。比方说，多个用户打开同一个文件等等。</p><p>​        5、一旦文件损坏（磁盘问题，误删除、误覆盖）等等，会造成无可挽回的数据丢失。</p><p><strong>如何解决这些问题</strong></p><p>​        引入数据库系统，通过数据库来管理、存取、备份数据，可以提供多并发、严格用户权限控制、数据安全保障等方面的功能。</p><p>​        比如说，用文件存储数据就好像是你家的书架，2到3个人来看书，摆放百把本书，还是不错的。如果有两三千人来看书，存书数百万册，那么就需要建立一个专门的图书馆，雇佣专门的图书管理员来为大家服务。</p><p>​        这个图书馆就可以理解成一个数据库。</p><h2 id="1-2-什么是数据库"><a href="#1-2-什么是数据库" class="headerlink" title="1.2 什么是数据库"></a>1.2 什么是数据库</h2><blockquote><p>数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。</p><p>数据库是以一定方式储存在一起、能与多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合，可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据进行新增、查询、更新、删除等操作。</p></blockquote><p>​    存储数据的仓库，其本质是一个文件系统，数据库按照特定的格式将数据存储起来，并通过特定的应用程序（数据库管理系统，DataBase Management System），用户可以对数据库中的数据进行增加，修改，删除及查询操作。</p><p><strong>关键字：</strong>文件系统、特定的格式、存储数据、对数据进行增删改查</p><h2 id="1-3-数据库的优点"><a href="#1-3-数据库的优点" class="headerlink" title="1.3 数据库的优点"></a>1.3 数据库的优点</h2><p>​    数据库是按照特定的格式将数据持久化存储在文件中，通过SQL语句可以方便的对大量数据进行增、删、改、查操作，数据库是对大量的信息进行管理的高效的解决方案。</p><ol><li><p><strong>整体数据结构化：</strong>在数据库系统中，记录的结构和记录之间的联系有数据库管理系统进行维护，从而减轻了程序员的工作量，提高了工作效率。</p></li><li><p><strong>数据的共享性高、冗余度低且易扩充</strong>：数据共享包括多个用户、多个应用可以同时存取数据库中的数据，也包括用户可以用各种方式通过接口使用数据库中的数据。同时，数据库实现数据共享大大减少了数据<a href="https://so.csdn.net/so/search?q=冗余&amp;spm=1001.2101.3001.7020">冗余</a>，还能够避免数据之间的不相容性和不一致性。（数据的不一致性：指同一数据不同副本的值不一样）</p></li><li><p><strong>数据独立性高</strong>：数据独立性包括数据的物理独立性和逻辑独立性，即用户的应用程序与数据库中数据的物理存储和数据的逻辑结构均相互独立。</p></li><li><p><strong>数据由数据库管理系统统一管理和控制</strong> ：利用数据库可对数据进行集中控制和管理，并通过数据模型表示各种数据的组织以及数据间的联系，同时数据库管理系统提供了以下几个方面的数据控制功能，以解决数据共享带来的安全隐患。</p></li></ol><h2 id="1-4-数据库管理系统"><a href="#1-4-数据库管理系统" class="headerlink" title="1.4 数据库管理系统"></a>1.4 数据库管理系统</h2><p>​    数据库管理系统（DataBase Management System，<strong>DBMS</strong>）：指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中表内的数据。</p><h2 id="1-5-数据库管理系统、数据库和表的关系"><a href="#1-5-数据库管理系统、数据库和表的关系" class="headerlink" title="1.5 数据库管理系统、数据库和表的关系"></a>1.5 数据库管理系统、数据库和表的关系</h2><p>​    数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。数据库管理系统、数据库和表的关系如图所示：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/DBMS.png" alt="DBMS"></p><p>先有数据库 → 再有表 → 再有数据<br>一个库包含多个表，一个表可以对应有多条数据</p><h2 id="1-6-常见数据库"><a href="#1-6-常见数据库" class="headerlink" title="1.6 常见数据库"></a>1.6 常见数据库</h2><p>数据库类型：数据库经过几十年的发展，出现了多种类型。目前最常见的数据库模型主要是：关系型数据库和（noSQL）非关系型数据库。</p><p>MySQL：其中的一款关系型数据库管理系统</p><p>以下是2020年<strong>DB-Engines Ranking</strong> 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:<a href="https://db-engines.com/en/ranking）">https://db-engines.com/en/ranking）</a></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220812231428108.png" alt="image-20220812231428108"><br><strong>MYSQL</strong>：开源免费的数据库，小型的数据库.已经被Oracle收购了.MySQL6.x版本也开始收费。<br><strong>Oracle</strong>：收费的大型数据库，Oracle公司的产品。Oracle收购SUN公司，收购MYSQL。<br><strong>DB2</strong> ：IBM公司的数据库产品,收费的。常应用在银行系统中.<br><strong>SQLServer</strong>：MicroSoft 公司收费的中型的数据库。C#、.net等语言常使用。<br><strong>SyBase</strong>：已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。<br><strong>SQLite</strong>: 嵌入式的小型数据库，应用在手机端。</p><p><strong>Redis：</strong> 是一个开源（BSD许可）的、使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型文件系统，它是内存中的数据结构存储系统，它可以用作数据库（非关系型数据库）、缓存和消息中间件。</p><p><strong>MongoDB：</strong>是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统，MongoDB是一个介于<a href="https://baike.baidu.com/item/关系数据库">关系数据库</a>和非关系数据库之间的产品。</p><p><strong>常用数据库</strong>：<strong>MYSQL</strong>，<strong>Oracle</strong>，<strong>Redis</strong><br>在web应用中，使用的最多的就是MySQL数据库，原因如下：</p><ol><li>开源、免费</li><li>功能足够强大，足以应付web应用开发</li></ol><h1 id="2-MySQL的安装、卸载与使用🌈"><a href="#2-MySQL的安装、卸载与使用🌈" class="headerlink" title="2.MySQL的安装、卸载与使用🌈"></a>2.MySQL的安装、卸载与使用🌈</h1><h3 id="2-1-1-下载安装版本"><a href="#2-1-1-下载安装版本" class="headerlink" title="2.1.1 下载安装版本"></a>2.1.1 下载安装版本</h3><p>​        <a href="https://dev.mysql.com/downloads/mysql/">点击MySQL下载</a>，目前最新版本为8.0.30。</p><p>!<img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808211841512.png" alt="image-20220808211841512" style="zoom:80%;" /></p><p>​        下载完成后进行解压</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808211946086.png" alt="image-20220808211946086" style="zoom:80%;" /></p><p>​        没有安装程序，直接将将解压完成后的目录复制到你计划安装MySQL的目录。</p><h3 id="2-1-2-初始化数据库"><a href="#2-1-2-初始化数据库" class="headerlink" title="2.1.2 初始化数据库"></a>2.1.2 初始化数据库</h3><p>配置初始化的my.ini文件的文件，解压后的目录并没有的my.ini文件，需自行创建在安装根目录下添加的my.ini（新建文本文件，将文件类型改为的.ini），写入基本配置： </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录，需指向自己计划安装MySQL的目录</span></span><br><span class="line"><span class="attr">basedir</span>=<span class="string">C:\Program Files\MySQL</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录，通常指定到安装目录下的Data文件夹</span></span><br><span class="line"><span class="attr">datadir</span>=<span class="string">C:\Program Files\MySQL\Data</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="string">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为utf8mb4</span></span><br><span class="line"><span class="attr">character-set-server</span>=<span class="string">utf8mb4</span></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=<span class="string">mysql_native_password</span></span><br><span class="line"><span class="comment"># 设置时区为东八区</span></span><br><span class="line"><span class="attr">default-time-zone</span>=<span class="string">&#x27;+8:00&#x27;</span></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8mb4</span></span><br><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8mb4</span></span><br></pre></td></tr></table></figure><p>​        配置文件中的路径要和实际存放的路径一致（8.0.18不要手动创建Data文件夹）</p><p>​        <strong>在初始化时，避免出错我们尽量全部使用管理员身份运行命令行程序，否则会报错，导致安装失败。打开cmd后进入mysql的bin目录。</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a01.png" alt="img"></p><p><strong>在MySQL目录下的bin目录下执行命令：</strong></p><p><strong>mysqld —initialize —console</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a02.png" alt="img"></p><p>​        <strong>注意！输出日志中中root @ localhost：后面的9P0gYk-？0，kT就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。复制密码先保存起来!!!</strong></p><p>​        在系统环境变量中加入MYSQL_HOME，其值为你安装mysql的物理路径。再在系统环境变量PATH中加入一项 %MYSQL_HOME%/bin。完成此操作后，就可以在任意目录下执行mysql相关命令。</p><h3 id="2-1-3-安装-启动MySQL服务"><a href="#2-1-3-安装-启动MySQL服务" class="headerlink" title="2.1.3 安装+启动MySQL服务"></a>2.1.3 安装+启动MySQL服务</h3><p><strong>执行下面的命令：</strong></p><p><strong>mysqld —install [服务名]（服务名可以不加默认为mysql）</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a03.png" alt="img"></p><p>窗口提示 successfully installed. 即代表成功完成安装服务。</p><blockquote><p><strong>如果出现这个</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a04.png" alt="img"></p><p><strong>说明mysql的服务还在把它删掉</strong>  </p><p><strong>用这个命令</strong></p><p><strong>SC删除的MySQL</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a05.png" alt="img"></p><p><strong>再执行上面安装服务</strong></p></blockquote><p><strong>服务安装成功之后通过命令net start mysql启动MySQL的服务</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a06.png" alt="img"></p><p>启动MYSQL: <code>net start mysql</code><br>停止MYSQL: <code>net stop mysql</code></p><p>​        <strong>也可以使用Windows服务方式启动</strong><br>操作步骤：<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a07.png" alt="mysql启动01"><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a08.png" alt=""></p><h3 id="2-1-4-卸载MySQL"><a href="#2-1-4-卸载MySQL" class="headerlink" title="2.1.4 卸载MySQL"></a>2.1.4 卸载MySQL</h3><ol><li>首先停止window的MySQL服务。<br>找到“控制面板”-&gt; “管理工具”-&gt; “服务”，停止MySQL后台服务。</li><li>卸载MySQL服务，用管理员身份启动命令行程序，执行 <strong>sc delete mysql</strong> 。</li><li>删除MySQL安装目录下的所有文件。</li><li>删除c盘ProgramDate目录中关于MySQL的目录。路径为：C:\ProgramData\MySQL(是隐藏文件,需要显示出来)<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808212528143.png" alt="image-20220808212528143" style="zoom:67%;" /><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808212557812.png" alt="image-20220808212557812" style="zoom:67%;" /></li></ol><p><strong>如果还是没有卸载干净，需要删除注册表残留</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">三、windows+R运行“regedit”文件，打开注册表；</span><br><span class="line"></span><br><span class="line">四、删除注册表：HKEY<span class="built_in">_</span>LOCAL<span class="built_in">_</span>MACHINE<span class="keyword">\SYSTEM</span><span class="keyword">\ControlSet</span>001<span class="keyword">\Services</span><span class="keyword">\Eventlog</span><span class="keyword">\Application</span><span class="keyword">\MySQL</span>文件夹；</span><br><span class="line"></span><br><span class="line">五、删除HKEY<span class="built_in">_</span>LOCAL<span class="built_in">_</span>MACHINE<span class="keyword">\SYSTEM</span><span class="keyword">\ControlSet</span>002<span class="keyword">\Services</span><span class="keyword">\Eventlog</span><span class="keyword">\Application</span><span class="keyword">\MySQL</span>文件夹，如果没有可以不用删除了；</span><br><span class="line"></span><br><span class="line">六、删除C盘下的C:<span class="keyword">\ProgramData</span><span class="keyword">\MySQL</span> 所有文件，如果删除不了则用360粉碎掉即可，该programData文件是隐藏的默认，设置显示后即可见；</span><br><span class="line"></span><br><span class="line">七、关键！！！！删除C:<span class="keyword">\Documents</span> and Settings<span class="keyword">\All</span> Users<span class="keyword">\Application</span> Data<span class="keyword">\MySQL</span>下的文件夹，一定要删；</span><br><span class="line"></span><br><span class="line">最好重启下电脑，重新安装就可以了!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-控制台连接数据库"><a href="#2-3-控制台连接数据库" class="headerlink" title="2.3 控制台连接数据库"></a>2.3 控制台连接数据库</h2><p>​    MySQL是一个需要账户名密码登录的数据库，登陆后使用，它提供了一个默认的root账号，使用安装时设置的密码即可登录,常见的登录方式有以下几种:掌握其中一种即可</p><p><strong>本地登录格式</strong>1：<code>mysql -u用户名 -p密码</code><br>例如：<code>mysql –uroot -proot</code><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808212648570.png" alt="image-20220808212648570"><br>后期输入密码的登录方式：</p><p><code>mysql -u用户名 -p回车</code></p><p><code>密码</code></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a12.png" alt="MYSQL登录04"></p><p><strong>远程登录精简格式</strong>2：<code>mysql -hip地址 -u用户名 -p密码</code><br>例如：<code>mysql –h127.0.0.1 –uroot -proot</code><br>​</p><p><strong>远程登录全写格式</strong>3：<code>mysql --host=ip地址 --user=用户名 --password=密码</code><br>例如：<code>mysql --host=localhost --user=root --password=root</code><br>​</p><p>退出MySQL：<code>exit</code><br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808212756746.png" alt="image-20220808212756746"></p><p><strong>修改root用户的初始密码</strong></p><p>在初始化时，系统自动生成了一个root的密码，但是很复杂，不方便使用。我们可以登录进mysql中重新设置一个好用的密码。</p><p>方法是以root身份，使用初始密码登录MySQL后，执行sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> root identified <span class="keyword">by</span> &quot;新密码&quot;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>退出后，就可以使用新密码登录。</p><h2 id="2-4-常见问题解决"><a href="#2-4-常见问题解决" class="headerlink" title="2.4 常见问题解决"></a>2.4 常见问题解决</h2><h3 id="2-4-1-忘记root密码后，如何重置root密码"><a href="#2-4-1-忘记root密码后，如何重置root密码" class="headerlink" title="2.4.1 忘记root密码后，如何重置root密码"></a>2.4.1 忘记root密码后，如何重置root密码</h3><p>停止mysql服务以后，以免密码方式登录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld <span class="comment">--console --skip-grant-tables --shared-memory</span></span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/WB}6BO0I2$81VB1MG%PK0EG.png" alt="img"></p><p>不要关闭cmd窗口，另开一屏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E7%A9%BA%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95MySQL.png" alt="空密码登录MySQL"></p><p>登入系统后执行以下sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> authentication_string<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>将root用户的密码置为空，然后退出SQL窗口，并关闭免密模式的启动窗口，以正常方式启动mysql。<br>重新用root用户身份，空密码登录mysql。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;xxxxx&#x27;</span>;</span><br></pre></td></tr></table></figure><p> 重新为root用户设置密码。</p><h3 id="2-4-2-客户端连接服务器报caching-sha2-password错"><a href="#2-4-2-客户端连接服务器报caching-sha2-password错" class="headerlink" title="2.4.2 客户端连接服务器报caching-sha2-password错"></a>2.4.2 客户端连接服务器报caching-sha2-password错</h3><p>这是是因为客户端不支持加密插件，可以如下来修改密码模式。</p><p>首先以root身份登录MySQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span> PASSWORD EXPIRE NEVER;</span><br></pre></td></tr></table></figure><p>这句sql的意思是，将指定用户对应localhost的密码设置为 native 模式的新密码，且此密码永不过期。</p><h3 id="2-4-3-登录报时区错误"><a href="#2-4-3-登录报时区错误" class="headerlink" title="2.4.3 登录报时区错误"></a>2.4.3 登录报时区错误</h3><p>登录时报告类似如下错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The server <span class="type">time</span> zone <span class="keyword">value</span> <span class="string">&#x27;ÖÐ¹ú±ê×¼Ê±¼ä&#x27;</span> <span class="keyword">is</span> unrecognized <span class="keyword">or</span> represents more t</span><br></pre></td></tr></table></figure><p>这都是因为安装mysql的时候时区设置的不正确，mysql默认的是美国的时区，而中国大陆要比他们迟8小时，采用+8:00格式。</p><p>可以找到mysql的安装目录下的<code>my.ini</code>文件，使用notepad++打开，在<code>mysqld</code>下加入如下代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置时区</span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span><span class="type">time</span><span class="operator">-</span>zone<span class="operator">=</span><span class="string">&#x27;+8:00&#x27;</span></span><br></pre></td></tr></table></figure><p>之后重启mysql即可。</p><h1 id="3-基本操作-😀"><a href="#3-基本操作-😀" class="headerlink" title="3.基本操作 😀"></a>3.基本操作 😀</h1><h2 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/ccc313e453cd40fdaf486671fb7b002a.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h2 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h2><blockquote><p>net start mysql</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32&gt;net <span class="built_in">start</span> mysql</span><br><span class="line">MySQL 服务正在启动 .</span><br><span class="line">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure><h2 id="关闭mysql服务"><a href="#关闭mysql服务" class="headerlink" title="关闭mysql服务"></a>关闭mysql服务</h2><blockquote><p>net stop mysql</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32<span class="operator">&gt;</span>net stop mysql</span><br><span class="line">MySQL 服务正在停止.</span><br><span class="line">MySQL 服务已成功停止。</span><br></pre></td></tr></table></figure><h2 id="登录mysql服务"><a href="#登录mysql服务" class="headerlink" title="登录mysql服务"></a>登录mysql服务</h2><p>注意，地址就是ip，本地可以写localhost和127.0.0.1，端口就是mysql启动服务占用的端口号 默认是3306</p><blockquote><p>mysql -h 地址 -P 端口 -u root -p 密码</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808213901855.png" alt="image-20220808213901855"></p><h2 id="退出mysql登录"><a href="#退出mysql登录" class="headerlink" title="退出mysql登录"></a>退出mysql登录</h2><blockquote><p>ctrl + z 回车<br>exit<br>quit</p></blockquote><h2 id="显示哪些线程正在运行"><a href="#显示哪些线程正在运行" class="headerlink" title="显示哪些线程正在运行"></a>显示哪些线程正在运行</h2><blockquote><p>show processlist;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808213946510.png" alt="image-20220808213946510"></p><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><blockquote><p>help 关键字;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214020840.png" alt="image-20220808214020840" style="zoom:67%;" /></p><h1 id="4-数据库可视化操作🔍"><a href="#4-数据库可视化操作🔍" class="headerlink" title="4.数据库可视化操作🔍"></a>4.数据库可视化操作🔍</h1><p>​    上面进行数据库连接登录，以及操作都是通过cmd终端窗口的形式来完成的，这种方式可视化效果较差，且不容易管理。为此，我们可以使用一些可视化管理工具来管理我们的MySQL数据库。</p><p>常见的一些数据库可视化管理工具：</p><p>有<strong>Navicat</strong>、<strong>SQLyog</strong>、<strong>Workbench</strong>等等。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/b01.png" alt="image-20191223105316836"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/b02.png" alt="image-20191223105441921"></p><h2 id="3-1-安装Navicat-For-Mysql"><a href="#3-1-安装Navicat-For-Mysql" class="headerlink" title="3.1 安装Navicat For Mysql"></a>3.1 安装Navicat For Mysql</h2><p>​        获取“NJava第二阶段_day01_MySQL入门.assetsavicat for MySQL”安装应用程序（navicat121_mysql_cs_x64.exe）完毕后双击运行，在欢迎安装向导页面，点击【下一步】继续。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114334935.png" alt="image-20200715114334935"></p><p>​    请阅读许可协议，接受并点击【下一步】。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114354622.png" alt="image-20200715114354622"></p><p>在“选择安装文件夹”窗口，软件默认安装在 C 盘，如果您想安装软件在其他目录请点击【浏览】操作，设置完安装位置点击【下一步】。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114411519.png" alt="image-20200715114411519" style="zoom:67%;" /></p><p>选择在“开始”菜单默认创建的快捷方式，点击【下一步】。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114425394.png" alt="image-20200715114425394" style="zoom:67%;" /></p><p>在“选择额外任务”窗口，默认选中“Create a deskstop icon”，即创建系统桌面图标，点击【下一步】，如果不想创建桌面图标，取消勾选。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114443929.png" alt="image-20200715114443929"></p><p>在“准备安装”窗口，安装程序即将安装 PremiumSoft Navicat 12 for MySQL，点击【安装】开始安装。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114506791.png" alt="image-20200715114506791"></p><p>耐心等待安装完成。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114535785.png" alt="image-20200715114535785"></p><p>运行 Navicat 12 for MySQL，因为新安装的 Navicat 只有 14 天的免费试用期，打开时会弹出“注册”页面，点击【试用】，后续我们将对此软件破解。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114601502.png" alt="image-20200715114601502" style="zoom:67%;" /></p><h2 id="3-2-破解Navicat-For-Mysql"><a href="#3-2-破解Navicat-For-Mysql" class="headerlink" title="3.2 破解Navicat For Mysql"></a>3.2 破解Navicat For Mysql</h2><p>在网上下载对应版本的注册机，准备开始破解，具体步骤如下：</p><p>1、关闭navicat<br>2、打开注册机，点右上角的path按钮，选择navicat安装到硬盘的路径，选中navicat.exe文件，点确定按钮<br>3、等注册机出现”cracked”对话框，再点击生成注册码<br>4、打开navicat，点击注册，输入注册码，注意，有可能出现注册码校验失败，打x的。关闭注册窗口，重新打开注册窗口，里面注册码已经填好，且校验成功。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114717047.png" alt="image-20200715114717047" style="zoom:67%;" /></p><p>5、选择我们要注册的MYSQL，选择中文版，选择site license，完了后点击“Generate”生成序列号<br>6、此时打开软件，将网线拔掉或热点断开，再点注册。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114758175.png" alt="image-20200715114758175" style="zoom:67%;" /></p><p>7、由于网络失败，Naticat 报错，提示转到手动激活。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114819125.png" alt="image-20200715114819125" style="zoom:80%;" /></p><p>8、这里将请求码中的代码复制到注册机中，再点击generate得到激活码，填入注册界面；</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114841259.png" alt="image-20200715114841259" style="zoom:80%;" /></p><p>9、点击激活；</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114902678.png" alt="image-20200715114902678" style="zoom:80%;" /></p><p>5、至此，navicat 12 for mysql中文破解版成功激活，从帮助菜单下可以查看软件已经是企业版本。注意：不要升级版本，以免破解失效。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715114938715.png" alt="image-20200715114938715" style="zoom:80%;" /></p><h2 id="3-3-使用Navicat-For-Mysql"><a href="#3-3-使用Navicat-For-Mysql" class="headerlink" title="3.3 使用Navicat For Mysql"></a>3.3 使用Navicat For Mysql</h2><p>启动 Naticat for MySQL，选择菜单： 文件 -》 新建连接  -》 MySQL…</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715115036969.png" alt="image-20200715115036969" style="zoom:80%;" /></p><p>在配置页面上，填入服务器IP或主机名<br>连接端口<br>连接用户名<br>连接密码<br>等参数，点击测试连接</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715115056993.png" alt="image-20200715115056993" style="zoom:80%;" /></p><p>在配置页面上，填入服务器IP或主机名<br>连接端口<br>连接用户名<br>连接密码<br>等参数，点击测试连接<br>若一切正常，即可显示“连接成功”，再点击确定按钮。<br>这个连接就被 Naticat for MySQL保存下来，下次连接就不需要输入IP、用户名、密码了。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715115112966.png" alt="image-20200715115112966" style="zoom:80%;" /></p><p>在软件页面上，左侧菜单上就会出现你命名的连接项，左键双击，或在右键菜单中选中“打开连接”。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715115143116.png" alt="image-20200715115143116"></p><p>即可显示数据库服务器上的数据库列表，下一步就可以点击相应菜单，显示表内容，或新建查询，执行SQL。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20200715115159230.png" alt="image-20200715115159230" style="zoom:67%;" /></p><p>或者是打开SQL窗口，直接输入SQL语句，选中待执行的语句，快捷键 ctrl+R 执行之。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215007388.png" alt="image-20220808215007388"></p><h1 id="5-数据库操作-💻"><a href="#5-数据库操作-💻" class="headerlink" title="5. 数据库操作 💻"></a>5. 数据库操作 💻</h1><h2 id="脑图-1"><a href="#脑图-1" class="headerlink" title="脑图"></a>脑图</h2><p>对数据库的操作，包括查看当前使用的哪个数据库，使用数据库，查看所有数据库，查看当前时间，查看当前用户，查看数据库版本，查看创建数据库语句，创建数据库，以及删除数据库等围绕着数据库的相关操作<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/db60b1735b6c415bada2f3e672a630c6.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><h2 id="查看当前使用数据库"><a href="#查看当前使用数据库" class="headerlink" title="查看当前使用数据库"></a>查看当前使用数据库</h2><blockquote><p>select database();</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214336940.png" alt="image-20220808214336940"></p><h2 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h2><blockquote><p>show databases;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214408820.png" alt="image-20220808214408820"></p><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><blockquote><p>use 数据库;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214442412.png" alt="image-20220808214442412"></p><h2 id="查看当前时间"><a href="#查看当前时间" class="headerlink" title="查看当前时间"></a>查看当前时间</h2><blockquote><p>select now();</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214504319.png" alt="image-20220808214504319"></p><h2 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h2><blockquote><p>select user();</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214521784.png" alt="image-20220808214521784"></p><h2 id="查看数据库版本"><a href="#查看数据库版本" class="headerlink" title="查看数据库版本"></a>查看数据库版本</h2><blockquote><p>select version();</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214541608.png" alt="image-20220808214541608"></p><h2 id="查看创建数据库信息"><a href="#查看创建数据库信息" class="headerlink" title="查看创建数据库信息"></a>查看创建数据库信息</h2><blockquote><p>show create database 数据库名;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214608277.png" alt="image-20220808214608277"></p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><blockquote><p>create database 数据库名;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214638490.png" alt="image-20220808214638490"></p><h3 id="创建数据库指定utf8编码"><a href="#创建数据库指定utf8编码" class="headerlink" title="创建数据库指定utf8编码"></a>创建数据库指定utf8编码</h3><blockquote><p>create database 数据库名 charset utf8;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214716276.png" alt="image-20220808214716276"></p><h3 id="不存在再创建数据库"><a href="#不存在再创建数据库" class="headerlink" title="不存在再创建数据库"></a>不存在再创建数据库</h3><blockquote><p>create database if not exists 数据库名;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214749880.png" alt="image-20220808214749880"></p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><h3 id="直接删除"><a href="#直接删除" class="headerlink" title="直接删除"></a>直接删除</h3><blockquote><p>drop database 数据库名;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214811779.png" alt="image-20220808214811779"></p><h3 id="判断删除"><a href="#判断删除" class="headerlink" title="判断删除"></a>判断删除</h3><blockquote><p>drop database if exists 数据库名;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808214833859.png" alt="image-20220808214833859"></p><hr><h1 id="6-表操作-❤️"><a href="#6-表操作-❤️" class="headerlink" title="6. 表操作 ❤️"></a>6. 表操作 ❤️</h1><h2 id="脑图-2"><a href="#脑图-2" class="headerlink" title="脑图"></a>脑图</h2><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/b24bfb3f167b4871923e960ee2d47e55.png" alt="在这里插入图片描述" style="zoom: 50%;" /></p><h2 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h2><blockquote><p>show tables;</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215331542.png" alt="image-20220808215331542"></p><h2 id="创建班级表-grade"><a href="#创建班级表-grade" class="headerlink" title="创建班级表 grade"></a>创建班级表 grade</h2><blockquote><p>id 主键<br>grade_name 班名 varchar(100)</p></blockquote><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215421880.png" alt="image-20220808215421880"></p><h2 id="创建学生表-stu，添加外键约束"><a href="#创建学生表-stu，添加外键约束" class="headerlink" title="创建学生表 stu，添加外键约束"></a>创建学生表 stu，添加外键约束</h2><blockquote><p>id 主键<br>name 学生姓名 varchar(100) not null<br>sex 学生性别</p><p>创建数据表 stu ，并在表 stu 上创建外键约束，让它的键 gradeId 作为外键关联到表 grade 的主键 id ，SQL这样写</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY 字段名 [，字段名<span class="number">2</span>，…]</span><br><span class="line"><span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> 主键列<span class="number">1</span> [，主键列<span class="number">2</span>，…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  NAME <span class="type">VARCHAR</span> (<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span> (<span class="number">3</span>),</span><br><span class="line">  bir <span class="type">DATE</span>,</span><br><span class="line">  english <span class="type">INT</span> (<span class="number">3</span>),</span><br><span class="line">  chinese <span class="type">INT</span> (<span class="number">3</span>),</span><br><span class="line">  gradeId <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> fk_stu_grade <span class="keyword">FOREIGN</span> KEY (gradeId) <span class="keyword">REFERENCES</span> grade (id)</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215507063.png" alt="image-20220808215507063"></p><blockquote><p>注意：从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。例如，两者都是 INT 类型，或者都是 CHAR 类型。如果不满足这样的要求，在创建从表时，就会出现“ERROR 1005(HY000): Can’t create table”错误</p></blockquote><h2 id="在修改表时添加外键约束"><a href="#在修改表时添加外键约束" class="headerlink" title="在修改表时添加外键约束"></a>在修改表时添加外键约束</h2><p>假如在创建表时，没有添加外键约束，那么可以在创建表后通过修改表给表添加外键约束，语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>) <span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  NAME <span class="type">VARCHAR</span> (<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span> (<span class="number">3</span>),</span><br><span class="line">  bir <span class="type">DATE</span>,</span><br><span class="line">  english <span class="type">INT</span> (<span class="number">3</span>),</span><br><span class="line">  chinese <span class="type">INT</span> (<span class="number">3</span>),</span><br><span class="line">  gradeId <span class="type">INT</span></span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu </span><br><span class="line">  <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_stu_grage <span class="keyword">FOREIGN</span> KEY (gradeId) <span class="keyword">REFERENCES</span> grade (id) ;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在为已经创建好的数据表添加外键约束时，要确保添加外键约束的列的值全部来源于主键列，并且外键列不能为空。</p></blockquote><h2 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h2><p>通过外键名删除外键，这里演示一下，删除之后会继续添加上的，因为需要这个外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY <span class="operator">&lt;</span>外键约束名<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stu <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_stu_grage;</span><br></pre></td></tr></table></figure><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> stu;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215714373.png" alt="image-20220808215714373"></p><h2 id="显示存储引擎的状态信息"><a href="#显示存储引擎的状态信息" class="headerlink" title="显示存储引擎的状态信息"></a>显示存储引擎的状态信息</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215742635.png" alt="image-20220808215742635"></p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><h3 id="修改表名-rename-to"><a href="#修改表名-rename-to" class="headerlink" title="修改表名 rename to"></a>修改表名 rename to</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stu rename <span class="keyword">to</span> stus;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215925553.png" alt="image-20220808215925553" style="zoom:67%;" /></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808215943762.png" alt="image-20220808215943762"></p><h3 id="添加一列-add"><a href="#添加一列-add" class="headerlink" title="添加一列 add"></a>添加一列 add</h3><blockquote><p>alter table 表名 add 列名 列数据类型;</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stus <span class="keyword">ADD</span> address <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808220119218.png" alt="image-20220808220119218"></p><h3 id="修改数据类型-modify"><a href="#修改数据类型-modify" class="headerlink" title="修改数据类型 modify"></a>修改数据类型 modify</h3><blockquote><p>alter table 表名 modify 列名 新的数据类型;</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stus MODIFY address <span class="type">CHAR</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808220338265.png" alt="image-20220808220338265"></p><h3 id="修改字段位置置顶-first"><a href="#修改字段位置置顶-first" class="headerlink" title="修改字段位置置顶 first"></a>修改字段位置置顶 first</h3><blockquote><p>alter table 表名 modify 字段名 字段属性 first;</p></blockquote><h3 id="修改字段位置再什么之后-after"><a href="#修改字段位置再什么之后-after" class="headerlink" title="修改字段位置再什么之后 after"></a>修改字段位置再什么之后 after</h3><blockquote><p>alter table 表名 modify 字段 字段属性 after 字段;</p></blockquote><h3 id="修改列名和数据类型-change"><a href="#修改列名和数据类型-change" class="headerlink" title="修改列名和数据类型 change"></a>修改列名和数据类型 change</h3><blockquote><p>alter table 表名 change 原列名 新列名 新数据类型;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE stus CHANGE NAME username <span class="title function_">VARCHAR</span><span class="params">(<span class="number">255</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808231152592.png" alt="image-20220808231152592"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808231224294.png" alt="image-20220808231224294" style="zoom:67%;" /></p><h3 id="删除列-drop"><a href="#删除列-drop" class="headerlink" title="删除列 drop"></a>删除列 drop</h3><blockquote><p>alter table 表名 drop 列名;</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stus <span class="keyword">DROP</span> address;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808231414504.png" alt="image-20220808231414504"></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220808231444908.png" alt="image-20220808231444908"></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><h3 id="直接删除-1"><a href="#直接删除-1" class="headerlink" title="直接删除"></a>直接删除</h3><blockquote><p>drop table 表名;</p></blockquote><h3 id="判断存在再删除"><a href="#判断存在再删除" class="headerlink" title="判断存在再删除"></a>判断存在再删除</h3><blockquote><p>drop table if exists 表名;</p></blockquote><h1 id="7-结构化查询语言SQL📌"><a href="#7-结构化查询语言SQL📌" class="headerlink" title="7. 结构化查询语言SQL📌"></a>7. 结构化查询语言SQL📌</h1><h2 id="SQL的概念"><a href="#SQL的概念" class="headerlink" title="SQL的概念"></a>SQL的概念</h2><h3 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h3><p>​    结构化查询语言(Structured Query Language)简称SQL,SQL语句就是对数据库进行操作的一种语言。</p><h3 id="SQL作用"><a href="#SQL作用" class="headerlink" title="SQL作用"></a>SQL作用</h3><p>​    通过SQL语句我们可以方便的操作数据库中的数据、表、数据库。<br>​    SQL是数据库管理系统都需要遵循的规范。不同的数据库生产厂商都支持SQL语句，但都有特有内容。<br><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/SQL%E8%A7%84%E8%8C%83.png" alt="SQL规范"></p><h3 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h3><ol><li><p>DDL(Data Definition Language)数据定义语言<br>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter等</p></li><li><p>DML(Data Manipulation Language)数据操作语言<br>用来对数据库中表的数据进行增删改。关键字：insert, delete, update等</p></li><li><p>DQL(Data Query Language) 数据查询语言 (掌握)</p><p>DQL语言并不是属于MYSQL官方的分类，但是对数据库的操作最多就是查询，所以把查询语句的语句称作为DQL语言</p></li><li><p>DCL(Data Control Language)数据控制语言(了解)</p><p>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE等</p></li><li><p>TCL(Transaction Control Language) 事务控制语言或TPL事务处理语言</p><p>用于控制数据库的事务操作，关键字; COMMIT，SAVEPOINT，ROLLBACK等</p></li><li><p>CCL（Cursor Control Language）指针控制语言（了解）</p><p>像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。多用于存储过程中对结果集的处理。</p></li></ol><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ol><li><p>SQL语句可以单行或多行书写，以分号结尾。</p></li><li><p>可使用空格和缩进来增强语句的可读性。</p></li><li><p>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure></li><li><p>3种注释<br>单行注释: — 注释内容 或 # 注释内容(mysql特有)<br>多行注释: /<em> 注释 </em>/</p></li></ol><h2 id="延展阅读"><a href="#延展阅读" class="headerlink" title="延展阅读"></a>延展阅读</h2><p>SQL标准简介</p><p>　　SQL是Structured Query Language的缩写，它的前身是著名的关系数据库原型系统System R所采用的SEQUEL语言。作为一种访问关系型数据库的标准语言，SQL自问世以来得到了广泛的应用，不仅是著名的大型商用数据库产品Oracle、DB2、Sybase、SQL Server支持它，很多开源的数据库产品如PostgreSQL、MySQL也支持它，甚至一些小型的产品如Access也支持SQL。近些年蓬勃发展的NoSQL系统最初是宣称不再需要SQL的，后来也不得不修正为Not Only SQL，来拥抱SQL。</p><p>　　蓝色巨人IBM对关系数据库以及SQL语言的形成和规范化产生了重大的影响，第一个版本的SQL标准SQL86就是基于System R的手册而来的。Oracle在1979年率先推出了支持SQL的商用产品。随着数据库技术和应用的发展，为不同RDBMS提供一致的语言成了一种现实需要。</p><p>　　对SQL标准影响最大的机构自然是那些著名的数据库产商，而具体的制订者则是一些非营利机构，例如国际标准化组织ISO、美国国家标准委员会ANSI等。各国通常会按照 ISO标准和ANSI标准（这两个机构的很多标准是差不多等同的）制定自己的国家标准。中国是ISO标准委员会的成员国，也经常翻译一些国际标准对应的中文版。标准为了避免采用具体产品的术语，往往会抽象出很多名词，从而增加了阅读和理解的难度，翻译成中文之后更容易词不达意。对于数据库系统实现者和用户而言，很多时候还不如直接读英文版本为好。虽然正式的标准不像RFC那样可以从网络上免费获得，标准草案还是比较容易找到的（例如：<a href="http://www.jtc1sc32.org/doc/）。待批准的标准草案和最终的标准也没有什么实质上的区别，能够满足日常工作的需要。">http://www.jtc1sc32.org/doc/）。待批准的标准草案和最终的标准也没有什么实质上的区别，能够满足日常工作的需要。</a></p><p>　　下面是SQL发展的简要历史：<br>1986年，ANSI X3.135-1986，ISO/IEC 9075:1986，SQL-86<br>1989年，ANSI X3.135-1989，ISO/IEC 9075:1989，SQL-89<br>1992年，ANSI X3.135-1992，ISO/IEC 9075:1992，SQL-92（SQL2）<br>1999年，ISO/IEC 9075:1999，SQL:1999（SQL3）<br>2003年，ISO/IEC 9075:2003，SQL:2003<br>2008年，ISO/IEC 9075:2008，SQL:2008<br>2011年，ISO/IEC 9075:2011，SQL:2011</p><p>　　细心的读者能发现，从SQL:1999开始，标准简称中的短横线（-）被换成了冒号（:），而且标准制定的年份也改用四位数字了。前一个修改的原因是ISO标准习惯上采用冒号，ANSI标准则一直采用短横线。后一个修改的原因是标准的命名也遇到了2000年问题。</p><p>　　SQL86大概只有几十页，SQL92正文大约有500页，而SQL99则超过了1000页。可以看出，从SQL99开始，SQL标准的个头就非常庞大了，内容包罗万象，已经没有人能够掌握标准的所有内容了。以SQL:2003为例，它包括以下9个部分（中间编号空缺是曾经被占用，之后被废弃的标准造成的）：</p><p>ISO/IEC9075-1: Framework (SQL/Framework)<br>ISO/IEC 9075-2: Foundation (SQL/Foundation)<br>ISO/IEC 9075-3: Call Level Interface (SQL/CLI)<br>ISO/IEC 9075-4: Persistent Stored Modules (SQL/PSM)<br>ISO/IEC 9075-9: Management of External Data (SQL/MED)<br>ISO/IEC 9075-10: Object Language Bindings (SQL/OLB)<br>ISO/IEC 9075-11: Information and Definition Schemas (SQL/Schemata)<br>ISO/IEC 9075-13: Java Routines and Types Using the Java Programming Language(SQL/JRT)<br>ISO/IEC 9075-14: XML-Related Specifications (SQL/XML)</p><p>负责具体制定工作的是ISO和IEC联合成立的一个技术委员会JTC1/SC32。正因为关系数据库市场非常成熟，竞争不够激烈，标准本身变得过于庞大等原因，SQL3制定的周期很长，制定期间也存在很多争议。例如文章《Is SQL a Real Standard Anymore?》对SQL标准化进程提出了置疑。</p><p>　　如果要了解标准的内容，比较推荐的方法是泛读SQL92（因为它涉及了SQL最基础和最核心的一些内容），然后增量式的阅读其他标准。标准在每次更新的时候，委员会的成员们都为大家提供比较好的介绍文档。例如针对最新的SQL:2011，SIGMODRecord上就有很不错的介绍：<a href="http://www.sigmod.org/publications/sigmod-record/1203/pdfs/10.industry.zemke.pdf">http://www.sigmod.org/publications/sigmod-record/1203/pdfs/10.industry.zemke.pdf</a></p><p>　　最后再简要介绍一下SQL标准的符合程度。绝大多数人提起SQL标准，涉及的内容其实是SQL92里头最基本或者说最核心的一部分。SQL92本身是分级的，包括入门级、过度级、中间级和完全级。为了验证具体的产品对标准的遵从程度，NIST还曾经专门发起了一个项目，来做标准符合程度的测试集合：<a href="http://itl.nist.gov/div897/ctg/sql_form.htm。不过，SQL标准包含的内容实在太多了，而且有很多特性对新的SQL产品而言也越来越不重要了。从SQL99之后，标准中符合程度的定义就不再分级，而是改成了核心兼容性和特性兼容性；也没有机构来推出权威的SQL标准符合程度的测试认证了。">http://itl.nist.gov/div897/ctg/sql_form.htm。不过，SQL标准包含的内容实在太多了，而且有很多特性对新的SQL产品而言也越来越不重要了。从SQL99之后，标准中符合程度的定义就不再分级，而是改成了核心兼容性和特性兼容性；也没有机构来推出权威的SQL标准符合程度的测试认证了。</a></p><h1 id="8-用户管理与权限管理🗓️"><a href="#8-用户管理与权限管理🗓️" class="headerlink" title="8. 用户管理与权限管理🗓️"></a>8. 用户管理与权限管理🗓️</h1><p>用户是我们使用数据库的基础，任何连入数据库的操作，都依托于一个用户，并受到这个用户所具有权限的限制。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,authentication_string <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><p>mysql是MySQL数据库中的系统库，所有用户、权限、密码、时区等信息都存放在这个库里。</p><p>库名.表名的方式可以让我们跨库来引用某个特定库的表。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7.png" alt="img"></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>语法：<strong>create user “username”@”host” identified by “password”;</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;192.168.7.22&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><p>host的含义是限制访问的客户端的主机IP，%表示无限制。</p><p>语句中的单引号表示字符串，在这里也可以使用双引号，用户名可以不用引号。</p><p>密码设置串可以不带，但是带了密码，就必须带引号。</p><h3 id="设置用户密码"><a href="#设置用户密码" class="headerlink" title="设置用户密码"></a>设置用户密码</h3><p><strong>方法1：用alter修改用户密码</strong><br>首先需要以root身份登录MySQL。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;bbb&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;456&#x27;</span>;</span><br><span class="line">flush privileges; </span><br></pre></td></tr></table></figure><p><strong>方法2：用mysqladmin</strong><br>格式：mysqladmin -u用户名 -p旧密码 password 新密码 </p><p>此语句需用在命令行下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="literal">-uroot</span> <span class="literal">-p123456</span> password <span class="number">123</span> </span><br></pre></td></tr></table></figure><p><strong>方法3：忘记root密码，需要重置root密码</strong></p><p>1、首先停止mysql服务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure><p>2、以管理员身份启动命令行，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld <span class="comment">--skip-grant-tables --shared-memory</span></span><br></pre></td></tr></table></figure><p>这时以忽略密码模式启动了mysql，不要关闭此cmd窗口。</p><p>3、再开一屏cmd窗口<br>用mysql直接登录，不输入用户和密码</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/%E9%87%8D%E7%BD%AEroot%E5%AF%86%E7%A0%81.png" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_psd_123&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>完成后此屏可以退出。<br>前一屏，先ctrl+C强制退出mysqld，再用net start mysql<br>最后尝试一下root的新密码登录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>pnew_psd_123</span><br></pre></td></tr></table></figure><h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;zs&#x27;</span> @<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;456&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p>语法：drop user 用户名@主机名；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> zhangsan@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表的相应记录都消失了。</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h3><p>初始创建的用户，还不能访问数据库，因为还没有给用户赋予相应权限，需要执行用户授权操作。</p><p>命令格式：grant 权限码 on 数据库名.表名 to 用户名@主机名 identified by “password”;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> dbname.<span class="operator">*</span> <span class="keyword">to</span> zhrt<span class="variable">@localhost</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>设置密码的子串可写可不写</p><p>权限码表示授予的权限类型，常用的有以下几种类型：</p><ul><li>all ：所有权限。</li><li>select：读取权限。</li><li>delete：删除权限。</li><li>update：更新权限。</li><li>create：创建权限。</li><li>drop：删除数据库、数据表权限。</li></ul><h3 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h3><p>语法：show grants for 用户名@主机名; </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;bbb&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="取消用户授权"><a href="#取消用户授权" class="headerlink" title="取消用户授权"></a>取消用户授权</h3><p>语法：REVOKE 权限码 ON 库名.表名 FROM 用户名@主机名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">all</span> <span class="keyword">ON</span> power.<span class="operator">*</span> <span class="keyword">FROM</span> bbb<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java第二阶段-day01-MySQL入门&quot;&gt;&lt;a href=&quot;#Java第二阶段-day01-MySQL入门&quot; class=&quot;headerlink&quot; title=&quot;Java第二阶段_day01_MySQL入门&quot;&gt;&lt;/a&gt;Java第二阶段_day01_MySQL</summary>
      
    
    
    
    <category term="MySQL" scheme="https://manamn.space/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://manamn.space/tags/MySQL/"/>
    
    <category term="百里半Java培训" scheme="https://manamn.space/tags/%E7%99%BE%E9%87%8C%E5%8D%8AJava%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>第17章 Java8新特性</title>
    <link href="https://manamn.space/2022/07/28/SGG_JavaSE/%E7%AC%AC17%E7%AB%A0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://manamn.space/2022/07/28/SGG_JavaSE/%E7%AC%AC17%E7%AB%A0-Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-28T05:08:53.000Z</published>
    <updated>2022-10-16T13:46:51.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第17章-Java8新特性"><a href="#第17章-Java8新特性" class="headerlink" title="第17章 Java8新特性"></a>第17章 Java8新特性</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li>Lambda表达式</li><li>StreamAPI</li><li>Optional</li></ul><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>[ ] 能够理解函数式编程相对于面向对象的优点</li><li>[ ] 能够掌握Lambda表达式的标准格式</li><li>[ ] 能够使用Lambda标准格式</li><li>[ ] 能够掌握Lambda表达式的省略格式与规则</li><li>[ ] 能够通过Lambda使用自定义的接口（有且仅有一个抽象方法）</li><li>[ ] 能够使用@FunctionalInterface注解</li><li>[ ] 能够使用Supplier函数式接口</li><li>[ ] 能够使用Consumer函数式接口</li><li>[ ] 能够使用Function函数式接口</li><li>[ ] 能够使用Predicate函数式接口</li><li>[ ] 能够使用方法引用和构造器引用</li><li>[ ] 能够理解流与集合相比的优点</li><li>[ ] 能够理解流的延迟执行特点</li><li>[ ] 能够通过集合、映射或数组获取流</li><li>[ ] 能够掌握常用的流操作</li><li>[ ] 能够使用Optional类包装对象并获取其中包装的对象</li></ul><h1 id="第17章-Java8新特性-1"><a href="#第17章-Java8新特性-1" class="headerlink" title="第17章 Java8新特性"></a>第17章 Java8新特性</h1><p>Java8的新特征有很多，之前我们在学习接口时，学习了接口的静态方法和默认方法，在学习常用类时，学习了新版的日期时间API。今天我们来学习Java8最具革命性的两个新特性：Lambda表达式和StreamAPI。然后带领大家用Optioanl类解决最令人头疼的空指针异常。</p><h2 id="17-1-Lambda表达式"><a href="#17-1-Lambda表达式" class="headerlink" title="17.1 Lambda表达式"></a>17.1 Lambda表达式</h2><h3 id="17-1-1-函数式编程思想"><a href="#17-1-1-函数式编程思想" class="headerlink" title="17.1.1 函数式编程思想"></a>17.1.1 函数式编程思想</h3><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/03-Overview.png" alt=""></p><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。编程中的函数，也有类似的概念，你调用我的时候，给我实参为形参赋值，然后通过运行方法体，给你返回一个结果。对于调用者来做，关注这个方法具备什么样的功能。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><ul><li><p>面向对象的思想:</p><ul><li>做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</li></ul></li><li><p>函数式编程思想:</p><ul><li>只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</li></ul></li></ul><p>Java8引入了Lambda表达式之后，Java也开始支持函数式编程。</p><p>Lambda表达式不是Java最早使用的，很多语言就支持Lambda表达式，例如：C++，C#，Python，Scala等。如果有Python或者Javascript的语言基础，对理解Lambda表达式有很大帮助，可以这么说lambda表达式其实就是实现SAM接口的语法糖，使得Java也算是支持函数式编程的语言。Lambda<strong>写的好</strong>可以极大的减少代码冗余，同时可读性也好过冗长的匿名内部类。</p><blockquote><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实<br>底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部<br>类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><h4 id="冗余的匿名内部类"><a href="#冗余的匿名内部类" class="headerlink" title="冗余的匿名内部类"></a>冗余的匿名内部类</h4><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Runnable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 匿名内部类</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p><p><strong>代码分析：</strong></p><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h4 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h4><p><strong>做什么，而不是谁来做，怎么做</strong></p><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><p><strong>生活举例：</strong></p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/01-%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F.png" alt=""></p><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/02-Lambda.png" alt=""></p><p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p><h4 id="体验Lambda的更优写法"><a href="#体验Lambda的更优写法" class="headerlink" title="体验Lambda的更优写法"></a>体验Lambda的更优写法</h4><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02LambdaRunnable</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h3 id="17-1-2-函数式接口"><a href="#17-1-2-函数式接口" class="headerlink" title="17.1.2 函数式接口"></a>17.1.2 函数式接口</h3><p>lambda表达式其实就是实现SAM接口的语法糖，所谓SAM接口就是Single Abstract Method，即该接口中只有一个抽象方法需要实现，当然该接口可以包含其他非抽象方法。</p><p>其实只要满足“SAM”特征的接口都可以称为函数式接口，都可以使用Lambda表达式，但是如果要更明确一点，最好在声明接口时，加上@FunctionalInterface。一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。</p><p>之前学过的SAM接口中，标记了@FunctionalInterface的函数式接口的有：Runnable，Comparator，FileFilter。</p><p>Java8在java.util.function新增了很多函数式接口：主要分为四大类，消费型、供给型、判断型、功能型。基本可以满足我们的开发需求。当然你也可以定义自己的函数式接口。</p><h4 id="1、自定义函数式接口"><a href="#1、自定义函数式接口" class="headerlink" title="1、自定义函数式接口"></a>1、自定义函数式接口</h4><p>只要确保接口中有且仅有一个抽象方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口当中抽象方法的 public abstract 是可以省略的</p></blockquote><p>例如：声明一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以对两个int数字进行计算，并返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中，声明一个如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.calc(a, b);</span><br><span class="line">    System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">invokeCalc(<span class="number">1</span>, <span class="number">2</span>, (<span class="type">int</span> a,<span class="type">int</span> b)-&gt; &#123;<span class="keyword">return</span> a+b;&#125;);</span><br><span class="line">invokeCalc(<span class="number">1</span>, <span class="number">2</span>, (<span class="type">int</span> a,<span class="type">int</span> b)-&gt; &#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">invokeCalc(<span class="number">1</span>, <span class="number">2</span>, (<span class="type">int</span> a,<span class="type">int</span> b)-&gt; &#123;<span class="keyword">return</span> a*b;&#125;);</span><br><span class="line">invokeCalc(<span class="number">1</span>, <span class="number">2</span>, (<span class="type">int</span> a,<span class="type">int</span> b)-&gt; &#123;<span class="keyword">return</span> a/b;&#125;);</span><br><span class="line">invokeCalc(<span class="number">1</span>, <span class="number">2</span>, (<span class="type">int</span> a,<span class="type">int</span> b)-&gt; &#123;<span class="keyword">return</span> a%b;&#125;);</span><br><span class="line">invokeCalc(<span class="number">1</span>, <span class="number">2</span>, (<span class="type">int</span> a,<span class="type">int</span> b)-&gt; &#123;<span class="keyword">return</span> a&gt;b?a:b;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、消费型接口"><a href="#2、消费型接口" class="headerlink" title="2、消费型接口"></a><strong>2、消费型接口</strong></h4><p>消费型接口的抽象方法特点：有形参，但是返回值类型是void</p><div class="table-container"><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Consumer<T></td><td>void accept(T t)</td><td>接收一个对象用于完成功能</td></tr><tr><td>BiConsumer<T,U></td><td>void accept(T t, U u)</td><td>接收两个对象用于完成功能</td></tr><tr><td>DoubleConsumer</td><td>void accept(double value)</td><td>接收一个double值</td></tr><tr><td>IntConsumer</td><td>void accept(int value)</td><td>接收一个int值</td></tr><tr><td>LongConsumer</td><td>void accept(long value)</td><td>接收一个long值</td></tr><tr><td>ObjDoubleConsumer<T></td><td>void accept(T t, double value)</td><td>接收一个对象和一个double值</td></tr><tr><td>ObjIntConsumer<T></td><td>void accept(T t, int value)</td><td>接收一个对象和一个int值</td></tr><tr><td>ObjLongConsumer<T></td><td>void accept(T t, long value)</td><td>接收一个对象和一个long值</td></tr></tbody></table></div><h4 id="3、供给型接口"><a href="#3、供给型接口" class="headerlink" title="3、供给型接口"></a><strong>3、供给型接口</strong></h4><p>这类接口的抽象方法特点：无参，但是无返回值</p><div class="table-container"><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Supplier<T></td><td>T get()</td><td>返回一个对象</td></tr><tr><td>BooleanSupplier</td><td>boolean getAsBoolean()</td><td>返回一个boolean值</td></tr><tr><td>DoubleSupplier</td><td>double getAsDouble()</td><td>返回一个double值</td></tr><tr><td>IntSupplier</td><td>int getAsInt()</td><td>返回一个int值</td></tr><tr><td>LongSupplier</td><td>long getAsLong()</td><td>返回一个long值</td></tr></tbody></table></div><h4 id="4、判断型接口"><a href="#4、判断型接口" class="headerlink" title="4、判断型接口"></a><strong>4、判断型接口</strong></h4><p>这里接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p><div class="table-container"><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Predicate<T></td><td>boolean test(T t)</td><td>接收一个对象</td></tr><tr><td>BiPredicate<T,U></td><td>boolean test(T t, U u)</td><td>接收两个对象</td></tr><tr><td>DoublePredicate</td><td>boolean test(double value)</td><td>接收一个double值</td></tr><tr><td>IntPredicate</td><td>boolean test(int value)</td><td>接收一个int值</td></tr><tr><td>LongPredicate</td><td>boolean test(long value)</td><td>接收一个long值</td></tr></tbody></table></div><h4 id="5、功能型接口"><a href="#5、功能型接口" class="headerlink" title="5、功能型接口"></a><strong>5、功能型接口</strong></h4><p>这类接口的抽象方法特点：既有参数又有返回值</p><div class="table-container"><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Function<T,R></td><td>R apply(T t)</td><td>接收一个T类型对象，返回一个R类型对象结果</td></tr><tr><td>UnaryOperator<T></td><td>T apply(T t)</td><td>接收一个T类型对象，返回一个T类型对象结果</td></tr><tr><td>DoubleFunction<R></td><td>R apply(double value)</td><td>接收一个double值，返回一个R类型对象</td></tr><tr><td>IntFunction<R></td><td>R apply(int value)</td><td>接收一个int值，返回一个R类型对象</td></tr><tr><td>LongFunction<R></td><td>R apply(long value)</td><td>接收一个long值，返回一个R类型对象</td></tr><tr><td>ToDoubleFunction<T></td><td>double applyAsDouble(T value)</td><td>接收一个T类型对象，返回一个double</td></tr><tr><td>ToIntFunction<T></td><td>int applyAsInt(T value)</td><td>接收一个T类型对象，返回一个int</td></tr><tr><td>ToLongFunction<T></td><td>long applyAsLong(T value)</td><td>接收一个T类型对象，返回一个long</td></tr><tr><td>DoubleToIntFunction</td><td>int applyAsInt(double value)</td><td>接收一个double值，返回一个int结果</td></tr><tr><td>DoubleToLongFunction</td><td>long applyAsLong(double value)</td><td>接收一个double值，返回一个long结果</td></tr><tr><td>IntToDoubleFunction</td><td>double applyAsDouble(int value)</td><td>接收一个int值，返回一个double结果</td></tr><tr><td>IntToLongFunction</td><td>long applyAsLong(int value)</td><td>接收一个int值，返回一个long结果</td></tr><tr><td>LongToDoubleFunction</td><td>double applyAsDouble(long value)</td><td>接收一个long值，返回一个double结果</td></tr><tr><td>LongToIntFunction</td><td>int applyAsInt(long value)</td><td>接收一个long值，返回一个int结果</td></tr><tr><td>DoubleUnaryOperator</td><td>double applyAsDouble(double operand)</td><td>接收一个double值，返回一个double</td></tr><tr><td>IntUnaryOperator</td><td>int applyAsInt(int operand)</td><td>接收一个int值，返回一个int结果</td></tr><tr><td>LongUnaryOperator</td><td>long applyAsLong(long operand)</td><td>接收一个long值，返回一个long结果</td></tr><tr><td></td><td></td><td></td></tr><tr><td>BiFunction<T,U,R></td><td>R apply(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td></tr><tr><td>BinaryOperator<T></td><td>T apply(T t, T u)</td><td>接收两个T类型对象，返回一个T类型对象结果</td></tr><tr><td>ToDoubleBiFunction<T,U></td><td>double applyAsDouble(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个double</td></tr><tr><td>ToIntBiFunction<T,U></td><td>int applyAsInt(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个int</td></tr><tr><td>ToLongBiFunction<T,U></td><td>long applyAsLong(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个long</td></tr><tr><td>DoubleBinaryOperator</td><td>double applyAsDouble(double left, double right)</td><td>接收两个double值，返回一个double结果</td></tr><tr><td>IntBinaryOperator</td><td>int applyAsInt(int left, int right)</td><td>接收两个int值，返回一个int结果</td></tr><tr><td>LongBinaryOperator</td><td>long applyAsLong(long left, long right)</td><td>接收两个long值，返回一个long结果</td></tr></tbody></table></div><h3 id="17-1-3-Lambda表达式语法"><a href="#17-1-3-Lambda表达式语法" class="headerlink" title="17.1.3 Lambda表达式语法"></a>17.1.3 Lambda表达式语法</h3><p>Lambda表达式是用来给【函数式接口】的变量或形参赋值用的。</p><p>其实本质上，Lambda表达式是用于实现【函数式接口】的“抽象方法”</p><p>Lambda表达式语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形参列表) -&gt; &#123;Lambda体&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>(形参列表)它就是你要赋值的函数式接口的抽象方法的(形参列表)，照抄</li><li>{Lambda体}就是实现这个抽象方法的方法体</li><li>-&gt;称为Lambda操作符（减号和大于号中间不能有空格，而且必须是英文状态下半角输入方式）</li></ul><p>优化：Lambda表达式可以精简</p><ul><li>当{Lambda体}中只有一句语句时，可以省略{}和{;}</li><li>当{Lambda体}中只有一句语句时，并且这个语句还是一个return语句，那么return也可以省略，但是如果{;}没有省略的话，return是不能省略的</li><li>(形参列表)的类型可以省略</li><li>当(形参列表)的形参个数只有一个，那么可以把数据类型和()一起省略，但是形参名不能省略</li><li>当(形参列表)是空参时，()不能省略</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambdaGrammer</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//用Lambda表达式给Runnable接口的形参或变量赋值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确定两件事，才能写好lambda表达式</span></span><br><span class="line"><span class="comment"> * （1）这个接口的抽象方法长什么样：</span></span><br><span class="line"><span class="comment"> * public void run()</span></span><br><span class="line"><span class="comment"> * （2）这个抽象方法的实现要干什么事</span></span><br><span class="line"><span class="comment"> * 例如：我要打印“hello lambda&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;System.out.println(<span class="string">&quot;hello lambda&quot;</span>);&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//lambda体省略了&#123;;&#125;</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;hello lambda&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;chai&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为arr数组排序，但是，想要不区分大小写</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static &lt;T&gt; void sort(T[] a,Comparator&lt;? super T&gt; c)</span></span><br><span class="line"><span class="comment"> * 这里要用Lambda表达式为Comparator类型的形参赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 两件事：</span></span><br><span class="line"><span class="comment"> * （1）这个接口的抽象方法：  int compare(T o1, T o2)</span></span><br><span class="line"><span class="comment"> * （2）这个抽象方法要做什么事？</span></span><br><span class="line"><span class="comment"> * 例如：这里要对String类型的元素，不区分大小写的比较大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Arrays.sort(arr, (String o1, String o2) -&gt; &#123;return o1.compareToIgnoreCase(o2);&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略了&#123;return ;&#125;</span></span><br><span class="line"><span class="comment">//Arrays.sort(arr, (String o1, String o2) -&gt;  o1.compareToIgnoreCase(o2));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略了两个String</span></span><br><span class="line">Arrays.sort(arr, (o1, o2) -&gt;  o1.compareToIgnoreCase(o2));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String string : arr) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JDK1.8给Collection系列的集合，准确的讲是在Iterable接口中，增加了一个默认方法</span></span><br><span class="line"><span class="comment"> * default void forEach(Consumer&lt;? super T&gt; action) </span></span><br><span class="line"><span class="comment"> * 这个方法是用来遍历集合等的。代替原来的foreach循环的。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个方法的形参是Consumer接口类型，它是函数式接口中消费型接口的代表</span></span><br><span class="line"><span class="comment"> * 我现在调用这个方法，想要用Lambda表达式为Consumer接口类型形参赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 两件事：</span></span><br><span class="line"><span class="comment"> * （1）它的抽象方法：  void  accept(T t)</span></span><br><span class="line"><span class="comment"> * （2）抽象方法的实现要完成的事是什么</span></span><br><span class="line"><span class="comment"> * 例如：这里要打印这个t</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//list.forEach((String t) -&gt; &#123;System.out.println(t);&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略&#123;;&#125;</span></span><br><span class="line"><span class="comment">//list.forEach((String t) -&gt; System.out.println(t));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略String</span></span><br><span class="line"><span class="comment">//list.forEach((t) -&gt; System.out.println(t));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以省略形参()</span></span><br><span class="line">list.forEach(t -&gt; System.out.println(t));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-1-4-Lambda表达式练习"><a href="#17-1-4-Lambda表达式练习" class="headerlink" title="17.1.4 Lambda表达式练习"></a>17.1.4 Lambda表达式练习</h3><h4 id="练习1：无参无返回值形式"><a href="#练习1：无参无返回值形式" class="headerlink" title="练习1：无参无返回值形式"></a>练习1：无参无返回值形式</h4><p>假如有自定义函数式接口Call如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中声明一个如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">callSomething</span><span class="params">(Call call)</span>&#123;</span><br><span class="line">call.shout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类的main方法中调用callSomething方法，并用Lambda表达式为形参call赋值，可以喊出任意你想说的话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">callSomething(()-&gt;System.out.println(<span class="string">&quot;回家吃饭&quot;</span>));</span><br><span class="line">callSomething(()-&gt;System.out.println(<span class="string">&quot;我爱你&quot;</span>));</span><br><span class="line">callSomething(()-&gt;System.out.println(<span class="string">&quot;滚蛋&quot;</span>));</span><br><span class="line">callSomething(()-&gt;System.out.println(<span class="string">&quot;回来&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">callSomething</span><span class="params">(Call call)</span>&#123;</span><br><span class="line">call.shout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Call</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2：消费型接口"><a href="#练习2：消费型接口" class="headerlink" title="练习2：消费型接口"></a>练习2：消费型接口</h4><p>代码示例：Consumer<T>接口</p><p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p><p><code>public default void forEach(Consumer&lt;? super T&gt; action)</code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p><p>在JDK1.8中Map集合接口中增加了一个默认方法：</p><p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p><p>案例：</p><p>（1）创建一个Collection系列的集合，添加你知道的编程语言，调用forEach方法遍历查看</p><p>（2）创建一个Map系列的集合，添加一些(key,value)键值对，例如，添加编程语言排名和语言名称，调用forEach方法遍历查看</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564370820279.png" alt="1564370820279"></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;python&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;VB&quot;</span>,<span class="string">&quot;C#&quot;</span>);</span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;python&quot;</span>);</span><br><span class="line">map.put(<span class="number">4</span>, <span class="string">&quot;c++&quot;</span>);</span><br><span class="line">       map.put(<span class="number">5</span>, <span class="string">&quot;VB&quot;</span>);</span><br><span class="line">       map.put(<span class="number">6</span>, <span class="string">&quot;C#&quot;</span>);</span><br><span class="line">map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;-&gt;&quot;</span>+v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3：供给型接口"><a href="#练习3：供给型接口" class="headerlink" title="练习3：供给型接口"></a>练习3：供给型接口</h4><p>代码示例：Supplier<T>接口</p><p>在JDK1.8中增加了StreamAPI，java.util.stream.Stream<T>是一个数据流。这个类型有一个静态方法：</p><p><code>public static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code>可以创建Stream的对象。而又包含一个forEach方法可以遍历流中的元素：<code>public void forEach(Consumer&lt;? super T&gt; action)</code>。</p><p>案例：</p><p>现在请调用Stream的generate方法，来产生一个流对象，并调用Math.random()方法来产生数据，为Supplier函数式接口的形参赋值。最后调用forEach方法遍历流中的数据查看结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.generate(() -&gt; Math.random()).forEach(num -&gt; System.out.println(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习4：功能型接口"><a href="#练习4：功能型接口" class="headerlink" title="练习4：功能型接口"></a>练习4：功能型接口</h4><p>代码示例：Funtion<T,R>接口</p><p>在JDK1.8时Map接口增加了很多方法，例如：</p><p><code>public default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>按照function指定的操作替换map中的value。</p><p><code>public default void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>遍历Map集合的每对映射关系，执行“xxx消费型”操作。</p><p>案例：</p><p>（1）声明一个Employee员工类型，包含编号、姓名、薪资。</p><p>（2）添加n个员工对象到一个HashMap<Integer,Employee>集合中，其中员工编号为key，员工对象为value。</p><p>（3）调用Map的forEach遍历集合</p><p>（4）调用Map的replaceAll方法，将其中薪资低于10000元的，薪资设置为10000。</p><p>（5）再次调用Map的forEach遍历集合查看结果</p><p>Employee类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, salary=&quot;</span> + salary + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">HashMap&lt;Integer,Employee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">8000</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">9000</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">11000</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">5</span>, <span class="string">&quot;钱七&quot;</span>, <span class="number">12000</span>);</span><br><span class="line"></span><br><span class="line">map.put(e1.getId(), e1);</span><br><span class="line">map.put(e2.getId(), e2);</span><br><span class="line">map.put(e3.getId(), e3);</span><br><span class="line">map.put(e4.getId(), e4);</span><br><span class="line">map.put(e5.getId(), e5);</span><br><span class="line"></span><br><span class="line">map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">map.replaceAll((k,v)-&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(v.getSalary()&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">v.setSalary(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((k,v) -&gt; System.out.println(k+<span class="string">&quot;=&quot;</span>+v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习5：判断型接口"><a href="#练习5：判断型接口" class="headerlink" title="练习5：判断型接口"></a>练习5：判断型接口</h4><p>代码示例：Predicate<T>接口</p><p>JDK1.8时，Collecton<E>接口增加了一下方法，其中一个如下：</p><p><code>public default boolean removeIf(Predicate&lt;? super E&gt; filter)</code> 用于删除集合中满足filter指定的条件判断的。</p><p><code>public default void forEach(Consumer&lt;? super T&gt; action)</code>遍历Collection集合的每个元素，执行“xxx消费型”操作。</p><p>案例：</p><p>（1）添加一些字符串到一个Collection集合中</p><p>（2）调用forEach遍历集合</p><p>（3）调用removeIf方法，删除其中字符串的长度&lt;5的</p><p>（4）再次调用forEach遍历集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"></span><br><span class="line">list.forEach(str-&gt;System.out.println(str));</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">list.removeIf(str-&gt;str.length()&lt;<span class="number">5</span>);</span><br><span class="line">list.forEach(str-&gt;System.out.println(str));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习6：判断型接口"><a href="#练习6：判断型接口" class="headerlink" title="练习6：判断型接口"></a>练习6：判断型接口</h4><p>案例：</p><p>（1）声明一个Employee员工类型，包含编号、姓名、性别，年龄，薪资。</p><p>（2）声明一个EmployeeSerice员工管理类，包含一个ArrayList<Employee>集合的属性all，在EmployeeSerice的构造器中，创建一些员工对象，为all集合初始化。</p><p>（3）在EmployeeSerice员工管理类中，声明一个方法：ArrayList<Employee> get(Predicate<Employee> p)，即将满足p指定的条件的员工，添加到一个新的ArrayList<Employee> 集合中返回。</p><p>（4）在测试类中创建EmployeeSerice员工管理类的对象，并调用get方法，分别获取：</p><ul><li>所有员工对象</li><li>所有年龄超过35的员工</li><li>所有薪资高于15000的女员工</li><li>所有编号是偶数的员工</li><li>名字是“张三”的员工</li><li>年龄超过25，薪资低于10000的男员工</li></ul><p>示例代码：</p><p>Employee类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">char</span> gender, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.gender = gender;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line"><span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, gender=&quot;</span> + gender + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;, salary=&quot;</span> + salary</span><br><span class="line">+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>员工管理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeService</span>&#123;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Employee&gt; all;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">EmployeeService</span><span class="params">()</span>&#123;</span><br><span class="line">all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line">all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">33</span>, <span class="number">8000</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">2</span>, <span class="string">&quot;翠花&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">23</span>, <span class="number">18000</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">3</span>, <span class="string">&quot;无能&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">46</span>, <span class="number">8000</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">4</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">23</span>, <span class="number">9000</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">5</span>, <span class="string">&quot;老王&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">15000</span>));</span><br><span class="line">all.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">6</span>, <span class="string">&quot;大嘴&quot;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">11000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Employee&gt; <span class="title function_">get</span><span class="params">(Predicate&lt;Employee&gt; p)</span>&#123;</span><br><span class="line">ArrayList&lt;Employee&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br><span class="line"><span class="keyword">for</span> (Employee emp : all) &#123;</span><br><span class="line"><span class="keyword">if</span>(p.test(emp))&#123;</span><br><span class="line">result.add(emp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">EmployeeService</span> <span class="variable">es</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeService</span>();</span><br><span class="line"></span><br><span class="line">es.get(e -&gt; <span class="literal">true</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">System.out.println();</span><br><span class="line">es.get(e -&gt; e.getAge()&gt;<span class="number">35</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">System.out.println();</span><br><span class="line">es.get(e -&gt; e.getSalary()&gt;<span class="number">15000</span> &amp;&amp; e.getGender()==<span class="string">&#x27;女&#x27;</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">System.out.println();</span><br><span class="line">es.get(e -&gt; e.getId()%<span class="number">2</span>==<span class="number">0</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">System.out.println();</span><br><span class="line">es.get(e -&gt; <span class="string">&quot;张三&quot;</span>.equals(e.getName())).forEach(e-&gt;System.out.println(e));</span><br><span class="line">System.out.println();</span><br><span class="line">es.get(e -&gt; e.getAge()&gt;<span class="number">25</span> &amp;&amp; e.getSalary()&lt;<span class="number">10000</span> &amp;&amp; e.getGender()==<span class="string">&#x27;男&#x27;</span>).forEach(e-&gt;System.out.println(e));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-1-3-方法引用与构造器引用"><a href="#17-1-3-方法引用与构造器引用" class="headerlink" title="17.1.3 方法引用与构造器引用"></a>17.1.3 方法引用与构造器引用</h3><p>Lambda表达式是可以简化函数式接口的变量与形参赋值的语法。而方法引用和构造器引用是为了简化Lambda表达式的。当Lambda表达式满足一些特殊的情况时，还可以再简化：</p><p>（1）Lambda体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的</p><p>例如：System.out对象，调用println()方法来完成Lambda体</p><p>​          Math类，调用random()静态方法来完成Lambda体</p><p>（2）并且Lambda表达式的形参正好是给该方法的实参</p><p>例如：t-&gt;System.out.println(t)</p><p>​        () -&gt; Math.random() 都是无参</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用的语法格式：</p><p>（1）实例对象名::实例方法        </p><p>（2）类名::静态方法</p><p>（3）类名::实例方法</p><p>说明：</p><ul><li>::称为方法引用操作符（两个:中间不能有空格，而且必须英文状态下半角输入）</li><li>Lambda表达式的形参列表，全部在Lambda体中使用上了，要么是作为调用方法的对象，要么是作为方法的实参。</li><li>在整个Lambda体中没有额外的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//Runnable r = () -&gt; System.out.println(&quot;hello lambda&quot;);</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> System.out::println;<span class="comment">//打印空行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能简化方法引用，因为&quot;hello lambda&quot;这个无法省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">String[] arr = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;chai&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//Arrays.sort(arr, (s1,s2) -&gt; s1.compareToIgnoreCase(s2));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用方法引用简化</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lambda表达式的形参，第一个（例如：s1），正好是调用方法的对象，剩下的形参(例如:s2)正好是给这个方法的实参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Arrays.sort(arr, String::compareToIgnoreCase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//Stream&lt;Double&gt; stream = Stream.generate(() -&gt; Math.random());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用方法引用简化</span></span><br><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//list.forEach(t -&gt; System.out.println(t));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用方法再简化</span></span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>（1）当Lambda表达式是创建一个对象，并且满足Lambda表达式形参，正好是给创建这个对象的构造器的实参列表。</p><p>（2）  当Lambda表达式是创建一个数组对象，并且满足Lambda表达式形参，正好是给创建这个数组对象的长度</p><p>构造器引用的语法格式：</p><ul><li>类名::new</li><li>数组类型名::new</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodReference</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teset04</span><span class="params">()</span> &#123;</span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Stream&lt;<span class="type">int</span>[]&gt; map = stream.map(<span class="type">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法是模仿HashMap中，把你指定的数组的长度纠正为2的n次方的代码</span></span><br><span class="line"><span class="comment">//createArray()的作用是，创建一个长度为2的n次方的数组</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; R[] createArray(Function&lt;Integer,R[]&gt; fun,<span class="type">int</span> length)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        length = n &lt; <span class="number">0</span> ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fun.apply(length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function是一个函数式接口，可以用Lambda表达式赋值</span></span><br><span class="line"><span class="comment"> * Function&lt;T,R&gt;的抽象方法   R apply(T t)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * createArray这个方法中用的是Function&lt;Integer,R[]&gt; fun。说明T类型已经指定为Integer</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Function&lt;Integer,String[]&gt; f = (Integer len) -&gt; new String[len];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为Lambda体是在创建一个数组对象完成的，而且Lambda表达式的形参正好是创建数组用的长度</span></span><br><span class="line"><span class="comment">//通过构造器引用省略</span></span><br><span class="line">Function&lt;Integer,String[]&gt; f = String[]::<span class="keyword">new</span>;</span><br><span class="line">String[] array = createArray(f, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(array.length);<span class="comment">//16</span></span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teset02</span><span class="params">()</span> &#123;</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;1.0&quot;</span>,<span class="string">&quot;2.3&quot;</span>,<span class="string">&quot;4.4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream&lt;BigDecimal&gt; stream2 = stream.map(num -&gt; new BigDecimal(num));</span></span><br><span class="line"></span><br><span class="line">Stream&lt;BigDecimal&gt; stream2 = stream.map(BigDecimal::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//Supplier&lt;String&gt; s = () -&gt; new String();//通过供给型接口，提供一个空字符串对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line">Supplier&lt;String&gt; s = String::<span class="keyword">new</span>;<span class="comment">//通过供给型接口，提供一个空字符串对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-2-StreamAPI"><a href="#17-2-StreamAPI" class="headerlink" title="17.2 StreamAPI"></a>17.2 StreamAPI</h2><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</p><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，负责存储数据，Stream流讲的是计算，负责处理数据！”</p><p>注意：</p><p>①Stream 自己不会存储元素。</p><p>②Stream 不会改变源对象。每次处理都会返回一个持有结果的新Stream。</p><p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><p>Stream 的操作三个步骤：</p><p>1- 创建 Stream：通过一个数据源（如：集合、数组），获取一个流</p><p>2- 中间操作：中间操作是个操作链，对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</p><p>3- 终止操作：一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1560769396655.png" alt="1560769396655"></p><h3 id="17-2-1-创建Stream"><a href="#17-2-1-创建Stream" class="headerlink" title="17.2.1 创建Stream"></a>17.2.1 创建Stream</h3><p><strong>1、创建 Stream方式一：通过集合</strong></p><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p><ul><li><p>public default Stream<E> stream() : 返回一个顺序流</p></li><li><p>public default Stream<E> parallelStream() : 返回一个并行流</p></li></ul><p><strong>2、创建 Stream方式二：通过数组</strong></p><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p><ul><li>public static <T> Stream<T> stream(T[] array): 返回一个流</li></ul><p>重载形式，能够处理对应基本类型的数组：</p><ul><li>public static IntStream stream(int[] array)：返回一个整型数据流</li><li>public static LongStream stream(long[] array)：返回一个长整型数据流</li><li>public static DoubleStream stream(double[] array)：返回一个浮点型数据流</li></ul><p><strong>3、创建 Stream方式三：通过Stream的of()</strong></p><p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个顺序流</li></ul><p><strong>4、创建 Stream方式四：创建无限流</strong></p><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f):返回一个无限流</li><li>public static<T> Stream<T> generate(Supplier<T> s) ：返回一个无限流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07StreamCreate</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)  </span></span><br><span class="line"><span class="comment"> * UnaryOperator接口，SAM接口，抽象方法：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * UnaryOperator&lt;T&gt; extends Function&lt;T,T&gt;</span></span><br><span class="line"><span class="comment"> * T apply(T t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, num -&gt; num+=<span class="number">2</span>);</span><br><span class="line"><span class="comment">//stream = stream.limit(10);</span></span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK1.8中，Collection系列集合增加了方法</span></span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-2-2-中间操作"><a href="#17-2-2-中间操作" class="headerlink" title="17.2.2  中间操作"></a>17.2.2  中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><div class="table-container"><table><thead><tr><th><strong>方  法</strong></th><th><strong>描  述</strong></th></tr></thead><tbody><tr><td><strong>filter(Predicate p)</strong></td><td>接收 Lambda ， 从流中排除某些元素</td></tr><tr><td><strong>distinct()</strong></td><td>筛选，通过流所生成元素的equals() 去除重复元素</td></tr><tr><td><strong>limit(long maxSize)</strong></td><td>截断流，使其元素不超过给定数量</td></tr><tr><td><strong>skip(long n)</strong></td><td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td></tr><tr><td><strong>peek(Consumer</strong> <strong>action)</strong></td><td>接收Lambda，对流中的每个数据执行Lambda体操作</td></tr><tr><td><strong>sorted()</strong></td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td><strong>sorted(Comparator com)</strong></td><td>产生一个新流，其中按比较器顺序排序</td></tr><tr><td><strong>map(Function f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td><strong>mapToDouble(ToDoubleFunction f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td></tr><tr><td><strong>mapToInt(ToIntFunction f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td></tr><tr><td><strong>mapToLong(ToLongFunction f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td></tr><tr><td><strong>flatMap(Function f)</strong></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test08StreamMiddle</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">.flatMap(t -&gt; Stream.of(t.split(<span class="string">&quot;|&quot;</span>)))<span class="comment">//Function&lt;T,R&gt;接口抽象方法 R apply(T t)  现在的R是一个Stream</span></span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">.map(t-&gt;t.toUpperCase())</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.map(t -&gt; t+=<span class="number">1</span>)<span class="comment">//Function&lt;T,R&gt;接口抽象方法 R apply(T t)</span></span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//希望能够找出前三个最大值，前三名最大的，不重复</span></span><br><span class="line">Stream.of(<span class="number">11</span>,<span class="number">2</span>,<span class="number">39</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">54</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.sorted((t1,t2) -&gt; -Integer.compare(t1, t2))<span class="comment">//Comparator接口  int compare(T t1, T t2)</span></span><br><span class="line">.limit(<span class="number">3</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.peek(System.out::println)  <span class="comment">//Consumer接口的抽象方法  void accept(T t)</span></span><br><span class="line">.count();</span><br><span class="line">System.out.println(<span class="string">&quot;count=&quot;</span>+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.skip(<span class="number">5</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.skip(<span class="number">5</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">.distinct()  <span class="comment">//(1,2,3,4,5,6,7)</span></span><br><span class="line">.filter(t -&gt; t%<span class="number">2</span>!=<span class="number">0</span>) <span class="comment">//(1,3,5,7)</span></span><br><span class="line">.limit(<span class="number">3</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.limit(<span class="number">3</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.distinct()</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">.filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//1、创建Stream</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、加工处理</span></span><br><span class="line"><span class="comment">//过滤：filter(Predicate p)</span></span><br><span class="line"><span class="comment">//把里面的偶数拿出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * filter(Predicate p)</span></span><br><span class="line"><span class="comment"> * Predicate是函数式接口，抽象方法：boolean test(T t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stream = stream.filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、终结操作：例如：遍历</span></span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-2-3-终结操作"><a href="#17-2-3-终结操作" class="headerlink" title="17.2.3  终结操作"></a>17.2.3  终结操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。流进行了终止操作后，不能再次使用。</p><div class="table-container"><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>boolean</strong> <strong>allMatch(Predicate p)</strong></td><td>检查是否匹配所有元素</td></tr><tr><td><strong>boolean</strong> <strong>anyMatch</strong>(<strong>Predicate p</strong>)</td><td>检查是否至少匹配一个元素</td></tr><tr><td><strong>boolean</strong> <strong>noneMatch(Predicate  p)</strong></td><td>检查是否没有匹配所有元素</td></tr><tr><td><strong>Optional<T></strong> <strong>findFirst()</strong></td><td>返回第一个元素</td></tr><tr><td><strong>Optional<T></strong> <strong>findAny()</strong></td><td>返回当前流中的任意元素</td></tr><tr><td><strong>long</strong> <strong>count()</strong></td><td>返回流中元素总数</td></tr><tr><td><strong>Optional<T></strong> <strong>max(Comparator c)</strong></td><td>返回流中最大值</td></tr><tr><td><strong>Optional<T></strong> <strong>min(Comparator c)</strong></td><td>返回流中最小值</td></tr><tr><td><strong>void</strong> <strong>forEach(Consumer c)</strong></td><td>迭代</td></tr><tr><td><strong>T</strong> <strong>reduce(T iden, BinaryOperator b)</strong></td><td>可以将流中元素反复结合起来，得到一个值。返回 T</td></tr><tr><td><strong>U</strong> <strong>reduce(BinaryOperator b)</strong></td><td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td></tr><tr><td><strong>R</strong> <strong>collect(Collector c)</strong></td><td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table></div><p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09StreamEnding</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test14</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">.filter(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test13</span><span class="params">()</span>&#123;</span><br><span class="line">Optional&lt;Integer&gt; max = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"> .reduce((t1,t2) -&gt; t1&gt;t2?t1:t2);<span class="comment">//BinaryOperator接口   T apply(T t1, T t2)</span></span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"> .reduce(<span class="number">0</span>, (t1,t2) -&gt; t1+t2);<span class="comment">//BinaryOperator接口   T apply(T t1, T t2)</span></span><br><span class="line">System.out.println(reduce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">Optional&lt;Integer&gt; max = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">.max((t1,t2) -&gt; Integer.compare(t1, t2));</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">Optional&lt;Integer&gt; opt = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">.filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">.findFirst();</span><br><span class="line">System.out.println(opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span>&#123;</span><br><span class="line">Optional&lt;Integer&gt; opt = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">.filter(t -&gt; t%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">.findFirst();</span><br><span class="line">System.out.println(opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">Optional&lt;Integer&gt; opt = Stream.of(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>).findFirst();</span><br><span class="line">System.out.println(opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">.anyMatch(t -&gt; t%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">.allMatch(t -&gt; t%<span class="number">2</span>!=<span class="number">0</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.count();</span><br><span class="line">System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-2-4-练习"><a href="#17-2-4-练习" class="headerlink" title="17.2.4 练习"></a>17.2.4 练习</h3><p>案例：</p><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以<br>下若干操作步骤：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li><li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li><li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><p>Person 类的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个队伍（集合）的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石中玉&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">        <span class="comment">//第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;尼古拉斯赵四&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ....编写代码完成题目要求 </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;石中玉&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;尼古拉斯赵四&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        Stream.concat(streamOne, streamTwo).map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-3-Optional类"><a href="#17-3-Optional类" class="headerlink" title="17.3 Optional类"></a>17.3 Optional类</h2><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p><p>   Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><h3 id="17-3-1-API"><a href="#17-3-1-API" class="headerlink" title="17.3.1 API"></a>17.3.1 API</h3><p>1、如何创建Optional对象？或者说如何用Optional来装值对象或null值</p><p>（1）static <T> Optional<T> empty() ：用来创建一个空的Optional</p><p>（2）static <T> Optional<T> of(T value) ：用来创建一个非空的Optional</p><p>（3）static <T> Optional<T> ofNullable(T value) ：用来创建一个可能是空，也可能非空的Optional</p><p>2、如何从Optional容器中取出所包装的对象呢？</p><p>（1）T get()  ：要求Optional容器必须非空</p><p>T get()与of(T value)使用是安全的</p><p>（2）T orElse(T other)  ：</p><p>orElse(T other) 与ofNullable(T value)配合使用，</p><p>如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替</p><p>（3）T orElseGet(Supplier&lt;? extends T&gt; other)  ：</p><p>如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替</p><p>（4）<X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) </p><p>如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException</p><p>3、其他方法</p><p>（1）boolean isPresent()  ：判断Optional容器中的值是否存在</p><p>（2）void ifPresent(Consumer&lt;? super T&gt; consumer) ：</p><p>判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做</p><p>（3）<U> Optional<U> map(Function&lt;? super T,? extends U&gt; mapper)  </p><p>判断Optional容器中的值是否存在，如果存在，就对它进行Function接口指定的操作，如果不存在就不做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestOptional</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test9</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(str);</span><br><span class="line">        <span class="comment">//判断是否是纯字母单词，如果是，转为大写，否则保持不变</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> opt.filter(s-&gt;s.matches(<span class="string">&quot;[a-zA-Z]+&quot;</span>)).</span><br><span class="line">map(s -&gt; s.toLowerCase()).</span><br><span class="line">orElse(str);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> opt.orElseThrow(()-&gt;<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;值不存在&quot;</span>));</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> opt.orElseGet(String::<span class="keyword">new</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> opt.orElse(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(str);</span><br><span class="line"><span class="comment">//System.out.println(opt.get());//java.util.NoSuchElementException: No value present</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.of(str);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> opt.get();</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(str);</span><br><span class="line">System.out.println(opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Optional&lt;String&gt; opt = Optional.of(str);</span><br><span class="line">System.out.println(opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="17-3-2-练习"><a href="#17-3-2-练习" class="headerlink" title="17.3.2 练习"></a>17.3.2 练习</h3><h4 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h4><p>案例：</p><p>（1）声明一个Girl类型，包含姓名（String）属性</p><p>（2）声明一个Boy类型，包含姓名（String），女朋友（Girl）属性</p><p>（3）在测试类中，创建一个Boy对象，并</p><p>如果他有女朋友，显示他女朋友名称；</p><p>如果他没有女朋友，他的女朋友默认为“嫦娥”，即只能欣赏“嫦娥”了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Girl [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Girl girlFriend;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(String name, Girl girlFriend)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.girlFriend = girlFriend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Girl <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> girlFriend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGirlFriend</span><span class="params">(Girl girlFriend)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.girlFriend = girlFriend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Boy [name=&quot;</span> + name + <span class="string">&quot;, girlFriend=&quot;</span> + girlFriend + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//Boy boy = new Boy(&quot;张三&quot;,null);</span></span><br><span class="line"><span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="string">&quot;张三&quot;</span>,<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;翠翠&quot;</span>));</span><br><span class="line">Optional&lt;Girl&gt; grilFriend = Optional.ofNullable(boy.getGirlFriend());</span><br><span class="line">Optional.of(grilFriend.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;嫦娥&quot;</span>))).ifPresent(g-&gt;System.out.println(g));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h4><p>案例：</p><p>（1）声明学生类，包含姓名和年龄</p><p>（2）添加几个学生对象到一个ArrayList<Student>集合中</p><p>（3）对集合中的学生进行操作，找出年龄大于30岁的，并取出第一个学生，如果没有这样的学生，用无参构造new一个学生对象，打印学生信息</p><p>学生类示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>));</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取出流中第一个年龄大于30岁的学生的年龄，并打印它的年龄，如果没有，用无参构造创建一个学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> list.stream()</span><br><span class="line">.filter(s -&gt; s.getAge()&gt;<span class="number">30</span>)</span><br><span class="line">.findFirst().orElse(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">System.out.println(<span class="string">&quot;学生的年龄：&quot;</span> + stu.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第17章-Java8新特性&quot;&gt;&lt;a href=&quot;#第17章-Java8新特性&quot; class=&quot;headerlink&quot; title=&quot;第17章 Java8新特性&quot;&gt;&lt;/a&gt;第17章 Java8新特性&lt;/h1&gt;&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot;</summary>
      
    
    
    
    <category term="重学Java基础" scheme="https://manamn.space/categories/%E9%87%8D%E5%AD%A6Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://manamn.space/tags/Java/"/>
    
    <category term="重学Java基础" scheme="https://manamn.space/tags/%E9%87%8D%E5%AD%A6Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>第16章 反射（Reflect）</title>
    <link href="https://manamn.space/2022/07/28/SGG_JavaSE/%E7%AC%AC16%E7%AB%A0-%E5%8F%8D%E5%B0%84%EF%BC%88Reflect%EF%BC%89/"/>
    <id>https://manamn.space/2022/07/28/SGG_JavaSE/%E7%AC%AC16%E7%AB%A0-%E5%8F%8D%E5%B0%84%EF%BC%88Reflect%EF%BC%89/</id>
    <published>2022-07-28T05:08:38.000Z</published>
    <updated>2022-10-16T13:46:48.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第16章-反射（Reflect）"><a href="#第16章-反射（Reflect）" class="headerlink" title="第16章 反射（Reflect）"></a>第16章 反射（Reflect）</h1><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li>[ ] 了解类的加载过程</li><li>[ ] 理解类初始化过程</li><li>[ ] 了解类加载器</li><li>[ ] 掌握获取Class对象的四种方式</li><li>[ ] 能够运用反射获取类型的详细信息</li><li>[ ] 能够运用反射动态创建对象</li><li>[ ] 能够运用反射动态获取成员变量并使用</li><li>[ ] 能够运用反射动态获取成员方法并使用</li><li>[ ] 能够运用反射读取注解</li><li>[ ] 能够运用反射获取泛型父类的类型参数</li></ul><h1 id="第16章-反射（Reflect）-1"><a href="#第16章-反射（Reflect）-1" class="headerlink" title="第16章 反射（Reflect）"></a>第16章 反射（Reflect）</h1><h2 id="16-1-类加载"><a href="#16-1-类加载" class="headerlink" title="16.1 类加载"></a>16.1 类加载</h2><p>类在内存中的生命周期：加载—&gt;使用—&gt;卸载</p><h3 id="16-1-1-类的加载过程"><a href="#16-1-1-类的加载过程" class="headerlink" title="16.1.1 类的加载过程"></a>16.1.1 类的加载过程</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p><p>类的加载又分为三个阶段：</p><p>（1）加载：load</p><p>就是指将类型的clas字节码数据读入内存</p><p>（2）连接：link</p><p>①验证：校验合法性等</p><p>②准备：准备对应的内存（方法区），创建Class对象，为类变量赋默认值，为静态常量赋初始值。</p><p>③解析：把字节码中的符号引用替换为对应的直接地址引用</p><p>（3）初始化：initialize（类初始化）即执行<clinit>类初始化方法，大多数情况下，类的加载就完成了类的初始化，有些情况下，会延迟类的初始化。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1560767438339.png" alt="1560767438339"></p><h3 id="16-1-2-类初始化"><a href="#16-1-2-类初始化" class="headerlink" title="16.1.2 类初始化"></a>16.1.2 类初始化</h3><p>1、哪些操作会导致类的初始化？</p><p>（1）运行主方法所在的类，要先完成类初始化，再执行main方法</p><p>（2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化</p><p>（3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化</p><p>（4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类</p><p>（5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化</p><blockquote><p>类初始化执行的是<clinit>()，该方法由（1）类变量的显式赋值代码（2）静态代码块中的代码构成</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main方法所在的类的父类(1)&quot;</span>);<span class="comment">//初始化子类时，会初始化父类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClinit1</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;main方法所在的类(2)&quot;</span>);<span class="comment">//主方法所在的类会初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//第一次使用A就是创建它的对象，会初始化A类</span></span><br><span class="line"></span><br><span class="line">B.test();<span class="comment">//直接使用B类的静态成员会初始化B类</span></span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.test02.C&quot;</span>);<span class="comment">//通过反射操作C类，会初始化C类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;A类初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B类初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;B类的静态方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;C类初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、哪些使用类的操作，但是不会导致类的初始化？</p><p>（1）使用某个类的静态的常量（static  final）</p><p>（2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有声明静态成员的类才会初始化</p><p>（3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClinit2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(D.NUM);<span class="comment">//D类不会初始化，因为NUM是final的</span></span><br><span class="line"></span><br><span class="line">System.out.println(F.num);</span><br><span class="line">F.test();<span class="comment">//F类不会初始化，E类会初始化，因为num和test()是在E类中声明的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//G类不会初始化，此时还没有正式用的G类</span></span><br><span class="line">G[] arr = <span class="keyword">new</span> <span class="title class_">G</span>[<span class="number">5</span>];<span class="comment">//没有创建G的对象，创建的是准备用来装G对象的数组对象</span></span><br><span class="line">        <span class="comment">//G[]是一种新的类型，是数组类想，动态编译生成的一种新的类型</span></span><br><span class="line">        <span class="comment">//G[].class</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;D类的初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;E父类的初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类的静态方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_">E</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;F子类的初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;G类的初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-1-3-类加载器"><a href="#16-1-3-类加载器" class="headerlink" title="16.1.3 类加载器"></a>16.1.3 类加载器</h3><p>很多开发人员都遇到过java.lang.ClassNotFoundException或java.lang.NoClassDefError，想要更好的解决这类问题，或者在一些特殊的应用场景，比如需要支持类的动态加载或需要对编译后的字节码文件进行加密解密操作，那么需要你自定义类加载器，因此了解类加载器及其类加载机制也就成了每一个Java开发人员的必备技能之一。</p><p><strong>1、类加载器分为：</strong></p><p>（1）引导类加载器（Bootstrap Classloader）又称为根类加载器</p><pre><code>它负责加载jre/rt.jar核心库它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null</code></pre><p>（2）扩展类加载器（Extension ClassLoader）</p><pre><code>它负责加载jre/lib/ext扩展库它是ClassLoader的子类</code></pre><p>（3）应用程序类加载器（Application Classloader）</p><pre><code>它负责加载项目的classpath路径下的类它是ClassLoader的子类</code></pre><p>（4）自定义类加载器</p><pre><code>当你的程序需要加载“特定”目录下的类，可以自定义类加载器；当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码后面会见到的自定义类加载器：tomcat中</code></pre><p><strong>2、Java系统类加载器的双亲委托模式</strong></p><p>简单描述：</p><pre><code>下一级的类加载器，如果接到任务时，会先搜索是否加载过，如果没有，会先把任务往上传，如果都没有加载过，一直到根加载器，如果根加载器在它负责的路径下没有找到，会往回传，如果一路回传到最后一级都没有找到，那么会报ClassNotFoundException或NoClassDefError，如果在某一级找到了，就直接返回Class对象。</code></pre><p>应用程序类加载器  把  扩展类加载器视为父加载器，</p><p>扩展类加载器 把 引导类加载器视为父加载器。</p><p>不是继承关系，是组合的方式实现的。</p><h2 id="16-2-javalang-Class类"><a href="#16-2-javalang-Class类" class="headerlink" title="16.2  javalang.Class类"></a>16.2  javalang.Class类</h2><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p><p>要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect.*。所以，Class对象是反射的根源。</p><h3 id="1、哪些类型可以获取Class对象"><a href="#1、哪些类型可以获取Class对象" class="headerlink" title="1、哪些类型可以获取Class对象"></a>1、哪些类型可以获取Class对象</h3><p>所有Java类型</p><p>用代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）基本数据类型和void</span></span><br><span class="line">例如：<span class="type">int</span>.<span class="keyword">class</span></span><br><span class="line"> <span class="title class_">void</span>.class</span><br><span class="line"><span class="comment">//（2）类和接口</span></span><br><span class="line">例如：String.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Comparable</span>.class</span><br><span class="line"><span class="comment">//（3）枚举</span></span><br><span class="line">例如：ElementType.class</span><br><span class="line"><span class="comment">//（4）注解</span></span><br><span class="line">例如：Override.class</span><br><span class="line"><span class="comment">//（5）数组</span></span><br><span class="line">例如：<span class="type">int</span>[].class</span><br></pre></td></tr></table></figure><h3 id="2、获取Class对象的四种方式"><a href="#2、获取Class对象的四种方式" class="headerlink" title="2、获取Class对象的四种方式"></a>2、获取Class对象的四种方式</h3><p>（1）类型名.class</p><p>要求编译期间已知类型</p><p>（2）对象.getClass()</p><p>获取对象的运行时类型</p><p>（3）Class.forName(类型全名称)</p><p> 可以获取编译期间未知的类型</p><p>（4）ClassLoader的类加载器对象.loadClass(类型全名称)</p><p>可以用系统类加载对象或自定义加载器对象加载指定路径下的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> TestClass.class;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> c.getClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;com.atguigu.test05.Employee&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Employee.class;</span><br><span class="line">System.out.println(c2 == c3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(c1 == c2);</span><br><span class="line">System.out.println(c1 == c3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、查看某个类的类加载器对象"><a href="#3、查看某个类的类加载器对象" class="headerlink" title="3、查看某个类的类加载器对象"></a>3、查看某个类的类加载器对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取应用程序类加载器对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取扩展类加载器对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根加载器对象</span></span><br></pre></td></tr></table></figure><h2 id="16-3-反射的应用"><a href="#16-3-反射的应用" class="headerlink" title="16.3 反射的应用"></a>16.3 反射的应用</h2><h3 id="16-3-1-获取类型的详细信息"><a href="#16-3-1-获取类型的详细信息" class="headerlink" title="16.3.1 获取类型的详细信息"></a>16.3.1 获取类型的详细信息</h3><p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）</p><p>示例代码获取常规信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException &#123;</span><br><span class="line"><span class="comment">//1、先得到某个类型的Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">//比喻clazz好比是镜子中的影子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取类信息</span></span><br><span class="line"><span class="comment">//（1）获取包对象，即所有java的包，都是Package的对象</span></span><br><span class="line"><span class="type">Package</span> <span class="variable">pkg</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">System.out.println(<span class="string">&quot;包名：&quot;</span> + pkg.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）获取修饰符</span></span><br><span class="line"><span class="comment">//其实修饰符是Modifier，里面有很多常量值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 0x是十六进制</span></span><br><span class="line"><span class="comment"> * PUBLIC           = 0x00000001;  1    1</span></span><br><span class="line"><span class="comment"> * PRIVATE          = 0x00000002;  210</span></span><br><span class="line"><span class="comment"> * PROTECTED        = 0x00000004;  4100</span></span><br><span class="line"><span class="comment"> * STATIC           = 0x00000008;  81000</span></span><br><span class="line"><span class="comment"> * FINAL            = 0x00000010;  1610000</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设计的理念，就是用二进制的某一位是1，来代表一种修饰符，整个二进制中只有一位是1，其余都是0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * mod = 17          0x00000011</span></span><br><span class="line"><span class="comment"> * if ((mod &amp; PUBLIC) != 0)  说明修饰符中有public</span></span><br><span class="line"><span class="comment"> * if ((mod &amp; FINAL) != 0)   说明修饰符中有final</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> clazz.getModifiers();</span><br><span class="line">System.out.println(Modifier.toString(mod));</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）类型名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getName();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）父类，父类也有父类对应的Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> clazz.getSuperclass();</span><br><span class="line">System.out.println(superclass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）父接口们</span></span><br><span class="line">Class[] interfaces = clazz.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class class1 : interfaces) &#123;</span><br><span class="line">System.out.println(class1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（6）类的属性，  你声明的一个属性，它是Field的对象</span></span><br><span class="line"><span class="comment">/*Field clazz.getField(name)  根据属性名获取一个属性对象，但是只能得到公共的</span></span><br><span class="line"><span class="comment">Field[] clazz.getFields();  获取所有公共的属性</span></span><br><span class="line"><span class="comment">Field clazz.getDeclaredField(name)  根据属性名获取一个属性对象，可以获取已声明的</span></span><br><span class="line"><span class="comment">Field[] clazz.getDeclaredFields()获取所有已声明的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(&quot;valueField = &quot; +valueField);</span></span><br><span class="line"></span><br><span class="line">Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line"><span class="comment">//修饰符、数据类型、属性名    </span></span><br><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> field.getModifiers();</span><br><span class="line">System.out.println(<span class="string">&quot;属性的修饰符：&quot;</span> + Modifier.toString(modifiers));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> field.getName();</span><br><span class="line">System.out.println(<span class="string">&quot;属性名：&quot;</span> + name2);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; type = field.getType();</span><br><span class="line">System.out.println(<span class="string">&quot;属性的数据类型：&quot;</span> + type);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"><span class="comment">//（7）构造器们</span></span><br><span class="line">Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor constructor : constructors) &#123;</span><br><span class="line"><span class="comment">//修饰符、构造器名称、构造器形参列表  、抛出异常列表</span></span><br><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> constructor.getModifiers();</span><br><span class="line">System.out.println(<span class="string">&quot;构造器的修饰符：&quot;</span> + Modifier.toString(modifiers));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> constructor.getName();</span><br><span class="line">System.out.println(<span class="string">&quot;构造器名：&quot;</span> + name2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参列表</span></span><br><span class="line">System.out.println(<span class="string">&quot;形参列表：&quot;</span>);</span><br><span class="line">Class[] parameterTypes = constructor.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class parameterType : parameterTypes) &#123;</span><br><span class="line">System.out.println(parameterType);</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//异常列表</span></span><br><span class="line">System.out.println(<span class="string">&quot;异常列表：&quot;</span>);</span><br><span class="line">Class&lt;?&gt;[] exceptionTypes = constructor.getExceptionTypes();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; exceptionType : exceptionTypes) &#123;</span><br><span class="line">System.out.println(exceptionType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;=--------------------------------&quot;</span>);</span><br><span class="line"><span class="comment">//(8)方法们</span></span><br><span class="line">Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line"><span class="comment">//修饰符、返回值类型、方法名、形参列表 、异常列表 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> method.getModifiers();</span><br><span class="line">System.out.println(<span class="string">&quot;方法的修饰符：&quot;</span> + Modifier.toString(modifiers));</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">System.out.println(<span class="string">&quot;返回值类型:&quot;</span> + returnType);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> method.getName();</span><br><span class="line">System.out.println(<span class="string">&quot;方法名：&quot;</span> + name2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参列表</span></span><br><span class="line">System.out.println(<span class="string">&quot;形参列表：&quot;</span>);</span><br><span class="line">Class[] parameterTypes = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class parameterType : parameterTypes) &#123;</span><br><span class="line">System.out.println(parameterType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异常列表</span></span><br><span class="line">System.out.println(<span class="string">&quot;异常列表：&quot;</span>);</span><br><span class="line">Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; exceptionType : exceptionTypes) &#123;</span><br><span class="line">System.out.println(exceptionType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-2-创建任意引用类型的对象"><a href="#16-3-2-创建任意引用类型的对象" class="headerlink" title="16.3.2  创建任意引用类型的对象"></a>16.3.2  创建任意引用类型的对象</h3><p>两种方式：</p><p>1、直接通过Class对象来实例化（要求必须有无参构造）</p><p>2、通过获取构造器对象来进行实例化</p><p>方式一的步骤：</p><p>（1）获取该类型的Class对象（2）创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line"><span class="comment">//Caused by: java.lang.NoSuchMethodException: com.atguigu.test.Student.&lt;init&gt;()</span></span><br><span class="line"><span class="comment">//即说明Student没有无参构造，就没有无参实例初始化方法&lt;init&gt;</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">stu</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException&#123;</span><br><span class="line"><span class="comment">//AtGuigu obj = new AtGuigu();//编译期间无法创建</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.AtGuigu&quot;</span>);</span><br><span class="line"><span class="comment">//clazz代表com.atguigu.test.AtGuigu类型</span></span><br><span class="line"><span class="comment">//clazz.newInstance()创建的就是AtGuigu的对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二的步骤：</p><p>（1）获取该类型的Class对象（2）获取构造器对象（3）创建对象</p><blockquote><p>如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNewInstance</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//(1)获取Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取Student类型中的有参构造</span></span><br><span class="line"><span class="comment"> * 如果构造器有多个，我们通常是根据形参【类型】列表来获取指定的一个构造器的</span></span><br><span class="line"><span class="comment"> * 例如：public Student(int id, String name) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//(2)获取构造器对象</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)创建实例对象</span></span><br><span class="line"><span class="comment">// T newInstance(Object... initargs)  这个Object...是在创建对象时，给有参构造的实参列表</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(<span class="number">2</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-3-操作任意类型的属性"><a href="#16-3-3-操作任意类型的属性" class="headerlink" title="16.3.3 操作任意类型的属性"></a>16.3.3 操作任意类型的属性</h3><p>（1）获取该类型的Class对象<br>Class clazz = Class.forName(“com.atguigu.bean.User”);</p><p>（2）获取属性对象<br>Field field = clazz.getDeclaredField(“username”);</p><p>（3）设置属性可访问</p><p>field.setAccessible(true);</p><p>（4）创建实例对象：如果操作的是非静态属性，需要创建实例对象<br>Object obj = clazz.newInstance();</p><p>（4）设置属性值</p><p>field.set(obj,”chai”);<br>（5）获取属性值<br>Object value = field.get(obj);</p><blockquote><p>如果操作静态变量，那么实例对象可以省略，用null表示</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestField</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、获取Student的Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取属性对象，例如：id属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">idField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、如果id是私有的等在当前类中不可访问access的，我们需要做如下操作</span></span><br><span class="line">idField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、创建实例对象，即，创建Student对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">stu</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、获取属性值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以前：int 变量= 学生对象.getId()</span></span><br><span class="line"><span class="comment"> * 现在：Object id属性对象.get(学生对象)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> idField.get(stu);</span><br><span class="line">System.out.println(<span class="string">&quot;id = &quot;</span>+ value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、设置属性值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以前：学生对象.setId(值)</span></span><br><span class="line"><span class="comment"> * 现在：id属性对象.set(学生对象,值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">idField.set(stu, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">value = idField.get(stu);</span><br><span class="line">System.out.println(<span class="string">&quot;id = &quot;</span>+ value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-4-调用任意类型的方法"><a href="#16-3-4-调用任意类型的方法" class="headerlink" title="16.3.4 调用任意类型的方法"></a>16.3.4 调用任意类型的方法</h3><p>（1）获取该类型的Class对象<br>Class clazz = Class.forName(“com.atguigu.service.UserService”);<br>（2）获取方法对象<br>Method method = clazz.getDeclaredMethod(“login”,String.class,String.class);<br>（3）创建实例对象<br>Object obj = clazz.newInstance();<br>（4）调用方法<br>Object result = method.invoke(obj,”chai”,”123);</p><blockquote><p>如果方法的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p><p>如果方法是静态方法，实例对象也可以省略，用null代替</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethod</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 1、获取Student的Class对象</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.atguigu.test.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取方法对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在一个类中，唯一定位到一个方法，需要：（1）方法名（2）形参列表，因为方法可能重载</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例如：void setName(String name)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、创建实例对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">stu</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、调用方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以前：学生对象.setName(值)</span></span><br><span class="line"><span class="comment"> * 现在：方法对象.invoke(学生对象，值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">method.invoke(stu, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-5-获取泛型父类信息"><a href="#16-3-5-获取泛型父类信息" class="headerlink" title="16.3.5 获取泛型父类信息"></a>16.3.5 获取泛型父类信息</h3><p>示例代码获取泛型父类信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type：</span></span><br><span class="line"><span class="comment"> * （1）Class</span></span><br><span class="line"><span class="comment"> * （2）ParameterizedType   </span></span><br><span class="line"><span class="comment"> * 例如：Father&lt;String,Integer&gt;</span></span><br><span class="line"><span class="comment"> * ArrayList&lt;String&gt;</span></span><br><span class="line"><span class="comment"> * （3）TypeVariable</span></span><br><span class="line"><span class="comment"> * 例如：T，U,E,K,V</span></span><br><span class="line"><span class="comment"> * （4）WildcardType</span></span><br><span class="line"><span class="comment"> * 例如：</span></span><br><span class="line"><span class="comment"> * ArrayList&lt;?&gt;</span></span><br><span class="line"><span class="comment"> * ArrayList&lt;? super 下限&gt;</span></span><br><span class="line"><span class="comment"> * ArrayList&lt;? extends 上限&gt;</span></span><br><span class="line"><span class="comment"> * （5）GenericArrayType</span></span><br><span class="line"><span class="comment"> * 例如：T[]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGeneric</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：在运行时，获取Son类型的泛型父类的泛型实参&lt;String,Integer&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）还是先获取Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Son.class;<span class="comment">//四种形式任意一种都可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）获取泛型父类</span></span><br><span class="line"><span class="comment">//Class sc = clazz.getSuperclass();</span></span><br><span class="line"><span class="comment">//System.out.println(sc);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * getSuperclass()只能得到父类名，无法得到父类的泛型实参列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Father&lt;String,Integer&gt;属于ParameterizedType</span></span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）获取泛型父类的泛型实参列表</span></span><br><span class="line">Type[] typeArray = pt.getActualTypeArguments();</span><br><span class="line"><span class="keyword">for</span> (Type type2 : typeArray) &#123;</span><br><span class="line">System.out.println(type2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型形参：&lt;T,U&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T,U&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型实参：&lt;String,Integer&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;String,Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-6-读取注解信息"><a href="#16-3-6-读取注解信息" class="headerlink" title="16.3.6 读取注解信息"></a>16.3.6 读取注解信息</h3><p>示例代码读取注解信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//需求：可以获取MyClass类型上面配置的注解@MyAnnotation的value值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取注解</span></span><br><span class="line"><span class="comment">//（1）获取Class对象</span></span><br><span class="line">Class&lt;MyClass&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）获取注解对象</span></span><br><span class="line"><span class="comment">//获取指定注解对象</span></span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">my</span> <span class="operator">=</span> clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）获取配置参数值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> my.value();</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="comment">//说明这个注解可以保留到运行时</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> <span class="comment">//说明这个注解只能用在类型上面，包括类，接口，枚举等</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"><span class="comment">//配置参数，如果只有一个配置参数，并且名称是value，在赋值时可以省略value=</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用注解</span></span><br><span class="line"><span class="meta">@MyAnnotation(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-7-获取内部类或外部类信息"><a href="#16-3-7-获取内部类或外部类信息" class="headerlink" title="16.3.7 获取内部类或外部类信息"></a>16.3.7 获取内部类或外部类信息</h3><p>public Class&lt;?&gt;[] getClasses()：返回所有公共内部类和内部接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。</p><p>public Class&lt;?&gt;[] getDeclaredClasses()：返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。</p><p>public Class&lt;?&gt; getDeclaringClass()：如果此 Class 对象所表示的类或接口是一个内部类或内部接口，则返回它的外部类或外部接口，否则返回null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">Class&lt;?&gt; clazz = Map.class;</span><br><span class="line">Class&lt;?&gt;[] inners = clazz.getDeclaredClasses();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; inner : inners) &#123;</span><br><span class="line">System.out.println(inner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; ec = Map.Entry.class;</span><br><span class="line">Class&lt;?&gt; outer = ec.getDeclaringClass();</span><br><span class="line">System.out.println(outer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-8-动态创建和操作任意类型的数组"><a href="#16-3-8-动态创建和操作任意类型的数组" class="headerlink" title="16.3.8 动态创建和操作任意类型的数组"></a>16.3.8 动态创建和操作任意类型的数组</h3><p>在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用Array类来动态的创建数组，操作数组元素等。</p><p>Array类提供了如下几个方法：</p><p>public static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)：创建一个具有指定的组件类型和维度的新数组。</p><p>public static void setXxx(Object array,int index,xxx value)：将array数组中[index]元素的值修改为value。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用set(Object array,int index, Object value)方法。</p><p>public static xxx getXxx(Object array,int index,xxx value)：将array数组中[index]元素的值返回。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用get(Object array,int index)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">arr</span> <span class="operator">=</span> Array.newInstance(String.class, <span class="number">5</span>);</span><br><span class="line">Array.set(arr, <span class="number">0</span>, <span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">Array.set(arr, <span class="number">1</span>, <span class="string">&quot;佟刚&quot;</span>);</span><br><span class="line">System.out.println(Array.get(arr, <span class="number">0</span>));</span><br><span class="line">System.out.println(Array.get(arr, <span class="number">1</span>));</span><br><span class="line">System.out.println(Array.get(arr, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第16章-反射（Reflect）&quot;&gt;&lt;a href=&quot;#第16章-反射（Reflect）&quot; class=&quot;headerlink&quot; title=&quot;第16章 反射（Reflect）&quot;&gt;&lt;/a&gt;第16章 反射（Reflect）&lt;/h1&gt;&lt;h2 id=&quot;教学目标&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="重学Java基础" scheme="https://manamn.space/categories/%E9%87%8D%E5%AD%A6Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://manamn.space/tags/Java/"/>
    
    <category term="重学Java基础" scheme="https://manamn.space/tags/%E9%87%8D%E5%AD%A6Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>第15章 网络编程</title>
    <link href="https://manamn.space/2022/07/28/SGG_JavaSE/%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://manamn.space/2022/07/28/SGG_JavaSE/%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-07-28T05:08:24.000Z</published>
    <updated>2022-10-16T13:46:44.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第15章-网络编程"><a href="#第15章-网络编程" class="headerlink" title="第15章 网络编程"></a>第15章 网络编程</h1><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul><li>[ ] 了解网络通信协议参考模型</li><li>[ ] 能够理解IP地址和端口号的作用</li><li>[ ] 能够在程序中表示IP地址和端口号</li><li>[ ] 能够说出TCP和UDP网络协议的区别</li><li>[ ] 了解基于Socket的TCP网络编程</li><li>[ ] 了解基于Socket的UDP网络编程</li></ul><h1 id="第15章-网络编程-1"><a href="#第15章-网络编程-1" class="headerlink" title="第15章 网络编程"></a>第15章 网络编程</h1><h2 id="15-1-软件结构"><a href="#15-1-软件结构" class="headerlink" title="15.1 软件结构"></a>15.1 软件结构</h2><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、红蜘蛛、飞秋等软件。</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1_cs.jpg" alt=""></p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有IE、谷歌、火狐等。</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/2_bs.jpg" alt=""></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h2 id="15-2-网络通信协议"><a href="#15-2-网络通信协议" class="headerlink" title="15.2 网络通信协议"></a>15.2 网络通信协议</h2><h3 id="15-2-1-TCP-IP协议参考模型"><a href="#15-2-1-TCP-IP协议参考模型" class="headerlink" title="15.2.1 TCP/IP协议参考模型"></a>15.2.1 TCP/IP协议参考模型</h3><ul><li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p></li><li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564019044385.png" alt="1564019044385"></p><p>上图中，OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广。 TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。</p><ul><li>TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li><li>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。而IP协议是一种非常重要的协议。IP（internet protocal）又称为互联网协议。IP的责任就是把数据从源传送到目的地。它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。</li><li>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。TCP（Transmission Control Protocol）协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务。</li><li>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li></ul><p>而通常我们说的TCP/IP协议，其实是指TCP/IP协议族，因为该协议家族的两个最核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准，所以简称为TCP/IP协议。</p><h3 id="15-2-2-TCP与UDP协议"><a href="#15-2-2-TCP与UDP协议" class="headerlink" title="15.2.2 TCP与UDP协议"></a>15.2.2 TCP与UDP协议</h3><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。</p><ul><li><p><strong>非面向连的，不可靠的：</strong>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。</p></li><li><p><strong>大小限制的</strong>：数据被限制在64kb以内，超出这个范围就不能发送了。</p></li><li><p><strong>数据报(Datagram)</strong>：网络传输的基本单位 </p></li></ul></li><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。</p><ul><li><p><strong>面向连接的，可靠的</strong>：TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。是一种面向连接的、可靠的、基于字节流的传输层的通信协议，可以连续传输大量的数据。类似于打电话的效果。</p><p>这是因为它为当一台计算机需要与另一台远程计算机连接时，TCP协议会采用“三次握手”方式让它们建立一个连接，用于发送和接收数据的虚拟链路。数据传输完毕TCP协议会采用“四次挥手”方式断开连接。</p><p>TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息。</p></li></ul></li><li><p><strong>三次握手：</strong>TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p><ul><li><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</p></li><li><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</p></li><li><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接。</p></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564020243342.png" alt="1564020243342"></p></li></ul><ul><li><strong>四次挥手：</strong>TCP协议中，在发送数据结束后，释放连接时需要经过四次挥手。<ul><li>第一次挥手：客户端向服务器端提出结束连接，让服务器做最后的准备工作。此时，客户端处于半关闭状态，即表示不再向服务器发送数据了，但是还可以接受数据。</li><li>第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发给客户端。并告知上层的应用进程不再接收数据。</li><li>第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了。</li><li>第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待2MSL后，没有收到，那么彻底断开。</li></ul></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564021582928.png" alt="1564021582928"></p><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h2 id="15-3-网络编程三要素"><a href="#15-3-网络编程三要素" class="headerlink" title="15.3 网络编程三要素"></a>15.3 网络编程三要素</h2><h3 id="1、协议"><a href="#1、协议" class="headerlink" title="1、协议"></a>1、协议</h3><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h3 id="2、IP地址"><a href="#2、IP地址" class="headerlink" title="2、IP地址"></a>2、IP地址</h3><p><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</p><p><strong>IP地址分类方式一：</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>IP地址分类方式二：</strong></p><p>公网地址( 万维网使用)和 私有地址( 局域网使用)。192.168.开头的就是私有址址，范围即为192.168.0.0—192.168.255.255，专门为组织机构内部使用</p><p><strong>常用命令：</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure><p><strong>特殊的IP地址：</strong></p><ul><li>本地回环地址(hostAddress)：<code>127.0.0.1</code>  </li><li>主机名(hostName)：<code>localhost</code></li></ul><p><strong>域名：</strong></p><p>因为IP地址数字不便于记忆，因此出现了域名，域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。 ———- 域名解析</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564021975715.png" alt="1564021975715"></p><h3 id="3、端口号"><a href="#3、端口号" class="headerlink" title="3、端口号"></a>3、端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。<ul><li>公认端口：0~1023。被预先定义的服务通信占用，如：HTTP（80），FTP（21），Telnet（23）</li><li>注册端口：1024~49151。分配给用户进程或应用程序。如：Tomcat（8080），MySQL（3306），Oracle（1521）。</li><li>动态/ 私有端口：49152~65535。</li></ul></li></ul><p>如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</p><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h2 id="15-4-InetAddress类"><a href="#15-4-InetAddress类" class="headerlink" title="15.4 InetAddress类"></a>15.4 InetAddress类</h2><p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。</p><p>Internet上的主机有两种方式表示地址：</p><ul><li>域名(hostName)：www.atguigu.com</li><li>IP 地址(hostAddress)：202.108.35.210</li></ul><p>lInetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取InetAddress 实例</p><ul><li>public static InetAddress getLocalHost()</li><li>public static InetAddress getByName(String host)</li><li>public static InetAddress getByAddress(byte[] addr)</li></ul><p>InetAddress 提供了如下几个常用的方法</p><ul><li>public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式）。</li><li>public String getHostName() ：获取此 IP 地址的主机名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetAddress</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException&#123;</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException&#123;</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">atguigu</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.atguigu.com&quot;</span>);</span><br><span class="line">System.out.println(atguigu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span><span class="keyword">throws</span> UnknownHostException&#123;</span><br><span class="line"><span class="comment">//byte[] addr = &#123;112,54,108,98&#125;;</span></span><br><span class="line"><span class="type">byte</span>[] addr = &#123;(<span class="type">byte</span>)<span class="number">192</span>,(<span class="type">byte</span>)<span class="number">168</span>,<span class="number">24</span>,<span class="number">56</span>&#125;;</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">atguigu</span> <span class="operator">=</span> InetAddress.getByAddress(addr);</span><br><span class="line">System.out.println(atguigu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564024137998.png" alt="1564024137998"></p><h2 id="15-5-Socket"><a href="#15-5-Socket" class="headerlink" title="15.5 Socket"></a>15.5 Socket</h2><p>通信的两端都要有Socket（也可以叫“套接字”），是两台机器间通信的端点。网络通信其实就是Socket间的通信。Socket可以分为：</p><ul><li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务<ul><li>ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。</li><li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。</li></ul></li><li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务<ul><li>DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。 </li></ul></li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564024229499.png" alt="1564024229499"></p><h2 id="15-6-TCP网络编程"><a href="#15-6-TCP网络编程" class="headerlink" title="15.6 TCP网络编程"></a>15.6 TCP网络编程</h2><h3 id="15-6-1-通信模型"><a href="#15-6-1-通信模型" class="headerlink" title="15.6.1 通信模型"></a>15.6.1 通信模型</h3><p>Java语言的基于套接字TCP编程分为服务端编程和客户端编程，其通信模型如图所示：</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564025942044.png" alt="1564025942044"></p><h3 id="15-6-2-开发步骤"><a href="#15-6-2-开发步骤" class="headerlink" title="15.6.2 开发步骤"></a>15.6.2 开发步骤</h3><h4 id="1、服务器端"><a href="#1、服务器端" class="headerlink" title="1、服务器端"></a>1、服务器端</h4><p>服务器 程序的工作过程包含以下四个基本的 步骤：</p><ul><li>调用 ServerSocket(int port)  ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 accept() ：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li><li>调用  该Socket 类对象的 getOutputStream()  和 getInputStream () ：获取输出流和输入流，开始网络数据的发送和接收。</li><li>关闭Socket 对象：客户端访问结束，关闭通信套接字。</li></ul><h4 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h4><p>客户端Socket 的工作过程包含以下四个基本的步骤 ：</p><ul><li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 Socket  的输入/ 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</li><li>按照一定的协议对 Socket 进行读/ 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线路。</li><li>关闭 Socket ：断开客户端到服务器的连接，释放线路</li></ul><h3 id="15-6-3-相关API"><a href="#15-6-3-相关API" class="headerlink" title="15.6.3 相关API"></a>15.6.3 相关API</h3><p><strong>ServerSocket类的构造方法：</strong></p><ul><li>ServerSocket(int port) ：创建绑定到特定端口的服务器套接字。</li></ul><p><strong>ServerSocket类的常用方法：</strong></p><ul><li>Socket accept()：侦听并接受到此套接字的连接。 </li></ul><p><strong>Socket类的常用构造方法</strong>：</p><ul><li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li><li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li></ul><p><strong>Socket类的常用方法</strong>：</p><ul><li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li><li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li><li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li><li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li><li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li><li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li><li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 </li><li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li><li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li></ul><p><strong>注意：</strong>先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Scoket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p><h3 id="15-6-4-示例一：单个客户端与服务器单次通信"><a href="#15-6-4-示例一：单个客户端与服务器单次通信" class="headerlink" title="15.6.4 示例一：单个客户端与服务器单次通信"></a>15.6.4 示例一：单个客户端与服务器单次通信</h3><p>需求：客户端连接服务器，连接成功后给服务发送“lalala”，服务器收到消息后，给客户端返回“欢迎登录”，客户端接收消息后，断开连接</p><h4 id="客户端示例代码"><a href="#客户端示例代码" class="headerlink" title="客户端示例代码"></a>客户端示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获取输出流，用来发送数据给服务器</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">out.write(<span class="string">&quot;lalala&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">//会在流末尾写入一个“流的末尾”标记，对方才能读到-1，否则对方的读取方法会一致阻塞</span></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、获取输入流，用来接收服务器发送给该客户端的数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">s.append(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;服务器返回的消息是：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭socket，不再与服务器通信，即断开与服务器的连接</span></span><br><span class="line"><span class="comment">//socket关闭，意味着InputStream和OutputStream也关闭了</span></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务器端示例代码"><a href="#服务器端示例代码" class="headerlink" title="服务器端示例代码"></a>服务器端示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、准备一个ServerSocket对象，并绑定8888端口</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、在8888端口监听客户端的连接，该方法是个阻塞的方法，如果没有客户端连接，将一直等待</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;一个客户端连接成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、获取输入流，用来接收该客户端发送给服务器的数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">s.append(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;客户端发送的消息是：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、获取输出流，用来发送数据给该客户端</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">out.write(<span class="string">&quot;欢迎登录&quot;</span>.getBytes());</span><br><span class="line">out.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭socket，不再与该客户端通信</span></span><br><span class="line"><span class="comment">//socket关闭，意味着InputStream和OutputStream也关闭了</span></span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、如果不再接收任何客户端通信，可以关闭ServerSocket</span></span><br><span class="line">server.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-6-5-示例二：多个客户端与服务器之间的多次通信"><a href="#15-6-5-示例二：多个客户端与服务器之间的多次通信" class="headerlink" title="15.6.5 示例二：多个客户端与服务器之间的多次通信"></a>15.6.5 示例二：多个客户端与服务器之间的多次通信</h3><p>通常情况下，服务器不应该只接受一个客户端请求，而应该不断地接受来自客户端的所有请求，所以Java程序通常会通过循环，不断地调用ServerSocket的accept()方法。</p><p>如果服务器端要“同时”处理多个客户端的请求，因此服务器端需要为<strong>每一个客户端单独分配一个线程</strong>来处理，否则无法实现“同时”。</p><p>咱们之前学习IO流的时候，提到过装饰者设计模式，该设计使得不管底层IO流是怎样的节点流：文件流也好，网络Socket产生的流也好，程序都可以将其包装成处理流，甚至可以多层包装，从而提供更多方便的处理。</p><p>案例需求：多个客户端连接服务器，并进行多次通信</p><ul><li>每一个客户端连接成功后，从键盘输入英文单词或中国成语，并发送给服务器</li><li>服务器收到客户端的消息后，把词语“反转”后返回给客户端</li><li>客户端接收服务器返回的“词语”，打印显示</li><li>当客户端输入“stop”时断开与服务器的连接</li><li>多个客户端可以同时给服务器发送“词语”，服务器可以“同时”处理多个客户端的请求</li></ul><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/1564027041074.png" alt="1564027041074"></p><h4 id="客户端示例代码-1"><a href="#客户端示例代码-1" class="headerlink" title="客户端示例代码"></a>客户端示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 1、准备Socket，连接服务器，需要指定服务器的IP地址和端口号</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获取输出流，用来发送数据给服务器</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、获取输入流，用来接收服务器发送给该客户端的数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input));</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入发送给服务器的单词或成语：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"><span class="keyword">if</span>(message.equals(<span class="string">&quot;stop&quot;</span>))&#123;</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、 发送数据</span></span><br><span class="line">ps.println(message);</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">feedback</span>  <span class="operator">=</span> br.readLine();</span><br><span class="line">System.out.println(<span class="string">&quot;从服务器收到的反馈是：&quot;</span> + feedback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭socket，断开与服务器的连接</span></span><br><span class="line">scanner.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="服务器端示例代码-1"><a href="#服务器端示例代码-1" class="headerlink" title="服务器端示例代码"></a>服务器端示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 1、准备一个ServerSocket</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待连接...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">// 2、监听一个客户端的连接</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span> + ++count + <span class="string">&quot;个客户端&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;连接成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ClientHandlerThread</span> <span class="variable">ct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientHandlerThread</span>(socket);</span><br><span class="line">ct.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里没有关闭server，永远监听</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientHandlerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClientHandlerThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//（1）获取输入流，用来接收该客户端发送给服务器的数据</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"><span class="comment">//（2）获取输出流，用来发送数据给该客户端</span></span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(socket.getOutputStream());</span><br><span class="line">String str;</span><br><span class="line"><span class="comment">// （3）接收数据</span></span><br><span class="line"><span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//（4）反转</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str);</span><br><span class="line">word.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）返回给客户端</span></span><br><span class="line">ps.println(word);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(socket.getInetAddress().getHostAddress()+<span class="string">&quot;正常退出&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception  e)&#123;</span><br><span class="line">System.out.println(socket.getInetAddress().getHostAddress()+<span class="string">&quot;意外退出&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//（6）断开连接</span></span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-7-UDP网络编程"><a href="#15-7-UDP网络编程" class="headerlink" title="15.7 UDP网络编程"></a>15.7 UDP网络编程</h2><p>UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务，类似于短信。</p><p>UDP协议是一种<strong>面向非连接</strong>的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此说，UDP协议是一种<strong>不可靠的</strong>协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</p><p>UDP协议是面向数据报文的信息传送服务。UDP在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于ip层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送100个字节的报文，我们调用一次send()方法就会发送100字节，接收方也需要用receive()方法一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p><p>UDP协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然UDP的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证UDP报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。</p><p>因此UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在64K以下。</p><h3 id="15-7-1-相关API"><a href="#15-7-1-相关API" class="headerlink" title="15.7.1 相关API"></a>15.7.1 相关API</h3><p>基于UDP协议的网络编程仍然需要在通信实例的两端各建立一个Socket，但这两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象，Java提供了DatagramSocket对象作为基于UDP协议的Socket，使用DatagramPacket代表DatagramSocket发送、接收的数据报。</p><p><strong>DatagramSocket 类的常用方法：</strong></p><ul><li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li><li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 </li><li>public void close()关闭此数据报套接字。 </li><li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 </li><li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 </li></ul><p><strong>DatagramPacket类的常用方法：</strong></p><ul><li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li><li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li><li>public int getLength()返回将要发送或接收到的数据的长度。 </li></ul><h3 id="15-7-2-示例代码"><a href="#15-7-2-示例代码" class="headerlink" title="15.7.2 示例代码"></a>15.7.2 示例代码</h3><h4 id="发送端："><a href="#发送端：" class="headerlink" title="发送端："></a>发送端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、建立发送端的DatagramSocket</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//要发送的数据</span></span><br><span class="line">ArrayList&lt;String&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">&quot;尚硅谷让天下没有难学的技术！&quot;</span>);</span><br><span class="line">all.add(<span class="string">&quot;学高端前沿的IT技术来尚硅谷！&quot;</span>);</span><br><span class="line">all.add(<span class="string">&quot;尚硅谷让你的梦想变得更具体！&quot;</span>);</span><br><span class="line">all.add(<span class="string">&quot;尚硅谷让你的努力更有价值！&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方的IP地址</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="comment">//接收方的监听端口号</span></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">         <span class="comment">//发送多个数据报</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line"><span class="comment">//2、建立数据包DatagramPacket</span></span><br><span class="line"><span class="type">byte</span>[] data = all.get(i).getBytes();</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, ip, port);</span><br><span class="line"><span class="comment">//3、调用Socket的发送方法</span></span><br><span class="line">ds.send(dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭Socket</span></span><br><span class="line">ds.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receive</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//1、建立接收端的DatagramSocket，需要指定本端的监听端口号</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一直监听数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//2、建立数据包DatagramPacket</span></span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer , buffer.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、调用Socket的接收方法</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、拆封数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,dp.getLength());</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第15章-网络编程&quot;&gt;&lt;a href=&quot;#第15章-网络编程&quot; class=&quot;headerlink&quot; title=&quot;第15章 网络编程&quot;&gt;&lt;/a&gt;第15章 网络编程&lt;/h1&gt;&lt;h2 id=&quot;教学目标&quot;&gt;&lt;a href=&quot;#教学目标&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="重学Java基础" scheme="https://manamn.space/categories/%E9%87%8D%E5%AD%A6Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://manamn.space/tags/Java/"/>
    
    <category term="重学Java基础" scheme="https://manamn.space/tags/%E9%87%8D%E5%AD%A6Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
